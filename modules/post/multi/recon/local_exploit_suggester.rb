##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post

  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'          => 'Multi Recon Local Exploit Suggester',
      'Description'   => %q{
        This module suggests local meterpreter exploits that can be used.

        The exploits are suggested based on the architecture and platform
        that the user has a shell opened as well as the available exploits
        in meterpreter.

        It's important to note that not all local exploits will be fired.
        Exploits are chosen based on these conditions: session type,
        platform, architecture, and required default options.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [ 'sinn3r', 'Mo' ],
      'Platform'      => all_platforms,
      'SessionTypes'  => [ 'meterpreter', 'shell' ]))
    register_options [
      Msf::OptInt.new('SESSION', [ true, 'The session to run this module on' ]),
      Msf::OptBool.new('SHOWDESCRIPTION', [true, 'Displays a detailed description for the available exploits', false])
    ]

    register_advanced_options(
      [
        Msf::OptBool.new('ValidateArch', [true, 'Validate architecture', true]),
        Msf::OptBool.new('ValidatePlatform', [true, 'Validate platform', true]),
        Msf::OptBool.new('ValidateMeterpreterCommands', [true, 'Validate Meterpreter commands', true]),
        Msf::OptString.new('Colors', [false, 'Valid, Invalid and Ignored colors for module checks (unset to disable)', 'grn/red/blu'])
      ]
    )
  end

  def all_platforms
    Msf::Module::Platform.subclasses.collect { |c| c.realname.downcase }
  end

  def is_module_arch?(mod)
    mod_arch = mod.target.arch || mod.arch
    mod_arch.include? session.arch
  end

  def is_module_options_ready?(mod)
    mod.options.each_pair do |option_name, option|
      return false if option.required && option.default.nil? && mod.datastore[option_name].blank?
    end

    true
  end

  def is_module_platform?(mod)
    platform_obj = Msf::Module::Platform.find_platform session.platform
    return false if mod.target.nil?

    module_platforms = mod.target.platform ? mod.target.platform.platforms : mod.platform.platforms
    module_platforms.include? platform_obj
  rescue ArgumentError => e
    # When not found, find_platform raises an ArgumentError
    elog('Could not find a platform', error: e)
    return false
  end

  def valid_incompatibility_reasons(mod)
    # These all the `reasons` due to which the module we are checking is not compatible with the current session
    reasons = mod.session_incompatibility_reasons(session.sid)

    # As we can potentially ignore some `reasons` (e.g. accepting arch values which are, on paper, not compatible),
    # this keeps track of valid reasons why we will not consider the module that we are evaluating to be valid.
    valid_reasons = []
    reasons.each do |reason|
      # If we are validating e.g. Arch, we want to remove modules that did not pass validation.
      if !@validate_arch && reason.include?('architecture')
        vprint_status "#{mod.name} included with override of #{reason}"
        next
      end
      if !@validate_platform && reason.include?('platform')
        vprint_status "#{mod.name} included with override of #{reason}"
        next
      end
      if !@validate_meterpreter_commands && (reason.start_with?('missing') || reason.start_with?('unloadable'))
        vprint_status "#{mod.name} included with override of #{reason}"
        next
      end

      # If we don't pass verification checks, and this reason is not specifically suppressed it is considered to be `valid`
      valid_reasons << reason
    end

    valid_reasons
  end

  def set_module_options(mod)
    datastore.each_pair do |k, v|
      mod.datastore[k] = v
    end
    if !mod.datastore['SESSION'] && session.present?
      mod.datastore['SESSION'] = session.sid
    end
  end

  def is_module_wanted?(mod)
    mod[:result][:incompatibility_reasons].empty?
  end

  def setup
    return unless session

    print_status "Collecting local exploits for #{session.session_type}..."

    setup_validation_options
    setup_color_options

    # Collects exploits into an array
    @local_exploits = []
    framework.exploits.each_with_index do |(name, _obj), index|
      print "%bld%blu[*]%clr Collecting exploit #{index + 1} / #{framework.exploits.count}\r"
      mod = framework.exploits.create name
      next unless mod

      set_module_options mod

      verify_result = verify_mod(mod)
      @local_exploits << { module: mod, result: verify_result } if verify_result[:has_check]
    end
  end

  def verify_mod(mod)
    return { has_check: false } unless mod.kind_of?(Msf::Exploit::Local) && mod.has_check?

    {
      has_check: true,
      incompatibility_reasons: valid_incompatibility_reasons(mod),
      is_module_platform: (@validate_platform ? is_module_platform?(mod) : true),
      is_module_arch: (@validate_arch ? is_module_arch?(mod) : true),
      is_module_options_ready: is_module_options_ready?(mod)
    }
  end

  def setup_validation_options
    @validate_arch = datastore['ValidateArch']
    @validate_platform = datastore['ValidatePlatform']
    @validate_meterpreter_commands = datastore['ValidateMeterpreterCommands']
  end

  def setup_color_options
    @valid_color, @invalid_color, @ignored_color =
      (datastore['Colors'] || '').split('/')

    @valid_color = "%#{@valid_color}" unless @valid_color.blank?
    @invalid_color = "%#{@invalid_color}" unless @invalid_color.blank?
    @ignored_color = "%#{@ignored_color}" unless @ignored_color.blank?
  end

  def show_found_exploits
    unless datastore['VERBOSE']
      print_status "#{@local_exploits.length} exploit checks are being tried..."
      return
    end

    vprint_status "The following #{@local_exploits.length} exploit checks are being tried:"
    @local_exploits.each do |x|
      vprint_status x[:module].fullname
    end
  end

  def run
    wanted_modules = @local_exploits.select { |mod| is_module_wanted?(mod) }
    if wanted_modules.empty?
      print_error 'No suggestions available.'
      vprint_line
      vprint_session_info
      vprint_status unwanted_modules_table(@local_exploits.select { |mod| !is_module_wanted?(mod) })
      return
    end

    show_found_exploits
    results = wanted_modules.map.with_index do |mod, index|
      print "%bld%blu[*]%clr Running check method for exploit #{index + 1} / #{wanted_modules.count}\r"
      begin
        checkcode = mod[:module].check
      rescue => e
        elog("#Local Exploit Suggester failed with: #{e.class} when using #{mod[:module].shortname}", error: e)
        vprint_error "Check with module #{mod[:module].fullname} failed with error #{e.class}"
        next { module: mod[:module], errors: ['The check raised an exception.'] }
      end

      if checkcode.nil?
        vprint_error "Check failed with #{mod[:module].fullname} for unknown reasons"
        next { module: mod[:module], errors: ['The check failed for unknown reasons.'] }
      end

      # See def is_check_interesting?
      unless is_check_interesting? checkcode
        vprint_status "#{mod[:module].fullname}: #{checkcode.message}"
        next { module: mod[:module], errors: [checkcode.message] }
      end

      # Prints the full name and the checkcode message for the exploit
      print_good "#{mod[:module].fullname}: #{checkcode.message}"

      # If the datastore option is true, a detailed description will show
      if datastore['SHOWDESCRIPTION']
        # Formatting for the description text
        Rex::Text.wordwrap(Rex::Text.compress(mod[:module].description), 2, 70).split(/\n/).each do |line|
          print_line line
        end
      end

      next { module: mod[:module], checkcode: checkcode.message }
    end

    vprint_line
    vprint_status valid_modules_table(results)

    vprint_line
    vprint_session_info
    vprint_status unwanted_modules_table(@local_exploits.select { |mod| !is_module_wanted?(mod) })

    report_note(
      :host => session.session_host,
      :type => 'local.suggested_exploits',
      :data => results
    )
  end

  def valid_modules_table(results)
    name_styler = ::Msf::Ui::Console::TablePrint::CustomColorStyler.new
    check_styler = ::Msf::Ui::Console::TablePrint::CustomColorStyler.new

    # Split all the results by their checkcode.
    # We want the modules that returned a checkcode to be at the top.
    checkcode_rows, without_checkcode_rows = results.partition { |result| result[:checkcode] }
    rows = (checkcode_rows + without_checkcode_rows).map.with_index do |result, index|
      color = result[:checkcode] ? @valid_color : @invalid_color
      check_res = result.fetch(:checkcode) { result[:errors].join(', ') }
      name_styler.merge!({ result[:module].fullname => color })
      check_styler.merge!({ check_res => color })
      [index + 1, result[:module].fullname, result[:checkcode] ? 'Yes' : 'No', check_res ]
    end

    Rex::Text::Table.new(
      'Header' => "Valid modules for session #{session.sid}:",
      'Indent' => 1,
      'Columns' => [ '#', 'Name', 'Potentially Vulnerable?', 'Check Result' ],
      'SortIndex' => -1,
      'WordWrap' => false, # Don't wordwrap as it messes up coloured output when it is broken up into more than one line
      'ColProps' => {
        'Name' => {
          'Stylers' => [name_styler]
        },
        'Potentially Vulnerable?' => {
          'Stylers' => [::Msf::Ui::Console::TablePrint::CustomColorStyler.new({ 'Yes' => @valid_color, 'No' => @invalid_color })]
        },
        'Check Result' => {
          'Stylers' => [check_styler]
        }
      },
      'Rows' => rows
    )
  end

  def unwanted_modules_table(unwanted_modules)
    arch_styler = ::Msf::Ui::Console::TablePrint::CustomColorStyler.new
    platform_styler = ::Msf::Ui::Console::TablePrint::CustomColorStyler.new

    rows = unwanted_modules.map.with_index do |mod, index|
      platforms = mod[:module].platform.platforms.any? ? mod[:module].platform.platforms : mod[:module].target.platform.platforms
      platforms ||= []
      arch = mod[:module].arch.any? ? mod[:module].arch : mod[:module].target.arch
      arch ||= []

      arch.each do |a|
        color = if a != session.arch
                  if @validate_arch
                    @invalid_color
                  else
                    @ignored_color
                  end
                else
                  @valid_color
                end
        arch_styler.merge!({ a.to_s => color })
      end

      platforms.each do |module_platform|
        color = if module_platform.realname != ::Msf::Module::Platform.find_platform(session.platform)
                  if @validate_platform
                    @invalid_color
                  else
                    @ignored_color
                  end
                else
                  @valid_color
                end
        platform_styler.merge!({ module_platform.realname => color })
      end

      [index + 1, mod[:module].fullname, mod[:result][:incompatibility_reasons].map { |reason| reason.split(':').first }.join(', '), platforms.map { |module_platform| module_platform.realname }.join(', '), arch.join(', ')]
    end

    Rex::Text::Table.new(
      'Header' => "Invalid modules for session #{session.sid}:",
      'Indent' => 1,
      'Columns' => [ '#', 'Name', 'Reasons', 'Platform', 'Architecture' ],
      'WordWrap' => false,
      'ColProps' => {
        'Architecture' => {
          'Stylers' => [arch_styler]
        },
        'Platform' => {
          'Stylers' => [platform_styler]
        }
      },
      'Rows' => rows
    )
  end

  def vprint_session_info
    vprint_status 'Current Session Info:'
    vprint_status "Session Type: #{session.type}"
    vprint_status "Architecture: #{session.arch}"
    vprint_status "Platform: #{session.platform}"
  end

  def is_check_interesting?(checkcode)
    [
      Msf::Exploit::CheckCode::Vulnerable,
      Msf::Exploit::CheckCode::Appears,
      Msf::Exploit::CheckCode::Detected
    ].include? checkcode
  end

  def print_status(msg='')
    super(session ? "#{session.session_host} - #{msg}" : msg)
  end

  def print_good(msg='')
    super(session ? "#{session.session_host} - #{msg}" : msg)
  end

  def print_error(msg='')
    super(session ? "#{session.session_host} - #{msg}" : msg)
  end
end
