#require 'spec_helper'
require 'msf/core'

describe Msf::Exploit::Remote::BrowserExploitServer do

  # When unpacked, this gives us:
  # {
  #  "BAP.1433806920.Client.blLGFIlwYrxfvcY" =>
  #    {
  #      "source"      => "script",
  #      "os_name"     => "Windows 8.1",
  #      "os_vendor"   => "undefined",
  #      "os_device"   => "undefined",
  #      "ua_name"     => "Firefox",
  #      "ua_ver"      => "35.0",
  #      "arch"        => "x86",
  #      "java"        => "1.7",
  #      "silverlight" => "false",
  #      "flash"       => "14.0",
  #      "vuln_test"   => "true",
  #      "proxy"       => false,
  #      "language"    => "en-US,en;q=0.5",
  #      "tried"       => true,
  #      "activex"     => [{"clsid"=>"{D27CDB6E-AE6D-11cf-96B8-444553540000}", "method"=>"LoadMovie"}]
  # }}
  let(:first_packed_profile) do
    "\x81\xD9%BAP.1433806920.Client.blLGFIlwYrxfvcY\x8F\xA6source\xA6script\xA7os_name\xABWindows 8.1\xA9os_vendor\xA9undefined\xA9os_device\xA9undefined\xA7ua_name\xA7Firefox\xA6ua_ver\xA435.0\xA4arch\xA3x86\xA4java\xA31.7\xABsilverlight\xA5false\xA5flash\xA414.0\xA9vuln_test\xA4true\xA5proxy\xC2\xA8language\xC4\x0Een-US,en;q=0.5\xA5tried\xC3\xA7activex\x91\x82\xA5clsid\xD9&{D27CDB6E-AE6D-11cf-96B8-444553540000}\xA6method\xA9LoadMovie"
  end

  let(:default_note_type_prefix) do
    MessagePack.unpack(first_packed_profile).keys.first.split('.')[0,3] * "."
  end

  let(:first_profile_tag) do
    MessagePack.unpack(first_packed_profile).keys.first.split('.')[3]
  end

  let(:first_profile_info) do
    MessagePack.unpack(first_packed_profile).values.first
  end

  let(:cli) do
    sock = Rex::Socket::Tcp
    allow(sock).to receive(:peerhost).and_return('0.0.0.0')
    allow(sock).to receive(:peerport).and_return(4444)
    sock
  end

  def create_fake_note(tag, data)
    note = double('note')
    allow(note).to receive(:ntype).and_return(tag)
    allow(note).to receive(:data).and_return(data)

    note
  end


  before(:each) do
    allow_any_instance_of(described_class).to receive(:vprint_status)
    @notes = [create_fake_note(first_profile_tag, first_packed_profile)]
  end

  subject(:server) do
    mod = Msf::Exploit::Remote.allocate
    mod.extend described_class
    mod.send(:initialize)
    mod.send(:datastore=, {'NoteTypePrefix' => default_note_type_prefix})
    mod
  end

  let(:service_double) do
    service = double('service')
    allow(service).to receive(:server_name=)
    allow(service).to receive(:add_resource)
    service
  end

  let(:exploit_page) do
    server.instance_variable_get(:@exploit_receiver_page)
  end

  before do
    Rex::ServiceManager.stub(:start => service_double)
  end

  before(:each) do
    server.start_service
  end

  it_should_behave_like 'Msf::Exploit::JSObfu'


  describe '#get_module_resource' do
    it "should give me a URI to access the exploit page" do
      module_resource = server.get_module_resource
      expect(module_resource).to include(exploit_page)
    end
  end

  describe '#has_bad_activex?' do
    context 'when there is a bad activex' do
      let(:js_ax_value) { "#{first_profile_info['activex'][0][:clsid]}=>#{first_profile_info['activex'][0][:method]}=>false" }
      it 'returns false' do
        expect(server.has_bad_activex?(js_ax_value)).to be_truthy
      end
    end

    context 'when there is no bad activex' do
      let(:js_ax_value) { "#{first_profile_info['activex'][0][:clsid]}=>#{first_profile_info['activex'][0][:method]}=>true" }
      it 'returns true' do
        expect(server.has_bad_activex?(js_ax_value)).to be_falsey
      end
    end
  end


  describe '#get_detection_html' do
    it "returns the detection code that the client will get" do
      expected_user_agent = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)'
      html = server.get_detection_html(expected_user_agent)
      expect(html).not_to eq('')
    end
  end


  describe '#on_request_exploit' do
    it "raises a NoMethodError if called" do
      fake_cli = nil
      fake_request = nil
      fake_browser_info = nil
      expect {
        server.on_request_exploit(fake_cli, fake_request, fake_browser_info)
      }.to raise_error
    end
  end

  describe '#get_target' do
    it "returns a target" do
      expected_object = double('Msf::Module::Target')
      server.instance_variable_set(:@target, expected_object)
      server.get_target.should eq(expected_object)
    end
  end


  describe 'extract_requirements' do
    context 'when a recognizable requirement is given' do
      it 'returns a hash that contains the recognizable requirement' do
        expected_hash = {:os_name=>'Linux'}
        expect(server.extract_requirements(expected_hash)).to eq(expected_hash)
      end
    end

    context 'when a unrecognizable requirement is given' do
      it 'returns a hash that does not have the unrecognizable requirement' do
        bad_hash = {'UNKNOWN_KEY'=>'VALUE'}
        expect(server.extract_requirements(bad_hash)).to be_empty
      end
    end
  end

  describe '#retrieve_tag' do
    context 'when the browser has a cookie that contains our tag' do
      let(:tag) do
        'tag'
      end

      let(:cookie) do
        "__ua=#{tag};"
      end

      let(:cli_request) do
        req = Rex::Proto::Http::Request.new
        req.headers['Cookie'] = cookie
        req
      end

      it 'returns the tag from the cookie' do
        expect(server.retrieve_tag(cli, cli_request)).to eq(tag)
      end
    end

    context 'when the browser does not have a tag' do

      let(:cli_request) do
        Rex::Proto::Http::Request.new
      end

      it 'returns a new one in MD5' do
        expect(server.retrieve_tag(cli, cli_request)).to match(/^[0-9a-f]{32}$/)
      end
    end
  end

  describe '#on_request_uri' do
    before(:each) do
      allow(server).to receive(:get_profile_info) { MessagePack.unpack(first_packed_profile) }
      allow(server).to receive(:init_profile).with(kind_of(String))
      allow(server).to receive(:update_profile)
      allow(server).to receive(:process_browser_info)
      allow(server).to receive(:send_response)      { @send_response_called = true }
      allow(server).to receive(:send_redirect)      { @send_redirect_called = true }
      allow(server).to receive(:send_not_found)     { @send_not_found_called = true}
      allow(server).to receive(:on_request_exploit) { @on_request_exploit_called = true }
      allow(server).to receive(:on_request_exploit) { @on_request_exploit_called = true }
    end

    after(:each) do
      @send_response_called      = false
      @send_redirect_called      = false
      @on_request_exploit_called = false
      @send_not_found_called     = false
      @on_request_exploit_called = false
    end


    context 'when info_receiver_page is requested' do
      it 'sends an empty page' do
        info_receiver_page_var = server.instance_variable_get(:@info_receiver_page)
        cli_request = Rex::Proto::Http::Request.new
        cli_request.uri = info_receiver_page_var
        server.on_request_uri(cli, cli_request)
        expect(@send_response_called).to be_truthy
      end
    end

    context 'when noscript_receiver_page is requested' do
      it 'sends a not-found' do
        noscript_receiver_page_var = server.instance_variable_get(:@noscript_receiver_page)
        cli_request = Rex::Proto::Http::Request.new
        cli_request.uri = noscript_receiver_page_var
        server.on_request_uri(cli, cli_request)
        expect(@send_not_found_called).to be_truthy
      end
    end

  end

  describe '#get_payload' do
    before(:each) do
      target = double('Msf::Module::Target')
      allow(target).to receive(:arch).and_return(nil)
      allow(server).to receive(:get_target).and_return(target)
    end

    let(:encoded) { '@EXE@' }

    let(:x86_payload) {
      double(:encoded => encoded, :arch => ['x86'])
    }

    let(:normalized_profile_info) {
      first_profile_info.inject({}){|data,(k,v)| data[k.to_sym] = v; data}
    }

    context 'when the payload supports the visitor\'s browser architecture' do
      it 'returns a payload' do
        allow(server).to receive(:regenerate_payload).and_return(x86_payload)
        expect(server.get_payload(cli, normalized_profile_info)).to eq(encoded)
      end
    end
  end
end
