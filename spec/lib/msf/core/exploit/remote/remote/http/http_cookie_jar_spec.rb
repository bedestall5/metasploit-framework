require 'spec_helper'
require 'msf/core/exploit/remote/http/http_cookie_jar'
require 'msf/core/exploit/remote/http/http_cookie'

RSpec.describe Msf::Exploit::Remote::HTTP::HttpCookieJar do
  def random_string(min_len = 1, max_len = 12)
    str = Faker::Alphanumeric.alpha(number: max_len)

    str[0, rand(min_len..max_len)]
  end

  def cookie
    Msf::Exploit::Remote::HTTP::HttpCookie.new(
      random_string,
      random_string,
      max_age: rand(1..100),
      path: '/' + random_string,
      secure: rand(0..1) == 1,
      httponly: rand(0..1) == 1,
      domain: random_string
    )
  end
  describe 'add' do
    before(:each) do
      @cookie_jar = described_class.new
    end

    describe 'empty?' do
      it 'will return true when no cookies are in a cookie_jar' do
        # cookie_jar made in before

        e = @cookie_jar.empty?

        expect(e).to eq(true)
      end

      it 'will return false when a cookie has been added to a cookie_jar' do
        c = cookie

        @cookie_jar.add(c)
        e = @cookie_jar.empty?

        expect(e).to eq(false)
      end
    end

    describe 'clear' do
      it 'will make no changes to an empty cookiejar' do
        # empty cookie_jar made in before

        @cookie_jar.clear

        expect(@cookie_jar.empty?).to eq(true)
      end

      it 'will return false when a cookie has been added to a cookie_jar' do
        c = cookie

        @cookie_jar.add(c)
        @cookie_jar.clear

        expect(@cookie_jar.empty?).to eq(true)
      end
    end

    describe 'cookies' do
      it 'will return an empty array when no cookies have been added to the jar' do
        # cookie_jar made in before

        c_array = @cookie_jar.cookies

        expect(c_array.class).to eq(Array)
        expect(c_array.empty?).to eq(true)
      end

      it 'will return an array of all cookies added to the cookie_jar when called with no url param' do
        c_array = []
        rand(1..10).times do
          c = cookie

          c_array.append(c)
          @cookie_jar.add(c)
        end

        jar_array = @cookie_jar.cookies

        expect(c_array.sort).to eq(jar_array.sort)
      end

      it 'will return an array of all cookies that have parent paths to the url passed' do
        c_array = [cookie, cookie, cookie, cookie]
        c_array[0].secure = false
        c_array[1].secure = false
        c_array[1].domain = c_array[0].domain
        c_array[1].path = '/'
        c_array.map { |c| @cookie_jar.add(c) }

        filtered_cookies = @cookie_jar.cookies("http://#{c_array[0].domain}#{c_array[0].path}")

        expect(filtered_cookies.length).to eq(2)
        expect(filtered_cookies.include?(c_array[0])).to eq(true)
        expect(filtered_cookies.include?(c_array[1])).to eq(true)
        expect(filtered_cookies.include?(c_array[2])).to eq(false)
        expect(filtered_cookies.include?(c_array[3])).to eq(false)
      end
    end

    describe 'add' do
      it 'unacceptable cookie missing path throws ArgumentError' do
        c = HttpCookie.new(random_string, random_string,
                           path: '/' + random_string)

        expect do
          @cookie_jar.add(c)
        end.to raise_error(ArgumentError)
      end

      it 'unacceptable cookie missing domain throws ArgumentError' do
        c = HttpCookie.new(random_string, random_string,
                           domain: random_string)

        expect do
          @cookie_jar.add(c)
        end.to raise_error(ArgumentError)
      end

      it 'acceptable cookie added to cookie_jar successfully' do
        c = cookie

        @cookie_jar.add(c)

        expect(@cookie_jar.cookies[0] == c)
      end

      it 'acceptable cookie added to cookie_jar containing cookie with the same name, domain, and path will result in an overwrite' do
        c = cookie
        c_dup = cookie
        c_dup.name = c.name
        c_dup.domain = c.domain
        c_dup.path = c.path

        @cookie_jar.add(c)
        @cookie_jar.add(c_dup)

        expect(@cookie_jar.cookies[0]).to eq(c_dup)
        expect(@cookie_jar.cookies[0]).to_not eq(c)
      end

      it 'variable not a subclass of ::HttpCookie will raise TypeError' do
        int = rand(1..100)

        expect do
          @cookie_jar.add(int)
        end.to raise_error(TypeError)
      end
    end

    describe 'delete' do
      it 'used on an empty jar will return nil' do
        # cookie_jar made in before

        n = @cookie_jar.delete(cookie)

        expect(n).to eq(nil)
      end

      it 'passed cookie with same name, domain, and path as cookie in jar, will delete cookie in jar' do
        c = cookie
        c_dup = cookie
        c_dup.name = c.name
        c_dup.domain = c.domain
        c_dup.path = c.path

        @cookie_jar.add(c)
        @cookie_jar.delete(c_dup)

        expect(@cookie_jar.empty?).to eq(true)
      end

      it 'passed a cookie different name, domain, and path as cookie in jar, will not delete cookie in jar' do
        c = cookie
        c_dup = cookie
        c_dup.name = c.name + random_string(1, 1)
        c_dup.domain = c.domain + random_string(1, 1)
        c_dup.path = c.path + random_string(1, 1)

        @cookie_jar.add(c)
        @cookie_jar.delete(c_dup)

        expect(@cookie_jar.cookies.length).to eq(1)
        expect(@cookie_jar.cookies[0]).to eql(c)
      end

      it 'variable not a subclass of ::HttpCookie will not raise TypeError when the cookie_jar is empty' do
        int = rand(1..100)

        n = @cookie_jar.delete(int)

        expect(n).to eq(nil)
        expect(@cookie_jar.empty?).to eq(true)
      end

      it 'variable not a subclass of ::HttpCookie will raise TypeError when the cookie_jar is not empty' do
        @cookie_jar.add(cookie)
        int = rand(1..100)

        expect do
          @cookie_jar.delete(int)
        end.to raise_error(TypeError)
      end
    end

    describe 'cleanup' do
      it 'will make no changes to an empty cookiejar' do
        # empty cookie_jar made in before

        @cookie_jar.cleanup

        expect(@cookie_jar.empty?).to eq(true)
      end

      it 'will remove expired cookies with max_age value' do
        freeze_time = Time.local(2008, 9, 5, 10, 5, 30)
        Timecop.freeze(freeze_time)
        expired_cookies = [cookie, cookie]
        expired_cookies[0].max_age = 1
        expired_cookies[1].max_age = 1
        expired_cookies[0].created_at = Time.local(2008, 9, 5, 10, 5, 1)
        expired_cookies[1].created_at = Time.local(2008, 9, 5, 10, 5, 1)
        cookies = [cookie, cookie]
        cookies[0].max_age = 10000
        cookies[1].max_age = 10000
        cookies[0].created_at = freeze_time
        cookies[1].created_at = freeze_time

        cookies.map { |c| @cookie_jar.add(c) }
        expired_cookies.map { |c| @cookie_jar.add(c) }
        @cookie_jar.cleanup

        expect(@cookie_jar.cookies.length).to eq(2)
        expect(@cookie_jar.cookies.include?(expired_cookies[0])).to eq(false)
        expect(@cookie_jar.cookies.include?(expired_cookies[1])).to eq(false)
        expect(@cookie_jar.cookies.include?(cookies[0])).to eq(true)
        expect(@cookie_jar.cookies.include?(cookies[1])).to eq(true)
        Timecop.return
      end

      it 'will remove expired cookies with expires value' do
        Timecop.freeze(Time.local(2008, 9, 5, 10, 5, 0))
        expired_cookies = [cookie, cookie]
        expired_cookies[0].expires = Time.local(2008, 9, 3, 10, 5, 0)
        expired_cookies[1].expires = Time.local(2008, 9, 4, 10, 5, 0)
        cookies = [cookie, cookie]
        cookies[0].expires = Time.local(2008, 9, 6, 10, 5, 0)
        cookies[1].expires = Time.local(2008, 9, 7, 10, 5, 0)

        cookies.map { |c| @cookie_jar.add(c) }
        expired_cookies.map { |c| @cookie_jar.add(c) }
        @cookie_jar.cleanup

        expect(@cookie_jar.cookies.length).to eq(2)
        expect(@cookie_jar.cookies.include?(expired_cookies[0])).to eq(false)
        expect(@cookie_jar.cookies.include?(expired_cookies[1])).to eq(false)
        expect(@cookie_jar.cookies.include?(cookies[0])).to eq(true)
        expect(@cookie_jar.cookies.include?(cookies[1])).to eq(true)
        Timecop.return
      end
    end
  end
end
