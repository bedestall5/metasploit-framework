# -*- coding:binary -*-
require 'spec_helper'

require 'msf/core'
require 'msf/core/exploit/powershell'

def decompress(code)
  Rex::Exploitation::Powershell::Script.new(code).decompress_code
end

describe Msf::Exploit::Powershell do
  subject do
    mod = Msf::Exploit.allocate
    mod.extend described_class
    mod.send(:initialize, {})
    mod
  end

  let(:example_script) do
    File.join(Msf::Config.data_directory, "exploits", "powershell", "powerdump.ps1")
  end

  describe "::read_script" do
    it 'should read a sample script file' do
      script = subject.read_script(example_script)
      script.should be_kind_of(Rex::Exploitation::Powershell::Script)
    end
  end

  describe "::encode_script" do
    it 'should read and encode a sample script file' do
      script = subject.encode_script(example_script)
      script.should be
      script.length.should be > 0
    end
  end

  describe "::compress_script" do
    context 'when default datastore is set' do
      it 'should create a compressed script' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        compressed.length.should be < script.length
        compressed.include?('IO.Compression').should be_true
      end

      it 'should create a compressed script with eof' do
        script = File.read(example_script)
        compressed = subject.compress_script(script, 'end_of_file')
        compressed.length.should be < script.length
      end
    end

    context 'when strip_comments is true' do
      before do
        subject.datastore['Powershell::strip_comments'] = true
        subject.options.validate(subject.datastore)
      end
      it 'should strip comments' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        compressed.length.should be < script.length
      end
    end
    context 'when strip_comment is false' do
      before do
        subject.datastore['Powershell::strip_comments'] = false
        subject.options.validate(subject.datastore)
      end
      it 'shouldnt strip comments' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        compressed.length.should be < script.length
      end
    end

    context 'when strip_whitespace is true' do
      before do
        subject.datastore['Powershell::strip_whitespace'] = true
        subject.options.validate(subject.datastore)
      end
      it 'should strip whitespace' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).length.should be < script.length
      end
    end

    context 'when strip_whitespace is false' do
      before do
        subject.datastore['Powershell::strip_whitespace'] = false
        subject.options.validate(subject.datastore)
      end
      it 'shouldnt strip whitespace' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).length.should be script.length
      end
    end

    context 'when sub_vars is true' do
      before do
        subject.datastore['Powershell::sub_vars'] = true
        subject.options.validate(subject.datastore)
      end
      it 'should substitute variables' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).include?('$hashes').should be_false
      end
    end

    context 'when sub_vars is false' do
      before do
        subject.datastore['Powershell::sub_vars'] = false
        subject.options.validate(subject.datastore)
      end
      it 'shouldnt substitute variables' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).include?('$hashes').should be_true
      end
    end

    context 'when sub_funcs is true' do
      before do
        subject.datastore['Powershell::sub_funcs'] = true
        subject.options.validate(subject.datastore)
      end
      it 'should substitute functions' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).include?('DumpHashes').should be_false
      end
    end

    context 'when sub_funcs is false' do
      before do
        subject.datastore['Powershell::sub_funcs'] = false
        subject.options.validate(subject.datastore)
      end
      it 'shouldnt substitute variables' do
        script = File.read(example_script)
        compressed = subject.compress_script(script)
        decompress(compressed).include?('DumpHashes').should be_true
      end
    end
  end

  describe "::cmd_psh_payload" do
    it 'should generate a command line with an x86 payload' do

    end

    it 'should generate a command line with an x64 payload' do

    end

    context 'when persist is true' do
      it 'should add a persistance loop'
      end
    end

    context 'when persist is false' do
      it 'shouldnt add a persistance loop' do
      end
    end

    context 'when prepend_sleep is set' do
      it 'should add a sleep' do

      end
    end

    context 'when prepend_sleep isnt set' do
      it 'shouldnt add a sleep' do

      end
    end

    context 'when method is old' do

    end

    context 'when method is net' do

    end

    context 'when method is reflection' do

    end

    context 'when method is msil' do

    end

    context 'when encode_inner_payload' do

    end

    context 'when encode_final_payload' do

    end

    context 'when remove_comspec' do

    end

    context 'when use single quotes' do

    end
  end

  describe "::generate_psh_command_line" do
    it 'should contain no full stop when :no_full_stop' do
      opts = {:no_full_stop => true}
      command = subject.generate_psh_command_line(opts)
      command.include?("powershell ").should be_true
    end

    it 'should contain full stop unless :no_full_stop' do
      opts = {}
      command = subject.generate_psh_command_line(opts)
      command.include?("powershell.exe ").should be_true

      opts = {:no_full_stop => false}
      command = subject.generate_psh_command_line(opts)
      command.include?("powershell.exe ").should be_true
    end

    it 'should ensure the path should always ends with \\' do
      opts = {:path => "test"}
      command = subject.generate_psh_command_line(opts)
      command.include?("test\\powershell.exe ").should be_true

      opts = {:path => "test\\"}
      command = subject.generate_psh_command_line(opts)
      command.include?("test\\powershell.exe ").should be_true
    end
  end

  describe "::generate_psh_args" do
    it 'should return empty string for nil opts' do
      subject.generate_psh_args(nil).should eql ""
    end

    command_args = [[:encodedcommand, "parp"],
                    [:executionpolicy, "bypass"],
                    [:inputformat, "xml"],
                    [:file, "x"],
                    [:noexit, true],
                    [:nologo, true],
                    [:noninteractive, true],
                    [:mta, true],
                    [:outputformat, 'xml'],
                    [:sta, true],
                    [:noprofile, true],
                    [:windowstyle, "hidden"],
                    [:command, "Z"]
    ]

    permutations = (0..command_args.length).to_a.combination(2).map{|i,j| command_args[i...j]}

    permutations.each do |perms|
      opts = {}
      perms.each do |k,v|
        opts[k] = v
        it "should generate correct arguments for #{opts}" do
          opts[:shorten] = true
          short_args = subject.generate_psh_args(opts)
          opts[:shorten] = false
          long_args = subject.generate_psh_args(opts)

          opt_length = opts.length - 1

          short_args.should_not be_nil
          long_args.should_not be_nil
          short_args.count('-').should eql opt_length
          long_args.count('-').should eql opt_length
          short_args[0].should_not eql " "
          long_args[0].should_not eql " "
          short_args[-1].should_not eql " "
          long_args[-1].should_not eql " "

          if opts[:command]
            long_args[-10..-1].should eql "-Command Z"
            short_args[-4..-1].should eql "-c Z"
          end
       end
      end
    end
  end

end

