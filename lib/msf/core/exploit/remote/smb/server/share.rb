# -*- coding: binary -*-
require 'rex/socket'
require 'rex/text'
require 'rex/struct2'

module Msf
  module Exploit::Remote::SMB::Server
    # This mixin provides a minimal SMB server sharing an UNC resource. At
    # this moment it is capable to share just one file. And the file should
    # live in the root folder "\\".
    module Share
      include Exploit::Remote::SocketServer

      module ServiceMixin
        def start
          self.listener_thread = Rex::ThreadFactory.spawn('SMBServerListener', false) do
            print_good 'Running the server'
            begin
              run do
                print_good 'Received SMB connection on share server!'
                true
              end
            rescue IOError => e
              # this 'IOError: stream closed in another thread' is expected, so disregard it
              wlog("#{e.class}: #{e.message}")
            end
          end
        end

        def thread_local_client
          connection = @connections.find { |connection| connection.thread.object_id == Thread.current.object_id }
          connection&.client
        end

        def stop
          @socket.close
        end

        def wait
          listener_thread.join if listener_thread
        end

        attr_accessor :listener_thread
      end

      # @!attribute share
      #   @return [String] The share portion of the provided UNC.
      attr_accessor :share
      # @!attribute folder_name
      #   @return [String] The folder where the provided file lives.
      attr_accessor :folder_name
      # @!attribute file_name
      #   @return [String] The file name of the provided UNC.
      attr_accessor :file_name
      # @!attribute file_contents
      #   @return [String] The contents of the provided file
      attr_reader :file_contents

      def initialize(info = {})
        super

        register_options(
          [
            OptPort.new('SRVPORT',    [ true, 'The local port to listen on.', 445 ]),
            OptString.new('SHARE', [ false, 'Share (Default Random)']),
            OptString.new('FILE_NAME', [ false, 'File name to share (Default Random)']),
            OptString.new('FOLDER_NAME', [ false, 'Folder name to share (Default none)'])
          ], Msf::Exploit::Remote::SMB::Server::Share)
        register_advanced_options(
          [
            OptString.new('SMBDomain', [ true, 'The domain name used during SMB exchange.', 'WORKGROUP'])
          ]
        )
      end

      def start_service(opts = {})
        @rsock = Rex::Socket::Tcp.create(
          'LocalHost' => bindhost,
          'LocalPort' => bindport,
          'Comm' => _determine_server_comm(bindhost),
          'Server' => true,
          'Context' =>
            {
              'Msf' => framework,
              'MsfExploit' => self
            }
        )

        ntlm_provider = RubySMB::Gss::Provider::NTLM.new(
          allow_anonymous: true,
          allow_guests: true
        )

        # Set domain name for all future server responses
        ntlm_provider.dns_domain = datastore['SMBDomain']
        ntlm_provider.dns_hostname = datastore['SMBDomain']
        ntlm_provider.netbios_domain = datastore['SMBDomain']
        ntlm_provider.netbios_hostname = datastore['SMBDomain']

        server = RubySMB::Server.new(
          server_sock: @rsock,
          gss_provider: ntlm_provider,
          logger: :stdout
        )

        virtual_disk = RubySMB::Server::Share::Provider::VirtualDisk.new(@share)
        virtual_disk.add_static_file("#{@folder_name}#{File::SEPARATOR}#{@file_name}", @file_contents) if @file_contents
        server.add_share(virtual_disk)

        server.extend(ServiceMixin)
        self.service = server
        self.service.start

        print_status("Server is running. Listening on #{bindhost}:#{bindport}")
      end

      def cleanup_service
        if service
          begin
            self.service.stop
            self.service.wait
            true
          rescue ::Exception => e
            print_error(e.message)
            false
          end
        end
      end

      # Setups the server configuration.
      def setup
        super

        self.folder_name = datastore['FOLDER_NAME']
        self.share = datastore['SHARE'] || Rex::Text.rand_text_alpha(4 + rand(3))
        self.file_name = datastore['FILE_NAME'] || Rex::Text.rand_text_alpha(4 + rand(3))
      end

      # Builds the UNC Name for the shared file
      def unc
        if folder_name
          path = "\\\\#{srvhost}\\#{share}\\#{folder_name}\\#{file_name}"
        else
          path = "\\\\#{srvhost}\\#{share}\\#{file_name}"
        end

        path
      end

      # Returns the file contents for the requested file
      #
      # @return [String] The file contents.
      def get_file_contents(client:)
        file_contents
      end

      def file_contents=(contents)
        @file_contents = contents
        return unless self.service

        virtual_disk = self.service.shares[@share]
        virtual_disk.add_static_file("#{@folder_name}#{File::SEPARATOR}#{@file_name}", contents)
      end
    end
  end
end
