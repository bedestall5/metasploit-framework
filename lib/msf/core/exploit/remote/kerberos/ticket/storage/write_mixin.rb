module Msf::Exploit::Remote::Kerberos::Ticket::Storage
  module WriteMixin
    # return [Array<FixMeKrbObj>]
    def delete_credentials(options = {})
      objects = objects(options)
      framework.db.delete_loot(ids: objects.map(&:id))
      objects.map do |stored_loot|
        ccache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.read(stored_loot.data)
        # at this time Metasploit stores 1 credential per ccache file, so no need to iterate through them
        ccache.credentials.first
      end
    end

    # @param [Rex::Proto::Kerberos::CredentialCache::Krb5Ccache] ccache
    # @return [nil]
    def store_ccache(ccache, options = {})
      realm = options.fetch(:realm) { ccache.default_principal.realm }
      # use #components.to_a.join('/') to omit the realm that #to_s includes
      client = options.fetch(:client) { ccache.credentials.first&.client&.components.to_a.join('/') }
      server = options.fetch(:server) { ccache.credentials.first&.server&.components.to_a.join('/') }
      info = loot_info(realm: realm, client: client, server: server)

      path = store_loot('mit.kerberos.ccache', 'application/octet-stream', options[:host], ccache.encode, nil, info)
      message = ''
      if @framework_module.respond_to?(:peer) && @framework_module.peer.present? && @framework_module.peer != ':'
        message << "#{@framework_module.peer} - "
      end
      if server && server.to_s.downcase.start_with?('krbtgt/')
        message << 'TGT '
      else
        message << 'TGS '
      end
      message << "MIT Credential Cache ticket saved to #{path}"
      print_status(message)

      nil
    end
  end
end
