module Msf::Exploit::Remote::Kerberos
  class TicketStorage
    extend Forwardable
    include Msf::Exploit::Remote::Kerberos::Client
    include Msf::Auxiliary::Report

    # @!attribute [r] framework
    #   @return [Msf::Framework] the Metasploit framework instance
    attr_reader :framework

    # @!attribute [r] framework
    #   @return [Msf::Module] the Metasploit framework module that is associated with the authentication instance
    attr_reader :framework_module

    def_delegators :@framework_module,
                  :print_status,
                  :print_good,
                  :vprint_error,
                  :workspace

    def initialize(framework: nil, framework_module: nil)
      @framework = framework || framework_module&.framework
      @framework_module = framework_module
    end

    def delete_credentials(options = {})
      creds = credentials(options)
      framework.db.delete_loot(ids: creds.map(&:id))
      creds
    end

    def credentials(options = {}, &block)
      objects(options) do |stored_loot|
        ccache = Rex::Proto::Kerberos::CredentialCache::Krb5Ccache.read(stored_loot.data)
        # at this time Metasploit stores 1 credential per ccache file, so no need to iterate through them
        credential = ccache.credentials.first
        block.call(credential) if block_given?
        credential
      end
    end

    def load_credential(options = {})
      return nil unless active_db?

      now = Time.now.utc
      credentials(options) do |credential|
        tkt_start = credential.starttime == Time.at(0).utc ? credential.authtime : credential.starttime
        tkt_end = credential.endtime
        return credential if tkt_start < now && now < tkt_end
      end

      nil
    end

    # @param [Rex::Proto::Kerberos::CredentialCache::Krb5Ccache] ccache
    # @return [nil]
    def store_ccache(ccache, options = {})
      realm = options.fetch(:realm) { ccache.default_principal.realm }
      # use #components.to_a.join('/') to omit the realm that #to_s includes
      client = options.fetch(:client) { ccache.credentials.first&.client&.components.to_a.join('/') }
      server = options.fetch(:server) { ccache.credentials.first&.server&.components.to_a.join('/') }
      info = loot_info(realm: realm, client: client, server: server)

      path = store_loot('mit.kerberos.ccache', 'application/octet-stream', options[:host], ccache.encode, nil, info)
      message = ''
      if @framework_module.respond_to?(:peer) && @framework_module.peer.present? && @framework_module.peer != ':'
        message << "#{@framework_module.peer} - "
      end
      if server && server.to_s.downcase.start_with?('krbtgt/')
        message << 'TGT '
      else
        message << 'TGS '
      end
      message << "MIT Credential Cache ticket saved to #{path}"
      print_status(message)

      nil
    end

    private

    def objects(options, &block)
      return [] unless active_db?

      filter = {}
      if options[:host].present?
        if options[:host].is_a?(Mdm::Host)
          filter[:host] = options[:host]
        else
          filter[:host] = { address: options[:host] }
        end
      end
      unless (info = loot_info(options)).blank?
        filter[:info] = info
      end
      framework.db.loots(workspace: myworkspace, ltype: 'mit.kerberos.ccache', **filter).each do |stored_loot|
        block.call(stored_loot)
      end
    end

    # Build a loot info string that can later be used in a lookup.
    #
    # @param [Hash] options
    # @option options [String] :realm the realm of the ticket (optional)
    # @option options [String] :server the service name of the ticket (optional)
    # @option options [String] :client the client username of the ticket (optional)
    # @option options [Boolean] :valid whether or not the ticket is valid, defaults to true (optional)
    # @return [String] the info string
    def loot_info(options = {})
      info = []

      info << '[invalid]' if !options.fetch(:valid, true)

      realm = options[:realm]
      info << "realm: #{realm.to_s.upcase}" if realm.present?

      client = options[:client]
      info << "client: #{client.to_s.downcase}" if client.present?

      server = options[:server]
      info << "server: #{server.to_s.downcase}" if server.present?

      info.join(', ')
    end
  end
end

