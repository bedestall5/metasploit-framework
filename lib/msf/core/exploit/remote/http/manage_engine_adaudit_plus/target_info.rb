# -*- coding: binary -*-

module Msf::Exploit::Remote::HTTP::ManageEngineAdauditPlus::TargetInfo
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::ManageEngineAdauditPlus::StatusCodes
  include Msf::Exploit::Remote::HTTP::ManageEngineAdauditPlus::URIs

  # Check that a target is likely running ManageEngine ADAudit Plus
  #
  # @return [Array<Integer, String>] Array containing a status code (Integer) and status message (String). If the target is ADAudit Plus, the Array also contains the server response
  def adaudit_plus_target_check
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET'
    })

    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res

    if res.code == 200 && res.body =~ /<title>ADAudit Plus/
      [adaudit_plus_status::SUCCESS, 'The target appears to be MangeEngine ADAudit Plus', res]
    else
      [adaudit_plus_status::UNEXPECTED_REPLY, 'The target does not appear to be MangeEngine ADAudit Plus']
    end
  end

  # Extract the configured aliases for the configured Active Directory
  # domains from a HTTP response body.
  #
  # @param res_body [String] HTTP response body obtained via a GET request to the ADAudit Plus base path
  # @return [Array<Integer, String>] Array containing a status code and status message.
  #  If AD domain aliases were found, the Array also contains an
  #  Array of Strings for the domain aliases.
  def adaudit_plus_grab_domain_aliases(res_body)
    domain_info = res_body.scan(/<select id="domainName" name="domainName" tabindex="\d+".*?>(.*?)<\/select>/m)&.flatten&.first
    domain_aliases = domain_info&.scan(/<option value="(.*?)">.*?<\/option>/m)&.flatten
    if domain_aliases.blank? || !domain_aliases.kind_of?(Array) || domain_aliases == ['ADAuditPlus Authentication']
      return [adaudit_plus_status::NO_MATCH, 'No configured Active Directory domains were found.']
    end

    # remove 'ADAuditPlus Authentication' from the configured domains if it is listed
    domain_aliases.delete('ADAuditPlus Authentication')

    [adaudit_plus_status::SUCCESS, "Identified #{domain_aliases.length} configured domain alias(es): #{domain_aliases.join(', ')}", domain_aliases]
  end

  # Performs an API call to obtain the configured domains. The adapcsrf
  # cookie obtained from this request is necessary to perform
  # further authenticated actions.
  #
  # @param adapcsrf_cookie [String] A valid adapcsrf_cookie obtained via a successful login action
  # @param silent [Boolean] Whether to run in silent mode or not (silent mode means fewer print messages)
  # @return [Hash] Hash containing a `status` key, which is used to hold a
  #   status value as an Integer value, a `message` key, which is used
  #   to hold a message associated with the status value as a String,
  #   an optional `adapcsrf_cookie` key which maps to a String containing the
  #   adapcsrf cookie to be used for authentication purposes, and an
  #   optional `configured_domains` key which maps to an Array of Strings,
  #   each containing a domain name that has been configured to be used by
  #   the ManageEngine ADAudit Plus target.
  def adaudit_plus_grab_configured_domains(adapcsrf_cookie, silent=false)
    vprint_status('Attempting to obtain the list of configured domains...') unless silent

    res = send_request_cgi({
      'uri' => adaudit_plus_configured_domains_uri,
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'JSONString' => '{"checkGDPR":true}',
        'adapcsrf' => adapcsrf_cookie.to_s
      }
    })
    unless res
      return {
        'status' => adaudit_plus_status::CONNECTION_FAILED,
        'message' => 'Connection failed while attempting to obtain the list of configured domains.'
      }
    end

    configured_domains = []
    if res.code == 200 && res.body.include?('domainFullList') && !silent
      begin
        domain_info = JSON.parse(res.body)
        if domain_info.blank? || !domain_info.include?('domainFullList') || domain_info['domainFullList'].empty?
          print_warning('Failed to identify any configured domains.')
        else
          domain_full_list = domain_info['domainFullList']
          domain_full_list.each do |domain|
            next unless domain.is_a?(Hash) && domain.key?('name')

            domain_name = domain['name']
            next if domain_name.empty?

            configured_domains << domain_name
          end
        end
      rescue JSON::ParserError => e
        print_error('Failed to identify any configured domains - The server response did not contain valid JSON.')
        print_error("Error was: #{e.message}")
      end
    end

    adapcsrf_cookie = cookie_jar.cookies.select { |k| k.name == 'adapcsrf' }&.first
    got_cookie = adapcsrf_cookie && adapcsrf_cookie.value.present? ? true : false

    if configured_domains.empty?
      if got_cookie
        return {
          'status' => adaudit_plus_status::NO_MATCH,
          'message' => 'Failed to obtain the list of configured domains.',
          'adapcsrf_cookie' => adapcsrf_cookie.value
        }
      else
        return {
          'status' => adaudit_plus_status::NO_ACCESS,
          'message' => 'Failed to obtain the required post-auth adapcsrf cookie'
        }
      end
    end

    print_status("Found #{configured_domains.length} configured domain(s): #{configured_domains.join(', ')}")
    if got_cookie
      # we don't need to return a message here
      return {
        'status' => adaudit_plus_status::SUCCESS,
        'adapcsrf_cookie' => adapcsrf_cookie.value,
        'configured_domains' => configured_domains
      }
    else
      return {
        'status' => adaudit_plus_status::NO_ACCESS,
        'message' => 'Failed to obtain the required post-auth adapcsrf cookie',
        'configured_domains' => configured_domains
      }
    end
  end

  # Check the build number for the ADAudit Plus installation
  #
  # @param adapcsrf_cookie [String] A valid ADAP CSRF cookie for API calls.
  # @see adaudit_plus_login The function which can be called to obtain a
  #   valid CSRF cookie that can be used by this code.
  # @return [Array<Integer, String>] Array containing a status code (Integer) and status message (String). If the build number is obtained, the Array also contains a Reg::Version object.
  def adaudit_plus_grab_build(adapcsrf_cookie)
    vprint_status('Attempting to obtain the ADAudit Plus build number')

    res = send_request_cgi({
      'uri' => adaudit_plus_license_details_uri,
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => { 'adapcsrf' => adapcsrf_cookie.to_s }
    })

    return [adaudit_plus_status::CONNECTION_FAILED, 'Connection failed'] unless res
    unless res.code == 200
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Received unexpected HTTP response #{res.code} when attempting to obtain the build number."]
    end

    build = res.body.scan(/"buildNumber":"(.+?)",/)&.flatten&.first
    return [adaudit_plus_status::NO_MATCH, 'No build number was obtained.'] if build.blank?

    begin
      build_version = Rex::Version.new(build)
    rescue ArgumentError
      return [adaudit_plus_status::UNEXPECTED_REPLY, "Recieved an invalid build number: #{build}"]
    end

    [adaudit_plus_status::SUCCESS, "The target is ADAudit Plus #{build}", build_version]
  end

  # Check if the GPOWatcherData endpoint is available
  #
  # @return [Integer] Status code
  def gpo_watcher_data_check
    res = send_request_cgi({
      'uri' => adaudit_plus_gpo_watcher_data_uri,
      'method' => 'POST'
    })

    return adaudit_plus_status::CONNECTION_FAILED unless res
    return adaudit_plus_status::NO_ACCESS unless res.code == 200

    adaudit_plus_status::SUCCESS
  end
end
