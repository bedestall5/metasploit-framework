# -*- coding: binary -*-

# GitLab Access Tokens mixin
module Msf::Exploit::Remote::HTTP::Gitlab::AccessTokens
  # Create Gitlab access access token
  #
  # @return [String,nil] Gitlab personal access token if created, nil otherwise
  def gitlab_create_personal_access_token
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, '/-/profile/personal_access_tokens'),
      'keep_cookies' => true,
      'vars_post' => {
        'personal_access_token[name]' => Rex::Text.rand_text_alphanumeric(8),
        'personal_access_token[expires_at]' => '',
        'personal_access_token[scopes][]' => 'api',
        'commit' => 'Create personal access token'
      },
      'headers' => {
        'X-CSRF-Token' => gitlab_helper_extract_csrf_token(path: '/-/profile/personal_access_tokens', regex: /name="csrf-token" content="(.*)"/)
      }
    })

    raise Msf::Exploit::Remote::HTTP::Gitlab::Error::ClientError, 'Failed to create access token' unless res&.code == 200

    token = JSON.parse(res.body)['new_token']

    return token if token

    nil
  end

  # Revoke Gitlab personal access token
  #
  # @return [nil,GitLabClientError] nil if revoke, Msf::Exploit::Remote::HTTP::Gitlab::GitLabClientError otherwise
  def gitlab_revoke_personal_access_token(personal_access_token)
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, '/api/v4/personal_access_tokens/self'),
      'ctype' => 'application/json',
      'headers' => {
        'PRIVATE-TOKEN' => api_token
      }
    })

    raise Msf::Exploit::Remote::HTTP::Gitlab::Error::ClientError, 'Failed to revoke access token' unless res&.code == 204

    nil
  end
end
