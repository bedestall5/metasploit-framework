# -*- coding: binary -*-

module Msf::Exploit::Remote::HTTP::NagiosXi::Login
  include Msf::Exploit::Remote::HTTP::NagiosXi::URIs
  # performs a Naxios XI login
  #
  # @param user [String] Username
  # @param pass [String] Password
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing the HTTP response body and session cookies if the Nagios XI backend was accessed successfully, Array containing an error code and nil if Nagios XI hasn't been fully installed, otherwise Array containing an error code and an error message
  def nagios_xi_login(user, pass, finish_install)
    print_status('Attempting to authenticate to Nagios XI...')

    # visit the login page in order to obtain the cookies and the `nsp_str` token required for authentication
    res_pre_login = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_login_url,
    })

    unless res_pre_login
      return [1, 'Connection failed']
    end

    unless res_pre_login.code == 200 && res_pre_login.body.include?('>Nagios XI<')
      # check if we are perhaps dealing with a Nagios XI app that hasn't been fully installed yet 
      unless res_pre_login.code == 302 && res_pre_login.body.include?('>Nagios XI<') && res_pre_login.headers['Location'].end_with?('/install.php')
        return [3, 'Target is not a Nagios XI application']
      end

      print_warning('The target seems to be a Nagios XI application that has not been fully installed yet.')
      unless finish_install
        return [2, 'You can let the module complete the installation by setting `FINISH_INSTALL` to true.']          
      end

      return [4, nil]
    end
    
    # grab the necessary tokens required for authentication
    nsp = get_nsp(res_pre_login)
    if nsp.blank?
      return [2, 'Unable to obtain the value of the `nsp_str` token required for authentication']
    end

    pre_auth_cookies = res_pre_login.get_cookies
    if pre_auth_cookies.blank?
      return [2, 'Unable to obtain the cookies required for authentication']
    end

    # authenticate
    res_login = send_request_cgi({
      'method' => 'POST',
      'uri' => nagios_xi_login_url,
      'cookie' => pre_auth_cookies,
      'vars_post' => {
        'nsp' => nsp,
        'pageopt' => 'login',
        'username' => user,
        'password' => pass
      }
    })

    unless res_login
      return [1, 'Connection failed']
    end

    unless res_login.code == 302 && res_login.headers['Location'] == 'index.php'
      return [2, 'Received unexpected reply while trying to authenticate']
    end

    # grab the cookies
    auth_cookies = res_login.get_cookies

    if auth_cookies.blank?
      return [2, 'Unable to obtain the cookies required for authentication']
    end

    # make sure we only use the cookies we need, otherwise we may encounter a session timeout
    auth_cookies = clean_cookies(pre_auth_cookies, auth_cookies)

    # try to visit the dasboard
    visit_nagios_dashboard(auth_cookies, finish_install)
  end

  # compares cookies obtained before and after authentication and modifies the latter to remove cookies that may cause session timeouts
  #
  # @param pre_auth_cookies [String] Cookies obtained before authenticating to Nagios XI
  # @param auth_cookies [String] Cookies obtained while authenticating to Nagios XI
  # @return [String, nil] String containing the cookies required for authentication, stripped off unnecessary/unwanted cookies, nil if one or both of the parameters passed to this method are nil
  def clean_cookies(pre_auth_cookies, auth_cookies)
    if pre_auth_cookies.nil? || auth_cookies.nil?
      return nil
    end
    # Nagios XI may sometimes send the cookie `nagiosxi=deleted;` as part of the cookies after authentication
    # This was observed when trying to access Nagios XI 5.3.0 when the license agreement had not been accepted yet.
    # The `nagiosxi=deleted;` cookie should be filtered out, since it may break authentication
    if auth_cookies.include?('nagiosxi=deleted;')
      auth_cookies = auth_cookies.gsub('nagiosxi=deleted;', '').strip
    end

    # remove duplicate cookies, necessary to make the next check work in case multiple identical cookies were set (as observed on older Nagios versions)
    auth_cookies_array = auth_cookies.split(' ')
    auth_cookies_array.uniq!
    auth_cookies = auth_cookies_array.join(' ')

    # for newer Nagios XI versions, we need to remove the pre_auth cookies from the auth_cookies string, otherwise the session will timeout
    # however, older Nagios XI versions use only cookie which has the same name both before and after authentication
    unless pre_auth_cookies == auth_cookies
      if auth_cookies.include?(pre_auth_cookies)
        auth_cookies = auth_cookies.gsub(pre_auth_cookies, '').strip
      end
    end

    auth_cookies
  end

  # performs an HTTP GET request to the Nagios XI backend to verify if authentication succeeded
  #
  # @param auth_cookies [String] Cookies required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing an HTTP response body and the authentication cookies if the Nagios XI backend was accessed successfully, otherwise Array containing an error code and either an error message or (if the license agreement is not signed) an Array with authentication tokens
  def visit_nagios_dashboard(auth_cookies, finish_install)
    # visit the index page to verify we successfully authenticated
    res_index = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_backend_url,
      'cookie' => auth_cookies
    })

    unless res_index
      return [1, 'Connection failed']
    end

    unless res_index.code == 200 && res_index.body.include?('>Home Dashboard<')
      # check if we need to sign the license agreement
      unless res_index.code == 302 && res_index.headers['Location'].end_with?('login.php?showlicense')
        return [2, 'Received unexpected reply while trying to acess the NagiosXI home dashboard after authenticating.']
      end

      print_warning('The Nagios XI license agreement has not yet been signed on the target.')
      unless finish_install
        return [2, 'You can let the module sign the Nagios XI license agreement by setting `FINISH_INSTALL` to true.']
      end

      nsp = get_nsp(res_index)

      if nsp.blank?
        return [2, 'Failed to obtain the nsp token required for signing the license agreement.']
      end

      return [5, [auth_cookies, nsp]]
    end

    # return the HTTP resonse body and the authentication cookies
    ## the response body can be used to obtain the version number
    ## the cookies can be used by exploit modules to send authenticated requests
    [res_index.body, auth_cookies]

  end

  # Grabs the nsp_str value from an HTTP response using regex
  #
  # @param res [Rex::Proto::Http::Response] HTTP response
  # @return [String] nsp_str value
  def get_nsp(res)
    nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue ''
  end

  # performs an authentication attempt. If the server does not return a response, a second attempt is made after a delay of 5 seconds
  #
  # @param username [String] Username required for authentication
  # @param password [String] Password required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the installation hasn't been completed or the license agreement is not signed
  # @return [Array] Array containing the HTTP response body and session cookies if the Nagios XI backend was accessed successfully, otherwise Array containing an error code and an error message
  def login_after_install_or_license(username, password, finish_install)
    # after installing Nagios XI or signing the license agreement, we sometimes don't receive a server response
    # this loop ensures that at least 2 login attempts are performed if this happens, as the second one usually works
    second_attempt = false
    while true
      login_result, error_message = nagios_xi_login(username, password, finish_install)

      break unless error_message
      break unless error_message == 'Connection failed'

      if second_attempt
        print_warning('The server is still not responding. If you wait a few seconds and rerun the module, it might still work.')
        break
      else
        print_warning('No response received from the server. This can happen after installing Nagios XI or signing the license agreement')
        print_status('The module will wait for 5 seconds and retry.')
        second_attempt = true
        sleep 5
      end
    end

    return [login_result, error_message]

  end
end
