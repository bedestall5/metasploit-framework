# -*- coding: binary -*-

module Msf::Exploit::Remote::HTTP::NagiosXi::Login
  # performs a Naxios XI login
  #
  # @param user [String] Username
  # @param pass [String] Password
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the isntallation hasn't been completed or the license agreement is not signed
  # @return [Array, String, Array, Msf::Exploit::CheckCode] Array containing the HTTP response body and session cookies if the Nagios XI backend was accessed successfully, String 'install_required' if Nagios Xi is not fully installed, Array containing 'sign_license' and the cookies and nsp token if the license agreement is not signed, Msf::Exploit::CheckCode otherwise
  def nagios_xi_login(user, pass, finish_intall)
    print_status('Attempting to authenticate to Nagios XI...')

    # visit the login page in order to obtain the cookies and the `nsp_str` token required for authentication
    res_pre_login = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_login_url,
    })

    unless res_pre_login
      return Msf::Exploit::CheckCode::Unknown('Connection failed')
    end

    unless res_pre_login.code == 200 && res_pre_login.body.include?('>Nagios XI<')
      # check if we are perhaps dealing with a Nagios XI app that hasn't been fully installed yet 
      unless res_pre_login.code == 302 && res_pre_login.body.include?('>Nagios XI<') && res_pre_login.headers['Location'].end_with?('/install.php')
        return Msf::Exploit::CheckCode::Safe('Target is not a Nagios XI application')
      end

      print_warning('The target seems to be a Nagios XI application that has not been fully installed yet.')
      unless finish_intall
        return Msf::Exploit::CheckCode::Detected('You can let the module complete the installation by setting `FINISH_INSTALL` to true.')
      end

      return 'install_required'
    end
    
    # grab the necessary tokens required for authentication
    nsp = get_nsp(res_pre_login)
    if nsp.blank?
      return Msf::Exploit::CheckCode::Unknown('Unable to obtain the value of the `nsp_str` token required for authentication')
    end

    pre_auth_cookies = res_pre_login.get_cookies
    if pre_auth_cookies.blank?
      return Msf::Exploit::CheckCode::Unknown('Unable to obtain the cookies required for authentication')
    end

    # authenticate
    res_login = send_request_cgi({
      'method' => 'POST',
      'uri' => nagios_xi_login_url,
      'cookie' => pre_auth_cookies,
      'vars_post' => {
        'nsp' => nsp,
        'pageopt' => 'login',
        'username' => user,
        'password' => pass
      }
    })

    unless res_login
      return Msf::Exploit::CheckCode::Unknown('Connection failed')
    end

    unless res_login.code == 302 && res_login.headers['Location'] == 'index.php'
      return Msf::Exploit::CheckCode::Detected('Received unexpected reply while trying to authenticate')
    end

    # grab the cookies
    auth_cookies = res_login.get_cookies

    if auth_cookies.blank?
      return Msf::Exploit::CheckCode::Unknown('Unable to obtain the cookies required for authentication')
    end

    # make sure we only use the cookies we need, otherwise we may encounter a session timeout
    auth_cookies = clean_cookies(pre_auth_cookies, auth_cookies)

    # try to visit the dasboard
    dashboard_response = visit_nagios_dashboard(auth_cookies, finish_intall)

    # if we visited the dashboard, return the response body and the cookies
    ## the response body can be used to obtain the version number
    ## the cookies can be used by exploit modules to send authenticated requests
    if dashboard_response.instance_of? Rex::Proto::Http::Response
      return [dashboard_response.body, auth_cookies]
    end

    dashboard_response

  end

  # compares cookies obtained before and after authentication and modifies the latter to remove cookies that may cause session timeouts
  #
  # @param pre_auth_cookies [String] Cookies obtained before authenticating to Nagios XI
  # @param auth_cookies [String] Cookies obtained while authenticating to Nagios XI
  # @return [String] String containing the cookies required for authentication, stripped off unnecessary/unwanted cookies
  def clean_cookies(pre_auth_cookies, auth_cookies)
    # Nagios XI may sometimes send the cookie `nagiosxi=deleted;` as part of the cookies after authentication
    # This was observed when trying to access Nagios XI 5.3.0 when the license agreement had not been accepted yet.
    # The `nagiosxi=deleted;` cookie should be filtered out, since it may break authentication
    if auth_cookies.include?('nagiosxi=deleted;')
      auth_cookies = auth_cookies.gsub('nagiosxi=deleted;', '').strip
    end

    # remove duplicate cookies, necessary to make the next check work in case multiple identical cookies were set (as observed on older Nagios versions)
    auth_cookies_array = auth_cookies.split(' ')
    auth_cookies_array.uniq!
    auth_cookies = auth_cookies_array.join(' ')

    # for newer Nagios XI versions, we need to remove the pre_auth cookies from the auth_cookies string, otherwise the session will timeout
    # however, older Nagios XI versions only use one and the same cookie before and after authentication
    unless pre_auth_cookies == auth_cookies
      if auth_cookies.include?(pre_auth_cookies)
        auth_cookies = auth_cookies.gsub(pre_auth_cookies, '').strip
      end
    end

    auth_cookies
  end

  # performs an HTTP GET request to the Nagios XI backend to verify if authentication succeeded
  #
  # @param auth_cookies [String] Cookies required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the isntallation hasn't been completed or the license agreement is not signed
  # @return [String, Array, Msf::Exploit::CheckCode] HTTP response body if the Nagios XI backend was accessed successfully, Array containing 'sign_license' and the cookies and nsp token if the license agreement is not signed yet, Msf::Exploit::CheckCode otherwise
  def visit_nagios_dashboard(auth_cookies, finish_intall)
    # visit the index page to verify we successfully authenticated
    res_index = send_request_cgi({
      'method' => 'GET',
      'uri' => nagios_xi_backend_url,
      'cookie' => auth_cookies
    })

    unless res_index
      return Msf::Exploit::CheckCode::Unknown('Connection failed')
    end

    unless res_index.code == 200 && res_index.body.include?('>Home Dashboard<')
      # check if we need to sign the license agreement
      unless res_index.code == 302 && res_index.headers['Location'].end_with?('login.php?showlicense')
        return Msf::Exploit::CheckCode::Detected('Received unexpected reply while trying to acess the NagiosXI home dashboard after authenticating.')
      end

      print_warning('The Nagios XI license agreement has not yet been signed on the target.')
      unless finish_intall
        return Msf::Exploit::CheckCode::Detected('You can let the module sign the Nagios XI license agreement by setting `FINISH_INSTALL` to true.')
      end

      nsp = get_nsp(res_index)

      if nsp.blank?
        return Msf::Exploit::CheckCode::Detected('Failed to obtain the nsp token required for signing the license agreement.')
      end

      return ['sign_license', auth_cookies, nsp]
    end

    res_index

  end

  # Grabs the nsp_str value from an HTTP response using regex
  #
  # @param res [Rex::Proto::Http::Response] HTTP response
  # @return [String] nsp_str value
  def get_nsp(res)
    nsp = res.body.scan(/nsp_str = "([a-z0-9]+)/).flatten.first rescue ''
  end

  # performs an authentication attempt. If the server does not return a response, a second attempt is made after a delay of 5 seconds
  #
  # @param username [String] Username required for authentication
  # @param password [String] Password required for authentication
  # @param finish_install [Boolean] Boolean indicating if the module should finish installing Nagios XI on target hosts if the isntallation hasn't been completed or the license agreement is not signed
  # @return [Array, String, Array, Msf::Exploit::CheckCode] Array containing the HTTP response body and session cookies if the Nagios XI backend was accessed successfully, String 'install_required' if Nagios Xi is not fully installed, Array containing 'sign_license' and the cookies and nsp token if the license agreement is not signed, Msf::Exploit::CheckCode otherwise
  def login_after_install_or_license(username, password, finish_install)
    # after installing Nagios XI or signing the license agreement, we sometimes don't receive a server response
    # this loop ensures that at least 2 login attempts are performed if this happens, as the second one usually works
    second_attempt = false
    while true
      login_result = nagios_xi_login(username, password, finish_install)

      break unless login_result.instance_of? Msf::Exploit::CheckCode
      break unless login_result.message.include?('Connection failed')

      if second_attempt
        print_warning('The server is still not responding. If you wait a few seconds and rerun the module, it might still work.')
        break
      else
        print_warning('No response received from the server. This can happen after installing Nagios XI or signing the license agreement')
        print_status('The module will wait for 5 seconds and retry.')
        second_attempt = true
        sleep 5
      end
    end

    return login_result

  end
end
