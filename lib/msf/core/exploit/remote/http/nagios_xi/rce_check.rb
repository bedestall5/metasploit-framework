# -*- coding: binary -*-

module Msf::Exploit::Remote::HTTP::NagiosXi::RceCheck
  # Uses the Nagios XI version to check which CVEs and related exploit modules the target is vulnerable to, if any
  #
  # @param version [Gem::Version] Nagios XI version
  # @return [Hash, Msf::Exploit::CheckCode], Hash mapping CVE numbers to exploit module names if the target is vulnerable, Msf::Exploit::CheckCode otherwise
  def nagios_xi_rce_check(version)
    matching_exploits = {}
    
    # known exploits that affect versions prior to the one in the hash key
    nagios_rce_version_prior = {
      '5.6.6' => [['CVE-2019-15949', 'nagios_xi_plugins_check_ping_authenticated_rce']],
      '5.8.0' => [['CVE-2020-35578', 'nagios_xi_plugins_filename_authenticated_rce']]
    }

    nagios_rce_version_prior.each do |fixed_version, info|
      if version < Gem::Version.new(fixed_version)
        matching_exploits = add_cve_module_to_hash(matching_exploits,info)
      end
    end

    # known exploits that affect only the version in the hash key
    nagios_rce_version_equals = {
      '5.7.3' => [['CVE-2020-5791', 'nagios_xi_mibs_authenticated_rce'],['CVE-2020-5792', 'nagios_xi_snmptrap_authenticated_rce']]
    }

    nagios_rce_version_equals.each do |fixed_version, info|
      if version == Gem::Version.new(fixed_version)
        matching_exploits = add_cve_module_to_hash(matching_exploits,info)
      end
    end

    # the below hash can be populated with exploits that affect version ranges
    # each hash key should be two versions separated by a hyphen, eg `5.8.0-5.8.5`
    nagios_rce_version_range = {} 

    nagios_rce_version_range.each do |fixed_version, info|
      safe_lower, safe_higher = fixed_version.split("-")
      safe_lower = Gem::Version.new(safe_lower)
      safe_higher = Gem::Version.new(safe_higher)
      if safe_lower < version < safe_higher
        matching_exploits = add_cve_module_to_hash(matching_exploits,info)
      end
    end

    if matching_exploits.empty?
      return Msf::Exploit::CheckCode::Safe("Nagios XI version #{version} doesn't match any exploit modules.")
    end

    matching_exploits
  end

  # Helper function that populates the matching_exploits hash with the contents of cve_module_array by setting index 0 of each array as the key and index 1 as the value
  #
  # @param matching_exploits [Hash] maps CVE numbers to exploit module names
  # @param cve_module_array [Array] contains arrays with a CVE number at index 0 and a matching exploit at index 1
  # @return [Hash] matching exploits, maps CVE numbers to exploit module names
  def add_cve_module_to_hash(matching_exploits, cve_module_array)
    # account for version numbers for which we have multiple exploits
    if cve_module_array.length > 1
      cve_module_array.each do |cma|
        cve, msf_module = cma
        matching_exploits[cve] = msf_module
      end
    else
      cve, msf_module = cve_module_array.flatten
      matching_exploits[cve] = msf_module
    end
    matching_exploits
  end
end
