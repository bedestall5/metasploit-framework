# 3rd party gems
require 'http/cookie_jar/hash_store'
require 'http/cookie_jar'
require 'http/cookie'
require 'domain_name'

module Msf
  class Exploit
    class Remote
      module HTTP
        # Acts as a wrapper for the 3rd party CookieJar (http-cookie)
        class HttpCookieJar
          def initialize
            @cookie_jar = ::HTTP::CookieJar.new({
              store: HashStoreWithoutAutomaticExpiry
            })
          end

          def add(cookie)
            raise TypeError, "Passed cookie is of class '#{cookie.class}' and not a subclass of '#{HttpCookie.class}" unless cookie.is_a?(HttpCookie)

            @cookie_jar.add(cookie)
            self
          end

          def delete(cookie)
            return if @cookie_jar.cookies.empty?
            raise TypeError, "Passed cookie is of class '#{cookie.class}' and not a subclass of '#{HttpCookie.class}" unless cookie.is_a?(HttpCookie)

            @cookie_jar.delete(cookie)
            self
          end

          # Iterates over all cookies that are not expired in no particular
          # order.
          #
          # `uri` specifies a URI/URL indicating the destination of the cookies
          # being selected. Every cookie yielded should be good to send to the
          # given URI, i.e. cookie.valid_for_uri?(uri) evaluates to true.
          def cookies(uri = nil)
            @cookie_jar.cookies(uri)
          end

          def [](c)
            @cookie_jar.cookies(uri)[c]
          end

          def clear
            @cookie_jar.clear
          end

          def cleanup(expire_all = false)
            @cookie_jar.cleanup(expire_all)
          end

          def empty?(url = nil)
            @cookie_jar.empty?(url)
          end

          def parse(set_cookie_header, origin_url, options = nil)
            parsed_cookies = HTTP::Cookie.parse(set_cookie_header, origin_url, options)
            parsed_cookies.each { |c| add(HttpCookie.new(c)) }
          end

        end

        class HashStoreWithoutAutomaticExpiry < ::HTTP::CookieJar::HashStore

          # +::HTTP::CookieJar::HashStore+ expires cookies as it iterates. We don't want that.
          def each(uri = nil)
            if uri
              thost = DomainName.new(uri.host)
              tpath = uri.path
              @jar.each do |domain, paths|
                next unless thost.cookie_domain?(domain)

                paths.each do |path, hash|
                  next unless HTTP::Cookie.path_match?(path, tpath)

                  hash.each do |_name, cookie|
                    if cookie.valid_for_uri?(uri)
                      yield cookie
                    end
                  end
                end
              end
            else
              synchronize do
                @jar.each do |_domain, paths|
                  paths.each do |_path, hash|
                    hash.each do |_name, cookie|
                      yield cookie
                    end
                  end
                end
              end
            end
            self
          end
        end
      end
    end
  end
end
