# -*- coding: binary -*-

module Msf
module Exploit::FileDropper

	#
	# When a new session is created, attempt to delete any files that the
	# exploit created.
	#
	# @param (see Msf::Exploit#on_new_session)
	# @return [void]
	#
	def on_new_session(session)
		if session.type == "meterpreter"
			session.core.use("stdapi") unless session.ext.aliases.include?("stdapi")
		end

		@dropped_files.delete_if do |file|
			if session.type == "meterpreter"
				begin
					session.fs.file.rm(file)
					print_good("Deleted #{file}")
					true
				rescue ::Rex::Post::Meterpreter::RequestError
					false
				end
			else
				# Need to be platform-independent here. Not sure of the best way
				# to do that since we can't be certain that {#target} is
				# accurate; exploits with automatic targets frequently change
				# it.
				false
			end
		end

		super
	end

	#
	# Record file as needing to be cleaned up
	#
	# @param [Array<String>] files List of paths on the target that should
	#   be deleted during cleanup. Each filename should be either a full
	#   path or relative to the current working directory of the session
	#   (not necessarily the same as the cwd of the server we're
	#   exploiting).
	# @return [void]
	def register_files_for_cleanup(*files)
		@dropped_files ||= []
		@dropped_files += files

		nil
	end

	# Singular version
	alias register_file_for_cleanup register_files_for_cleanup

	#
	# Warn the user if any files (registered with {#register_dropped_file}) were
	# not cleaned up
	#
	# @see Msf::Exploit#cleanup
	def cleanup
		super
		if @dropped_files and @dropped_files.any?
			@dropped_files.each do |f|
				print_warning("This exploit may require manual cleanup of: #{f}")
			end
		end
	end
end
end
