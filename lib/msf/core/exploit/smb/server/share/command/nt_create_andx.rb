# -*- coding: binary -*-

module Msf
  module Exploit::Remote::SMB::Server
    module Share
      module Command
        module NtCreateAndx
          #
          # Responds to a client NT_CREATE_ANDX request
          #
          def smb_cmd_create(c, buff)
            dprint("[SMB_CMD_CREATE]")
            smb = @state[c]
            pkt = CONST::SMB_CREATE_PKT.make_struct
            pkt.from_s(buff)

            # Tries to do CREATE and X
            payload = pkt['Payload'].v['Payload'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip.split('\\').last
            file = file_name
            path = path_name

            if payload.nil?
              payload = file
            end

            if payload.length.to_s.eql?('1') or payload.eql?(path)
              fid = smb[:dir_id].to_i
              attribs = 0x10 # Ordinary Dir
              eof = 0
              isdir = 1
            else
              fid = smb[:file_id].to_i
              attribs = 0x80 # File Attributes
              eof = exe_contents.length
              isdir = 0
            end

            pkt = CONST::SMB_CREATE_RES_PKT.make_struct
            smb_set_defaults(c, pkt)
            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            pkt['Payload']['SMB'].v['WordCount'] = 42
            pkt['Payload'].v['AndX'] = 0xff # no further commands
            pkt['Payload'].v['OpLock'] = 0x3 # Grant Oplock on File
            pkt['Payload'].v['FileID'] = fid
            pkt['Payload'].v['Action'] = 0x1 # The file existed and was opened
            pkt['Payload'].v['CreateTimeLow'] = lo
            pkt['Payload'].v['CreateTimeHigh'] = hi
            pkt['Payload'].v['AccessTimeLow'] = lo
            pkt['Payload'].v['AccessTimeHigh'] = hi
            pkt['Payload'].v['WriteTimeLow'] = lo
            pkt['Payload'].v['WriteTimeHigh'] = hi
            pkt['Payload'].v['ChangeTimeLow'] = lo
            pkt['Payload'].v['ChangeTimeHigh'] = hi
            pkt['Payload'].v['Attributes'] = attribs
            pkt['Payload'].v['AllocLow'] = 0x100000
            pkt['Payload'].v['AllocHigh'] = 0
            pkt['Payload'].v['EOFLow'] = eof
            pkt['Payload'].v['EOFHigh'] = 0
            pkt['Payload'].v['FileType'] = 0
            pkt['Payload'].v['IPCState'] = 0x7
            pkt['Payload'].v['IsDirectory'] = isdir

            # As above, if payload is a file or "\" send found response
            if (payload.downcase.eql?(file.downcase)) or payload.length.to_s.eql?('1') or payload.eql?(path)
              connect_response = ""
              # GUID
              connect_response << ([0].pack("C") * 16)
              # File ID
              connect_response << ([0].pack("C") * 6)
              # Access Rights
              connect_response << [0xff].pack("C")
              connect_response << [0x01].pack("C")
              connect_response << [0x1f].pack("C")
              connect_response << [0].pack("C")
              connect_response << ([0].pack("C") * 4) # Guest access
              connect_response << ([0].pack("C") * 2) # Byte Count

              my_pkt = pkt.to_s + connect_response
              original_length = my_pkt[2, 2].unpack("n").first
              original_length = original_length + connect_response.length
              my_pkt[2, 2] = [original_length].pack("n")
              c.put(my_pkt)
            else
              # Otherwise send not found
              pkt = CONST::SMB_CREATE_RES_PKT.make_struct
              smb_set_defaults(c, pkt)
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
              pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = 0x88
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
            end
          end
        end
      end
    end
  end
end
