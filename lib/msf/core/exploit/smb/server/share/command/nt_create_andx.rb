# -*- coding: binary -*-

module Msf
  module Exploit::Remote::SMB::Server
    module Share
      module Command
        module NtCreateAndx
          #
          # Responds to a client NT_CREATE_ANDX request
          #
          def smb_cmd_create(c, buff)
            smb = @state[c]
            pkt = CONST::SMB_CREATE_PKT.make_struct
            pkt.from_s(buff)

            payload = (pkt['Payload'].v['Payload']).downcase
            payload.gsub!(/^[\x00]*/, '') # delete padding
            payload = Rex::Text.ascii_safe_hex(payload)
            payload.gsub!(/\\x([0-9a-f]{2})/i, '') # delete hex chars

            if payload.nil? || payload.empty?
              payload = file_name
            end

            if payload.ends_with?(file_name)
              fid = smb[:file_id].to_i
              attribs = CONST::SMB_EXT_FILE_ATTR_NORMAL
              eof = exe_contents.length
              is_dir = 0
            elsif payload.eql?(path_name)
              fid = smb[:dir_id].to_i
              attribs = CONST::SMB_EXT_FILE_ATTR_DIRECTORY
              eof = 0
              is_dir = 1
            else
              # Otherwise send not found
              pkt = CONST::SMB_CREATE_RES_PKT.make_struct
              smb_set_defaults(c, pkt)
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
              pkt['Payload']['SMB'].v['ErrorClass'] = CONST::SMB_STATUS_OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = FLAGS
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
              return
            end

            pkt = CONST::SMB_CREATE_ANDX_RES_PKT.make_struct
            smb_set_defaults(c, pkt)
            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
            pkt['Payload']['SMB'].v['Flags1'] = FLAGS
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            pkt['Payload']['SMB'].v['WordCount'] = 42
            pkt['Payload'].v['AndX'] = CONST::SMB_COM_NO_ANDX_COMMAND
            pkt['Payload'].v['OpLock'] = CONST::LEVEL_II_OPLOCK # Grant Oplock on File
            pkt['Payload'].v['FileID'] = fid
            pkt['Payload'].v['Action'] = CONST::FILE_OPEN # The file existed and was opened
            pkt['Payload'].v['CreateTimeLow'] = lo
            pkt['Payload'].v['CreateTimeHigh'] = hi
            pkt['Payload'].v['AccessTimeLow'] = lo
            pkt['Payload'].v['AccessTimeHigh'] = hi
            pkt['Payload'].v['WriteTimeLow'] = lo
            pkt['Payload'].v['WriteTimeHigh'] = hi
            pkt['Payload'].v['ChangeTimeLow'] = lo
            pkt['Payload'].v['ChangeTimeHigh'] = hi
            pkt['Payload'].v['Attributes'] = attribs
            pkt['Payload'].v['AllocLow'] = 0x100000
            pkt['Payload'].v['AllocHigh'] = 0
            pkt['Payload'].v['EOFLow'] = eof
            pkt['Payload'].v['EOFHigh'] = 0
            pkt['Payload'].v['FileType'] = CONST::SMB_RESOURCE_FILE_TYPE_DISK
            pkt['Payload'].v['IPCState'] = 0x7 # Number maxim of instance a named pipe can have
            pkt['Payload'].v['IsDirectory'] = is_dir
            pkt['Payload'].v['MaxAccess'] = CREATE_MAX_ACCESS
            c.put(pkt.to_s)
          end
        end
      end
    end
  end
end
