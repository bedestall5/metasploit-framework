# -*- coding: binary -*-

module Msf
  module Exploit::Remote::SMB::Server
    module Share
      module InformationLevel
        # This mixin provides methods to handle TRAN2_QUERY_PATH_INFORMATION subcommands
        module Query

          #
          # Tweak.. always send OBJECT_NAME_NOT_FOUND
          #
          def smb_cmd_trans_query_file_info_basic(c, buff)
            #dprint("[smb_cmd_trans_query_file_info_basic]")

            # try it...
            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)
            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
            pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            c.put(pkt.to_s)
            return
          end

          # Tweak, we only have one file....
          def smb_cmd_trans_query_file_info_standard(c, buff)
            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_STANDARD_INFO_HDR.make_struct
            query_path_info.v['AllocationSize'] = 1048576
            query_path_info.v['EndOfFile'] = exe_contents.length
            query_path_info.v['NumberOfLinks'] = 1
            query_path_info.v['DeletePending'] = 0
            query_path_info.v['Directory'] = 0 #isdir == false

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            pkt['Payload']['SMB'].v['WordCount'] = 10
            pkt['Payload'].v['ParamCountTotal'] = 2
            pkt['Payload'].v['DataCountTotal'] = 24
            pkt['Payload'].v['ParamCount'] = 2
            pkt['Payload'].v['ParamOffset'] = 56
            pkt['Payload'].v['DataCount'] = 24
            pkt['Payload'].v['DataOffset'] = 60
            pkt['Payload'].v['Payload'] =
              "\x00" + # Padding
              trans2_params.to_s +
              "\x00\x00" + # Padding
              query_path_info.to_s +
              "\x00\x00" # Unknown

            c.put(pkt.to_s)
          end

          #
          # Responds to QUERY_PATH_INFO (Basic) requests
          #
          def smb_cmd_trans_query_path_info_basic(c, buff)
            #dprint("[smb_cmd_trans_query_path_info_basic]")
            pkt = CONST::SMB_TRANS2_PKT.make_struct
            pkt.from_s(buff)

            # we don't know how to parse it.... better object name not found
            if pkt['Payload'].v['SetupCount'] != 1
              pkt = CONST::SMB_TRANS_RES_PKT.make_struct
              smb_set_defaults(c, pkt)
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
              pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = 0x88
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
              return
            end

            #puts "SETUP_DATA\n#{Rex::Text.to_hex_dump(pkt['Payload'].v['SetupData'])}"
            smb_data = CONST::SMB_DATA_TRANS2.make_struct
            smb_data.from_s(pkt['Payload'].v['SetupData'])

            #puts "SMB_DATA\n#{Rex::Text.to_hex_dump(smb_data.to_s)}"

            params = smb_data.v['Parameters']

            #puts "params\n#{Rex::Text.to_hex_dump(params.to_s)}"

            params.gsub!(/^[\x00]*/, '') #remove padding

            trans_params = CONST::SMB_QUERY_PATH_TRANS2_PARAMETERS.make_struct
            trans_params.from_s(params)

            path = Rex::Text.to_ascii(trans_params.v['FileName'])
            path.gsub!(/[\x00]*$/, '') #remove padding

            #puts "path: #{path}"
            #puts "path: #{Rex::Text.to_hex_dump(path)}"

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            if path && path.ends_with?(file_name) #TODO: do it better
              attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL # File attributes => file
            elsif path && path.ends_with?(file_name + '.Local')
              attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL # File attributes => file
            #elsif path && path.ends_with?(file_name + '.Manifest')
              #attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL # File attributes => file
            elsif path && path == path_name
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY # File attributes => directory
            elsif path.nil? || path.empty? || path == "\x00" # empty path
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY # File attributes => directory
            else
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
              pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = 0x88
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
              return
            end

            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_BASIC_INFO_HDR.make_struct
            query_path_info.v['loCreationTime'] = lo
            query_path_info.v['hiCreationTime'] = hi
            query_path_info.v['loLastAccessTime'] = lo
            query_path_info.v['hiLastAccessTime'] = hi
            query_path_info.v['loLastWriteTime'] = lo
            query_path_info.v['hiLastWriteTime'] = hi
            query_path_info.v['loLastChangeTime'] = lo
            query_path_info.v['hiLastChangeTime'] = hi
            query_path_info.v['ExtFileAttributes'] = attrib

            # If payload contains our file, send the response
            #if payload.downcase.eql?(file.downcase) or payload.length.to_s.eql?('4') or payload.downcase.include?(file.downcase)
            # At the moment we just support '\\' path always send a SUCCESS...
            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            pkt['Payload']['SMB'].v['WordCount'] = 10
            pkt['Payload'].v['ParamCountTotal'] = 2
            pkt['Payload'].v['DataCountTotal'] = 40
            pkt['Payload'].v['ParamCount'] = 2
            pkt['Payload'].v['ParamOffset'] = 56
            pkt['Payload'].v['DataCount'] = 40
            pkt['Payload'].v['DataOffset'] = 60
            pkt['Payload'].v['Payload'] =
              "\x00" + # Padding
              trans2_params.to_s +
              "\x00\x00" + # Padding
              query_path_info.to_s

            c.put(pkt.to_s)
          end

          #
          # Responds to QUERY_PATH_INFO (Standard) requests
          #
          # At the moment we just support '\\' path always send a SUCCESS...
          def smb_cmd_trans_query_path_info_standard(c, buff)
            #dprint("[smb_cmd_trans_query_path_info_standard]")
            pkt = CONST::SMB_TRANS2_PKT.make_struct
            pkt.from_s(buff)

            # we don't know how to parse it.... better object name not found
            if pkt['Payload'].v['SetupCount'] != 1
              pkt = CONST::SMB_TRANS_RES_PKT.make_struct
              smb_set_defaults(c, pkt)
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
              pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = 0x88
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
              return
            end

            #puts "SETUP_DATA\n#{Rex::Text.to_hex_dump(pkt['Payload'].v['SetupData'])}"
            smb_data = CONST::SMB_DATA_TRANS2.make_struct
            smb_data.from_s(pkt['Payload'].v['SetupData'])

            #puts "SMB_DATA\n#{Rex::Text.to_hex_dump(smb_data.to_s)}"

            params = smb_data.v['Parameters']

            #puts "params\n#{Rex::Text.to_hex_dump(params.to_s)}"

            params.gsub!(/^[\x00]*/, '') #remove padding

            trans_params = CONST::SMB_QUERY_PATH_TRANS2_PARAMETERS.make_struct
            trans_params.from_s(params)

            path = Rex::Text.to_ascii(trans_params.v['FileName'])
            path.gsub!(/[\x00]*$/, '') #remove padding

            #puts "path: #{path}"
            #puts "path: #{Rex::Text.to_hex_dump(path)}"

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            if path && path.ends_with?(file_name) #TODO: do it better
              attrib = 0 # File attributes => file
            elsif path && path.ends_with?(file_name + '.Local')
              attrib = 1 # File attributes => file
            #elsif path && path.ends_with?(file_name + '.Manifest')
              #attrib = 0 # File attributes => file
            elsif path && path == path_name
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = 1 # File attributes => directory
            elsif path.nil? || path.empty? || path == "\x00" # empty path
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = 1 # File attributes => directory
            else
              pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
              pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
              pkt['Payload']['SMB'].v['Flags1'] = 0x88
              pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
              c.put(pkt.to_s)
              return
            end

            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_STANDARD_INFO_HDR.make_struct
            query_path_info.v['AllocationSize'] = 1048576
            query_path_info.v['EndOfFile'] = exe_contents.length
            query_path_info.v['NumberOfLinks'] = 1
            query_path_info.v['DeletePending'] = 0
            query_path_info.v['Directory'] = attrib

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
            pkt['Payload']['SMB'].v['WordCount'] = 10
            pkt['Payload'].v['ParamCountTotal'] = 2
            pkt['Payload'].v['DataCountTotal'] = 24
            pkt['Payload'].v['ParamCount'] = 2
            pkt['Payload'].v['ParamOffset'] = 56
            pkt['Payload'].v['DataCount'] = 24
            pkt['Payload'].v['DataOffset'] = 60
            pkt['Payload'].v['Payload'] =
              "\x00" + # Padding
              trans2_params.to_s +
              "\x00\x00" + # Padding
              query_path_info.to_s +
              "\x00\x00" # Unknown
            c.put(pkt.to_s)
          end

          #
          # Responds to QUERY_FILE_INFO (Network) requests
          #
          def smb_cmd_trans_query_file_info_network(c, buff)
            pkt = CONST::SMB_TRANS2_PKT.make_struct
            pkt.from_s(buff)

            payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '').chomp.strip
            #dprint("[smb_cmd_trans_query_file_info_network] Payload length: #{payload.length.to_s}")
            #dprint("[smb_cmd_trans_query_file_info_network] Payload is : #{payload.to_s}")

            if payload.length.to_s.eql?('4')
              attrib = "\x10\x00\x00\x00" # File attributes => directory
            else
              attrib = "\x80\x00\x00\x00" # File attributes => normal file
            end

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
            pkt['Payload']['SMB'].v['Flags1'] = 0x88
            pkt['Payload']['SMB'].v['Flags2'] = flags2
            pkt['Payload']['SMB'].v['WordCount'] = 10
            pkt['Payload'].v['ParamCountTotal'] = 2
            pkt['Payload'].v['DataCountTotal'] = 56
            pkt['Payload'].v['ParamCount'] = 2
            pkt['Payload'].v['ParamOffset'] = 56
            pkt['Payload'].v['DataCount'] = 56
            pkt['Payload'].v['DataOffset'] = 60
            pkt['Payload'].v['Payload'] =
                "\x00" + # Padding
                # QUERY_PATH_INFO Parameters
                "\x00\x00" + # EA Error Offset
                "\x00\x00" + # Padding
                # QUERY_PATH_INFO Data
                [lo, hi].pack("VV") + # Created
                [lo, hi].pack("VV") + # Last Access
                [lo, hi].pack("VV") + # Last Write
                [lo, hi].pack("VV") + # Change
                "\x00\x00\x10\x00\x00\x00\x00\x00" + # Allocation Size = 1048576 || 1Mb
                [exe_contents.length].pack("V") + "\x00\x00\x00\x00" + # End Of File
                attrib +
                "\x00\x00\x00\x00" # Unknown

            my_pkt = pkt.to_s
            original_length = my_pkt[2, 2].unpack("n").first
            original_length = original_length + 24
            my_pkt[2, 2] = [original_length].pack("n")
            new_length = my_pkt[2, 2].unpack("n").first
            c.put(pkt.to_s)
          end

        end
      end
    end
  end
end
