# -*- coding: binary -*-

module Msf
  module Exploit::Remote::SMB::Server
    module Share
      module InformationLevel
        # This mixin provides methods to handle TRAN2_QUERY_PATH_INFORMATION subcommands
        module Query

          #
          # Responds to QUERY_PATH_INFO (Basic) requests
          #
          def smb_cmd_trans_query_file_info_basic(c, fid)
            smb = @state[c]

            if fid.eql?smb[:file_id].to_i
              attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL # File attributes => file
            elsif fid.nil? || fid.empty? || fid == "\x00" # empty path
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY # File attributes => directory
            else
              smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_OBJECT_NAME_NOT_FOUND, true)
              return
            end

            send_info_basic_res(c, { file_attributes: attrib })
          end

          # shortcut, we only have one file....
          def smb_cmd_trans_query_file_info_standard(c, fid)
            send_info_standard_res(c, {
              allocation_size: 1048576,
              number_links: 1,
              delete_pending: 0,
              directory: 0,
              end_of_file: exe_contents.length
            })
          end

          #
          # Responds to QUERY_PATH_INFO (Basic) requests
          #
          def smb_cmd_trans_query_path_info_basic(c, path)
            if path && path.ends_with?(file_name) #TODO: do it better
              attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL
            elsif path && path.ends_with?(file_name + '.Local')
              attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL
            elsif path && path == path_name
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY
            elsif path.nil? || path.empty? || path == "\x00" # empty path
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY
            else
              smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_OBJECT_NAME_NOT_FOUND, true)
              return
            end

            send_info_basic_res(c, { file_attributes: attrib })
          end

          #
          # Responds to QUERY_PATH_INFO (Standard) requests
          #
          # At the moment we just support '\\' path always send a SUCCESS...
          def smb_cmd_trans_query_path_info_standard(c, path)

            puts "[smb_cmd_trans_query_path_info_standard] #{path}"

            if path && path.include?(file_name) #TODO: do it better
              attrib = 0 # File attributes => file
            elsif path && path == path_name
              attrib = 1 # File attributes => directory
            elsif path.nil? || path.empty? || path == "\x00" # empty path
              attrib = 1 # File attributes => directory
            else
              smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_OBJECT_NAME_NOT_FOUND, true)
              return
            end

            send_info_standard_res(c, {
                allocation_size: 1048576,
                number_links: 1,
                delete_pending: 0,
                directory: attrib,
                end_of_file: exe_contents.length
            })
          end

          #
          # Responds to QUERY_PATH_INFO (Network Open) requests
          #
          # At the moment we just support '\\' path always send a SUCCESS...
          def smb_cmd_trans_query_path_info_network(c, path)

            if path && path.include?(file_name) #TODO: do it better
              attrib = 0 # File attributes => file
            elsif path && path == path_name
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY # File attributes => directory
            elsif path.nil? || path.empty? || path == "\x00" # empty path
              # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
              attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY # File attributes => directory
            else
              smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_OBJECT_NAME_NOT_FOUND, true)
              return
            end

            send_info_network_res(c, {
              allocation_size: 1048576,
              end_of_file: exe_contents.length,
              file_attributes: attrib
            })
          end

          def send_info_basic_res(c, opts = {})
            file_attributes = opts[:file_attributes] || 0

            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_BASIC_INFO_HDR.make_struct
            query_path_info.v['loCreationTime'] = lo
            query_path_info.v['hiCreationTime'] = hi
            query_path_info.v['loLastAccessTime'] = lo
            query_path_info.v['hiLastAccessTime'] = hi
            query_path_info.v['loLastWriteTime'] = lo
            query_path_info.v['hiLastWriteTime'] = hi
            query_path_info.v['loLastChangeTime'] = lo
            query_path_info.v['hiLastChangeTime'] = hi
            query_path_info.v['ExtFileAttributes'] = file_attributes

            send_trans2_res(c, trans2_params, query_path_info)
          end

          def send_info_standard_res(c, opts = {})
            allocation_size = opts[:allocation_size] || 0
            number_links = opts[:number_links] || 0
            delete_pending = opts[:delete_pending] || 0
            directory = opts[:directory] || 0
            end_of_file = opts[:end_of_file] || 0

            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_STANDARD_INFO_HDR.make_struct
            query_path_info.v['AllocationSize'] = allocation_size
            query_path_info.v['EndOfFile'] = end_of_file
            query_path_info.v['NumberOfLinks'] = number_links
            query_path_info.v['DeletePending'] = delete_pending
            query_path_info.v['Directory'] = directory

            send_trans2_res(c, trans2_params, query_path_info)
          end

          def send_info_network_res(c, opts= {})
            allocation_size = opts[:allocation_size] || 0
            end_of_file = opts[:end_of_file] || 0
            file_attributes = opts[:file_attributes] || 0

            pkt = CONST::SMB_TRANS_RES_PKT.make_struct
            smb_set_defaults(c, pkt)

            trans2_params = CONST::SMB_TRANS2_QUERY_PATH_INFORMATION_RES_PARAMETERS.make_struct
            trans2_params.v['EaErrorOffset'] = 0

            query_path_info = CONST::SMB_QUERY_FILE_NETWORK_INFO_HDR.make_struct
            query_path_info.v['loCreationTime'] = lo
            query_path_info.v['hiCreationTime'] = hi
            query_path_info.v['loLastAccessTime'] = lo
            query_path_info.v['hiLastAccessTime'] = hi
            query_path_info.v['loLastWriteTime'] = lo
            query_path_info.v['hiLastWriteTime'] = hi
            query_path_info.v['loLastChangeTime'] = lo
            query_path_info.v['hiLastChangeTime'] = hi
            query_path_info.v['AllocationSize'] = allocation_size
            query_path_info.v['EndOfFile'] = end_of_file
            query_path_info.v['ExtFileAttributes'] = file_attributes

            send_trans2_res(c, trans2_params, query_path_info)
          end
        end
      end
    end
  end
end
