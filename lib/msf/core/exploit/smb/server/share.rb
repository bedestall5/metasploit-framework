# -*- coding: binary -*-
require 'rex/socket'
require 'rex/proto/smb'
require 'rex/text'
require 'rex/logging'
require 'rex/struct2'
require 'rex/proto/smb/constants'
require 'rex/proto/smb/utils'
require 'rex/proto/dcerpc'

module Msf
  module Exploit::Remote::SMB::Server
    # This mixin provides a minimal SMB server
    module Share

      include Msf::Exploit::Remote::SMB::Server

      FLAGS2 = CONST::FLAGS2_UNICODE_STRINGS +
        CONST::FLAGS2_EXTENDED_SECURITY +
        CONST::FLAGS2_32_BIT_ERROR_CODES +
        CONST::FLAGS2_LONG_PATH_COMPONENTS

      attr_accessor :unc
      attr_accessor :share
      attr_accessor :path_name
      attr_accessor :file_name
      attr_accessor :hi
      attr_accessor :lo
      attr_accessor :exe_contents

      def initialize(info = {})
        super

        register_options(
          [
            OptString.new('SHARE', [ false, 'Share (Default Random)']),
            OptString.new('FILE_NAME', [ false, 'File name to share (Default Random)']),
            OptPath.new('FILE_CONTENTS', [ false, 'File contents (Default Random)'])
          ], Msf::Exploit::Remote::SMB::Server::Share)
      end

      #
      # Debugging
      #
      def dprint(msg)
        $stdout.puts "#{msg}"
        #dlog("#{msg}", 'rex', LEV_3)
      end

      def setup
        super

        print_status("Setup...")

        # TODO: Improve tree directories support
        self.path_name = '\\'
        self.share = datastore['SHARE'] || Rex::Text.rand_text_alpha(4 + rand(3))
        self.file_name = datastore['FILE_NAME'] || Rex::Text.rand_text_alpha(4 + rand(3))
        self.unc = "\\\\#{srvhost}\\#{share}\\#{file_name}"

        t = Time.now.to_i
        self.hi, self.lo = ::Rex::Proto::SMB::Utils.time_unix_to_smb(t)

        # The module has an opportunity to set up the file contents in the "primer callback"
        if datastore['FILE_CONTENTS']
          File.open(datastore['FILE_CONTENTS'], 'rb') { |f| self.exe_contents = f.read }
        else
          self.exe_contents = Rex::Text.rand_text_alpha(50 + rand(150))
        end
      end

      def srvhost
        datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['SRVHOST']
      end

      def smb_conn(c)
        @state[c] = {
          :name         => "#{c.peerhost}:#{c.peerport}",
          :ip           => c.peerhost,
          :port         => c.peerport,
          :multiplex_id => rand(0xffff),
          :process_id   => rand(0xffff),
          :file_id      => 0xdead,
          :dir_id       => 0xbeef
        }
      end

      #
      # Main dispatcher function
      # Takes the client data and performs a case switch
      # on the command (e.g. Negotiate, Session Setup, Read file, etc.)
      #
      def smb_cmd_dispatch(cmd, c, buff)
        smb = @state[c]
        dprint("Received command #{cmd.to_s(16)} from #{smb[:name]}")

        pkt = CONST::SMB_BASE_PKT.make_struct
        pkt.from_s(buff)
        #Record the IDs
        smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
        smb[:user_id] = pkt['Payload']['SMB'].v['UserID']
        smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
        smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']

        case cmd
          when CONST::SMB_COM_NEGOTIATE
            smb_cmd_negotiate(c, buff)
          when CONST::SMB_COM_SESSION_SETUP_ANDX
            wordcount = pkt['Payload']['SMB'].v['WordCount']
            if wordcount == 0x0D # Share Security Mode sessions
              smb_cmd_session_setup(c, buff)
            else
              dprint("SMB Share - #{smb[:ip]} Unknown SMB_COM_SESSION_SETUP_ANDX request type , ignoring... ")
              smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
            end
          when CONST::SMB_COM_TRANSACTION2
            smb_cmd_trans(c, buff)
          when CONST::SMB_COM_NT_CREATE_ANDX
            smb_cmd_create(c, buff)
          when CONST::SMB_COM_READ_ANDX
            smb_cmd_read(c, buff)
          when CONST::SMB_COM_CLOSE
            smb_cmd_close(c, buff)
          else
            smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
        end
      end

      #
      # Responds to a client CLOSE request
      #
      def smb_cmd_close(c, buff)
        dprint("[SMB_CMD_CLOSE]")
        pkt = CONST::SMB_CLOSE_PKT.make_struct
        pkt.from_s(buff)

        pkt = CONST::SMB_CLOSE_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_CLOSE
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 0

        c.put(pkt.to_s)
      end

      #
      # Negotiates a SHARE session with the client
      #
      def smb_cmd_negotiate(c, buff)
        dprint("[SMB_CMD_NEGOTIATE]")
        pkt = CONST::SMB_NEG_PKT.make_struct
        pkt.from_s(buff)

        dialects = pkt['Payload'].v['Payload'].gsub(/\x00/, '').split(/\x02/).grep(/^\w+/)

        dialect = dialects.index("NT LM 0.12") || dialects.length-1

        pkt = CONST::SMB_NEG_RES_NT_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NEGOTIATE
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 17
        pkt['Payload'].v['Dialect'] = dialect
        pkt['Payload'].v['SecurityMode'] = 2 # SHARE Security Mode
        pkt['Payload'].v['MaxMPX'] = 50
        pkt['Payload'].v['MaxVCS'] = 1
        pkt['Payload'].v['MaxBuff'] = 4356
        pkt['Payload'].v['MaxRaw'] = 65536
        pkt['Payload'].v['SystemTimeLow'] = lo
        pkt['Payload'].v['SystemTimeHigh'] = hi
        pkt['Payload'].v['ServerTimeZone'] = 0x0
        pkt['Payload'].v['SessionKey'] = 0
        pkt['Payload'].v['Capabilities'] = 0x0080f3fd
        pkt['Payload'].v['KeyLength'] = 8
        pkt['Payload'].v['Payload'] = Rex::Text.rand_text_hex(8)

        c.put(pkt.to_s)
      end

      #
      # Sets up an SMB session in response to a SESSION_SETUP_ANDX request
      #
      def smb_cmd_session_setup(c, buff)
        dprint("[SMB_CMD_SESSION_SETUP]")
        pkt = CONST::SMB_SETUP_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 3
        pkt['Payload'].v['AndX'] = 0x75
        pkt['Payload'].v['Reserved1'] = 00
        pkt['Payload'].v['AndXOffset'] = 96
        pkt['Payload'].v['Action'] = 0x1 # Logged in as Guest
        pkt['Payload'].v['Payload'] =
          Rex::Text.to_unicode("Unix", 'utf-16be') + "\x00\x00" + # Native OS # Samba signature
          Rex::Text.to_unicode("Samba 3.4.7", 'utf-16be') + "\x00\x00" + # Native LAN Manager # Samba signature
          Rex::Text.to_unicode("WORKGROUP", 'utf-16be') + "\x00\x00\x00" + # Primary DOMAIN # Samba signature
        tree_connect_response = ""
        tree_connect_response << [7].pack("C")  # Tree Connect Response : WordCount
        tree_connect_response << [0xff].pack("C") # Tree Connect Response : AndXCommand
        tree_connect_response << [0].pack("C") # Tree Connect Response : Reserved
        tree_connect_response << [0].pack("v")  # Tree Connect Response : AndXOffset
        tree_connect_response << [0x1].pack("v")  # Tree Connect Response : Optional Support
        tree_connect_response << [0xa9].pack("C") # Access Mask for just Read and Exec
        tree_connect_response << [0x00].pack("C")
        tree_connect_response << [0x12].pack("C")
        tree_connect_response << [0x00].pack("C")
        tree_connect_response << [0].pack("v") # Tree Connect Response : Word Parameter
        tree_connect_response << [0].pack("v") # Tree Connect Response : Word Parameter
        tree_connect_response << [13].pack("v") # Tree Connect Response : ByteCount
        tree_connect_response << "A:\x00" # Service
        tree_connect_response << "#{Rex::Text.to_unicode("NTFS")}\x00\x00" # Extra byte parameters
        # Fix the Netbios Session Service Message Length
        # to have into account the tree_connect_response,
        # need to do this because there isn't support for
        # AndX still
        my_pkt = pkt.to_s + tree_connect_response
        original_length = my_pkt[2, 2].unpack("n").first
        original_length = original_length +  tree_connect_response.length
        my_pkt[2, 2] = [original_length].pack("n")
        c.put(my_pkt)
      end

      #
      # Responds to a client NT_CREATE_ANDX request
      #
      def smb_cmd_create(c, buff)
        dprint("[SMB_CMD_CREATE]")
        smb = @state[c]
        pkt = CONST::SMB_CREATE_PKT.make_struct
        pkt.from_s(buff)

        # Tries to do CREATE and X
        payload = pkt['Payload'].v['Payload'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip.split('\\').last
        file = file_name
        path = path_name

        if payload.nil?
          payload = file
        end

        if payload.length.to_s.eql?('1') or payload.eql?(path)
          fid = smb[:dir_id].to_i
          attribs = 0x10 # Ordinary Dir
          eof = 0
          isdir = 1
        else
          fid = smb[:file_id].to_i
          attribs = 0x80 # File Attributes
          eof = exe_contents.length
          isdir = 0
        end

        pkt = CONST::SMB_CREATE_RES_PKT.make_struct
        smb_set_defaults(c, pkt)
        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 42
        pkt['Payload'].v['AndX'] = 0xff # no further commands
        pkt['Payload'].v['OpLock'] = 0x3 # Grant Oplock on File
        pkt['Payload'].v['FileID'] = fid
        pkt['Payload'].v['Action'] = 0x1 # The file existed and was opened
        pkt['Payload'].v['CreateTimeLow'] = lo
        pkt['Payload'].v['CreateTimeHigh'] = hi
        pkt['Payload'].v['AccessTimeLow'] = lo
        pkt['Payload'].v['AccessTimeHigh'] = hi
        pkt['Payload'].v['WriteTimeLow'] = lo
        pkt['Payload'].v['WriteTimeHigh'] = hi
        pkt['Payload'].v['ChangeTimeLow'] = lo
        pkt['Payload'].v['ChangeTimeHigh'] = hi
        pkt['Payload'].v['Attributes'] = attribs
        pkt['Payload'].v['AllocLow'] = 0x100000
        pkt['Payload'].v['AllocHigh'] = 0
        pkt['Payload'].v['EOFLow'] = eof
        pkt['Payload'].v['EOFHigh'] = 0
        pkt['Payload'].v['FileType'] = 0
        pkt['Payload'].v['IPCState'] = 0x7
        pkt['Payload'].v['IsDirectory'] = isdir

        # As above, if payload is a file or "\" send found response
        if (payload.downcase.eql?(file.downcase)) or payload.length.to_s.eql?('1') or payload.eql?(path)
          connect_response = ""
          # GUID
          connect_response << ([0].pack("C") * 16)
          # File ID
          connect_response << ([0].pack("C") * 6)
          # Access Rights
          connect_response << [0xff].pack("C")
          connect_response << [0x01].pack("C")
          connect_response << [0x1f].pack("C")
          connect_response << [0].pack("C")
          connect_response << ([0].pack("C") * 4) # Guest access
          connect_response << ([0].pack("C") * 2) # Byte Count

          my_pkt = pkt.to_s + connect_response
          original_length = my_pkt[2, 2].unpack("n").first
          original_length = original_length + connect_response.length
          my_pkt[2, 2] = [original_length].pack("n")
          c.put(my_pkt)
        else
          # Otherwise send not found
          pkt = CONST::SMB_CREATE_RES_PKT.make_struct
          smb_set_defaults(c, pkt)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX
          pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          c.put(pkt.to_s)
        end
      end

      #
      # Responds to a client READ_ANDX request
      # This function sends chunks of the payload to the client
      # by reading the offset and length requested by the client
      # and sending the appropriate chunk of the payload
      #
      def smb_cmd_read(c, buff)
        dprint("[SMB_CMD_READ]")
        pkt = CONST::SMB_READ_PKT.make_struct
        pkt.from_s(buff)

        offset = pkt['Payload'].v['Offset']
        length = pkt['Payload'].v['MaxCountLow']

        pkt = CONST::SMB_READ_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_READ_ANDX
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 12
        pkt['Payload'].v['AndX'] = 0xff # no more commands
        pkt['Payload'].v['Remaining'] = 0xffff
        pkt['Payload'].v['DataLenLow'] = length
        pkt['Payload'].v['DataOffset'] = 59
        pkt['Payload'].v['DataLenHigh'] = 0
        pkt['Payload'].v['Reserved3'] = 0
        pkt['Payload'].v['Reserved4'] = 0x0a
        pkt['Payload'].v['ByteCount'] = length
        pkt['Payload'].v['Payload'] = exe_contents[offset, length]
        c.put(pkt.to_s)
      end

      #
      # Responds to client TRANSACTION2 requests and dispatches the request off to
      # other functions dependent on what the sub_command is. Commands supported
      # include:
      #  QUERY_FILE_INFO (Basic, Standard and Internal)
      #  QUERY_PATH_INFO (Basic and Standard)
      #
      def smb_cmd_trans(c, buff)
        dprint("[SMB_CMD_TRANS]")
        # Client socket is c
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        sub_command = pkt['Payload'].v['SetupData'].unpack("v").first
        ar = Rex::Text.to_hex(buff, '').to_s
        mdc = ar[86..89].unpack('n*').reverse.pack('n*').to_i(16)

        case sub_command
        when CONST::TRANS2_QUERY_FILE_INFO_BASIC
          dprint("\t[query_file_info_basic]")
          smb_cmd_trans_query_path_info_standard(c, buff)
        when CONST::TRANS2_QUERY_FILE_INFO_STANDARD
          dprint("\t[query_file_info_standard]")
          loi = ar[148..151].unpack('n*').reverse.pack('n*').to_i(16)
          case loi
          when CONST::SMB_QUERY_PATH_STANDARD_INFO
            dprint("\t\t[smb_cmd_trans_query_path_info_standard]")
            smb_cmd_trans_query_path_info_standard(c, buff)
          when CONST::SMB_QUERY_FILE_STANDARD_INFO_BASIC
            dprint("\t\t[smb_cmd_trans_query_file_info_basic]")
            smb_cmd_trans_query_file_info_basic(c, buff)
          when CONST::SMB_QUERY_FILE_NETWORK_OPEN_INFO
            dprint("\t\t[smb_cmd_trans_query_file_info_network]")
            smb_cmd_trans_query_file_info_network(c, buff)
          else
            dprint("\t\tUnknown LOI [smb_cmd_trans_query_path_info_standard] - #{loi.to_s}")
            smb_cmd_trans_query_file_info_standard(c, buff)
          end
        when CONST::TRANS2_QUERY_PATH_INFO
          dprint("\t[query_path_info]")
          loi = ar[144..147].unpack('n*').reverse.pack('n*').to_i(16)

          case mdc # MAX DATA COUNT
          when CONST::SMB_QUERY_BASIC_MDC
            case loi
            when CONST::SMB_QUERY_FILE_BASIC_INFO
              dprint("\t\t[query_file_info_basic]")
              smb_cmd_trans_query_file_info_basic(c, buff)
            else
              dprint("\t\tUnknown LOI [smb_cmd_trans_query_path_info_basic] - #{loi.to_s}")
              smb_cmd_trans_query_path_info_basic(c, buff)
            end
          when CONST::SMB_QUERY_STANDARD_MDC1, CONST::SMB_QUERY_STANDARD_MDC2
            dprint("\t\t[query_path_info_standard]")
            smb_cmd_trans_query_path_info_standard(c, buff)
          when CONST::SMB_QUERY_FILE_INTERNAL_INFO_MDC
            dprint("\t\t[query_path_info_standard]")
            smb_cmd_trans_query_file_info_standard(c, buff)
          when CONST::SMB_QUERY_FILE_NETWORK_INFO_MDC
            dprint("\t\t[query_file_info_network]")
            smb_cmd_trans_query_file_info_network(c, buff)
          else
            dprint("\t\tUnknown MDC - Sending to [query_path_info_standard]: #{mdc.to_s}")
            smb_cmd_trans_query_path_info_standard(c, buff)
          end
        when CONST::TRANS2_FIND_FIRST2
          dprint("\t[find_first2]")
          loi = ar[156..159].unpack('n*').reverse.pack('n*').to_i(16)
          case loi
          when CONST::SMB_FIND_FILE_NAMES_INFO
            dprint("\t\t[SMB_FIND_FILE_NAMES_INFO]")
            smb_cmd_trans_find_first2_file(c, buff)
          when CONST::SMB_FIND_FILE_BOTH_DIRECTORY_INFO
            dprint("\t\t[SMB_FIND_FILE_BOTH_DIRECTORY_INFO]")
            smb_cmd_trans_find_first2(c, buff)
          when CONST::SMB_FIND_FILE_FULL_DIRECTORY_INFO
            dprint("\t\t[SMB_FIND_FILE_FULL_DIRECTORY_INFO]")
            smb_cmd_trans_find_first2_full(c, buff)
          else
            smb_cmd_trans_find_first2(c, buff)
          end
        else
          dprint("\t[UNKNOWN SUBCOMMAND]")
          pkt = CONST::SMB_TRANS_RES_PKT.make_struct
          smb_set_defaults(c, pkt)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          pkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000225 # NT_STATUS_NOT_FOUND
          c.put(pkt.to_s)
        end
      end

      #
      # Responds to QUERY_FILE_INFO (Network) requests
      #
      def smb_cmd_trans_query_file_info_network(c, buff)
        dprint("[smb_cmd_trans_query_file_info_network]")
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '').chomp.strip

        if payload.length.to_s.eql?('4')
          attrib = "\x10\x00\x00\x00" # File attributes => directory
        else
          attrib = "\x80\x00\x00\x00" # File attributes => normal file
        end

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 2
        pkt['Payload'].v['DataCountTotal'] = 56
        pkt['Payload'].v['ParamCount'] = 2
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 56
        pkt['Payload'].v['DataOffset'] = 60
        pkt['Payload'].v['Payload'] =
          "\x00" + # Padding
          # QUERY_PATH_INFO Parameters
          "\x00\x00" + # EA Error Offset
          "\x00\x00" + # Padding
          # QUERY_PATH_INFO Data
          [lo, hi].pack("VV") + # Created
          [lo, hi].pack("VV") + # Last Access
          [lo, hi].pack("VV") + # Last Write
          [lo, hi].pack("VV") + # Change
          "\x00\x00\x10\x00\x00\x00\x00\x00" + # Allocation Size = 1048576 || 1Mb
          [exe_contents.length].pack("V") + "\x00\x00\x00\x00" + # End Of File
          attrib +
          "\x00\x00\x00\x00" # Unknown
        c.put(pkt.to_s)
      end

      #
      # Responds to QUERY_FILE_INFO (Standard) requests
      #
      def smb_cmd_trans_query_file_info_standard(c, buff)
        dprint("[smb_cmd_trans_query_file_info_standard]")
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 2
        pkt['Payload'].v['DataCountTotal'] = 8
        pkt['Payload'].v['ParamCount'] = 2
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 8
        pkt['Payload'].v['DataOffset'] = 60
        pkt['Payload'].v['Payload'] =
        "\x00" + # Padding
        # QUERY_FILE Parameters
        "\x00\x00" + # EA Error Offset
        "\x00\x00" + # Padding
        # QUERY_FILE_INFO Data
        "\x95\x1c\x02\x00\x00\x00\x00\x00"
        c.put(pkt.to_s)
      end

      #
      # Responds to QUERY_PATH_INFO (Standard) requests
      #
      def smb_cmd_trans_query_path_info_standard(c, buff)
        dprint("[smb_cmd_trans_query_path_info_standard]")
        smb = @state[c]
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '').chomp.strip
        ar = Rex::Text.to_hex(buff, '').to_s
        fid = ar[144..147].unpack('n*').reverse.pack('n*')

        # If FileID matches or matches file, send file response
        if ( fid.hex.eql?(smb[:file_id].to_i) or payload.length.eql?(file_name.length) )
          attrib2 = "\x00" # IsFile
        else
          # Otherwise return a Directory answer
          attrib2 = "\x01" # IsDir
        end

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 2
        pkt['Payload'].v['DataCountTotal'] = 24
        pkt['Payload'].v['ParamCount'] = 2
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 24
        pkt['Payload'].v['DataOffset'] = 60
        pkt['Payload'].v['Payload'] =
          "\x00" + # Padding
          # QUERY_PATH_INFO Parameters
          "\x00\x00" + # EA Error Offset
          "\x00\x00" + # Padding
          # QUERY_PATH_INFO Data
          "\x00\x00\x10\x00\x00\x00\x00\x00" + # Allocation Size = 1048576 || 1Mb
          [exe_contents.length].pack("V") + "\x00\x00\x00\x00" + # End Of File
          "\x01\x00\x00\x00" + # Link Count
          "\x00" + # Delete Pending
          attrib2 +
          "\x00\x00" # Unknown
        c.put(pkt.to_s)
      end

      #
      # Responds to QUERY_FILE_INFO (Basic) requests
      #
      def smb_cmd_trans_query_file_info_basic(c, buff)
        dprint("[smb_cmd_trans_query_file_info_basic]")
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip
        file = file_name
        path = path_name

        begin
          fileext = file.split('.').last
        rescue
          fileext = file
        end

        begin
          payext = payload.split('.').last
        rescue
          payext = payload
        end

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        # If payload contains our file extension, send file response
        if payext and payext.downcase.eql?(fileext.downcase)
          attrib = "\x80\x00\x00\x00" # File attributes => file
        elsif payload.length.to_s.eql?('1') or payload.eql?(path)
          # if QUERY_PATH_INFO_PARAMETERS doesn't include a file name,
          # return a Directory answer
          attrib = "\x10\x00\x00\x00" # File attributes => directory
        end

        if (payext and payext.downcase.eql?(fileext.downcase)) or payload.length.to_s.eql?('1') or payload.length.to_s.eql?('4') or payload.eql?(path)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          pkt['Payload']['SMB'].v['WordCount'] = 10
          pkt['Payload'].v['ParamCountTotal'] = 2
          pkt['Payload'].v['DataCountTotal'] = 40
          pkt['Payload'].v['ParamCount'] = 2
          pkt['Payload'].v['ParamOffset'] = 56
          pkt['Payload'].v['DataCount'] = 40
          pkt['Payload'].v['DataOffset'] = 60
          pkt['Payload'].v['Payload'] =
            "\x00" + # Padding
            # QUERY_PATH_INFO Parameters
            "\x00\x00" + # EA Error Offset
            "\x00\x00" + # Padding
            #QUERY_PATH_INFO Data
            [lo, hi].pack("VV") + # Created
            [lo, hi].pack("VV") + # Last Access
            [lo, hi].pack("VV") + # Last Write
            [lo, hi].pack("VV") + # Change
            attrib +
            "\x00\x00\x00\x00" # Unknown
          c.put(pkt.to_s)
        else
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          c.put(pkt.to_s)
        end
      end

      #
      # Responds to QUERY_PATH_INFO (Basic) requests
      #
      def smb_cmd_trans_query_path_info_basic(c, buff)
        dprint("[smb_cmd_trans_query_path_info_basic]")
        pkt = CONST::SMB_TRANS2_PKT.make_struct
        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip.split('\\').last
        file = file_name

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        # If payload contains our file, send a file response
        # For MS13-071, payload is an empty unicode request (4 bytes)
        if payload.downcase.eql?(file.downcase) or payload.length.to_s.eql?('4')
          if payload.length.to_s.eql?('4')
            attrib = "\x10\x00\x00\x00" # File attributes => directory
          else
            attrib = "\x80\x00\x00\x00" # File attributes => file
          end
        else
          if payload.downcase.include?(file.downcase)
            attrib = "\x80\x00\x00\x00" # File attributes => file
          else
            # QUERY_PATH_INFO_PARAMETERS doesn't include a file name, return a Directory answer
            attrib = "\x10\x00\x00\x00" # File attributes => directory
          end
        end

        # If payload contains our file, send the response
        if payload.downcase.eql?(file.downcase) or payload.length.to_s.eql?('4') or payload.downcase.include?(file.downcase)
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          pkt['Payload']['SMB'].v['WordCount'] = 10
          pkt['Payload'].v['ParamCountTotal'] = 2
          pkt['Payload'].v['DataCountTotal'] = 40
          pkt['Payload'].v['ParamCount'] = 2
          pkt['Payload'].v['ParamOffset'] = 56
          pkt['Payload'].v['DataCount'] = 40
          pkt['Payload'].v['DataOffset'] = 60
          pkt['Payload'].v['Payload'] =
            "\x00" + # Padding
            # QUERY_PATH_INFO Parameters
            "\x00\x00" + # EA Error Offset
            "\x00\x00" + # Padding
            #QUERY_PATH_INFO Data
            [lo, hi].pack("VV") + # Created
            [lo, hi].pack("VV") + # Last Access
            [lo, hi].pack("VV") + # Last Write
            [lo, hi].pack("VV") + # Change
            attrib +
            "\x00\x00\x00\x00" # Unknown
          c.put(pkt.to_s)
        else
          # Else send not found
          pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
          pkt['Payload']['SMB'].v['ErrorClass'] = 0xC0000034 # OBJECT_NAME_NOT_FOUND
          pkt['Payload']['SMB'].v['Flags1'] = 0x88
          pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
          c.put(pkt.to_s)
        end
      end

      #
      # Responds to FIND_FIRST2 requests
      # Command: Find File Both Directory Info
      #
      def smb_cmd_trans_find_first2(c, buff)
        dprint("[smb_cmd_trans_find_first2]")
        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip

        print_status("#{Rex::Text.to_hex_dump(payload)}")

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        if payload && payload.include?(file_name)
          data = Rex::Text.to_unicode(file_name)
          length = exe_contents.length
          ea = 0
          alloc = 1048576 # Allocation Size = 1048576 || 1Mb
          attrib = CONST::SMB_EXT_FILE_ATTR_NORMAL
          search = 1
        elsif payload && payload == path_name
          data = Rex::Text.to_unicode(path)
          length = 0
          ea = 0x21
          alloc = 0 # 0Mb
          attrib = CONST::SMB_EXT_FILE_ATTR_DIRECTORY
          pkt['Payload'].v['SetupCount'] = 0
          search = 0x100
        else
          smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_NO_SUCH_FILE, true)
          return
        end

        trans2_params = CONST::SMB_TRANS2_PARAMETERS.make_struct
        trans2_params.v['SID'] = 0xfffd
        trans2_params.v['SearchCount'] = search
        trans2_params.v['EndOfSearch'] = search
        trans2_params.v['EaErrorOffset'] = ea
        trans2_params.v['LastNameOffset'] = 0

        find_file = CONST::SMB_FIND_FILE_BOTH_DIRECTORY_INFO_HDR.make_struct
        find_file.v['NextEntryOffset'] = 94 + data.length
        find_file.v['FileIndex'] = 0
        find_file.v['loCreationTime'] = lo
        find_file.v['hiCreationTime'] = hi
        find_file.v['loLastAccessTime'] = lo
        find_file.v['hiLastAccessTime'] = hi
        find_file.v['loLastWriteTime'] = lo
        find_file.v['hiLastWriteTime'] = hi
        find_file.v['loLastChangeTime'] = lo
        find_file.v['hiLastChangeTime'] = hi
        find_file.v['EndOfFile'] = length
        find_file.v['AllocationSize'] = alloc
        find_file.v['ExtFileAttributes'] = attrib
        find_file.v['EaSize'] = 0
        find_file.v['Reserved'] = 0
        find_file.v['FileName'] = data

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 10
        pkt['Payload'].v['DataCountTotal'] = 14 + data.length
        pkt['Payload'].v['ParamCount'] = 10
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 14 + data.length
        pkt['Payload'].v['DataOffset'] = 68
        pkt['Payload'].v['Payload'] =
          "\x00" + # Padding
          trans2_params.to_s + # FIND_FIRST2 Parameters
          "\x00\x00" + # Padding
          find_file.to_s
          #QUERY_PATH_INFO Data
        c.put(pkt.to_s)
      end

      #
      # Responds to FIND_FIRST2 requests
      # Command: Find File Names Info
      #
      def smb_cmd_trans_find_first2_file(c, buff)
        dprint("[smb_cmd_trans_find_first2_file]")
        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip.split('\\').last

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        if payload && payload.include?(file_name)
          data = Rex::Text.to_unicode(file_name)
        elsif payload && payload == path_name
          data = Rex::Text.to_unicode(path_name)
        else
          smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_NO_SUCH_FILE, true)
          return
        end

        trans2_params = CONST::SMB_TRANS2_PARAMETERS.make_struct
        trans2_params.v['SID'] = 0xfffd
        trans2_params.v['SearchCount'] = 1
        trans2_params.v['EndOfSearch'] = 1
        trans2_params.v['EaErrorOffset'] = 0
        trans2_params.v['LastNameOffset'] = 0

        # If its asking for a file, return file
        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 10
        pkt['Payload'].v['DataCountTotal'] = 14 + data.length
        pkt['Payload'].v['ParamCount'] = 10
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 14 + data.length
        pkt['Payload'].v['DataOffset'] = 68
        pkt['Payload'].v['Payload'] =
          "\x00" + # Padding
          trans2_params.to_s + # FIND_FIRST2 Parameters
          "\x00\x00" + # Padding
          # QUERY_PATH_INFO Data
          [14 + data.length].pack("V") + # Next Entry Offset
          "\x00\x00\x00\x00" + # File Index
          [data.length].pack("V") + # File Name Len
          data +
          "\x00\x00" # Padding
        c.put(pkt.to_s)
      end

      #
      # Responds to FIND_FIRST2 requests
      # Command: Find File Full Directory Info
      #
      def smb_cmd_trans_find_first2_full(c, buff)
        dprint("[smb_cmd_trans_find_first2_full]")
        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        pkt.from_s(buff)

        payload = pkt['Payload'].v['SetupData'].gsub(/\x00/, '').gsub(/.*\\/, '\\').chomp.strip

        pkt = CONST::SMB_TRANS_RES_PKT.make_struct
        smb_set_defaults(c, pkt)

        if payload && payload.include?(file_name)
          data = Rex::Text.to_unicode(file_name)
          length = [exe_contents.length].pack("V")
          ea = 0
          alloc = "\x00\x00\x10\x00\x00\x00\x00\x00" # Allocation Size = 1048576 || 1Mb
          attrib = "\x80\x00\x00\x00" # File
          search = 0x100
        elsif payload && payload == path_name
          data = path
          length = "\x00\x00\x00\x00"
          ea = 0x21
          alloc = "\x00\x00\x00\x00\x00\x00\x00\x00" # 0Mb
          attrib = "\x10\x00\x00\x00" # Dir
          pkt['Payload'].v['SetupCount'] = 0
          search = 1
        else
          smb_error(CONST::SMB_COM_TRANSACTION2, c, CONST::SMB_STATUS_NO_SUCH_FILE, true)
          return
        end

        trans2_params = CONST::SMB_TRANS2_PARAMETERS.make_struct
        trans2_params.v['SID'] = 0xfffd
        trans2_params.v['SearchCount'] = search
        trans2_params.v['EndOfSearch'] = search
        trans2_params.v['EaErrorOffset'] = ea
        trans2_params.v['LastNameOffset'] = 0

        pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
        pkt['Payload']['SMB'].v['Flags1'] = 0x88
        pkt['Payload']['SMB'].v['Flags2'] = FLAGS2
        pkt['Payload']['SMB'].v['WordCount'] = 10
        pkt['Payload'].v['ParamCountTotal'] = 10
        pkt['Payload'].v['DataCountTotal'] = 68 + data.length
        pkt['Payload'].v['ParamCount'] = 10
        pkt['Payload'].v['ParamOffset'] = 56
        pkt['Payload'].v['DataCount'] = 68 + data.length
        pkt['Payload'].v['DataOffset'] = 68
        pkt['Payload'].v['Payload'] =
          "\x00" + # Padding
          trans2_params.to_s + # FIND_FIRST2 Parameters
          "\x00\x00" + # Padding
          # QUERY_PATH_INFO Data
          [68 + data.length].pack("V") + # Next Entry Offset
          "\x00\x00\x00\x00" + # File Index
          [lo, hi].pack("VV") + # Created
          [lo, hi].pack("VV") + # Last Access
          [lo, hi].pack("VV") + # Last Write
          [lo, hi].pack("VV") + # Change
          length + "\x00\x00\x00\x00" + # End Of File
          alloc +
          attrib +
          [data.length].pack("V") + # File name len
          "\x00\x00\x00\x00" + # EA List Length
          data
        c.put(pkt.to_s)
      end
    end
  end
end
