# -*- coding: binary -*-
require 'rex/socket'
require 'rex/proto/smb'
require 'rex/text'
require 'rex/logging'
require 'rex/struct2'
require 'rex/proto/smb/constants'
require 'rex/proto/smb/utils'
require 'rex/proto/dcerpc'

module Msf
  module Exploit::Remote::SMB::Server
    # This mixin provides a minimal SMB server
    module Share
      require 'msf/core/exploit/smb/server/share/command'
      require 'msf/core/exploit/smb/server/share/information_level'

      include Msf::Exploit::Remote::SMB::Server::Share::Command::Close
      include Msf::Exploit::Remote::SMB::Server::Share::Command::Negotiate
      include Msf::Exploit::Remote::SMB::Server::Share::Command::NtCreateAndx
      include Msf::Exploit::Remote::SMB::Server::Share::Command::ReadAndx
      include Msf::Exploit::Remote::SMB::Server::Share::Command::SessionSetupAndx
      include Msf::Exploit::Remote::SMB::Server::Share::Command::Trans2
      include Msf::Exploit::Remote::SMB::Server::Share::Command::Trans2::FindFirst2
      include Msf::Exploit::Remote::SMB::Server::Share::Command::Trans2::QueryFileInformation
      include Msf::Exploit::Remote::SMB::Server::Share::Command::Trans2::QueryPathInformation
      include Msf::Exploit::Remote::SMB::Server::Share::InformationLevel::Find
      include Msf::Exploit::Remote::SMB::Server::Share::InformationLevel::Query

      include Msf::Exploit::Remote::SMB::Server

      FLAGS = CONST::FLAGS_REQ_RES | CONST::FLAGS_CASE_SENSITIVE

      FLAGS2 = CONST::FLAGS2_UNICODE_STRINGS |
        CONST::FLAGS2_EXTENDED_SECURITY |
        CONST::FLAGS2_32_BIT_ERROR_CODES |
        CONST::FLAGS2_LONG_PATH_COMPONENTS

      CAPABILITIES = CONST::CAP_UNIX_EXTENSIONS |
        CONST::CAP_LARGE_WRITEX |
        CONST::CAP_LARGE_READX |
        CONST::CAP_PASSTHRU |
        CONST::CAP_DFS |
        CONST::CAP_NT_FIND |
        CONST::CAP_LOCK_AND_READ |
        CONST::CAP_LEVEL_II_OPLOCKS |
        CONST::CAP_STATUS32 |
        CONST::CAP_RPC_REMOTE_APIS |
        CONST::CAP_NT_SMBS |
        CONST::CAP_LARGE_FILES |
        CONST::CAP_UNICODE |
        CONST::CAP_RAW_MODE

      CREATE_MAX_ACCESS = CONST::SMB_READ_ACCESS |
        CONST::SMB_WRITE_ACCESS |
        CONST::SMB_APPEND_ACCESS |
        CONST::SMB_READ_EA_ACCESS |
        CONST::SMB_WRITE_EA_ACCESS |
        CONST::SMB_EXECUTE_ACCESS |
        CONST::SMB_DELETE_CHILD_ACCESS |
        CONST::SMB_READ_ATTRIBUTES_ACCESS |
        CONST::SMB_WRITE_ATTRIBUTES_ACCESS |
        CONST::SMB_DELETE_ACCESS |
        CONST::SMB_READ_CONTROL_ACCESS |
        CONST::SMB_WRITE_DAC_ACCESS |
        CONST::SMB_WRITE_OWNER_ACCESS |
        CONST::SMB_SYNC_ACCESS

      attr_accessor :unc
      attr_accessor :share
      attr_accessor :path_name
      attr_accessor :file_name
      attr_accessor :hi
      attr_accessor :lo
      attr_accessor :exe_contents

      def initialize(info = {})
        super

        register_options(
          [
            OptString.new('SHARE', [ false, 'Share (Default Random)']),
            OptString.new('FILE_NAME', [ false, 'File name to share (Default Random)']),
            OptPath.new('FILE_CONTENTS', [ false, 'File contents (Default Random)'])
          ], Msf::Exploit::Remote::SMB::Server::Share)
      end

      #
      # Debugging
      #
      def dprint(msg)
        $stdout.puts "#{msg}"
        #dlog("#{msg}", 'rex', LEV_3)
      end

      def setup
        super

        print_status("Setup...")

        # TODO: Improve tree directories support
        self.path_name = '\\'
        self.share = datastore['SHARE'] || Rex::Text.rand_text_alpha(4 + rand(3))
        self.file_name = datastore['FILE_NAME'] || Rex::Text.rand_text_alpha(4 + rand(3))
        self.unc = "\\\\#{srvhost}\\#{share}\\#{file_name}"

        t = Time.now.to_i
        self.hi, self.lo = ::Rex::Proto::SMB::Utils.time_unix_to_smb(t)

        # The module has an opportunity to set up the file contents in the "primer callback"
        if datastore['FILE_CONTENTS']
          File.open(datastore['FILE_CONTENTS'], 'rb') { |f| self.exe_contents = f.read }
        else
          self.exe_contents = Rex::Text.rand_text_alpha(50 + rand(150))
        end
      end

      def srvhost
        datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['SRVHOST']
      end

      def smb_conn(c)
        @state[c] = {
          :name         => "#{c.peerhost}:#{c.peerport}",
          :ip           => c.peerhost,
          :port         => c.peerport,
          :multiplex_id => rand(0xffff),
          :process_id   => rand(0xffff),
          :file_id      => 0xdead,
          :dir_id       => 0xbeef
        }
      end

      #
      # Main dispatcher function
      # Takes the client data and performs a case switch
      # on the command (e.g. Negotiate, Session Setup, Read file, etc.)
      #
      def smb_cmd_dispatch(cmd, c, buff)
        smb = @state[c]
        #dprint("Received command #{cmd.to_s(16)} from #{smb[:name]}")

        pkt = CONST::SMB_BASE_PKT.make_struct
        pkt.from_s(buff)
        #Record the IDs
        smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
        smb[:user_id] = pkt['Payload']['SMB'].v['UserID']
        smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
        smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']

        case cmd
          when CONST::SMB_COM_NEGOTIATE
            smb_cmd_negotiate(c, buff)
          when CONST::SMB_COM_SESSION_SETUP_ANDX
            wordcount = pkt['Payload']['SMB'].v['WordCount']
            if wordcount == 0x0D # Share Security Mode sessions
              smb_cmd_session_setup(c, buff)
            else
              dprint("SMB Share - #{smb[:ip]} Unknown SMB_COM_SESSION_SETUP_ANDX request type , ignoring... ")
              smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
            end
          when CONST::SMB_COM_TRANSACTION2
            smb_cmd_trans(c, buff)
          when CONST::SMB_COM_NT_CREATE_ANDX
            smb_cmd_create(c, buff)
          when CONST::SMB_COM_READ_ANDX
            smb_cmd_read(c, buff)
          when CONST::SMB_COM_CLOSE
            smb_cmd_close(c, buff)
          else
            smb_error(cmd, c, CONST::SMB_STATUS_SUCCESS)
        end
      end
    end
  end
end
