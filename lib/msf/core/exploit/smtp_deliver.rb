module Msf

require 'msf/core/exploit/tcp'
require 'rex/mime'

###
#
# This module exposes methods that may be useful to exploits that deal that
# send email messages via SMTP
#
###

module Exploit::Remote::SMTPDeliver
	
	include Exploit::Remote::Tcp

	#
	# Creates an instance of an exploit that delivers messages via SMTP
	#
	def initialize(info = {})
		super

		# Register our options, overriding the RHOST/RPORT from TCP
		register_options(
			[
				OptAddress.new("RHOST", [ true, "The SMTP server to send through" ]),
				OptPort.new("RPORT", [ true, "The SMTP server port (e.g. 25, 465, 587, 2525)", 25 ]),
				OptString.new('MAILFROM', [ true, 'The FROM address of the e-mail', 'random@example.com' ]),
				OptString.new('MAILTO', [ true, 'The TO address of the email' ]),
				OptString.new('SUBJECT', [ true, 'Subject line of the email' ]),
				OptString.new('USERNAME', [ false, 'SMTP Username for sending email' ]),
				OptString.new('PASSWORD', [ false, 'SMTP Password for sending email' ]),
				OptString.new('VERBOSE', [ false, 'Display verbose information' ]),
			], Msf::Exploit::Remote::SMTPDeliver)
		register_autofilter_ports([ 25, 465, 587, 2525, 25025, 25000])
		register_autofilter_services(%W{ smtp smtps })

		@connected = false
	end

	def connected?
		(@connected)
	end

	#
	# This method establishes a SMTP connection to host and port specified by
	# the RHOST and RPORT options, respectively.  After connecting, the banner
	# message is read in and stored in the 'banner' attribute.
	#
	def connect(global = true)
		fd = super

		if fd
			@connected = true
			# Wait for a banner to arrive...
			self.banner = fd.get_once(-1, 30)
		end
		fd
	end

	#
	# Connect to the remote SMTP server, start TLS if the server asks for it,
	# and authenticate if we've got creds.
	#
	def connect_login(global = true)
		print_verbose("Connecting to SMTP server #{rhost}:#{rport}...")
		nsock = connect(global)

		domain = Rex::Text.rand_text_alpha(rand(32)+1)

		res = raw_send_recv("EHLO #{domain}\r\n", nsock)
		if res =~ /STARTTLS/
			print_status("Starting tls")
			raw_send_recv("STARTTLS\r\n", nsock)
			swap_sock_plain_to_ssl
			raw_send_recv("EHLO #{domain}\r\n", nsock)
		end
		# TODO: other auth methods
		if datastore['PASSWORD']
			# Have to double the username.  SMTP auth is weird
			user = "#{datastore["USERNAME"]}\0" * 2
			auth = Rex::Text.encode_base64("#{user}#{datastore["PASSWORD"]}")
			raw_send_recv("AUTH PLAIN #{auth}\r\n", nsock)
		end

		return nsock
	end


	# This method connects to the server and sends a message
	def send_message(data)

		already_connected = connected?
		if already_connected
			print_status("Already connected, reusing")
			nsock = self.sock
		else
			nsock = connect_login(false)
		end

		raw_send_recv("MAIL FROM: <#{datastore['MAILFROM']}>\r\n", nsock)
		raw_send_recv("RCPT TO: <#{datastore['MAILTO']}>\r\n", nsock)

		raw_send_recv("DATA\r\n", nsock)
		raw_send_recv("#{data}\r\n.\r\n", nsock)

		if not already_connected
			print_verbose("Closing the connection...")
			disconnect(nsock)
		end
	end

	def disconnect(nsock=self.sock)
		raw_send_recv("QUIT\r\n", nsock)
		super
		@connected = false
	end

	def raw_send_recv(cmd, nsock=self.sock)
		return false if not nsock
		print_verbose("C: #{cmd.strip}")
		nsock.put(cmd)
		res = nsock.get_once
		print_verbose("S: #{res.strip}")		

		return res
	end

	def print_verbose(msg)
		if datastore['VERBOSE']
			m = (msg.length > 120) ? msg[0,120] + "..." : msg
			print_status(m)
		end
	end


	attr_reader :banner
	
protected
	attr_writer :banner

	def swap_sock_plain_to_ssl(nsock=self.sock)
		# Create a new SSL session on the existing socket
		ctx = generate_ssl_context()
		ssl = OpenSSL::SSL::SSLSocket.new(nsock, ctx)

		ssl.connect

		nsock.extend(Rex::Socket::SslTcp)
		nsock.sslsock = ssl
		nsock.sslctx  = ctx

		tag = nsock.get_once(-1, 30)
	end

	def generate_ssl_context
		ctx = OpenSSL::SSL::SSLContext.new(:SSLv3)
		ctx.key = OpenSSL::PKey::RSA.new(1024){ }

		ctx.session_id_context = Rex::Text.rand_text(16)

		return ctx
	end

end

end
