# -*- coding: binary -*-
require 'msf/core'
require 'rex/proto/dns'


module Msf

###
#
# This module exposes methods for querying a remote DNS service
#
###
module Exploit::Remote::DNS
module Server

  MATCH_HOSTNAME = Rex::Proto::DNS::Constants::MATCH_HOSTNAME

  #
  # Initializes an exploit module that serves DNS requests
  #
  def initialize(info = {})
    super

    register_options(
      [
        OptAddress.new('SRVHOST', [ true, "The local host to listen on.", '0.0.0.0' ]),
        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 53]),
        OptString.new('STATIC_ENTRIES', [ false, "DNS domain search list (hosts file or space/semicolon separate entries)"]),
        OptBool.new('DISABLE_RESOLVER', [ false, "Disable DNS request forwarding", false]),
        OptBool.new('DISABLE_NS_CACHE', [ false, "Disable DNS response caching", false])
      ], Exploit::Remote::DNS::Server
    )

    register_advanced_options(
      [
        OptBool.new('DNS::Server::UDP_DNS', [true, "Serve UDP DNS requests", true]),
        OptBool.new('DNS::Server::TCP_DNS', [true, "Serve TCP DNS requests", false])
      ], Exploit::Remote::DNS::Server
    )
  end

  attr_accessor :service

  #
  # Process static entries
  #
  # @param entries [String] Filename or String containing static entries
  # @param type [String] Type of record for which to add static entries
  #
  # @return [Array] List of static entries in the cache
  def add_static_hosts(entries = datastore['STATIC_ENTRIES'], type = 'A')
    if File.file?(File.expand_path(entries))
      data = File.read(File.expand_path(entries)).split("\n")
    else
      data = entries.split(';')
    end
    data.each do |entry|
      next if data.gsub(/\s/,'').empty?
      addr, names = entry.split(' ', 2)
      names.split.each do |name|
        server.cache.add_static(name, addr, type)
      end
    end
    data.cache.records.select {|r,e| e == 0}
  end

  #
  # Flush all static entries
  #
  def flush_static_hosts
    data.cache.records.select {|r,e| e == 0}.each do |flush|
      data.cache.delete(flush)
    end
  end

  #
  # Flush cache entries
  # @param static [TrueClass, FalseClass] flush static hosts
  def flush_cache(static = false)
    self.service.cache.stop(true)
    flush_static_hosts if static
    self.service.cache.start
  end

  #
  # Starts the server
  #
  def start_service
    setup_server
    self.service = @dns_server
    self.service.start(!datastore['DISABLE_NS_CACHE'])
  end

  #
  # Stops the server
  # @param destroy [TrueClass,FalseClass] Dereference the server object
  def stop_service(destroy = false)
    self.service.stop unless self.service.nil?
    self.service = nil
    @dns_server = nil if destroy
  end

  #
  # Resets the DNS server
  #
  def reset_service
    stop_service
    @dns_server = nil
    start_service
  end

  #
  # Returns the server
  #
  def service
    @dns_server
  end

  #
  # Returns the local host that is being listened on.
  #
  def srvhost
    datastore['SRVHOST']
  end

  #
  # Returns the local port that is being listened on.
  #
  def srvport
    datastore['SRVPORT']
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def handle_request
    nil
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def handle_response
    nil
  end

  #
  # Create and configure Server object unless one exists
  # Pass in existing resolver if available and allowed
  # Create Procs for request and response handlers if defined
  #
  def setup_server
    return if @dns_server
    options.validate(datastore) # This is a hack, DS values should not be Strings prior to this
    if !datastore['DISABLE_RESOLVER'] and self.respond_to?(:setup_resolver)
      setup_resolver
    end
    @dns_server = Rex::Proto::DNS::Server.new(
      datastore['SRVHOST'],
      datastore['SRVPORT'],
      datastore['DNS::Server::UDP_DNS'],
      datastore['DNS::Server::TCP_DNS'],
      (datastore['DISABLE_RESOLVER'] ? false : @dns_resolver),
      nil,
      {'Msf' => framework, 'MsfExploit' => self},
      handle_request,
      handle_response
    )
  end


end
end
end
