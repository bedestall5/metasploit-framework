require 'msf/core'
require 'msf/core/exploit/tcp'

module Msf

module Exploit::Remote::AFP
	include Msf::Exploit::Remote::Tcp

	def initialize(info={})
		super

		@id = 1
		register_options(
			[
				Opt::RPORT(548)
			], Msf::Exploit::Remote::AFP)
	end

	def get_info
		packet =  "\00"    # Flag: Request
		packet << "\x03"   # Command: FPGetSrvrInfo
		packet << [@id].pack('n') # requestID
		packet << "\x00\x00\x00\x00" #Data offset
		packet << "\x00\x00\x00\x00" #Length
		packet << "\x00\x00\x00\x00" #Reserved

		sock.put(packet)
		@id += 1

		response = sock.timed_read(1024)
		parse_response(response)
	end

	def parse_response(response)
		parsed_data = {}

		flags, command, request_id, error_code, length, reserved = response.unpack('CCnNNN')
		raise "Server response with error" if error_code != 0
		body = get_body(response, length)
		machine_type_offset, afp_versions_offset, uam_count_offset, icon_offset, server_flags =
		body.unpack('nnnnn')

		server_name_length = body.unpack('@10C').first
		parsed_data[:server_name] = body.unpack("@11A#{server_name_length}").first

		pos = 11 + server_name_length
		pos += 1 if pos % 2 != 0 #padding

		server_signature_offset, network_addresses_offset, directory_names_offset,
		utf8_servername_offset = body.unpack("@#{pos}nnnn")

		parsed_data[:machine_type] = read_pascal_string(body, machine_type_offset)
		parsed_data[:versions] = read_array(body, afp_versions_offset)
		parsed_data[:uams] = read_array(body, uam_count_offset)
		# skiped icon
		parsed_data[:server_flags] = parse_flags(server_flags)
		parsed_data[:signature] = body.unpack("@#{server_signature_offset}H32").first

		network_addresses = read_array(body, network_addresses_offset, true)
		parsed_data[:network_addresses] = parse_network_addresses(network_addresses)
		# skiped directory names
		parsed_data[:utf8_server_name] = read_utf8_pascal_string(body, utf8_servername_offset)

		return parsed_data
	end

	def get_body(packet, body_length)
		body = packet[16..body_length + 15]
		raise "Invalid body length" if body.length != body_length
		return body
	end

	def read_pascal_string(str, offset)
		length = str.unpack("@#{offset}C").first
		return str.unpack("@#{offset + 1}A#{length}").first
	end

	def read_utf8_pascal_string(str, offset)
		length = str.unpack("@#{offset}n").first
		return str[offset + 2..offset + length + 1]
	end

	def read_array(str, offset, afp_network_address=false)
		size = str.unpack("@#{offset}C").first
		pos = offset + 1

		result = []
		size.times do
			result << read_pascal_string(str, pos)
			pos += str.unpack("@#{pos}C").first
			pos += 1 unless afp_network_address
		end
		return result
	end

	def parse_network_addresses(network_addresses)
		parsed_addreses = []
		network_addresses.each do |address|
			case address.unpack('C').first
			when 0 #Reserved
				next
			when 1 # Four-byte IP address
				parsed_addreses << IPAddr.ntop(address[1..4]).to_s
			when 2 # Four-byte IP address followed by a two-byte port number
				parsed_addreses <<  "#{IPAddr.ntop(address[1..4])}:#{address[5..6].unpack("n").first}"
			when 3 # DDP address (depricated)
				next
			when 4 # DNS name (maximum of 254 bytes)
				parsed_addreses << address[1..address.length - 2]
			when 5 # This functionality is deprecated.
				next
			when 6 # IPv6 address (16 bytes)
				parsed_addreses << "[#{IPAddr.ntop(address[1..16])}]"
			when 7 # IPv6 address (16 bytes) followed by a two-byte port number
				parsed_addreses << "[#{IPAddr.ntop(address[1..16])}]:#{address[17..18].unpack("n").first}"
			else   # Something wrong?
				raise "Error pasing network addresses"
			end
		end
		return parsed_addreses
	end

	def parse_flags(flags)
		flags = flags.to_s(2)
		result = {}
		result['Super Client'] = flags[0,1] == '1' ? true : false
		result['UUIDs'] = flags[5,1] == '1' ? true : false
		result['UTF8 Server Name'] = flags[6,1] == '1' ? true : false
		result['Open Directory'] = flags[7,1] == '1' ? true : false
		result['Reconnect'] = flags[8,1] == '1' ? true : false
		result['Server Notifications'] = flags[9,1] == '1' ? true : false
		result['TCP/IP'] = flags[10,1] == '1' ? true : false
		result['Server Signature'] = flags[11,1] == '1' ? true : false
		result['Server Messages'] = flags[12,1] == '1' ? true : false
		result['Password Saving Prohibited'] = flags[13,1] == '1' ? true : false
		result['Password Changing'] = flags[14,1] == '1' ? true : false
		result['Copy File'] = flags[5,1] == '1' ? true : false
		return result
	end

end
end
