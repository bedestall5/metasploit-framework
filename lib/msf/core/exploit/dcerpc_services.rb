# -*- coding: binary -*-
module Msf

###
# This module implements MSRPC functions that control creating, deleting,
# starting, stopping, and querying system services.
###
module Exploit::Remote::DCERPC_SERVICES

  NDR = Rex::Encoder::NDR

  SC_MANAGER_ALL_ACCESS = 0xF003F
  SERVICE_ALL_ACCESS = 0x0F01FF
  ERROR_SUCCESS = 0x0
  ERROR_FILE_NOT_FOUND = 0x2
  ERROR_ACCESS_DENIED = 0x5
  ERROR_SERVICE_REQUEST_TIMEOUT = 0x41D
  ERROR_SERVICE_EXISTS = 0x431

  # Calls OpenSCManagerW() to obtain a handle to the service control manager.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param rhost [String] the target host.
  # @param access [Fixnum] the access flags requested.
  #
  # @return [String, Integer] the handle to the service control manager or nil if
  #   the call is not successful and the Windows error code
  def dce_openscmanagerw(dcerpc, rhost, access = SC_MANAGER_ALL_ACCESS)
    scm_handle = nil
    scm_status = nil
    stubdata =
      NDR.uwstring("\\\\#{rhost}") +
      NDR.long(0) +
      NDR.long(access)
    begin
      response = dcerpc.call(0x0f, stubdata)
      if response
        scm_status = response[20,4].unpack('V').first
        if scm_status == ERROR_SUCCESS
          scm_handle = response[0,20]
        end
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error getting scm handle: #{e}")
    end

    return scm_handle, scm_status
  end


  # Calls CreateServiceW() to create a system service.  Returns a handle to
  # the service on success, or nil.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param scm_handle [String] the SCM handle (from dce_openscmanagerw()).
  # @param service_name [String] the service name.
  # @param display_name [String] the display name.
  # @param binary_path [String] the path of the binary to run.
  # @param opts [Hash] a hash containing the following keys and values:
  #                 access [Fixnum] the access level (default is maximum).
  #                 type [Fixnum] the type of service (default is interactive,
  #                               own process).
  #                 start [Fixnum] the start options (default is on demand).
  #                 errors [Fixnum] the error options (default is ignore).
  #                 load_order_group [Fixnum] the load order group.
  #                 dependencies [Fixnum] the dependencies of the service.
  #                 service_start [Fixnum]
  #                 password1 [Fixnum]
  #                 password2 [Fixnum]
  #                 password3 [Fixnum]
  #                 password4 [Fixnum]
  #
  # @return [String, Integer] a handle to the created service, windows
  #   error code.
  def dce_createservicew(dcerpc, scm_handle, service_name, display_name, binary_path, opts)
    default_opts = {
      :access => SERVICE_ALL_ACCESS,  # Maximum access.
      :type => 0x00000110,  # Interactive, own process.
      :start => 0x00000003, # Start on demand.
      :errors => 0x00000000,# Ignore errors.
      :load_order_group => 0,
      :dependencies => 0,
      :service_start => 0,
      :password1 => 0,
      :password2 => 0,
      :password3 => 0,
      :password4 => 0
    }.merge(opts)

    svc_handle  = nil
    svc_status  = nil
    stubdata = scm_handle +
      NDR.wstring(service_name) +
      NDR.uwstring(display_name) +
      NDR.long(default_opts[:access]) +
      NDR.long(default_opts[:type]) +
      NDR.long(default_opts[:start]) +
      NDR.long(default_opts[:errors]) +
      NDR.wstring(binary_path) +
      NDR.long(default_opts[:load_order_group]) +
      NDR.long(default_opts[:dependencies]) +
      NDR.long(default_opts[:service_start]) +
      NDR.long(default_opts[:password1]) +
      NDR.long(default_opts[:password2]) +
      NDR.long(default_opts[:password3]) +
      NDR.long(default_opts[:password4])
    begin
      response = dcerpc.call(0x0c, stubdata)
      if response
        svc_status = response[24,4].unpack('V').first

        if svc_status == ERROR_SUCCESS
          svc_handle = response[4,20]
        end
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error creating service: #{e}")
    end

    return svc_handle, svc_status
  end

  # Calls ChangeServiceConfig2() to change the service description.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the service handle to change.
  # @param service_description [String] the service description.
  #
  # @return [Integer] Windows error code
  def dce_changeservicedescription(dcerpc, svc_handle, service_description)
    svc_status = nil
    stubdata =
      svc_handle +
      NDR.long(1) + # dwInfoLevel = SERVICE_CONFIG_DESCRIPTION
      NDR.long(1) + # lpInfo -> *SERVICE_DESCRIPTION
      NDR.long(0x0200) + # SERVICE_DESCRIPTION struct
      NDR.long(0x04000200) +
      NDR.wstring(service_description)
    begin
      response = dcerpc.call(0x25, stubdata) # ChangeServiceConfig2
      svc_status = response.unpack('V').first
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error changing service description : #{e}")
    end

    svc_status
  end


  # Calls CloseHandle() to close a handle.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param handle [String] the handle to close.
  #
  # @return [Integer] Windows error code
  def dce_closehandle(dcerpc, handle)
    svc_status = nil
    begin
      response = dcerpc.call(0x0, handle)
      if response
        svc_status = response[20,4].unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error closing service handle: #{e}")
    end

    svc_status
  end

  # Calls OpenServiceW to obtain a handle to an existing service.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param scm_handle [String] the SCM handle (from dce_openscmanagerw()).
  # @param service_name [String] the name of the service to open.
  # @param access [Fixnum] the level of access requested (default is maximum).
  #
  # @return [String, nil] the handle of the service opened, or nil on failure.
  def dce_openservicew(dcerpc, scm_handle, service_name, access = SERVICE_ALL_ACCESS)
    svc_handle = nil
    svc_status = nil
    stubdata = scm_handle + NDR.wstring(service_name) + NDR.long(access)
    begin
      response = dcerpc.call(0x10, stubdata)
      if response
        svc_status = response[20,4]
        if svc_status == ERROR_SUCCESS
          svc_handle = response[0,20]
        end
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error opening service handle: #{e}")
    end

    svc_handle
  end

  # Calls StartService() on a handle to an existing service in order to start
  # it.  Returns true on success, or false.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the handle of the service to start (from
  #                            dce_openservicew()).
  # @param magic1 [Fixnum] an unknown value.
  # @param magic2 [Fixnum] another unknown value.
  #
  # @return [Integer] Windows error code
  def dce_startservice(dcerpc, svc_handle, magic1 = 0, magic2 = 0)
    svc_status = nil
    stubdata = svc_handle + NDR.long(magic1) + NDR.long(magic2)

    begin
      response = dcerpc.call(0x13, stubdata)
      if response
        svc_status = response[0,4].unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error starting service: #{e}")
    end

    svc_status
  end

  # Stops a running service.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the handle of the service to stop (from
  #                            dce_openservicew()).
  #
  # @return [Integer] Windows error code
  def dce_stopservice(dcerpc, svc_handle)
    return dce_controlservice(dcerpc, svc_handle, 1)
  end

  # Controls an existing service.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the handle of the service to control
  #                            (from dce_openservicew()).
  # @param operation [Fixnum] the operation number to perform (1 = stop
  #                           service; others are unknown).
  #
  # @return [Integer] Windows error code
  def dce_controlservice(dcerpc, svc_handle, operation)
    svc_status = nil
    begin
      response = dcerpc.call(0x01, svc_handle + NDR.long(operation))
      if response
       svc_status =  dcerpc.last_response.stub_data[28,4].unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error controlling service: #{e}")
    end

    svc_status
  end

  # Calls DeleteService() to delete a service.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the handle of the service to delete (from
  #                            dce_openservicew()).
  #
  # @return [Integer] Windows error code
  def dce_deleteservice(dcerpc, svc_handle)
    svc_status = nil
    begin
      response = dcerpc.call(0x02, svc_handle)
      if response
        svc_status = response[0,4].unpack('V').first
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error deleting service: #{e}")
    end

    svc_status
  end

  # Calls QueryServiceStatus() to query the status of a service.
  #
  # @param dcerpc [Rex::Proto::DCERPC::Client] the DCERPC client to use.
  # @param svc_handle [String] the handle of the service to query (from
  #                            dce_openservicew()).
  #
  # @return [Fixnum] Returns 0 if the query failed (i.e.: a state was returned
  #                  that isn't implemented), 1 if the service is running, and
  #                  2 if the service is stopped.
  def dce_queryservice(dcerpc, svc_handle)
    ret = 0

    begin
      response = dcerpc.call(0x06, svc_handle)
      if response[0,9] == "\x10\x00\x00\x00\x04\x00\x00\x00\x01"
        ret = 1
      elsif response[0,9] == "\x10\x00\x00\x00\x01\x00\x00\x00\x00"
        ret = 2
      end
    rescue Rex::Proto::DCERPC::Exceptions::Fault => e
      print_error("#{peer} - Error deleting service: #{e}")
    end

    ret
  end

end
end

